src_sent
params is an empty list ,
hypothesis
params = []
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
params is a list with second element of source as a element .
hypothesis
params = [list(source[1])]
src_sent
return a list containing first element of source and a list containing params .
hypothesis
return [params, source[0]]
src_sent
result is a list containing an empty string .
hypothesis
result = ['']
src_sent
result_args is a list containing an empty list .
hypothesis
result_args = [[]]
src_sent
pos and last are integer 0 .
hypothesis
pos, last = 0
src_sent
for every pos and elt in enumerated iterable source ,
hypothesis
for pos, elt in enumerate(source):
    pass
src_sent
if elt is an instance of six.string_types [ six . string_types ] class ,
hypothesis
if isinstance(elt, six.string_types):
    pass
src_sent
skip this loop iteration .
hypothesis
continue
src_sent
join source list elements from last till pos indexes into a string , substitute the result for piece .
hypothesis
piece = ''.join(source[2:list])
src_sent
if elt is an instance of Group class ,
hypothesis
if isinstance(elt, Group):
    pass
src_sent
increment piece by firs element of elt .
hypothesis
piece += elt[:3]
src_sent
substitute second element of elt for param .
hypothesis
param = elt[1]
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
param is None .
hypothesis
param = None
src_sent
increment pos by one , substitute the result for last .
hypothesis
last = pos + 1
src_sent
for every i in range of integers from 0 to length of result , not included ,
hypothesis
for i in range(0, len(result)):
    pass
src_sent
increment i-th element of result by piece .
hypothesis
result[i] += piece
src_sent
if param is true ,
hypothesis
if param:
    pass
src_sent
append param to i-th element of result_args .
hypothesis
result_args[i] += param
src_sent
if elt is an instance of Choice or NonCapture classes ,
hypothesis
if isinstance(elt, Choice) or isinstance(elt, NonCapture):
    pass
src_sent
if elt is an instance of NonCapture class ,
hypothesis
if isinstance(elt, NonCapture):
    pass
src_sent
elt is an list with an element elt .
hypothesis
elt = [elt]
src_sent
inner_result and inner_args are empty lists .
hypothesis
inner_result, inner_args = [], []
src_sent
for every item in elt ,
hypothesis
for item in elt:
    pass
src_sent
call the function flatten_result with an argument item , assign the result to res and args , respectively .
hypothesis
res, args = flatten_result(item)
src_sent
extend list inner_result with res .
hypothesis
inner_result.extend(res)
src_sent
extend list inner_args with args .
hypothesis
inner_args.extend(args)
src_sent
new_result is an empty list .
hypothesis
new_result = []
src_sent
new_args is an empty list .
hypothesis
new_args = []
src_sent
zip elements of result and result_args into a list of tuples , for every item and args in the result ,
hypothesis
for item, args in list(result):
    pass
src_sent
zip elements of inner_result and inner_args into a list of tuples , for every i_item and i_args in the result ,
hypothesis
for i_item, i_args in list(inner_result):
    pass
src_sent
sum item and i_item together , append the result to new_result .
hypothesis
new_result.append(item + i_item)
src_sent
append i_args to args , append new_args with the result .
hypothesis
args += i_args
src_sent
substitute new_result for result .
hypothesis
result = new_result
src_sent
substitute new_args for result_args .
hypothesis
result_args = new_args
src_sent
if pos is greater than or equal to last ,
hypothesis
if pos >= last:
    pass
src_sent
join elements of list source from index last to the end into a string , substitute it for piece .
hypothesis
piece = ''.join(source[last:])
src_sent
for every i in range of integers from 0 to length of result , not included ,
hypothesis
for i in range(0, len(result)):
    pass
src_sent
increment i-th element of result by piece .
hypothesis
result[i] += piece
src_sent
return result and result_args .
hypothesis
return result, result_args
src_sent
from django.utils.functional [ django . utils . functional ] import curry and Promise into default name space .
hypothesis
from django.utils.functional import curry, Promise
src_sent
from django.utils [ django . utils ] import six into default name space .
hypothesis
from django.utils import six
src_sent
derive the class EscapeData from object base class .
hypothesis
class EscapeData(object):
    pass
src_sent
do nothing .
hypothesis
pass
src_sent
derive the class EscapeBytes from bytes and EscapeData base classes .
hypothesis
class EscapeBytes(bytes, EscapeData):
    pass
src_sent
do nothing .
hypothesis
pass
src_sent
derive the class EscapeText from six.text_type [ six . text_type ] and EscapeData base classes .
hypothesis
class EscapeText(six.text_type, EscapeData):
    pass
src_sent
do nothing .
hypothesis
pass
src_sent
if six.PY3 [ six . PY3 ] is true ,
hypothesis
if six.PY3:
    pass
src_sent
substitute EscapeText for EscapeString .
hypothesis
EscapeString = EscapeText
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute EscapeBytes for EscapeString .
hypothesis
EscapeString = EscapeBytes
src_sent
substitute EscapeText for EscapeUnicode .
hypothesis
EscapeUnicode = EscapeText
src_sent
derive the class SafeData from object base class .
hypothesis
class SafeData(object):
    pass
src_sent
define the method __html__ with an argument self .
hypothesis
def __html__(self):
    pass
src_sent
return self .
hypothesis
return self
src_sent
derive the class SafeBytes from bytes and SafeData base classes .
hypothesis
class SafeBytes(bytes, SafeData):
    pass
src_sent
define the method __add__ with 2 arguments self and rhs .
hypothesis
def __add__(self, rhs):
    pass
src_sent
call the __add__ method with an arguments rhs from the base class of the class SafeBytes , substitute the result for t .
hypothesis
t = super(SafeBytes, self).__add__(rhs)
src_sent
if rhs is an instance of SafeText ,
hypothesis
if isinstance(rhs, SafeText):
    pass
src_sent
return an instance of SafeText , created with an argument t .
hypothesis
return SafeText(t)
src_sent
otherwise if rhs is an instance of SafeBytes ,
hypothesis
if True:
    pass
elif isinstance(rhs, SafeBytes):
    pass
src_sent
return an instance of SafeBytes , created with an argument t .
hypothesis
return SafeBytes(t)
src_sent
return t .
hypothesis
return t
src_sent
define the method _proxy_method with 3 arguments self , unpacked list args and unpacked dictionary kwargs .
hypothesis
def _proxy_method(self, *args, **kwargs):
    pass
src_sent
remove kwargs dictionary element under the _STR:0_ key , substitute it for method .
hypothesis
method = kwargs.pop('_STR:0_')
src_sent
call the function method with 3 arguments : self , unpacked list args and unpacked dictionary kwargs , substitute the result for data .
hypothesis
data = list(method(self, *args, **kwargs))
src_sent
if data is an instance of bytes ,
hypothesis
if isinstance(data, bytes):
    pass
src_sent
return an instance of SafeBytes , created with an argument data .
hypothesis
return SafeBytes(data)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
return an instance of SafeText , created with an argument data .
hypothesis
return SafeText(data)
src_sent
call the function curry with 2 arguments : _proxy_method and method set to bytes.decode [ bytes . decode ] , substitute the result for decode .
hypothesis
decode = curry(_proxy_method, method=bytes.decode)
src_sent
derive the class SafeText from six.text_type [ six . text_type ] and SafeData base classes .
hypothesis
class SafeText(six.text_type, SafeData):
    pass
src_sent
define the method __add__ with 2 arguments self and rhs .
hypothesis
def __add__(self, rhs):
    pass
src_sent
call the __add__ method with an arguments rhs from the base class of the class SafeText , substitute the result for t .
hypothesis
t = super(SafeText, self).__add__(rhs)
src_sent
if rhs is an instance of SafeData .
hypothesis
if isinstance(rhs, SafeData):
    pass
src_sent
return an instance of SafeText , created with an argument t .
hypothesis
return SafeText(t)
src_sent
return t .
hypothesis
return t
src_sent
define the method _proxy_method with 3 arguments self , unpacked list args and unpacked dictionary kwargs .
hypothesis
def _proxy_method(self, *args, **kwargs):
    pass
src_sent
remove kwargs dictionary element under the _STR:0_ key , substitute it for method .
hypothesis
method = kwargs.pop('_STR:0_')
src_sent
call the function method with 3 arguments : self , unpacked list args and unpacked dictionary kwargs , substitute the result for data .
hypothesis
data = list(method(self, *args, **kwargs))
src_sent
if data is an instance of bytes .
hypothesis
if isinstance(data, bytes):
    pass
src_sent
return an instance of SafeBytes , created with an argument data .
hypothesis
return SafeBytes(data)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
return an instance of SafeText , created with an argument data .
hypothesis
return SafeText(data)
src_sent
call the function curry with 2 arguments : _proxy_method and method set to six.text_type.encode [ six . text_type . encode ] , substitute the result for encode .
hypothesis
encode = curry(_proxy_method, method=six.text_type.encode)
src_sent
if six.PY3 [ six . PY3 ] is true ,
hypothesis
if six.PY3:
    pass
src_sent
substitute SafeText for SafeString .
hypothesis
SafeString = SafeText
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute SafeBytes for SafeString .
hypothesis
SafeString = SafeBytes
src_sent
substitute SafeText for SafeUnicode .
hypothesis
SafeUnicode = SafeText
src_sent
define the function mark_safe with an argument s .
hypothesis
def mark_safe(s):
    pass
src_sent
if s is an instance of SafeData .
hypothesis
if isinstance(s, SafeData):
    pass
src_sent
return s .
hypothesis
return s
src_sent
if s is an instance of bytes or Promise and s._delegate_bytes [ s . _delegate_bytes ] is true ,
hypothesis
if isinstance(s, (bytes, Promise)) or s._delegate_bytes and s._delegate_bytes:
    pass
src_sent
return an instance of SafeBytes , created with an argument s .
hypothesis
return SafeBytes(s)
src_sent
if s is an instance of six.text_type [ six . text_type ] or Promise ,
hypothesis
if isinstance(s, six.text_type, Promise):
    pass
src_sent
return an instance of SafeText , created with an argument s .
hypothesis
return SafeText(s)
src_sent
return an instance of SafeText , created with an argument s converted into a string .
hypothesis
return SafeText(str(s))
src_sent
define the function mark_for_escaping with an argument s .
hypothesis
def mark_for_escaping(s):
    pass
src_sent
if s is an instance of SafeData or EscapeData ,
hypothesis
if isinstance(s, (SafeData, EscapeData)):
    pass
src_sent
return s .
hypothesis
return s
src_sent
if s is an instance of bytes or Promise and s._delegate_bytes [ s . _delegate_bytes ] is true ,
hypothesis
if isinstance(s, (bytes, Promise)) or s._delegate_bytes and s._delegate_bytes:
    pass
src_sent
return an instance of EscapeBytes , created with an argument s .
hypothesis
return EscapeBytes(s)
src_sent
if s is an instance of six.text_type [ six . text_type ] or Promise ,
hypothesis
if isinstance(s, six.text_type, Promise):
    pass
src_sent
return an instance of EscapeText , created with an argument s .
hypothesis
return EscapeText(s)
src_sent
return an instance of EscapeBytes , created with an argument , reuslt of the call to the function bytes with an argument s .
hypothesis
return EscapeBytes(s)
src_sent
import module opera .
hypothesis
import opera
src_sent
import module sys .
hypothesis
import sys
src_sent
import module types .
hypothesis
import types
src_sent
__author__ is a string _STR:0_ .
hypothesis
__author__ = '_STR:0_'
src_sent
__version__ is a string _STR:0_ .
hypothesis
__version__ = '_STR:0_'
src_sent
if first element of sys.version_info [ sys . version_info ] equals integer 2 , PY2 is boolean True , otherwise it is boolean False .
hypothesis
PY2 = True if sys.version_info[0] == 2 else True
src_sent
if first element of sys.version_info [ sys . version_info ] equals integer 3 , PY3 is boolean True , otherwise it is boolean False .
hypothesis
PY3 = sys.version_info[0] == 3
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
substitute str for string_types .
hypothesis
string_types = str
src_sent
substitute int for integer_types .
hypothesis
integer_types = int
src_sent
substitute type for class_types .
hypothesis
class_types = type
src_sent
substitute str for text_type .
hypothesis
text_type = str
src_sent
substitute bytes for binary_type .
hypothesis
binary_type = bytes
src_sent
substitute sys.maxsize [ sys . maxsize ] for MAXSIZE .
hypothesis
MAXSIZE = sys.maxsize
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute basestring for string_types .
hypothesis
string_types = basestring
src_sent
integer_types is a tuple with 2 elements int and long .
hypothesis
integer_types = int, long
src_sent
class_types is a tuple with 2 elements : type and types.ClassType [ types . ClassType ] .
hypothesis
class_types = type, types.ClassType
src_sent
substitute unicode for text_type .
hypothesis
text_type = unicode
src_sent
substitute str for binary_type .
hypothesis
binary_type = str
src_sent
if sys.platform [ sys . platform ] starts with string _STR:0_ ,
hypothesis
if sys.platform.startswith('_STR:0_'):
    pass
src_sent
bitwise shift integer 1 to the left by 31 spaces , substitute integer 1 from the result , convert the result to a integer , substitute it for MAXSIZE .
hypothesis
MAXSIZE = int(1, (1 << 31) * 1)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
derive class X from the object base class .
hypothesis
class X(object):
    pass
src_sent
define the method __len__ with an argument self .
hypothesis
def __len__(self):
    pass
src_sent
bitwise shift integer 1 to the left by 31 spaces , return the result .
hypothesis
return left - 1 ** spaces
src_sent
try
hypothesis
raise
src_sent
instantiate class X , get its length .
hypothesis
X = len(X())
src_sent
if OverflowError exception is caught ,
hypothesis
raise OverflowError
src_sent
bitwise shift integer 1 to the left by 31 spaces , substitute integer 1 from the result , convert the result to a integer , substitute it for MAXSIZE .
hypothesis
MAXSIZE = int(1, (1 << 31) * 1)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
bitwise shift integer 1 to the left by 63 spaces , substitute integer 1 from the result , convert the result to a integer , substitute it for MAXSIZE .
hypothesis
MAXSIZE = int(1, (1 << 63) * 1)
src_sent
delete X .
hypothesis
del X
src_sent
define the function _add_doc with 2 arguments : func and doc .
hypothesis
def _add_doc(func, doc):
    pass
src_sent
substitute doc for func.__doc__ [ func . __doc__ ] .
hypothesis
func.__doc__ = doc
src_sent
define the function _import_module with an argument name .
hypothesis
def _import_module(name):
    pass
src_sent
call the function __import__ with an argument name .
hypothesis
__import__(name)
src_sent
return value under the name key of the sys.modules [ sys . modules ] dictionary .
hypothesis
return sys.modules[name]
src_sent
derive class _LazyDescr from the object base class .
hypothesis
class _LazyDescr(object):
    pass
src_sent
define the method __init__ with 2 arguments : self and name .
hypothesis
def __init__(self, name):
    pass
src_sent
substitute name for self.name [ self . name ] .
hypothesis
self.name = name
src_sent
define the method __get__ with 3 arguments : self , obj and tp .
hypothesis
def __get__(self, obj, tp):
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the method self._resolve [ self . _resolve ] , substitute the result for result .
hypothesis
result = self._resolve()
src_sent
if ImportError exception is caught ,
hypothesis
if ImportError:
    pass
src_sent
raise an AttributeError with an argument string _STR:0_ , formated with self.name [ self . name ] .
hypothesis
raise AttributeError('_STR:0_' % self.name)
src_sent
set self.name [ self . name ] attribute of the obj object to result .
hypothesis
hasattr(obj, self.name, result)
src_sent
delete self.name [ self . name ] attribute from the obj.__class__ [ obj . __class__ ] object .
hypothesis
del obj.__class__[self.name]
src_sent
return result .
hypothesis
return result
src_sent
derive class MovedModule from the _LazyDescr base class .
hypothesis
class MovedModule(_LazyDescr):
    pass
src_sent
define the method __init__ with 4 arguments : self , name , old and new set to None .
hypothesis
def __init__(self, name, old, new=None):
    pass
src_sent
call the __init__ method with an argument name from the base class of the MovedModule class .
hypothesis
super(MovedModule, self).__init__(name)
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
if new is None ,
hypothesis
if new is None:
    pass
src_sent
substitute name for new .
hypothesis
new = name
src_sent
substitute new for self.mod [ self . mod ] .
hypothesis
self.mod = new
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute old for self.mod [ self . mod ] .
hypothesis
self.mod = old
src_sent
define the method _resolve with an argument self .
hypothesis
def _resolve(self):
    pass
src_sent
call the function _import_module with an argument self.mod [ self . mod ] , return the result .
hypothesis
return _import_module(self.mod)
src_sent
define the method __getattr__ with 2 arguments : self and attr set to None .
hypothesis
def __getattr__(self, attr=None):
    pass
src_sent
if attr equals any of the strings _STR:0_ , _STR:1_ or _STR:2_ and self.mod [ self . mod ] is not contained in sys.modules [ sys . modules ] ,
hypothesis
if attr == '_STR:0_' + attr and self.mod not in sys.modules:
    pass
src_sent
raise an AttributeError with an argument attr .
hypothesis
raise AttributeError(attr)
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the method self._resolve [ self . _resolve ] , substitute the result for _module .
hypothesis
_module = self._resolve()
src_sent
if ImportError exception is caught ,
hypothesis
if ImportError:
    pass
src_sent
raise an AttributeError with an argument attr .
hypothesis
raise AttributeError(attr)
src_sent
get attr attribute from the _module object , substitute it for value .
hypothesis
value = getattr(_module, attr)
src_sent
set attr attribute of the self object to value .
hypothesis
messages(self, attr, value)
src_sent
return value .
hypothesis
return value
src_sent
derive class _LazyModule from the types.ModuleType [ types . ModuleType ] base class .
hypothesis
class _LazyModule(types.ModuleType):
    pass
src_sent
define the method __init__ with 2 arguments : self and name .
hypothesis
def __init__(self, name):
    pass
src_sent
call the method __init__ with an argument name form the base class of the class _LazyModule .
hypothesis
super(_LazyModule, self).__init__(name)
src_sent
substitute self.__class__.__doc__ [ self . __class__ . __doc__ ] for self.__doc__ [ self . __doc__ ] .
hypothesis
self.__doc__ = self.__class__.__doc__
src_sent
define the method __dir__ with an argument self .
hypothesis
def __dir__(self):
    pass
src_sent
attrs is a list with 2 elements : strings _STR:0_ and _STR:1_ .
hypothesis
attrs = ['_STR:0_', '_STR:1_']
src_sent
append attr.name [ attr . name ] to attrs for every attr in self._moved_attributes [ self . _moved_attributes ] .
hypothesis
attrs = [attr.name for attr in self._moved_attributes]
src_sent
return attrs .
hypothesis
return attrs
src_sent
_moved_attributes is an empty list .
hypothesis
_moved_attributes = []
src_sent
derive class MovedAttribute from the _LazyDescr base class .
hypothesis
class MovedAttribute(_LazyDescr):
    pass
src_sent
define the method __init__ with 6 arguments : self , name , old_mod , new_mod , old_attr set to None , new_attr set to None .
hypothesis
def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
    pass
src_sent
call the method __init__ with an argument name form the base class of the class MovedAttribute .
hypothesis
super(MovedAttribute, self).__init__(name)
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
if new_mod is None ,
hypothesis
if new_mod is None:
    pass
src_sent
substitute name for new_mod .
hypothesis
new_mod = name
src_sent
substitute new_mod for self.mod [ self . mod ] .
hypothesis
self.mod = new_mod
src_sent
if new_attr is None ,
hypothesis
if new_attr is None:
    pass
src_sent
if old_attr is None ,
hypothesis
if old_attr is None:
    pass
src_sent
substitute name for new_attr .
hypothesis
new_attr = name
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute old_attr for new_attr .
hypothesis
new_attr = old_attr
src_sent
substitute new_attr for self.attr [ self . attr ] .
hypothesis
self.attr = new_attr
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute old_mod for self.mod [ self . mod ] .
hypothesis
self.mod = old_mod
src_sent
if old_attr is None ,
hypothesis
if old_attr is None:
    pass
src_sent
substitute name for old_attr .
hypothesis
old_attr = name
src_sent
substitute old_attr for self.attr [ self . attr ] .
hypothesis
self.attr = old_attr
src_sent
define the method _resolve with an argument self .
hypothesis
def _resolve(self):
    pass
src_sent
call the function _import_module with an argument self.mod [ self . mod ] , substitute the result for module .
hypothesis
module = _import_module(self.mod)
src_sent
gett self.attr [ self . attr ] from the module object , return it .
hypothesis
return module.get(self.attr)
src_sent
derive class _MovedItems from the _LazyModule base class .
hypothesis
class _MovedItems(_LazyModule):
    pass
src_sent
_moved_attributes is a list with 55 initial elements , 13 of them are the results of the call to the function MovedAttribute ,
hypothesis
_moved_attributes = [MovedAttribute(them), MovedAttribute(them),
    MovedAttribute(them)]
src_sent
with different 3 string arguments , the others are results of the call to the function MovedModule called with 3 string arguments . for every attr in _moved_attributes ,
hypothesis
for attr in _moved_attributes:
    pass
src_sent
set attr.name [ attr . name ] attribute of the _MovedItemst object to attr .
hypothesis
True(_MovedItemst, attr.name, attr)
src_sent
if attr is an instance of MovedModule .
hypothesis
if isinstance(attr, MovedModule):
    pass
src_sent
concatenate __name__ , string _STR:0_ and attr.name [ attr . name ] together , use it as an key to get the value from the sys.modules [ sys . modules ] dictionary ,
hypothesis
sys.modules[attr.name()] = '_STR:0_' + attr.name, attr.name(attr.name)
src_sent
substitute attr for the obtained value . delete attr .
hypothesis
attr.delete(attr)
src_sent
substitute _moved_attributes for _MovedItems._moved_attributes [ _MovedItems . _moved_attributes ] .
hypothesis
_MovedItems._moved_attributes = _moved_attributes
src_sent
append string _STR:0_ to __name__ , use it as an argument to instantiate _MovedItems class , assign it to moves ,
hypothesis
moves = _MovedItems(__name__.append('_STR:0_'))
src_sent
and to value under the _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_parse from the _LazyModule base class .
hypothesis
class Module_six_moves_urllib_parse(_LazyModule):
    pass
src_sent
_urllib_parse_moved_attributes is a list with 16 elemetns , all of them are the results of the call to the function MovedAttribute with different 3 string arguments .
hypothesis
_urllib_parse_moved_attributes = [MovedAttribute(elemetns, all(3))]
src_sent
for every attr in _urllib_parse_moved_attributes ,
hypothesis
for attr in _urllib_parse_moved_attributes:
    pass
src_sent
set attr.name [ attr . name ] attribute of the Module_six_moves_urllib_parse object to attr .
hypothesis
True(Module_six_moves_urllib_parse, attr.name, attr)
src_sent
delete attr .
hypothesis
del attr
src_sent
substitute _urllib_parse_moved_attributes for Module_six_moves_urllib_parse._moved_attributes [ Module_six_moves_urllib_parse . _moved_attributes ] .
hypothesis
Module_six_moves_urllib_parse._moved_attributes = (
    _urllib_parse_moved_attributes)
src_sent
call the method Module_six_moves_urllib_request with an argument : string _STR:0_ appended to __name__ ,
hypothesis
return Module_six_moves_urllib_request(__name__ + '_STR:0_' % __name__)()
src_sent
assign the result to the value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to the value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_error from the _LazyModule base class .
hypothesis
class Module_six_moves_urllib_error(_LazyModule):
    pass
src_sent
_urllib_error_moved_attributes is a list with 3 elements : result of the call to the function MovedAttribute with 3 arguments :
hypothesis
_urllib_error_moved_attributes = [MovedAttribute(result, MovedAttribute(
    format + max_age))]
src_sent
strings _STR:0_ , _STR:1_ , _STR:2_ , result of the call to the function MovedAttribute with 3 arguments : strings _STR:3_ , _STR:1_ , _STR:2_ and result of the call to the function MovedAttribute with 3 arguments : strings _STR:4_ , _STR:5_ , _STR:2_ . for every attr in _urllib_error_moved_attributes ,
hypothesis
for attr in _urllib_error_moved_attributes[:-MovedAttribute('_STR:3_',
    '_STR:2_', MovedAttribute('_STR:3_', '_urllib_error_moved_attributes'))]:
    pass
src_sent
set attr.name [ attr . name ] attribute of the Module_six_moves_urllib_error object to attr .
hypothesis
True(Module_six_moves_urllib_error, attr.name, attr)
src_sent
delete attr .
hypothesis
del attr
src_sent
substitute _urllib_error_moved_attributes for Module_six_moves_urllib_error._moved_attributes [ Module_six_moves_urllib_error . _moved_attributes ] .
hypothesis
Module_six_moves_urllib_error._moved_attributes = (
    _urllib_error_moved_attributes)
src_sent
call the method Module_six_moves_urllib_request with an argument : string _STR:0_ appended to __name__ ,
hypothesis
return Module_six_moves_urllib_request(__name__ + '_STR:0_' % __name__)()
src_sent
assign the result to the value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to the value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_request from the _LazyModule base class .
hypothesis
class Module_six_moves_urllib_request(_LazyModule):
    pass
src_sent
_urllib_request_moved_attributes is an list with 33 elements , all of them are the results of the call to the function MovedAttribute with 3 different string arguments .
hypothesis
_urllib_request_moved_attributes = [MovedAttribute(33, *MovedAttribute('3')
    ), '3']
src_sent
for every attr in _urllib_request_moved_attributes ,
hypothesis
for attr in _urllib_request_moved_attributes:
    pass
src_sent
set attr.name [ attr . name ] attribute of the Module_six_moves_urllib_request object to attr .
hypothesis
True(Module_six_moves_urllib_request, attr.name, attr)
src_sent
delete attr .
hypothesis
del attr
src_sent
substitute _urllib_request_moved_attributes for Module_six_moves_urllib_request._moved_attributes [ Module_six_moves_urllib_request . _moved_attributes ] .
hypothesis
Module_six_moves_urllib_request._moved_attributes = (
    _urllib_request_moved_attributes)
src_sent
call the method Module_six_moves_urllib_request with an argument : string _STR:0_ appended to __name__ ,
hypothesis
return Module_six_moves_urllib_request(__name__ + '_STR:0_' % __name__)()
src_sent
assign the result to the value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to the value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_response from the _LazyModule base class .
hypothesis
class Module_six_moves_urllib_response(_LazyModule):
    pass
src_sent
_urllib_response_moved_attributes is a list with 4 elements : result of the function MovedAttribute , called with 3 arguments :
hypothesis
_urllib_response_moved_attributes = [MovedAttribute(key, MovedAttribute(
    value, encoding, errors='replace'))]
src_sent
strings _STR:0_ , _STR:1_ and _STR:2_ , result of the function MovedAttribute , called with 3 arguments : strings _STR:3_ , _STR:1_ , _STR:2_ , result of the function MovedAttribute , called with 3 arguments : strings _STR:4_ , _STR:1_ , _STR:2_ and result of the function MovedAttribute , called with 3 arguments : strings _STR:5_ , _STR:1_ , _STR:2_ . for every attr in _urllib_response_moved_attributes ,
hypothesis
for attr in _urllib_response_moved_attributes[:-MovedAttribute('_STR:0_',
    '_STR:1_', '_STR:2_')]:
    pass
src_sent
set attr.name [ attr . name ] attribute of Module_six_moves_urllib_response object to attr .
hypothesis
getattr(Module_six_moves_urllib_response, attr.name, attr)
src_sent
delete attr .
hypothesis
del attr
src_sent
substitute _urllib_response_moved_attributes for Module_six_moves_urllib_response._moved_attributes [ Module_six_moves_urllib_response . _moved_attributes ] .
hypothesis
Module_six_moves_urllib_response._moved_attributes = (
    _urllib_response_moved_attributes)
src_sent
instantiate class Module_six_moves_urllib_response with an argument , string _STR:0_ appended to __name__ ,
hypothesis
return Module_six_moves_urllib_response(__name__ + '_STR:0_') % (__name__,
    app_or_project)
src_sent
assign it to value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib_robotparser from the _LazyModule base class .
hypothesis
class Module_six_moves_urllib_robotparser(_LazyModule):
    pass
src_sent
_urllib_robotparser_moved_attributes is a list containing an instance of MovedAttribute class , created with 3 argument : strings ,
hypothesis
_urllib_robotparser_moved_attributes = [MovedAttribute('', [self.app_name,
    self.__class__.__name__])]
src_sent
_STR:0_ , _STR:1_ , _STR:2_ . for every attr in _urllib_robotparser_moved_attributes ,
hypothesis
for attr in _urllib_robotparser_moved_attributes:
    pass
src_sent
set attr.name [ attr . name ] attribute of Module_six_moves_urllib_robotparser object to attr .
hypothesis
getattr(Module_six_moves_urllib_robotparser, attr.name, attr)
src_sent
delete attr .
hypothesis
del attr
src_sent
substitute _urllib_robotparser_moved_attributes for Module_six_moves_urllib_robotparser._moved_attributes [ Module_six_moves_urllib_robotparser . _moved_attributes ] .
hypothesis
Module_six_moves_urllib_robotparser._moved_attributes = (
    _urllib_robotparser_moved_attributes)
src_sent
instantiate class Module_six_moves_urllib_robotparser with an argument , string _STR:0_ appended to __name__ ,
hypothesis
return Module_six_moves_urllib_robotparser(__name__ + '_STR:0_') % (__name__,
    app_or_project)
src_sent
assign it to value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary , and to value under the string _STR:1_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . derive class Module_six_moves_urllib from the types.ModuleType [ types . ModuleType ] base class .
hypothesis
class Module_six_moves_urllib(types.ModuleType, [sys.get(__name__, None)[0] for
    x in None]):
    pass
src_sent
append string _STR:0_ to __name__ , use it as an key to get the value from the sys.modules [ sys . modules ] dictionary , substitute it for parse .
hypothesis
parse = sys.modules[__name__.append('_STR:0_')]
src_sent
append string _STR:0_ to __name__ , use it as an key to get the value from the sys.modules [ sys . modules ] dictionary , substitute it for error .
hypothesis
error = sys.modules[__name__.append('_STR:0_')]
src_sent
append string _STR:0_ to __name__ , use it as an key to get the value from the sys.modules [ sys . modules ] dictionary , substitute it for request .
hypothesis
request = sys.modules[__name__.append('_STR:0_')]
src_sent
append string _STR:0_ to __name__ , use it as an key to get the value from the sys.modules [ sys . modules ] dictionary , substitute it for response .
hypothesis
response = sys.modules[__name__.append('_STR:0_')]
src_sent
append string _STR:0_ to __name__ , use it as an key to get the value from the sys.modules [ sys . modules ] dictionary , substitute it for robotparser .
hypothesis
robotparser = sys.modules[__name__.append('_STR:0_')]
src_sent
define the method __dir__ with an argument self .
hypothesis
def __dir__(self):
    pass
src_sent
return a list with 5 elements : strings _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ and _STR:4_ .
hypothesis
return ['_STR:0_', '_STR:1_', '_STR:2_', '_STR:3_', '_STR:4_']
src_sent
instantiate class Module_six_moves_urllib with an argument , string _STR:0_ appended to __name__ ,
hypothesis
return Module_six_moves_urllib(__name__ + '_STR:0_') % (__name__,
    app_or_project)
src_sent
substitute it for value under the string _STR:0_ appended to __name__ key of the sys.modules [ sys . modules ] dictionary . define the function add_move with an argument move .
hypothesis
def add_move(move):
    pass
src_sent
set move.name [ move . name ] attribute of the _MovedItems to move .
hypothesis
hasattr(move.name, move.name)
src_sent
define the function remove_move with an argument name .
hypothesis
def remove_move(name):
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
delete name attribute of the _MovedItems object .
hypothesis
del getattr(_MovedItems, name)
src_sent
if AttributeError exception is caught ,
hypothesis
if AttributeError:
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
delete entry under the name key of the moves.__dict__ [ moves . __dict__ ] dictionary .
hypothesis
del moves.__dict__[name]
src_sent
if NameError exception is caught ,
hypothesis
raise NameError
src_sent
raise an AttributeError with an argument string _STR:0_ , formated with a tuple with an element name .
hypothesis
raise AttributeError('_STR:0_' % (a, name))
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
_meth_func is a string _STR:0_ .
hypothesis
_meth_func = '_STR:0_'
src_sent
_meth_self is a string _STR:0_ .
hypothesis
_meth_self = '_STR:0_'
src_sent
_func_closure is a string _STR:0_ .
hypothesis
_func_closure = '_STR:0_'
src_sent
_func_code is a string _STR:0_ .
hypothesis
_func_code = '_STR:0_'
src_sent
_func_defaults is a string _STR:0_ .
hypothesis
_func_defaults = '_STR:0_'
src_sent
_func_globals is a string _STR:0_ .
hypothesis
_func_globals = '_STR:0_'
src_sent
_iterkeys is a string _STR:0_ .
hypothesis
_iterkeys = '_STR:0_'
src_sent
_itervalues is a string _STR:0_ .
hypothesis
_itervalues = '_STR:0_'
src_sent
_iteritems is a string _STR:0_ .
hypothesis
_iteritems = '_STR:0_'
src_sent
_iterlists is a string _STR:0_ .
hypothesis
_iterlists = '_STR:0_'
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
_meth_func is a string _STR:0_ .
hypothesis
_meth_func = '_STR:0_'
src_sent
_meth_self is a string _STR:0_ .
hypothesis
_meth_self = '_STR:0_'
src_sent
_func_closure is a string _STR:0_ .
hypothesis
_func_closure = '_STR:0_'
src_sent
_func_code is a string _STR:0_ .
hypothesis
_func_code = '_STR:0_'
src_sent
_func_defaults is a string _STR:0_ .
hypothesis
_func_defaults = '_STR:0_'
src_sent
_func_globals is a string _STR:0_ .
hypothesis
_func_globals = '_STR:0_'
src_sent
_iterkeys is a string _STR:0_ .
hypothesis
_iterkeys = '_STR:0_'
src_sent
_iterkeys is a string _STR:0_ .
hypothesis
_iterkeys = '_STR:0_'
src_sent
_iteritems is a string _STR:0_ .
hypothesis
_iteritems = '_STR:0_'
src_sent
_iterlists is a string _STR:0_ .
hypothesis
_iterlists = '_STR:0_'
src_sent
try ,
hypothesis
if any():
    pass
src_sent
substitute next for advance_iterator .
hypothesis
advance_iterator = next
src_sent
if NameError exception is caught ,
hypothesis
raise NameError
src_sent
define the function advance_iterator with an argument it .
hypothesis
def advance_iterator():
    pass
src_sent
return next element of the iterable it .
hypothesis
return iterable[3]
src_sent
substitute klass.__dict__ [ klass . __dict__ ] for next .
hypothesis
next = klass.__dict__
src_sent
try ,
hypothesis
if any():
    pass
src_sent
substitute callable for callable .
hypothesis
callable = callable
src_sent
if NameError exception is caught ,
hypothesis
raise NameError
src_sent
define the function callable with an argument obj .
hypothesis
def callable(obj):
    pass
src_sent
if _STR:0_ is contained in klass.__dict__ [ klass . __dict__ ] for any klass in __mro__ field of the obj class , return boolean True , otherwise return False .
hypothesis
return '_STR:0_' in klass.__dict__
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
define the function get_unbound_function with an argument unbound .
hypothesis
def get_unbound_function(unbound):
    pass
src_sent
return unbound .
hypothesis
return unbound
src_sent
substitute Iterator for create_bound_method .
hypothesis
create_bound_method = Iterator
src_sent
substitute object for Iterator .
hypothesis
Iterator = object
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
define the function get_unbound_function with an argument unbound .
hypothesis
def get_unbound_function(unbound):
    pass
src_sent
return unbound.im_func [ unbound . im_func ] .
hypothesis
return unbound.im_func
src_sent
define the function create_bound_function with 2 arguments : func and obj .
hypothesis
def create_bound_function(func, obj):
    pass
src_sent
call the method types.MethodType [ types . MethodType ] with 3 arguments : func , obj and obj.__class__ [ obj . __class__ ] , return the result .
hypothesis
return types.MethodType(func, obj, obj.__class__)
src_sent
derive the class Iterator from the base class object .
hypothesis
class Iterator(object):
    pass
src_sent
define the method next with an argument self .
hypothesis
def next(self):
    pass
src_sent
call the function type with an argument self , on the result call the method __next__ with an argument self , return the result .
hypothesis
return type(self).__next__(self)
src_sent
substitute callable for callable .
hypothesis
callable = callable
src_sent
call the function _add_doc with 2 arguments : get_unbound_function and string _STR:0_ '' Get the function out of a possibly unbound function_STR:0_ '' .
hypothesis
value = _add_doc(get_unbound_function, '_STR:0_')
src_sent
call the method operator.attrgetter [ operator . attrgetter ] with an argument _meth_func , substitute the result for get_method_function .
hypothesis
get_method_function = operator.attrgetter(_meth_func)
src_sent
call the method operator.attrgetter [ operator . attrgetter ] with an argument _meth_self , substitute the result for get_method_self .
hypothesis
get_method_self = operator.attrgetter(_meth_self)
src_sent
call the method operator.attrgetter [ operator . attrgetter ] with an argument _func_closure , substitute the result for get_method_closure .
hypothesis
get_method_closure = operator.attrgetter(_func_closure)
src_sent
call the method operator.attrgetter [ operator . attrgetter ] with an argument _func_code , substitute the result for get_method_code .
hypothesis
get_method_code = operator.attrgetter(_func_code)
src_sent
call the method operator.attrgetter [ operator . attrgetter ] with an argument _func_defaults , substitute the result for get_method_defaults .
hypothesis
get_method_defaults = operator.attrgetter(_func_defaults)
src_sent
call the method operator.attrgetter [ operator . attrgetter ] with an argument _func_globals , substitute the result for get_method_globals .
hypothesis
get_method_globals = operator.attrgetter(_func_globals)
src_sent
define the function iterkeys with 2 arguments : d and unpacked dictionary kw .
hypothesis
def iterkeys(d, **kw):
    pass
src_sent
get _iterkeys attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable ,
hypothesis
self.queryset.write(property(getattr(d, _iterkeys), **kw).,(*kw))
src_sent
return it . define the function itervalues with 2 arguments : d and unpacked dictionary kw .
hypothesis
def itervalues(d, **kw):
    pass
src_sent
get _itervalues attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable ,
hypothesis
self.queryset.write(property(getattr(d, _itervalues), **kw).,(*kw))
src_sent
return it . define the function iteritems with 2 arguments : d and unpacked dictionary kw .
hypothesis
def iteritems(d, **kw):
    pass
src_sent
get _iteritems attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable ,
hypothesis
self.queryset.write(property(getattr(d, _iteritems), **kw).,(*kw))
src_sent
return it . define the function iterlists with 2 arguments : d and unpacked dictionary kw .
hypothesis
def iterlists(d, **kw):
    pass
src_sent
get _iterlists attribute of the class d , call the result with an argument unpacked dictionary kw , convert the result to a iterable ,
hypothesis
self.queryset.write(property(getattr(d, _iterlists), **kw).,(*kw))
src_sent
return it . if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
define the function b with an argument s .
hypothesis
def b(s):
    pass
src_sent
call the method e.encode [ e . encode ] with an argument string _STR:0_ .
hypothesis
e.encode('_STR:0_')
src_sent
define the function u with an argument s .
hypothesis
def u(s):
    pass
src_sent
return s .
hypothesis
return s
src_sent
substitute chr for unichr .
hypothesis
unichr = chr
src_sent
if second element of sys.version_info [ sys . version_info ] is smaller than or equal to integer 1 ,
hypothesis
if sys.version_info[1] >= 1:
    pass
src_sent
define the function int2byte with an argument i .
hypothesis
def int2byte(i):
    pass
src_sent
call the function bytes with an argument tuple with an element i , return the result .
hypothesis
return bytes((i,))
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the method operator.methodcaller [ operator . methodcaller ] with 3 arguments : string _STR:0_ , integer 1 and string _STR:1_ , substitute the result for int2byte .
hypothesis
int2byte = operator.methodcaller('_STR:0_', 1, '_STR:1_')
src_sent
call te method operator.itemgetter [ operator . itemgetter ] with an argument integer 0 , substitute the result for byte2int .
hypothesis
byte2int = operator.itemgetter(0)
src_sent
substitute operator.getitem [ operator . getitem ] for indexbytes .
hypothesis
indexbytes = operator.getitem
src_sent
substitute iter for iterbytes .
hypothesis
iterbytes = iter
src_sent
import io .
hypothesis
import io
src_sent
substitute io.StringIO [ io . StringIO ] for StringIO .
hypothesis
StringIO = io.StringIO
src_sent
substitute io.BytesIO [ io . BytesIO ] for BytesIO .
hypothesis
BytesIO = io.BytesIO
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
define the function b with an argument s .
hypothesis
def b(s):
    pass
src_sent
return s .
hypothesis
return s
src_sent
define the function u with an argument s .
hypothesis
def u(s):
    pass
src_sent
replace every occurrence of raw string _STR:0_\\\\ ' , use the result and string _STR:1_ ,
hypothesis
value = value.replace(str('_STR:0_\\\\\\\\'), raw.replace('\\', '_STR:1_'),
    '_STR:1_')
src_sent
as arguments for the call to the unicode function , return the result . substitute unichr for unichr .
hypothesis
unichr = unichr
src_sent
substitute chr for int2byte .
hypothesis
int2byte = chr
src_sent
define the function byte2int with an argument bs .
hypothesis
def byte2int(bs):
    pass
src_sent
get the integer representation of the first element of bs , return it .
hypothesis
return representation(bs[0])
src_sent
define the function indexbytes with 2 arguments buf and i .
hypothesis
def indexbytes(buf, i):
    pass
src_sent
get the integer representation of the i-th element of buf , return it .
hypothesis
return ord(buf[i])
src_sent
define the function iterbytes with an argument buf .
hypothesis
def iterbytes(buf):
    pass
src_sent
convert byte to its integer representation , return all of the results for every byte in buf .
hypothesis
return all(byte(byte) for byte in buf)
src_sent
import StringIO .
hypothesis
import StringIO
src_sent
assign StringIO.StringIO [ StringIO . StringIO ] to StringIO and BytesIO .
hypothesis
StringIO = BytesIO = StringIO.StringIO
src_sent
call the function _add_doc with 2 arguments : b and string _STR:0_ '' Byte literal_STR:0_ '' .
hypothesis
return _add_doc(b, '_STR:0_')
src_sent
call the function _add_doc with 2 arguments : u and string _STR:0_ '' Text literal_STR:0_ '' .
hypothesis
return _add_doc(u, '_STR:0_')
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
get _STR:0_ attribute from the moves.builtins [ moves . builtins ] object , substitute it for exec_ .
hypothesis
exec_ = getattr(moves.builtins, '_STR:0_')
src_sent
define the function reraise with 3 arguments : tp , value and tb set to None .
hypothesis
def reraise(tp, value, tb=None):
    pass
src_sent
if value.__traceback__ [ value . __traceback__ ] is not tb ,
hypothesis
if value.__traceback__ is not tb:
    pass
src_sent
raise an value.with_traceback [ value . with_traceback ] exception with an argument tb .
hypothesis
raise value.with_traceback(tb)
src_sent
raise an exception value .
hypothesis
raise value
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
define the function exec with 3 arguments : _code_ , _globs_ set to None and _locs_ set to None .
hypothesis
def exec(_code_, _globs_=None, _locs_=None):
    pass
src_sent
if _globs_ is None ,
hypothesis
if _globs_ is None:
    pass
src_sent
call the method sys._getframe [ sys . _getframe ] with an argument 1 , substitute the result for frame .
hypothesis
frame = sys._getframe(1)
src_sent
substitute frame.f_globals [ frame . f_globals ] for _globs_ .
hypothesis
_globs_ = frame.f_globals
src_sent
if _locs_ is None ,
hypothesis
if _locs_ is None:
    pass
src_sent
substitute if _locs_ is None for _locs_ .
hypothesis
_locs_ = _locs_[None:]
src_sent
delete frame .
hypothesis
del frame
src_sent
otherwise if _locs_ is None ,
hypothesis
if True:
    pass
elif _locs_ is None:
    pass
src_sent
substitute _globs_ with an argument _locs_ .
hypothesis
_locs_ = _globs_
src_sent
execute code statement _STR:0_ '' exec _code_ in _globs_ , _locs__STR:0_ '' .
hypothesis
_globs_, _globs_ = str('_globs_'), str(_globs_)
src_sent
call the function exec_ with an argument string _STR:0_ '' def reraise ( tp , value , tb=None ) : raise tp , value , tb_STR:0_ '' .
hypothesis
return exec_('_STR:0_', reraise(value, value))
src_sent
get attribute _STR:0_ from the moves.builtins [ moves . builtins ] object , if it exists substitute it for print_ , if not print_ is None .
hypothesis
print_ = getattr(moves.builtins, '_STR:0_', None)
src_sent
if print_ is None ,
hypothesis
if print_ is None:
    pass
src_sent
define the function print_ with 2 arguments : unpacked list args and unpacked dictionary kwargs .
hypothesis
def print_(*args, **kwargs):
    pass
src_sent
remover _STR:0_ key from the kwargs dictionary , if it exists substitute it for fp , if not substitute sys.stdout [ sys . stdout ] for fp .
hypothesis
fp = kwargs.pop('_STR:0_', sys.stdout)
src_sent
if fp is None ,
hypothesis
if fp is None:
    pass
src_sent
return nothing .
hypothesis
return
src_sent
define the function write with an argument data .
hypothesis
def write(data):
    pass
src_sent
if data is not an instance of basestring ,
hypothesis
if not isinstance(data, basestring):
    pass
src_sent
convert data to string , substitute it for data .
hypothesis
data = str(data)
src_sent
if fp is an instance of file and data is an instance of unicode and fp.encoding [ fp . encoding ] is not None ,
hypothesis
if isinstance(fp, unicode) and isinstance(data, unicode
    ) and fp.encoding is not None:
    pass
src_sent
get _STR:0_ attribute from fp object , substitute it for errors if it exists , if not errors is None .
hypothesis
errors = getattr(fp, '_STR:0_', None)
src_sent
if errors is None ,
hypothesis
if errors is None:
    pass
src_sent
errors is a string _STR:0_ .
hypothesis
errors = '_STR:0_'
src_sent
call the method data.encode [ data . encode ] with 2 arguments : fp.encoding [ fp . encoding ] and errors , substitute the result for data .
hypothesis
data = data.encode(fp.encoding, errors)
src_sent
write data to fp .
hypothesis
fp.write(data)
src_sent
want_unicode is boolean False .
hypothesis
want_unicode = False
src_sent
remove _STR:0_ key from the kwargs dictionary , if it exists substitute it for sep , if not sep is None .
hypothesis
sep = kwargs.pop('_STR:0_', None)
src_sent
if sep is not None ,
hypothesis
if sep is not None:
    pass
src_sent
if sep is an instance of unicode ,
hypothesis
if isinstance(sep, unicode):
    pass
src_sent
want_unicode is boolean True .
hypothesis
want_unicode = True
src_sent
otherwise if sep is not an instance of string type ,
hypothesis
if True:
    pass
elif not isinstance(sep, string):
    pass
src_sent
raise an TypeError exception with an argument string _STR:0_ .
hypothesis
raise TypeError('_STR:0_')
src_sent
remove _STR:0_ key from the kwargs dictionary , if it exists substitute it for end , if not end is None .
hypothesis
end = kwargs.pop('_STR:0_', None)
src_sent
if end is not None ,
hypothesis
if end is not None:
    pass
src_sent
if end is an instance of unicode ,
hypothesis
if isinstance(end, unicode):
    pass
src_sent
want_unicode is boolean True .
hypothesis
want_unicode = True
src_sent
otherwise if end is not an instance of string type ,
hypothesis
if True:
    pass
elif not isinstance(end, string):
    pass
src_sent
raise an TypeError exception with an argument string _STR:0_ .
hypothesis
raise TypeError('_STR:0_')
src_sent
if kwargs is true ,
hypothesis
if kwargs:
    pass
src_sent
raise an TypeError exception with an argument string _STR:0_ .
hypothesis
raise TypeError('_STR:0_')
src_sent
if want_unicode is false ,
hypothesis
if not want_unicode:
    pass
src_sent
for every arg in args ,
hypothesis
for arg in args:
    pass
src_sent
if arg is an instance of unicode ,
hypothesis
if isinstance(arg, unicode):
    pass
src_sent
want_unicode is boolean True .
hypothesis
want_unicode = True
src_sent
break from the loop execution .
hypothesis
break
src_sent
if want_unicode is true ,
hypothesis
if want_unicode:
    pass
src_sent
convert newline character to unicode and substitute the result for newline .
hypothesis
str('\n', 1)
src_sent
convert whitespace character to unicode and substitute the result for space .
hypothesis
space = max(whitespace)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute newline character for newline .
hypothesis
"""
""" = '\n'
src_sent
substitute string _STR:0_ for space .
hypothesis
space = '_STR:0_'
src_sent
if sep is None ,
hypothesis
if sep is None:
    pass
src_sent
substitute space for sep .
hypothesis
sep = space
src_sent
if end is None
hypothesis
if end is None:
    pass
src_sent
substitute space for end .
hypothesis
end = space
src_sent
for every i and arg in enumerated iterable args ,
hypothesis
for i, arg in enumerate(args):
    pass
src_sent
if i is true ,
hypothesis
if i:
    pass
src_sent
call the function write with an argument sep .
hypothesis
write(sep)
src_sent
call the function write with an argument arg .
hypothesis
write(arg)
src_sent
call the function write with an argument end .
hypothesis
write(end)
src_sent
call the function _add_doc with 2 arguments : reraise and string _STR:0_ '' Reraise an exception._STR:0_ [ exception . _STR:0_ ] '' .
hypothesis
return _add_doc(reraise, '_STR:0_')
src_sent
define the function with_metaclass with 2 arguments meta and unpacked list bases .
hypothesis
def with_metaclass(meta, *bases):
    pass
src_sent
derive the class metaclass form the meta base class .
hypothesis
class metaclass(meta):
    pass
src_sent
substitute type.__call__ [ type . __call__ ] for __call__ .
hypothesis
__call__ = type.__call__
src_sent
substitute type.__init__ [ type . __init__ ] for __init__ .
hypothesis
__init__ = type.__init__
src_sent
define the method __new__ with 4 arguments : cls , name , this_bases and d .
hypothesis
def __new__(cls, name, this_bases, d):
    pass
src_sent
if this_bases is None ,
hypothesis
if this_bases is None:
    pass
src_sent
call the method type.__new__ [ type . __new__ ] with 4 arguments : cls , name , empty tuple and d , return the result .
hypothesis
return type.__new__(cls, name, empty, d)
src_sent
call the function meta with 3 arguments : name , base and d .
hypothesis
meta(name, base, d)
src_sent
return an instance of metaclass class , created with 3 arguments : string _STR:0_ , None and an empty dictionary .
hypothesis
return metaclass('_STR:0_', None, {})
src_sent
define the function add_metaclass with an argument metaclass .
hypothesis
def add_metaclass(metaclass):
    pass
src_sent
define the function wrapper with an argument cls .
hypothesis
def wrapper(cls):
    pass
src_sent
call the method cls.__dict__.copy [ cls . __dict__ . copy ] substitute the result for orig_vars .
hypothesis
orig_vars = cls.__dict__.copy()
src_sent
remove _STR:0_ key from the orig_vars dictionary .
hypothesis
orig_vars.pop('_STR:0_', None)
src_sent
remove _STR:0_ key from the orig_vars dictionary .
hypothesis
orig_vars.pop('_STR:0_', None)
src_sent
get the value under the _STR:0_ key of the orig_vars dictionary , substitute it for slots .
hypothesis
slots = orig_vars.get('_STR:0_')
src_sent
if slots is not None ,
hypothesis
if slots is not None:
    pass
src_sent
if slots is an instance of str ,
hypothesis
if isinstance(slots, str):
    pass
src_sent
slots is a list with an element , slots .
hypothesis
slots = [slots]
src_sent
for every slots_var in slots ,
hypothesis
for slots_var in slots:
    pass
src_sent
remove slots_var key from the orig_vars dictionary .
hypothesis
orig_vars.pop(slots_var)
src_sent
return an instance of metaclass class , created with 3 arguments : cls.__name__ [ cls . __name__ ] , cls.__bases__ [ cls . __bases__ ] and orig_vars .
hypothesis
return metaclass(cls.__name__, cls.__bases__, orig_vars)
src_sent
return wrapper .
hypothesis
return wrapper
src_sent
if PY3 is true ,
hypothesis
if PY3:
    pass
src_sent
_assertCountEqual is a strnig _STR:0_ .
hypothesis
_assertCountEqual = '_STR:0_'
src_sent
_assertRaisesRegex is a strnig _STR:0_ .
hypothesis
_assertRaisesRegex = '_STR:0_'
src_sent
_assertRegex is a strnig _STR:0_ .
hypothesis
_assertRegex = '_STR:0_'
src_sent
substitute memoryview for memoryview .
hypothesis
memoryview = memoryview
src_sent
buffer_types is a tuple with 3 elements : bytes , bytearray and memoryview .
hypothesis
buffer_types = bytes, bytearray, memoryview
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
_assertCountEqual is a strnig _STR:0_ .
hypothesis
_assertCountEqual = '_STR:0_'
src_sent
_assertRaisesRegex is a strnig _STR:0_ .
hypothesis
_assertRaisesRegex = '_STR:0_'
src_sent
_assertRegex is a strnig _STR:0_ .
hypothesis
_assertRegex = '_STR:0_'
src_sent
if sys.platform [ sys . platform ] starts with a string _STR:0_ ,
hypothesis
if sys.platform.startswith('_STR:0_'):
    pass
src_sent
substitute memoryview for memoryview .
hypothesis
memoryview = memoryview
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute buffer for memoryview .
hypothesis
memoryview = buffer
src_sent
buffer_types is a tuple with 2 elements bytearray and memoryview .
hypothesis
buffer_types = bytearray, memoryview
src_sent
define the function assertCountEqual with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
hypothesis
def assertCountEqual(self, *args, **kwargs):
    pass
src_sent
get _assertCountEqual attribute of the self object , call the result with 2 arguments : unpacked list args ,
hypothesis
return getattr(self, _assertCountEqual)(*args, **kwargs)
src_sent
and unpacked dictionary kwargs , return the result . define the function assertRaisesRegex with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
hypothesis
def assertRaisesRegex(self, *args, **kwargs):
    pass
src_sent
get _assertRaisesRegex attribute of the self object , call the result with 2 arguments : unpacked list args ,
hypothesis
return getattr(self, _assertRaisesRegex)(*args, **kwargs)
src_sent
and unpacked dictionary kwargs , return the result . define the function assertRegex with 3 arguments : self , unpacked list args and unpacked dictionary kwargs .
hypothesis
def assertRegex(self, *args, **kwargs):
    pass
src_sent
get _assertRegex attribute of the self object , call the result with 2 arguments : unpacked list args ,
hypothesis
return getattr(self, _assertRegex)(*args, **kwargs)
src_sent
and unpacked dictionary kwargs , return the result . call the function MovedModule with 2 arguments : strings _STR:0_ and _STR:1_ ,
hypothesis
return mark_safe(MovedModule('_STR:0_', '_STR:1_'), **kwargs)
src_sent
use the result as an argument for the call to the add_move function . call the function MovedModule with 2 arguments : strings _STR:0_ and _STR:1_ ,
hypothesis
MovedModule('_STR:0_', '_STR:1_')
src_sent
import module contextlib .
hypothesis
import contextlib
src_sent
try ,
hypothesis
if any():
    pass
src_sent
import threading .
hypothesis
import threading
src_sent
except ImportError .
hypothesis
ImportError *= 2
src_sent
import dummy_threading as threading .
hypothesis
import dummy_threading as threading
src_sent
derive the class RWLock from the object base class .
hypothesis
class RWLock(object):
    pass
src_sent
define the method __init__ with an argument self .
hypothesis
def __init__(self):
    pass
src_sent
call the method threading.RLock [ threading . RLock ] , substitute the result for self.mutex [ self . mutex ] .
hypothesis
self.mutex = threading.RLock()
src_sent
call the method threading.Semaphore [ threading . Semaphore ] with an argument integer 0 , substitute the result for self.can_read [ self . can_read ] .
hypothesis
self.can_read = threading.Semaphore(0)
src_sent
call the method threading.Semaphore [ threading . Semaphore ] with an argument integer 0 , substitute the result for self.can_write [ self . can_write ] .
hypothesis
self.can_write = threading.Semaphore(0)
src_sent
self.active_readers [ self . active_readers ] is an integer 0 .
hypothesis
self.active_readers = 0
src_sent
self.active_writers [ self . active_writers ] is an integer 0 .
hypothesis
self.active_writers = 0
src_sent
self.waiting_readers [ self . waiting_readers ] is an integer 0 .
hypothesis
self.waiting_readers = 0
src_sent
self.waiting_writers [ self . waiting_writers ] is an integer 0 .
hypothesis
self.waiting_writers = 0
src_sent
define the method reader_enters with an argument self .
hypothesis
def reader_enters(self):
    pass
src_sent
with self.mutex [ self . mutex ] perform ,
hypothesis
with self.mutex:
    pass
src_sent
if self.active_writers [ self . active_writers ] and self.waiting_writers [ self . waiting_writers ] both equal to integer 0 ,
hypothesis
if self.active_writers and self.waiting_writers == 0:
    pass
src_sent
increment self.active_readers [ self . active_readers ] by 1 .
hypothesis
self.active_readers += 1
src_sent
call the method self.can_read.release [ self . can_read . release ] .
hypothesis
self.can_read.release()
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
increment self.waiting_readers [ self . waiting_readers ] by 1 .
hypothesis
self.waiting_readers += 1
src_sent
call the method self.can_read.acquire [ self . can_read . acquire ] .
hypothesis
self.can_read.acquire()
src_sent
define the method reader_leaves with an argument self .
hypothesis
def reader_leaves(self):
    pass
src_sent
with self.mutex [ self . mutex ] perform ,
hypothesis
with self.mutex:
    pass
src_sent
decrement self.active_readers [ self . active_readers ] by integer 1 ,
hypothesis
self.active_readers -= 1
src_sent
if self.active_readers [ self . active_readers ] equals integer 0 and self.waiting_writers [ self . waiting_writers ] is not equal to integer 0 ,
hypothesis
if self.active_readers == 0 and self.waiting_writers != 0:
    pass
src_sent
increment self.active_writers [ self . active_writers ] by 1 .
hypothesis
self.active_writers += 1
src_sent
decrement self.waiting_writers [ self . waiting_writers ] by integer 1 ,
hypothesis
self.waiting_writers -= 1
src_sent
call the method self.can_write.release [ self . can_write . release ] .
hypothesis
self.can_write.release()
src_sent
contextlib.contextmanager [ contextlib . contextmanager ] decorator ,
hypothesis
@contextlib.contextmanager
def dummy():
    pass
src_sent
define the method reader with an argument self .
hypothesis
def reader(self):
    pass
src_sent
call the method self.reader_enters [ self . reader_enters ] .
hypothesis
self.reader_enters()
src_sent
try ,
hypothesis
if any():
    pass
src_sent
yield nothing .
hypothesis
yield
src_sent
finally perform ,
hypothesis
def dummy():
    pass
src_sent
call the method self.reader_leaves [ self . reader_leaves ] .
hypothesis
self.reader_leaves()
src_sent
define the method writer_enters with an argument self .
hypothesis
def writer_enters(self):
    pass
src_sent
with self.mutex [ self . mutex ] perform ,
hypothesis
with self.mutex:
    pass
src_sent
if self.active_writers [ self . active_writers ] equals integer 0 and self.waiting_writers [ self . waiting_writers ] equals integer 0 and self.active_readers [ self . active_readers ] equals integer 0 ,
hypothesis
if self.active_writers == 0 and self.waiting_writers == 0:
    pass
src_sent
increment self.active_writers [ self . active_writers ] by integer 1 ,
hypothesis
self.active_writers += 1
src_sent
call the method self.can_write.release [ self . can_write . release ] .
hypothesis
self.can_write.release()
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
increment self.waiting_writers [ self . waiting_writers ] by integer 1 ,
hypothesis
self.waiting_writers += 1
src_sent
call the method self.can_write.acquire [ self . can_write . acquire ] .
hypothesis
self.can_write.acquire()
src_sent
define the method writer_leaves with an argument self .
hypothesis
def writer_leaves(self):
    pass
src_sent
with self.mutex [ self . mutex ] perform ,
hypothesis
with self.mutex:
    pass
src_sent
decrement self.active_writers [ self . active_writers ] by integer 1 ,
hypothesis
self.active_writers -= 1
src_sent
if self.waiting_writers [ self . waiting_writers ] is not equal to integer 0 ,
hypothesis
if self.waiting_writers != 0:
    pass
src_sent
increment self.active_writers [ self . active_writers ] by integer 1 ,
hypothesis
self.active_writers += 1
src_sent
decrement self.waiting_writers [ self . waiting_writers ] by integer 1 ,
hypothesis
self.waiting_writers -= 1
src_sent
call the method self.can_write.release [ self . can_write . release ] .
hypothesis
self.can_write.release()
src_sent
otherwise if self.waiting_readers [ self . waiting_readers ] is not equal to integer 0 ,
hypothesis
if True:
    pass
elif self.waiting_readers != 0:
    pass
src_sent
substitute self.waiting_readers [ self . waiting_readers ] for t .
hypothesis
t = self.waiting_readers
src_sent
self.waiting_readers [ self . waiting_readers ] is integer 0 .
hypothesis
self.waiting_readers = 0
src_sent
increment self.active_readers [ self . active_readers ] by t .
hypothesis
self.active_readers += t
src_sent
while t is greater than integer 0 ,
hypothesis
while t > 0:
    pass
src_sent
call the method self.can_read.release [ self . can_read . release ] .
hypothesis
self.can_read.release()
src_sent
decrement t by integer 1 ,
hypothesis
t -= 1
src_sent
contextlib.contextmanager [ contextlib . contextmanager ] decorator ,
hypothesis
@contextlib.contextmanager
def dummy():
    pass
src_sent
define the method writer with an argument self .
hypothesis
def writer(self):
    pass
src_sent
call the method self.writer_enters [ self . writer_enters ] .
hypothesis
self.writer_enters()
src_sent
try ,
hypothesis
if any():
    pass
src_sent
yield nothing .
hypothesis
yield
src_sent
finally perform ,
hypothesis
def dummy():
    pass
src_sent
call the method self.writer_leaves [ self . writer_leaves ] .
hypothesis
self.writer_leaves()
src_sent
from django.utils [ django . utils ] import six into default name space .
hypothesis
from django.utils import six
src_sent
color_names is a tuple with 8 elements : strings _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ and _STR:7_ .
hypothesis
color_names = ('_STR:0_', '_STR:1_', '_STR:2_', '_STR:3_', '_STR:4_',
    '_STR:5_', '_STR:6_', '_STR:7_')
src_sent
foreground is a dictionary created with elements : x appended to a string _STR:0_ for value under the key x of color_names dictionary ,
hypothesis
foreground = dict((str(x), x.split('_STR:0_', '')) for x, color_names in
    color_names.items())
src_sent
for every x in sequence of integers from 0 to 7. background is a dictionary created with elements : x appended to a string _STR:0_ for value under the key x of color_names dictionary ,
hypothesis
background = dict((color_names.split('_STR:0_'), '_STR:0_'.join(color_names +
    ('_STR:0_' + x), required=False), x) for x in sequence)
src_sent
for every x in sequence of integers from 0 to 7 . RESET is a string _STR:0_ .
hypothesis
RESET = '_STR:0_' + int(7)
src_sent
opt_dict is an dictionary with 5 elements : _STR:0_ for _STR:1_ , _STR:2_ for _STR:3_ , _STR:4_ for _STR:5_ , _STR:6_ for _STR:7_ ,
hypothesis
opt_dict = {'_STR:1_': '_STR:0_', '_STR:3_': '_STR:2_', '_STR:4_': '_STR:2_'}
src_sent
and _STR:0_ for _STR:1_ . define the method colorize with 3 arguments : text set to an empty string , opts set to an empty tuple and unpacked dictionary kwargs .
hypothesis
def colorize(text, files=(), *kwargs, **kwargs):
    pass
src_sent
code_list is an empty list .
hypothesis
code_list = []
src_sent
if text is an empty string and length of opts equals integer 1 and first element of opts equals string _STR:0_ ,
hypothesis
if text == '' and (len(opts) == 1 and opts[0] == '_STR:0_'):
    pass
src_sent
format string _STR:0_ with RESET , return the result .
hypothesis
return '_STR:0_' % RESET
src_sent
call the function six.iteritems [ six . iteritems ] with an argument kwargs , for every k and v in the result ,
hypothesis
for k, v in six.iteritems(kwargs):
    pass
src_sent
if k equals a string _STR:0_ ,
hypothesis
if k == '_STR:0_':
    pass
src_sent
append value under the key v of foreground dictionary to code_list .
hypothesis
foreground.append(foreground[key])
src_sent
otherwise if k equals a string _STR:0_ ,
hypothesis
if True:
    pass
elif k == '_STR:0_':
    pass
src_sent
append value under the key v of background dictionary to code_list .
hypothesis
background.append(background[key])
src_sent
for every o in opts ,
hypothesis
for o in opts:
    pass
src_sent
if o is contained in opt_dict ,
hypothesis
if o in opt_dict:
    pass
src_sent
append value under the 0 key of the opt_dict dictionary to code_list .
hypothesis
opt_dict.append(opt_dict[0])
src_sent
if string _STR:0_ is not contained in opts ,
hypothesis
if '_STR:0_' not in opts:
    pass
src_sent
if text is true format with it and RESET a string _STR:0_ , if not format it with an empty string and RESET , substitute the result for text .
hypothesis
text = text or getattr(format, '_STR:0_', RESET)
src_sent
join elements of code_list in a string , separated by _STR:0_ , format string _STR:1_ with it , append text to the result if exists ,
hypothesis
return '\n'.join(code_list, '_STR:1_' % text)
src_sent
return the string . define the function make_style with 2 arguments : opts set to an empty tuple and unpacked dictionary kwargs .
hypothesis
def make_style(opts=(), **kwargs):
    pass
src_sent
return lambda function with text as argument and return value being result of the function colorize , called with 3 arguments : text ,
hypothesis
return (lambda text: colorize(text, safe='replace')) % colorize(text,
    errors='replace')
src_sent
opts and unpacked dictionary kwargs . NOCOLOR_PALETTE is a string _STR:0_ .
hypothesis
NOCOLOR_PALETTE = '_STR:0_'
src_sent
DARK_PALETTE is a string _STR:0_ .
hypothesis
DARK_PALETTE = '_STR:0_'
src_sent
LIGHT_PALETTE is a string _STR:0_ .
hypothesis
LIGHT_PALETTE = '_STR:0_'
src_sent
PALETTES is a dictionary containing 3 elements , a dictionary with 18 pairs of dictionary value and string keys for NOCOLOR_PALETTE ,
hypothesis
PALETTES = {NOCOLOR_PALETTE: dict(value), NOCOLOR_PALETTE: str(keys)}
src_sent
a dictionary with 18 pairs of dictionary value and string keys for DARK_PALETTE , and a dictionary with 18 pairs of dictionary value and string keys for LIGHT_PALETTE . substitute DARK_PALETTE for DEFAULT_PALETTE .
hypothesis
DEFAULT_PALETTE = DARK_PALETTE
src_sent
define the function parse_color_setting with an argument config_string .
hypothesis
def parse_color_setting(config_string):
    pass
src_sent
if config_string is false ,
hypothesis
if not config_string:
    pass
src_sent
return value under the DEFAULT_PALETTE key of the PALETTES dictionary .
hypothesis
return PALETTES[DEFAULT_PALETTE]
src_sent
convert config_string to lowercase and split it by _STR:0_ character , substitute the result for parts .
hypothesis
parts = config_string.lower().split('_STR:0_')
src_sent
get value under the config_string key of the PALETTES dictionary , call the copy method on the result and substitute it for palette .
hypothesis
palette = PALETTES(PALETTES[config_string]).copy()
src_sent
for every part in parts ,
hypothesis
for part in parts:
    pass
src_sent
if part is contained in PALETTES ,
hypothesis
if part in PALETTES:
    pass
src_sent
get the value under the part key of the PALETTES dictionary , update with it palette dictionary .
hypothesis
PALETTES[part].update(PALETTES[part])
src_sent
otherwise if _STR:0_ is contained in part ,
hypothesis
if True:
    pass
elif '_STR:0_' in part:
    pass
src_sent
definition is an empty dictionary ,
hypothesis
definition = {}
src_sent
split part by _STR:0_ character , substitute the result for role and instructions , respectively .
hypothesis
role, instructions = part.split('_STR:0_')
src_sent
convert role to uppercase .
hypothesis
uppercase = max(role)
src_sent
split instructions by _STR:0_ character , substitute the result for styles .
hypothesis
styles = instructions.split('_STR:0_')
src_sent
reverse the order of elements of styles .
hypothesis
styles = reversed(styles)
src_sent
remove first element from styles , split it by the _STR:0_ character , substitute the result for colors .
hypothesis
colors = styles.pop(styles[0], '_STR:0_')
src_sent
reverse the order of colors elements ,
hypothesis
colors['max_length'] = reversed(colors) - reversed(colors)
src_sent
remove the first element from colors , substitute it for fg .
hypothesis
fg = colors.pop()
src_sent
if fg is contained in color_names ,
hypothesis
if fg in color_names:
    pass
src_sent
substitute fg for value under the _STR:0_ key of definition dictionary .
hypothesis
definition['_STR:0_'] = fg
src_sent
if colors is true and last element of colors is contained in color_names ,
hypothesis
if colors and colors[-1] in color_names:
    pass
src_sent
substitute last element of colors for value under the _STR:0_ key of definition dictionary .
hypothesis
definition['_STR:0_'] = colors[-1]
src_sent
opts is a tuple created out of elements s , for every s in styles is s is in the keys of the opt_dict dictionary .
hypothesis
opts = [(s,) for s in styles]
src_sent
if opts is true ,
hypothesis
if opts:
    pass
src_sent
substitute opts for value under the _STR:0_ key of definition dictionary .
hypothesis
definition['_STR:0_'] = opts
src_sent
if role is contained in value under the NOCOLOR_PALETTE key of the PALETTES dictionary and definition is true ,
hypothesis
if role in PALETTES[NOCOLOR_PALETTE] and definition:
    pass
src_sent
substitute definition for value under the role key of palette dictionary .
hypothesis
palette[role] = definition
src_sent
if palette equals value under the NOCOLOR_PALETTE key of the PALETTES dictionary ,
hypothesis
if palette == PALETTES[NOCOLOR_PALETTE]:
    pass
src_sent
return None .
hypothesis
return None
src_sent
return palette .
hypothesis
return palette
src_sent
from __future__ import unicode_literals into default name space .
hypothesis
from __future__ import unicode_literals
src_sent
import module re .
hypothesis
import re
src_sent
import module unicodedata .
hypothesis
import unicodedata
src_sent
from gzip import GzipFile into default name space .
hypothesis
from gzip import GzipFile
src_sent
from io import BytesIO into default name space .
hypothesis
from io import BytesIO
src_sent
import module warnings .
hypothesis
import warnings
src_sent
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
hypothesis
from django.utils.deprecation import RemovedInDjango19Warning
src_sent
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
hypothesis
from django.utils.encoding import force_text
src_sent
from django.utils.functional [ django . utils . functional ] import allow_lazy and SimpleLazyObject into default name space .
hypothesis
from django.utils.functional import allow_lazy, SimpleLazyObject
src_sent
from django.utils [ django . utils ] import six into default name space .
hypothesis
from django.utils import six
src_sent
from django.utils.six.moves [ django . utils . six . moves ] import html_entities into default name space .
hypothesis
from django.utils.six.moves import html_entities
src_sent
from django.utils.translation [ django . utils . translation ] import ugettext_lazy , ugettext as _ and pgettext into default name space .
hypothesis
from django.utils.translation import ugettext_lazy, ugettext as _, pgettext
src_sent
from django.utils.safestring [ django . utils . safestring ] import mark_safe into default name space .
hypothesis
from django.utils.safestring import mark_safe
src_sent
if six.PY2 [ six . PY2 ] is true ,
hypothesis
if six.PY2:
    pass
src_sent
from django.utils.encoding [ django . utils . encoding ] import force_unicode .
hypothesis
from django.utils.encoding import force_unicode
src_sent
if identity lambda function returns false , substitute the x for capfirst , if not call the function force_text with an argument x ,
hypothesis
capfirst = identity or (force_text(x), force_text(x))
src_sent
convert the first element of the result to uppercase , append to it the rest of the result , substitute it for capfirst . call the function allow_lazy with 3 arguments : capfirst and six.text_type [ six . text_type ] .
hypothesis
capfirst = allow_lazy(capfirst, six.text_type)
src_sent
call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ and bitwise OR performed with 2 operands ,
hypothesis
p = re.compile('_STR:0_', performed % 2)
src_sent
re.U [ re . U ] and re.S [ re . S ] , substitute the result for re_words . call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ and bitwise OR performed with 2 operands ,
hypothesis
message = re.compile('_STR:0_', (operands, re.escape(operands)) | operands)
src_sent
re.U [ re . U ] and re.S [ re . S ] , substitute the result for re_chars . call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ and bitwise OR performed with 2 operands ,
hypothesis
message = re.compile('_STR:0_', (operands, re.escape(operands)) | operands)
src_sent
re.U [ re . U ] and re.S [ re . S ] , substitute the result for re_chars . call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for re_newlines .
hypothesis
re_newlines = re.compile('_STR:0_')
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for re_camel_case .
hypothesis
re_camel_case = re.compile('_STR:0_')
src_sent
define the function wrap with 2 arguments text and width .
hypothesis
def wrap(text, width):
    pass
src_sent
call the function force_text with an argument text , substitute the result for text .
hypothesis
text = force_text(text)
src_sent
define the function _generator .
hypothesis
def _generator():
    pass
src_sent
call the method text.splitlines [ text . splitlines ] with an argument boolean True , for every line in the result ,
hypothesis
for line in text.splitlines(True):
    pass
src_sent
if line ends with a new line character substitute width incremented by integer 1 for max_width , if not substitute width for max_width .
hypothesis
max_width = width[1:] + width if line.endswith(width) else width
src_sent
while length of line is grater than max_width ,
hypothesis
while len(line) > max_width:
    pass
src_sent
get fist max_width incremented by 1 elements from line , find index of the first occurrenece of whitespace from the right side ,
hypothesis
value = line[max_width + 1:3]
src_sent
add integer 1 to it , substitute the result for space . if space equals integer 0 ,
hypothesis
if space == 0:
    pass
src_sent
find first index of whitespace occurrence in line , add integer 1 to it , substitute the result for space .
hypothesis
space = max(whitespace)[0] + 1
src_sent
if space equals integer 0 ,
hypothesis
if space == 0:
    pass
src_sent
yield line .
hypothesis
yield line
src_sent
line is an empty string .
hypothesis
line = ''
src_sent
break from the loop execution
hypothesis
break
src_sent
get the first space decremented with integer 1 elements from string line , append newline character to it , and yield the result .
hypothesis
yield line[1:line + 1]
src_sent
remove all the elements from space index of line .
hypothesis
connection = line[space.pop(line, line):]
src_sent
if line ends with a new line character substitute width incremented by integer 1 for max_width , if not substitute width for max_width .
hypothesis
max_width = width[1:] + width if line.endswith(width) else width
src_sent
if line is true ,
hypothesis
if line:
    pass
src_sent
yield line .
hypothesis
yield line
src_sent
call the function _generator , join the result into a string , return the result .
hypothesis
return ''.join(_generator(_generator()))
src_sent
call the function allow_lazy with 2 arguments : wrap and six.text_type [ six . text_type ] , substitute the result for wrap .
hypothesis
wrap = allow_lazy(wrap, six.text_type)
src_sent
derive the class Truncator form the SimpleLazyObject class .
hypothesis
class Truncator(SimpleLazyObject):
    pass
src_sent
define the method __init__ with 2 arguments : self and text .
hypothesis
def __init__(self, text):
    pass
src_sent
call the method __init__ from the base class of the class Truncator ,
hypothesis
super(Truncator, self).__init__()
src_sent
called with with an argument lambda function which returns result of the force_text function called with an argument text . define the method add_truncation_text with 3 arguments : self , text and truncate set to None .
hypothesis
def add_truncation_text(self, text, truncate=None):
    pass
src_sent
if truncate is None ,
hypothesis
if truncate is None:
    pass
src_sent
call the function pgettext with an argument _STR:0_ , _STR:1_ , substitute the result for truncate .
hypothesis
truncate = pgettext('_STR:0_', '_STR:1_')
src_sent
call the function force_text with an argument truncate , substitute the result for truncate .
hypothesis
truncate = force_text(truncate)
src_sent
if string _STR:0_ is contained in truncate ,
hypothesis
if '_STR:0_' in truncate:
    pass
src_sent
format truncate with a dictionary with an element : text for _STR:0_ , return the result .
hypothesis
return format(truncate, {'_STR:0_': text})
src_sent
if text ends with truncate ,
hypothesis
if text.endswith(truncate):
    pass
src_sent
return text .
hypothesis
return text
src_sent
append truncate to text , return the result .
hypothesis
return text + truncate
src_sent
define the method chars with 4 arguments : self , num , truncate set to None , html set to boolean False .
hypothesis
def chars(self, num, truncate=None, html=False):
    pass
src_sent
convert num to an integer , substitute it for length .
hypothesis
length = int(num)
src_sent
call the function unicodedata.normalize [ unicodedata . normalize ] with 2 arguments : string _STR:0_ and self._wrapped [ self . _wrapped ] , substitute the result for text .
hypothesis
text = unicodedata.normalize('_STR:0_', self._wrapped)
src_sent
substitute length for truncate_len .
hypothesis
truncate_len = length
src_sent
for every char in result of the self.add_truncation_text [ self . add_truncation_text ] , called with 2 arguments : an empty string and truncate .
hypothesis
for char in self.add_truncation_text('', truncate):
    pass
src_sent
call the method unicodedata.combining [ unicodedata . combining ] with an argument char , if it evaluates to false ,
hypothesis
if not unicodedata.combining(char):
    pass
src_sent
decrement truncate_len by integer 1 .
hypothesis
truncate_len -= 1
src_sent
if truncate_len equals integer 0 .
hypothesis
if truncate_len == 0:
    pass
src_sent
break from the loop execution .
hypothesis
break
src_sent
if html is true ,
hypothesis
if html:
    pass
src_sent
call the function self._truncate_html [ self . _truncate_html ] with 5 arguments : length , truncate , text , truncate_len and boolean False , return the result .
hypothesis
return self._truncate_html(length, truncate, text, truncate_len, False)
src_sent
call the method self._text_chars [ self . _text_chars ] with 4 arguments : length , truncate , text and truncate_len , return the result .
hypothesis
return self._text_chars(length, truncate, text, truncate_len)
src_sent
call the function allow_lazy with an argument chars , substitute the result for chars .
hypothesis
chars = allow_lazy(chars)
src_sent
define the method _text_chars with 5 arguments : self , length , truncate , text and truncate_len .
hypothesis
def _text_chars(self, length, truncate, text, truncate_len):
    pass
src_sent
s_len is integer 0 .
hypothesis
s_len = 0
src_sent
end_index is None .
hypothesis
end_index = None
src_sent
for every i and char in enumerated text ,
hypothesis
for i, char in enumerate(text):
    pass
src_sent
call the function unicodedata.combining [ unicodedata . combining ] with an argument char , if it evaluates to true ,
hypothesis
if unicodedata.combining(char):
    pass
src_sent
skip this loop iteration , s
hypothesis
continue
src_sent
increment s_len by integer 1 ,
hypothesis
s_len += 1
src_sent
if end_index is None and s_len is greater than truncate_len ,
hypothesis
if end_index is None and s_len > truncate_len:
    pass
src_sent
substitute i for end_index .
hypothesis
end_index = i
src_sent
if s_len is greater than length ,
hypothesis
if s_len > length:
    pass
src_sent
call the method self.add_truncation_text [ self . add_truncation_text ] with 2 arguments : if end_index is greater than zero , first end_index elements of text ,
hypothesis
if end_index > zero or text[:2]:
    pass
src_sent
if not an empty string , and truncate , return the result . return text .
hypothesis
return text
src_sent
define the method words with 4 arguments : self , num , truncate set to None , html set to boolean False .
hypothesis
def words(self, num, truncate=None, html=False):
    pass
src_sent
convert num to an integer , substitute the result for length .
hypothesis
length = int(num)
src_sent
if html is true ,
hypothesis
if html:
    pass
src_sent
call the method self._truncate_html [ self . _truncate_html ] with 5 arguments : length , truncate , self._wrapped [ self . _wrapped ] , length and boolean True , return the result .
hypothesis
return self._truncate_html(length, truncate, self._wrapped, length, True)
src_sent
call the method self._text_words [ self . _text_words ] with 2 arguments length and truncate , return the result .
hypothesis
return self._text_words(length, truncate)
src_sent
call the function allow_lazy with an argument words , substitute the result for words .
hypothesis
words = allow_lazy(words)
src_sent
define the method _text_words with 3 arguments : self , length and truncate .
hypothesis
def _text_words(self, length, truncate):
    pass
src_sent
split self._wrapped [ self . _wrapped ] into words , substitute the result for words .
hypothesis
words = words.split(self._wrapped)
src_sent
if length of words is greater than length ,
hypothesis
if len(words) > length:
    pass
src_sent
substitute first length elements of words for words .
hypothesis
words = words[:len(words)]
src_sent
call the method self.add_truncation_text [ self . add_truncation_text ] with 2 arguments : elements of words joined in a string , separated with whitespaces ,
hypothesis
self.add_truncation_text(''.join(words), ' '.join(sep))
src_sent
and truncate , return the result . return elements of words joined in a string , separated with whitespaces .
hypothesis
return elements(words)
src_sent
define the method _truncate_html with 6 arguments : self , length , truncate , text , truncate_len and words .
hypothesis
def _truncate_html(self, length, truncate, text, truncate_len, words):
    pass
src_sent
if words is not empty and length is smaller than or equal to integer 0 ,
hypothesis
if words is not empty and length < 0:
    pass
src_sent
return an empty string .
hypothesis
return ''
src_sent
html4_singlets is a tuple with 9 elements : strings _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ and _STR:8_ .
hypothesis
html4_singlets = ('_STR:0_', '_STR:1_', '_STR:2_', '_STR:3_', '_STR:4_',
    '_STR:5_', '_STR:6_', '_STR:7_', '_STR:7_')
src_sent
pos is equal to integer 0 .
hypothesis
pos = 0
src_sent
end_text_pos is equal to integer 0 .
hypothesis
end_text_pos = 0
src_sent
current_len is equal to integer 0 .
hypothesis
current_len = 0
src_sent
open_tags is an empty list .
hypothesis
open_tags = []
src_sent
if words is true , substitute re_words for regex , if not substitute re_chars for regex .
hypothesis
regex = re_words if words else re_chars
src_sent
while current_len is smaller than or equal to length ,
hypothesis
while current_len >= length:
    pass
src_sent
call the method regex.search [ regex . search ] with 2 arguments : text and pos .
hypothesis
regex.search(text, pos)
src_sent
if m is false ,
hypothesis
if not m:
    pass
src_sent
break from the loop execution ,
hypothesis
break
src_sent
call the method m.end [ m . end ] with an argument integer 0 , substitute the result for pos .
hypothesis
pos = m.end(0)
src_sent
call the function m.group [ m . group ] , if the result evaluates to true ,
hypothesis
if m.group():
    pass
src_sent
increment current_len by integer 1 ,
hypothesis
current_len += 1
src_sent
if current_len equals truncate_len ,
hypothesis
if current_len == truncate_len:
    pass
src_sent
substitute pos for end_text_pos .
hypothesis
end_text_pos = pos
src_sent
skip this loop iteration .
hypothesis
continue
src_sent
call the method m.group [ m . group ] with an argument integer 0 , use it as an argument for the call to the re_tag.match [ re_tag . match ] function ,
hypothesis
queryset = re_tag.match(m.match(0))
src_sent
substitute the result for tag . if tag is false or current_len is greater or equal to truncate_len ,
hypothesis
if not tag or current_len >= truncate_len:
    pass
src_sent
skip this loop iteration .
hypothesis
continue
src_sent
call the method tag.groups [ tag . groups ] , substitute the result for closing_tag , tagname and self_closing , respectively .
hypothesis
closing_tag, tagname, self_closing = tag.groups()
src_sent
convert tagname to lowercase , substitute it for tagname .
hypothesis
tagname = tagname.lower()
src_sent
if self_closing is true or tagname is contained in html4_singlets ,
hypothesis
if self_closing or tagname in html4_singlets:
    pass
src_sent
do nothing .
hypothesis
pass
src_sent
otherwise if closing_tag is true ,
hypothesis
if True:
    pass
elif closing_tag:
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
get the index of the first occurrence of tagname , substitute it for i .
hypothesis
i = tagname[0].index(tagname)
src_sent
if ValueError exception is caught ,
hypothesis
raise ValueError
src_sent
do nothing .
hypothesis
pass
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
create a list out of open_tags elements form ( i+1 ) -th index to the end , substitute it for open_tags .
hypothesis
open_tags = form[open_tags[i+1]:]
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
insert tagname at the beginning of open_tags .
hypothesis
open_tags.insert(0, tagname)
src_sent
if current_len is smaller than or equal to length ,
hypothesis
if current_len in len(length):
    pass
src_sent
return text .
hypothesis
return text
src_sent
create a list out of fist end_text_pos text elemnts , substitue it for out .
hypothesis
out = filter(elemnts, fist[::-2] + out)
src_sent
call the method self.add_truncation_text [ self . add_truncation_text ] with 2 arguments : an empty string and truncate , substitute it for truncate_text .
hypothesis
truncate_text = self.add_truncation_text('', truncate)
src_sent
if truncate_text is true ,
hypothesis
if truncate_text:
    pass
src_sent
append truncate_text to out .
hypothesis
out.append(truncate_text)
src_sent
for every tag in open_tags ,
hypothesis
for tag in open_tags:
    pass
src_sent
replace %s in string _STR:0_ with tag , append the result to out .
hypothesis
out.append('_STR:0_' % tag)
src_sent
return out .
hypothesis
return out
src_sent
define the function get_valid_filename with an argument s .
hypothesis
def get_valid_filename(s):
    pass
src_sent
call the function force_text with an argument s , strip the result of whitespaces from both ends ,
hypothesis
data = force_text(s).strip()
src_sent
replace every occurrence of whitespaces in the previous result for _STR:0_ , substitute the result for s. call the function re.sub [ re . sub ] with 3 arguments : raw string _STR:1_ , an empty string and s , return the result .
hypothesis
return re.sub('_STR:1_', '', s)
src_sent
call the function allow_lazy with 2 arguments : get_valid_filename and six.text_type [ six . text_type ] , substitute the result for get_valid_filename .
hypothesis
get_valid_filename = allow_lazy(get_valid_filename, six.text_type)
src_sent
define the function get_text_list with 2 arguments : list_ and last_word set to result of the function ugettext_lazy called with an argument string _STR:0_ .
hypothesis
def get_text_list(list_, last_word=ugettext_lazy('_STR:0_')):
    pass
src_sent
is length of list_ equals integer 0 ,
hypothesis
list_ = len(list_) % 0
src_sent
return an empty string .
hypothesis
return ''
src_sent
if length of list_ equals integer 1 ,
hypothesis
if len(list_) == 1:
    pass
src_sent
call the function force_text with first element of list_ as an argument , return the result .
hypothesis
return force_text(list_[0])
src_sent
return a string _STR:0_ formated with 3 elements : result of the function force_text called with an argument i ,
hypothesis
return '_STR:0_' % (force_text(i), force_text(i), force_text(i))
src_sent
separated by result of the function _ called with an argument string _STR:0_ , for every i in list_ without last element , result of the function force_text called with an argument last_word , result of the function force_text called with an argument : last element of list_ . call the function allow_lazy with 2 arguments : get_text_list and six.text_type [ six . text_type ] , substitute the result for
hypothesis
i = filter(allow_lazy(get_text_list, six.text_type) for i in list_[2:])
src_sent
define the function normalize_newlines with an argument text .
hypothesis
def normalize_newlines(text):
    pass
src_sent
call the function force_text with an argument text , substitute the result for text .
hypothesis
text = force_text(text)
src_sent
call the method re_newlines.sub [ re_newlines . sub ] with 2 arguments : _STR:0_ and text , return the result .
hypothesis
return re_newlines.sub('_STR:0_', text)
src_sent
call the function allow_lazy with 2 arguments : normalize_newlines and six.text_type [ six . text_type ] , substitute the result for normalize_newlines .
hypothesis
normalize_newlines = allow_lazy(normalize_newlines, six.text_type)
src_sent
define the function phone2numeric with an argument phone .
hypothesis
def phone2numeric(phone):
    pass
src_sent
char2number is an dictionary , with 26 elements : 2 for _STR:0_ , 2 for _STR:1_ , 2 for _STR:2_ , 3 for _STR:3_ , 3 for _STR:4_ , 3 for _STR:5_ , 4 for _STR:6_ ,
hypothesis
continue
src_sent
4 for _STR:0_ , 4 for _STR:1_ , 4 for _STR:2_ , 5 for _STR:3_ , 5 for _STR:4_ , 5 for _STR:5_ , 6 for _STR:6_ , 6 for _STR:7_ , 6 for _STR:8_ , 7 for _STR:9_ , 7 for _STR:10_ , 7 for _STR:10_ , 7 for _STR:11_ , 7 for _STR:12_ , 8 for _STR:12_ , 8 for _STR:13_ , 8 for _STR:14_ , 9 for
hypothesis
attrs = '_STR:0_' + {'_STR:0_': _STR:14_, '_STR:1_': 7}
src_sent
call the function allow_lazy with an argument phone2numeric , substitute the result for phone2numeric .
hypothesis
phone2numeric = allow_lazy(phone2numeric)
src_sent
define the function compress_string with an argument s .
hypothesis
def compress_string(s):
    pass
src_sent
zbuf is an instance of BytesIO class .
hypothesis
zbuf = BytesIO()
src_sent
zfile is an instance of GzipFile class , created with 3 arguments : mode set to string _STR:0_ , compresslevel set to integer 6 ,
hypothesis
zfile = GzipFile(mode='_STR:0_', compresslevel=6, **(6))
src_sent
and fileobj set to zbuf . call the method zfile.write [ zfile . write ] with an argument s .
hypothesis
zfile.write(s)
src_sent
call the method zfile.close [ zfile . close ] .
hypothesis
zfile.close()
src_sent
call the method zbuf.getvalue [ zbuf . getvalue ] , return the result .
hypothesis
return zbuf.getvalue()
src_sent
derive the class StreamingBuffer from the object base class .
hypothesis
class StreamingBuffer(object):
    pass
src_sent
define the method __init__ with an argument self .
hypothesis
def __init__(self):
    pass
src_sent
self.vals [ self . vals ] is an empty list .
hypothesis
self.vals = []
src_sent
define the method write with 2 arguments : self and val .
hypothesis
def write(self, val):
    pass
src_sent
append val to self.vals [ self . vals ] .
hypothesis
self.vals.append(val)
src_sent
define the method read with an argument self .
hypothesis
def read(self):
    pass
src_sent
join elements of self.vals [ self . vals ] into a bytes string , substitute the result for ret .
hypothesis
ret = ''.join(self.vals)
src_sent
self.vals [ self . vals ] is an empty list .
hypothesis
self.vals = []
src_sent
return ret .
hypothesis
return ret
src_sent
define the method flush with an argument self .
hypothesis
def flush(self):
    pass
src_sent
return nothing .
hypothesis
return
src_sent
define the method close with an argument self .
hypothesis
def close(self):
    pass
src_sent
return nothing .
hypothesis
return
src_sent
define the function compress_sequence with an argument sequence .
hypothesis
def compress_sequence(sequence):
    pass
src_sent
buf is an instance of StreamingBuffer class .
hypothesis
buf = StreamingBuffer()
src_sent
zfile is an instance of GzipFile class , created with 3 arguments : mode set to string _STR:0_ , compresslevel set to integer 6 ,
hypothesis
zfile = GzipFile(mode='_STR:0_', compresslevel=6, **(6))
src_sent
and fileobj set to buf . read data from buf file stream , yield the result .
hypothesis
yield buf.read()
src_sent
for every item in sequence ,
hypothesis
for item in sequence:
    pass
src_sent
write item to zfile stream .
hypothesis
zfile.write(item)
src_sent
flush zfile stream buffer .
hypothesis
stream.flush()
src_sent
read data from buf , yield the result .
hypothesis
yield buf.read(buf)
src_sent
close zfile stream .
hypothesis
stream.close()
src_sent
read data from buf , yield the result .
hypothesis
yield buf.read(buf)
src_sent
call the function re.compile [ re . compile ] with an argument string _STR:0_ , substitute the result for ustring_re .
hypothesis
ustring_re = re.compile('_STR:0_')
src_sent
define the function javascript_quote with 2 arguments : s and quote_double_quotes set to boolean False .
hypothesis
def javascript_quote(s, quote_double_quotes=False):
    pass
src_sent
msg is an string _STR:0_ .
hypothesis
msg = '_STR:0_'
src_sent
call the function warnings.warn [ warnings . warn ] with 3 arguments : msg , RemovedInDjango19Warning and stacklevel as integer 2 .
hypothesis
warnings.warn(msg, RemovedInDjango19Warning, stacklevel=2)
src_sent
define the function fix with an argument match .
hypothesis
def fix(match):
    pass
src_sent
get the unicode representation of result of the method match.group [ match . group ] called with an integer 1 , format with in a string _STR:0_ ,
hypothesis
return match(match.group()) % {'_STR:0_': int(match.group())}
src_sent
return the result . if type of s equals bytes ,
hypothesis
if type(s) == bytes:
    pass
src_sent
call the method s.decode [ s . decode ] with an argument string _STR:0_ , substitute the result for s .
hypothesis
s = s.decode('_STR:0_')
src_sent
otherwise if , type of s doesnt equal to six.text_type [ six . text_type ] ,
hypothesis
if True:
    pass
elif type(s) == six.text_type:
    pass
src_sent
raise an TypeError with an argument s .
hypothesis
raise TypeError(s)
src_sent
replace every occurrence of _STR:0_\\\\ ' .
hypothesis
value = [self._STR:0_\\\\ for k, _STR:0_\\\\ in _STR:0_\\\\.replace('\\', '\\')
    ]
src_sent
replace every occurrence of _STR:0_ in s with _STR:1_ .
hypothesis
s.replace('_STR:0_', '_STR:1_')
src_sent
replace every occurrence of _STR:0_ in s with _STR:1_ .
hypothesis
s.replace('_STR:0_', '_STR:1_')
src_sent
replace every occurrence of _STR:0_ in s with _STR:1_ .
hypothesis
s.replace('_STR:0_', '_STR:1_')
src_sent
replace every occurrence of _STR:0_ in s with _STR:1_ .
hypothesis
s.replace('_STR:0_', '_STR:1_')
src_sent
replace every occurrence of _STR:0_ in s with _STR:1_ .
hypothesis
s.replace('_STR:0_', '_STR:1_')
src_sent
if quote_double_quotes is true ,
hypothesis
if quote_double_quotes:
    pass
src_sent
replace every occurrence of _STR:0_ in s with _STR:1_ .
hypothesis
s.replace('_STR:0_', '_STR:1_')
src_sent
call the method ustring_re.sub [ ustring_re . sub ] with 2 arguments : fix and s , return the result .
hypothesis
return ustring_re.sub(fix, s)
src_sent
call the function allow_lazy with 2 arguments : javascript_quote and six.text_type [ six . text_type ] , substitute the result for javascript_quote .
hypothesis
javascript_quote = allow_lazy(javascript_quote, six.text_type)
src_sent
call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ ] * ( ? : ( ? : _STR:1_\\ ] |\\ . ) *_STR:2_ ] * ) + ) | \+ ) '' ,
hypothesis
message = re.compile('_STR:0_' % ''.join(re.escape(p) for x in +))
src_sent
and re.VERBOSE [ re . VERBOSE ] , substitute the result for smart_split_re . define the function smart_split with an argument text .
hypothesis
def smart_split(text):
    pass
src_sent
call the function force_text with an argument text , substitute the result for text .
hypothesis
text = force_text(text)
src_sent
call the method smart_split_re.finditer [ smart_split_re . finditer ] with an argument text , for every bit in result ,
hypothesis
for bit in smart_split_re.finditer(text):
    pass
src_sent
call the method bit.group [ bit . group ] with an argument integer 0 , yield the result .
hypothesis
yield bit.group(0)
src_sent
define the function _replace_entity with an argument match .
hypothesis
def _replace_entity(match):
    pass
src_sent
call the method match.group [ match . group ] with an argument integer 1 , substitute the result for text .
hypothesis
text = match.group(1)
src_sent
if first element of text equals _STR:0_ ,
hypothesis
if text[0] == '_STR:0_':
    pass
src_sent
remove first element of text .
hypothesis
text.pop()
src_sent
try ,
hypothesis
if any():
    pass
src_sent
if first element of text is contained in _STR:0_ .
hypothesis
if text[0] in '_STR:0_':
    pass
src_sent
convert text without first element to hexadecimal integer , substitute it for c .
hypothesis
c = int(text[1:])
src_sent
if nor ,
hypothesis
if nor:
    pass
src_sent
convert text to an integer , substitute it for c .
hypothesis
c = int(text)
src_sent
call the method six.unichr [ six . unichr ] with an argument c , return the result .
hypothesis
return six.unichr(c)
src_sent
if ValueError exception is caught ,
hypothesis
raise ValueError
src_sent
call the method match.group [ match . group ] with an argument integer 0 , return the result .
hypothesis
return match.group(0)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the function six.unichr [ six . unichr ] with value under the text key of the html_entities.name2codepoint [ html_entities . name2codepoint ] dictionary , return the result .
hypothesis
return six.unichr(html_entities.name2codepoint[text][text])
src_sent
if OverflowError or ValueError exceptions are caught ,
hypothesis
if OverflowError:
    pass
src_sent
call the method match.group [ match . group ] with an argument integer 0 , return the result .
hypothesis
return match.group(0)
src_sent
call the method re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for _entity_re .
hypothesis
_entity_re = re.compile('_STR:0_')
src_sent
define the function unescape_entities with an argument text .
hypothesis
def unescape_entities(text):
    pass
src_sent
call the method _entity_re.sub [ _entity_re . sub ] with 2 arguments : _replace_entity and text , return the result .
hypothesis
return _entity_re.sub(_replace_entity, text)
src_sent
call the function allow_lazy with 2 arguments : unescape_entities and six.text_type [ six . text_type ] , substitute the result for unescape_entities .
hypothesis
unescape_entities = allow_lazy(unescape_entities, six.text_type)
src_sent
define the function unescape_string_literal with an argument s .
hypothesis
def unescape_string_literal(s):
    pass
src_sent
if first element of s is not contained in _STR:0_ or last element of s is not equal to first element of s ,
hypothesis
if s[0] not in '_STR:0_' or s[-1] != s[0]:
    pass
src_sent
raise an ValueError exception wit an argument string _STR:0_ , where _STR:1_ is replaced with s .
hypothesis
raise ValueError('_STR:0_' % s)
src_sent
substitute first element of s for quote .
hypothesis
quote = s[0]
src_sent
remove first and last elements of s , replace every occurrence of string _STR:0_ formated with quote with quote ,
hypothesis
s.append(s.replace('_STR:0_', last, quote.replace(quote, quote)))
src_sent
replace every occurrence of raw string _STR:0_\\ ' , return the result . call the function allow_lazy with an argument unescape_string_literal , substitute the result for unescape_string_literal .
hypothesis
unescape_string_literal = allow_lazy(unescape_string_literal)
src_sent
define the function slugify with an argument value .
hypothesis
def slugify(value):
    pass
src_sent
call the method unicodedata.normalize [ unicodedata . normalize ] with 2 arguments : string _STR:0_ and value , encode the result with 2 arguments : string _STR:1_ ,
hypothesis
unicodedata.extend(unicodedata.normalize('_STR:0_', value))
src_sent
and string _STR:0_ , call the method decode on the result with an argument string _STR:1_ , substitute the result for value . call the method re.sub [ re . sub ] with 3 arguments : string _STR:2_ , empty string and value , strip the result of whitespaces from both ends ,
hypothesis
value = re.sub('_STR:2_', '', value).strip()
src_sent
and convert it to lowercase , substitute the result for value . call the function re.sub [ re . sub ] with 3 arguments : string _STR:0_ , string _STR:1_ and value , use the result as an argument for the call to the ,
hypothesis
value = import_module(re.sub('_STR:0_', '_STR:1_', value))
src_sent
mark_safe function , return the result . call the function allow_lazy with 2 arguments : slugify and six.text_type [ six . text_type ] , substitute the result slugify .
hypothesis
slugify = allow_lazy(slugify, six.text_type)
src_sent
define the function camel_case_to_spaces with an argument value .
hypothesis
def camel_case_to_spaces(value):
    pass
src_sent
call the method re_camel_case.sub [ re_camel_case . sub ] with 2 arguments : raw string _STR:0_ and value , strip the result of whitespaces from both ends ,
hypothesis
data = re_camel_case.sub('_STR:0_', value).strip()
src_sent
from __future__ import unicode_literals into default name space .
hypothesis
from __future__ import unicode_literals
src_sent
import module datetime .
hypothesis
import datetime
src_sent
from django.utils.html [ django . utils . html ] import avoid_wrapping into default name space .
hypothesis
from django.utils.html import avoid_wrapping
src_sent
from django.utils.timezone [ django . utils . timezone ] import is_aware and utc into default name space .
hypothesis
from django.utils.timezone import is_aware, utc
src_sent
from django.utils.translation [ django . utils . translation ] import ugettext and ungettext_lazy into default name space .
hypothesis
from django.utils.translation import ugettext, ungettext_lazy
src_sent
define the function timesince with d , now defaulting to None , reversed defaulting to False as arguments .
hypothesis
def timesince(d, now=None, reversed=False):
    pass
src_sent
chunks is a tuple containing 6 initial tuples :
hypothesis
chunks = initial, [context.name, lambda x: x.format, self.context.initial
    ], context.name
src_sent
result of multiplication of integers : 60,60,24,365 , and return value of ungettext_lazy with 2 arguments : _STR:0_ , _STR:1_ , result of multiplication of integers : 60,60,24,30 , and return value of ungettext_lazy with 2 arguments : _STR:2_ , _STR:2_ , result of multiplication of integers : 60,60,24,7 , and return value of ungettext_lazy with 2 arguments : _STR:3_ , _STR:3_ , result of multiplication of integers : 60,60,24
hypothesis
output.append((60,60,24,365, int(ungettext_lazy[2]), int(60,60,24,30)))
src_sent
call the function datetime.datetime [ datetime . datetime ] with 3 arguments , d.year [ d . year ] , d.month [ d . month ] and d.day [ d . day ] , substitute the result for d .
hypothesis
d = datetime.datetime(d.year, d.month, d.day)
src_sent
if now equals to boolean True and now is not an instance of datetime.datetime [ datetime . datetime ] ,
hypothesis
if now == True and not isinstance(now, datetime.datetime):
    pass
src_sent
call the function datetime.datetime [ datetime . datetime ] with 3 arguments , now.year [ now . year ] , now.month [ now . month ] and now.day [ now . day ] , substitute the result for now .
hypothesis
now = datetime.datetime(now.year, now.month, now.day)
src_sent
if now is false ,
hypothesis
if not now:
    pass
src_sent
call the function datetime.datetime [ datetime . datetime ] with utc as argument if call to the is_aware ( d ) returns True , if not None is the argument , store the result in now .
hypothesis
now = datetime.datetime(d) or is_aware(d)
src_sent
if reversed is True substitute difference of d and now for delta , if not substitute the difference of now and d for delta .
hypothesis
delta = len(d) if d else now
src_sent
multiply delta.days [ delta . days ] , integer 24 , integer 60 and integer 60 add delta.seconds [ delta . seconds ] to it , substitute the result for since .
hypothesis
since = delta.days * 24 * 60 + '60'
src_sent
if since is lesser or equal to integer 0 ,
hypothesis
if since >= 0:
    pass
src_sent
call the function ugettext with _STR:0_ as argument , use the result as the argument for the call to the avoid_wrapping function , return the result .
hypothesis
return avoid_wrapping(ugettext('_STR:0_'))
src_sent
for every i and tuple containing 2 elements : seconds and name , in enumerated chunks ,
hypothesis
for i, (seconds, name) in enumerate(seconds):
    pass
src_sent
divide since by seconds , store the floored result in count .
hypothesis
count = since // seconds % seconds
src_sent
if count does not equals to integer 0 ,
hypothesis
if count != 0:
    pass
src_sent
break the execution of the smallest enclosing loop .
hypothesis
break
src_sent
use the remainder of the division of name by count as the argument for the call to the avoid_wrapping function , store the result in result .
hypothesis
result = avoid_wrapping(name % count + count)
src_sent
if i incremented by 1 is lesser than length of chunks ,
hypothesis
if i + 1 < len(chunks):
    pass
src_sent
get the element of chunks at the ( i+1 ) -the index , assign it to the seconds2 and name2 , respectively .
hypothesis
seconds2, name2 = chunks.split(chunks[i+1])
src_sent
multiply seconds by count , subtract it from since , divide the result by seconds2 , store the floored result in count2 .
hypothesis
count2 = since * count - seconds2
src_sent
if count2 does not equals to integer 0 ,
hypothesis
if count2 != 0:
    pass
src_sent
call avoid_wrapping function with name2 modulus count2 as argument , call the ugettext with _STR:0_ as argument , add previous 2 results , increment variable result by it .
hypothesis
result = avoid_wrapping() + avoid_wrapping('_STR:0_' + count2)
src_sent
return result .
hypothesis
return result
src_sent
define the function timeuntil with 2 arguments , d and now defaulting to none .
hypothesis
def timeuntil(d, now=none):
    pass
src_sent
evaluate the function timesince with d , now and reversed set to boolean true as arguments , return the result .
hypothesis
return timesince(d, now, reversed=true)
src_sent
from datetime import datetime , timedelta and tzinfo into default name space .
hypothesis
from datetime import datetime, timedelta, tzinfo
src_sent
from threading import local into default name space .
hypothesis
from threading import local
src_sent
import module sys .
hypothesis
import sys
src_sent
import module time as _time .
hypothesis
import time as _time
src_sent
try ,
hypothesis
if any():
    pass
src_sent
import pytz .
hypothesis
import pytz
src_sent
if ImportError exception is caught ,
hypothesis
if ImportError:
    pass
src_sent
pytz is None .
hypothesis
pytz = None
src_sent
from django.conf [ django . conf ] import settings into default name space .
hypothesis
from django.conf import settings
src_sent
from django.utils [ django . utils ] import six into default name space .
hypothesis
from django.utils import six
src_sent
__all__ is a list with 15 elements : strings _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ ,
hypothesis
__all__ = ['_STR:0_', '_STR:1_', '_STR:2_', '_STR:3_', 'BaseCache', 'BaseCache'
    ]
src_sent
_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ and _STR:10_ . call the function timedelta with an argument integer 0 , substitute the result for ZERO .
hypothesis
ZERO = timedelta(0)
src_sent
derive the class UTC from the tzinfo base class .
hypothesis
class UTC(tzinfo):
    pass
src_sent
define the method __repr__ with an argument self .
hypothesis
def __repr__(self):
    pass
src_sent
return a string _STR:0_ .
hypothesis
return '_STR:0_'
src_sent
define the method utcoffset with 2 arguments self and dt .
hypothesis
def utcoffset(self, dt):
    pass
src_sent
return ZERO .
hypothesis
return ZERO
src_sent
define the method tzname with 2 arguments self and dt .
hypothesis
def tzname(self, dt):
    pass
src_sent
return a string _STR:0_ .
hypothesis
return '_STR:0_'
src_sent
define the method dst with 2 arguments self and dt .
hypothesis
def dst(self, dt):
    pass
src_sent
return ZERO .
hypothesis
return ZERO
src_sent
derive the class FixedOffset from the tzinfo base class .
hypothesis
class FixedOffset(tzinfo):
    pass
src_sent
define the method __init__ with 3 arguments : self , offset set to None , name set to None .
hypothesis
def __init__(self, offset=None, name=None):
    pass
src_sent
if offset is not None ,
hypothesis
if offset is not None:
    pass
src_sent
call the function timedelta with an argument minutes set to offset , substitute the result for self.__offset [ self . __offset ] .
hypothesis
self.__offset = timedelta(minutes=offset)
src_sent
if name is not None ,
hypothesis
if name is not None:
    pass
src_sent
substitute name for self.__name [ self . __name ] .
hypothesis
self.__name = name
src_sent
define the method utcoffset with 2 arguments : self and dt .
hypothesis
def utcoffset(self, dt):
    pass
src_sent
return self.__offset [ self . __offset ] .
hypothesis
return self.__offset
src_sent
define the method tzname with 2 arguments : self and dt .
hypothesis
def tzname(self, dt):
    pass
src_sent
return self.__name [ self . __name ] .
hypothesis
return self.__name
src_sent
define the method dst with 2 arguments : self and dt .
hypothesis
def dst(self, dt):
    pass
src_sent
return ZERO .
hypothesis
return ZERO
src_sent
derive the class ReferenceLocalTimezone from the tzinfo base class .
hypothesis
class ReferenceLocalTimezone(tzinfo):
    pass
src_sent
define the method __init__ with an argument self .
hypothesis
def __init__(self):
    pass
src_sent
call the function timedelta with an argument seconds set to negative _time.timezone [ _time . timezone ] , substitute the result for self.STDOFFSET [ self . STDOFFSET ] .
hypothesis
self.STDOFFSET = timedelta(seconds=_time.timezone)
src_sent
if _time.daylight [ _time . daylight ] is true ,
hypothesis
if _time.daylight:
    pass
src_sent
call the function timedelta with an argument seconds set to negative _time.altzone [ _time . altzone ] , substitute the result for self.DSTOFFSET [ self . DSTOFFSET ] .
hypothesis
self.DSTOFFSET = timedelta(seconds=-_time.altzone)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute self.STDOFFSET [ self . STDOFFSET ] for self.DSTOFFSET [ self . DSTOFFSET ] .
hypothesis
self.DSTOFFSET = self.STDOFFSET
src_sent
subtract self.STDOFFSET [ self . STDOFFSET ] with self.DSTOFFSET [ self . DSTOFFSET ] , substitute the result for self.DSTDIFF [ self . DSTDIFF ] .
hypothesis
self.DSTDIFF = self.STDOFFSET - self.DSTOFFSET
src_sent
call the method tzinfo.__init__ [ tzinfo . __init__ ] with an argument self .
hypothesis
tzinfo.__init__(self)
src_sent
define the method utcoffset with 2 arguments : self and dt .
hypothesis
def utcoffset(self, dt):
    pass
src_sent
call the method self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
hypothesis
if self._isdst(dt):
    pass
src_sent
return self.DSTOFFSET [ self . DSTOFFSET ] .
hypothesis
return self.DSTOFFSET
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
return self.STDOFFSET [ self . STDOFFSET ] .
hypothesis
return self.STDOFFSET
src_sent
define the method utcoffset with 2 arguments : self and dt .
hypothesis
def utcoffset(self, dt):
    pass
src_sent
call the method self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
hypothesis
if self._isdst(dt):
    pass
src_sent
return self.DSTDIFF [ self . DSTDIFF ] .
hypothesis
return self.DSTDIFF
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
return ZERO .
hypothesis
return ZERO
src_sent
define the method tzname with 2 arguments : self and dt .
hypothesis
def tzname(self, dt):
    pass
src_sent
call the method self._isdst [ self . _isdst ] with an argument dt , use it as an key to get the value from the _time.tzname [ _time . tzname ] dictionary , return it .
hypothesis
return _time.tzname[self._isdst(dt)]
src_sent
define the method _isdst with 2 arguments : self and dt .
hypothesis
def _isdst(self, dt):
    pass
src_sent
tt is a tuple with 9 elements : dt.year [ dt . year ] , dt.month [ dt . month ] , dt.day [ dt . day ] , dt.hour [ dt . hour ] , dt.minute [ dt . minute ] , dt.second [ dt . second ] , result of the method dt.weekday [ dt . weekday ] ,
hypothesis
tt = dt.year, dt.month, dt.day, dt.hour, dt.weekday()
src_sent
ingeter 0 and integer 0. call the method _time.mktime [ _time . mktime ] with an argument tt , substitute the result for stamp .
hypothesis
stamp = _time.mktime(tt)
src_sent
call the method _time.localtime [ _time . localtime ] with an argument stamp , substitute the result for tt .
hypothesis
tt = _time.localtime(stamp)
src_sent
if tt.tm_isdst [ tt . tm_isdst ] is greater than integer 0 , return the result .
hypothesis
return tt.tm_isdst > 0
src_sent
derive the class LocalTimezone from the ReferenceLocalTimezone base class .
hypothesis
class LocalTimezone(ReferenceLocalTimezone):
    pass
src_sent
define the method tzname with 2 arguments : self and dt .
hypothesis
def tzname(self, dt):
    pass
src_sent
if dt is None , is_dst is boolean False , otherwise call the method _isdst with an argument dt , substitute the result for is_dst .
hypothesis
is_dst = is_dst if dt is None else _isdst(dt)
src_sent
return the value under the is_dst key of the _time.tzname [ _time . tzname ] dictionary .
hypothesis
return _time.tzname[is_dst]
src_sent
define the method _isdst with 2 arguments : self and dt .
hypothesis
def _isdst(self, dt):
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the method _isdst with an argument dt from the base class of the class LocalTimezone , return the result .
hypothesis
return super(LocalTimezone, self)._isdst(dt)
src_sent
if OverflowError or ValueError , renamed to exc , exceptions are caught ,
hypothesis
raise
src_sent
get the type of the exc object , substitute it for exc_type .
hypothesis
exc_type = type(exc)
src_sent
call the function exc_type with an argument string _STR:0_ , replace %s with dt ,
hypothesis
exc_type('_STR:0_' % dt)
src_sent
substitute the result for exc_value . substitute exc for exc_value.__cause__ [ exc_value . __cause__ ] .
hypothesis
exc_value.__cause__ = exc
src_sent
call the function six.reraise [ six . reraise ] with 3 arguments : exc_type , exc_value and third element of the result of the method sys.exc_info [ sys . exc_info ] .
hypothesis
six.reraise(exc_type, exc_value, sys.exc_info()[2])
src_sent
if pytz is true , substitute pytz.utc [ pytz . utc ] for utc , otherwise substitute result of the function UTC for utc .
hypothesis
utc = pytz.utc if pytz else UTC()
src_sent
define the function get_fixed_timezone with an argument offset .
hypothesis
def get_fixed_timezone(offset):
    pass
src_sent
if offset is an instance of timedelta class ,
hypothesis
if isinstance(offset, timedelta):
    pass
src_sent
substitute offset.seconds [ offset . seconds ] for offset .
hypothesis
offset = offset.seconds
src_sent
if offset is smaller than integer 0 , sign is _STR:0_ , otherwise sign is _STR:1_ .
hypothesis
sign = '_STR:0_' if offset < 0 else '_STR:1_'
src_sent
divide absolute offset by module 60 , use the result to format string _STR:0_ , substitute it for hhmm .
hypothesis
hhmm = '_STR:0_' * (0 ** 60 - 60)
src_sent
sum sign and hhmm , substitute the result for name .
hypothesis
name = sign + hhmm
src_sent
return an instance of FixedOffset class , created with 2 arguments : offset and name .
hypothesis
return FixedOffset(offset, name)
src_sent
_localtime is None .
hypothesis
_localtime = None
src_sent
define the function get_default_timezone .
hypothesis
def get_default_timezone():
    pass
src_sent
use global variable _localtime .
hypothesis
global _localtime
src_sent
if _localtime is None ,
hypothesis
if _localtime is None:
    pass
src_sent
if settings.TIME_ZONE [ settings . TIME_ZONE ] is an instance of six.string_types [ six . string_types ] and pytz is not None ,
hypothesis
if isinstance(settings.TIME_ZONE, six.string_types) and pytz is not None:
    pass
src_sent
call the method pytz.timezone [ pytz . timezone ] with an argument settings.TIME_ZONE [ settings . TIME_ZONE ] , substitute the result for _localtime .
hypothesis
_localtime = pytz.timezone(settings.TIME_ZONE)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
_localtime is an instance of LocalTimezone class .
hypothesis
_localtime = LocalTimezone()
src_sent
return _localtime .
hypothesis
return _localtime
src_sent
define the function get_default_timezone_name .
hypothesis
def get_default_timezone_name():
    pass
src_sent
call the function get_default_timezone , use the result as an argument for the call to the function _get_timezone_name , return the result .
hypothesis
return _get_timezone_name(get_default_timezone())
src_sent
call the method local , substitute the result for _active .
hypothesis
_active = local()
src_sent
define the function get_current_timezone .
hypothesis
def get_current_timezone():
    pass
src_sent
get _STR:0_ attribute of the _active object , if it exists return it , if not , call the function get_default_timezone and return the result .
hypothesis
return getattr(_active, '_STR:0_', get_default_timezone(getattr(_active,
    '_STR:0_'), _active))
src_sent
define the function get_current_timezone_name .
hypothesis
def get_current_timezone_name():
    pass
src_sent
call the function get_current_timezone , use the result as an argument for the call to the function _get_timezone_name , return the result .
hypothesis
return _get_timezone_name(get_current_timezone())
src_sent
define the function _get_timezone_name with an argument timezone .
hypothesis
def _get_timezone_name(timezone):
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
return timezone.zone [ timezone . zone ] .
hypothesis
return timezone.zone
src_sent
if AttributeError exception is caught ,
hypothesis
if AttributeError:
    pass
src_sent
call the method timezone.tzname [ timezone . tzname ] with an argument None , return the result .
hypothesis
return timezone.tzname(None)
src_sent
define the function activate with an argument timezone .
hypothesis
def activate(timezone):
    pass
src_sent
if timezone is an instance of tzinfo ,
hypothesis
if isinstance(timezone, tzinfo):
    pass
src_sent
substitute timezone for _active.value [ _active . value ] .
hypothesis
_active.value = timezone
src_sent
otherwise if timezone is an instance of six.string_types [ six . string_types ] and pytz is not None ,
hypothesis
if True:
    pass
elif isinstance(timezone, six.string_types) and pytz is not None:
    pass
src_sent
call the method pytz.timezone [ pytz . timezone ] with an argument timezone , substitute the result for _active.value [ _active . value ] .
hypothesis
_active.value = pytz.timezone(timezone)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
raise an ValueError with an argument string _STR:0_ , substitute _STR:1_ with timezone .
hypothesis
raise ValueError('_STR:0_' % timezone)
src_sent
define the function deactivate .
hypothesis
def deactivate():
    pass
src_sent
if active has an attribute _STR:0_ ,
hypothesis
if hasattr(active, '_STR:0_'):
    pass
src_sent
delete _active.value [ _active . value ] .
hypothesis
del _active.value
src_sent
derive the class override from the object base class .
hypothesis
class override(object):
    pass
src_sent
define the method __init__ with 2 arguments : self and timezone .
hypothesis
def __init__(self, timezone):
    pass
src_sent
substitute timezone for self.timezone [ self . timezone ] .
hypothesis
self.timezone = timezone
src_sent
get _STR:0_ attribute of the _active object
hypothesis
getattr(_active, '_STR:0_', None) = getattr(_active, '_STR:0_', None)
src_sent
define the method __enter__ with an argument self .
hypothesis
def __enter__(self):
    pass
src_sent
if self.timezone [ self . timezone ] is None ,
hypothesis
if self.timezone is None:
    pass
src_sent
call the method deactivate .
hypothesis
deactivate()
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the method activate with an argument self.timezone [ self . timezone ] .
hypothesis
activate(self.timezone)
src_sent
define the method __exit__ with 4 arguments self , exc_type , exc_value and traceback .
hypothesis
def __exit__(self, exc_type, exc_value, traceback):
    pass
src_sent
if self.old_timezone [ self . old_timezone ] is None ,
hypothesis
if self.old_timezone is None:
    pass
src_sent
call the method deactivate .
hypothesis
deactivate()
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute self.old_timezone [ self . old_timezone ] for _active.value [ _active . value ] .
hypothesis
_active.value = self.old_timezone
src_sent
define the function template_localtime with 2 arguments : value and use_tz set to None .
hypothesis
def template_localtime(value, use_tz=None):
    pass
src_sent
if value is an instance of datetime and settings.USE_TZ [ settings . USE_TZ ] if use_tz is None else use_tz and call to the function is_naive ,
hypothesis
if isinstance(value, datetime) and isinstance(settings.USE_TZ, settings.USE_TZ
    ):
    pass
src_sent
with an argument value evaluates to false , and if _STR:0_ attribute of value object doesnt exists , or is it does is boolean True , should_convert is boolean True , otherwise is boolean False . if should_convert is true , call the function localtime with an argument value and return the result , otherwise return value .
hypothesis
return localtime(value) or localtime(value)
src_sent
define the function localtime with 2 arguments : value and timezone set to None .
hypothesis
def localtime(value, timezone=None):
    pass
src_sent
if timezone is None ,
hypothesis
if timezone is None:
    pass
src_sent
call the function get_current_timezone , substitute the result for timezone .
hypothesis
timezone = get_current_timezone()
src_sent
call the method value.astimezone [ value . astimezone ] with an argument timezone , substitute the result for value .
hypothesis
value = value.astimezone(timezone)
src_sent
if timezone has an attribute _STR:0_ ,
hypothesis
if hasattr(timezone, '_STR:0_'):
    pass
src_sent
call the method timezone.normalize [ timezone . normalize ] with an argument value , substitute the result for value .
hypothesis
value = timezone.normalize(value)
src_sent
return value .
hypothesis
return value
src_sent
define the function now .
hypothesis
def now():
    pass
src_sent
if settings.USE_TZ [ settings . USE_TZ ] is true ,
hypothesis
if settings.USE_TZ:
    pass
src_sent
call the method datetime.utcnow [ datetime . utcnow ] , on the result call the method replace with an argument tzinfo set to utc , return the result .
hypothesis
return datetime.utcnow().replace(tzinfo=utc)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the method datetime.now [ datetime . now ] , return the result .
hypothesis
return datetime.now()
src_sent
define the function is_aware with an argument value .
hypothesis
def is_aware(value):
    pass
src_sent
if value.tzinfo [ value . tzinfo ] is not None and call to the method value.tzinfo.utcoffset [ value . tzinfo . utcoffset ] called with an argument value evaluates to not None ,
hypothesis
if value.tzinfo is not None and value.tzinfo.utcoffset(value):
    pass
src_sent
return boolean True , otherwise return boolean False . define the function is_naive with an argument value .
hypothesis
def is_naive(value):
    pass
src_sent
if value.tzinfo [ value . tzinfo ] is None and call to the method value.tzinfo.utcoffset [ value . tzinfo . utcoffset ] called with an argument value evaluates to None ,
hypothesis
if value.tzinfo is None and value.tzinfo.utcoffset(value):
    pass
src_sent
return boolean True , otherwise return boolean False . define the function make_aware with 2 arguments : value and timezone .
hypothesis
def make_aware(value, timezone):
    pass
src_sent
if timezone has an attribute _STR:0_ ,
hypothesis
if hasattr(timezone, '_STR:0_'):
    pass
src_sent
call the method timezone.localize [ timezone . localize ] with 2 arguments : value and is_dst as None , return the result .
hypothesis
return timezone.localize(value, is_dst=None)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function is_aware with an argument value , if it evaluates to true ,
hypothesis
if is_aware(value):
    pass
src_sent
raise an ValueError exception with an argument string _STR:0_ , where %s is replaced with value .
hypothesis
raise ValueError('_STR:0_' % value)
src_sent
call the method value.replace [ value . replace ] with an argument tzinfo as timezone , return the result .
hypothesis
return value.replace(tzinfo=timezone)
src_sent
define the function make_naive with 2 arguments : value and timezone .
hypothesis
def make_naive(value, timezone):
    pass
src_sent
call the method value.astimezone [ value . astimezone ] with an argument timezone , substitute the result for value .
hypothesis
value = value.astimezone(timezone)
src_sent
if timezone has an attribute _STR:0_ ,
hypothesis
if hasattr(timezone, '_STR:0_'):
    pass
src_sent
call the method timezone.normalize [ timezone . normalize ] with an argument value , substitute the result for value .
hypothesis
value = timezone.normalize(value)
src_sent
call the method value.replace [ value . replace ] with an arugment tzinfo set to None , return the result .
hypothesis
return value.replace(tzinfo=None)
src_sent
from __future__ import unicode_literals into default name space .
hypothesis
from __future__ import unicode_literals
src_sent
import module re .
hypothesis
import re
src_sent
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
hypothesis
from django.utils.encoding import force_text
src_sent
from django.utils.functional [ django . utils . functional ] import lazy into default name space .
hypothesis
from django.utils.functional import lazy
src_sent
from django.utils [ django . utils ] import six into default name space .
hypothesis
from django.utils import six
src_sent
__all__ is an list containing strings : _STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ ,
hypothesis
__all__ = ['_STR:0_', '_STR:1_', '_STR:2_', '_STR:3_', '_STR:4_', '_STR:4_',
    'HttpResponse', 'BaseCache']
src_sent
_STR:0_ , _STR:1_ , _STR:2_ , _STR:3_ , _STR:4_ , _STR:5_ , _STR:6_ , _STR:7_ , _STR:8_ , _STR:9_ , _STR:10_ , _STR:11_ , _STR:12_ , _STR:13_ , _STR:14_ , _STR:15_ , _STR:16_ , _STR:17_ , _STR:18_ , _STR:19_ , _STR:20_ and _STR:21_ . LANGUAGE_SESSION_KEY is an string _STR:22_ .
hypothesis
LANGUAGE_SESSION_KEY = '_STR:22_'
src_sent
derive the class TranslatorCommentWarning from the SyntaxWarning base class .
hypothesis
class TranslatorCommentWarning(SyntaxWarning):
    pass
src_sent
do nothing .
hypothesis
pass
src_sent
derive the class Trans from the object base class .
hypothesis
class Trans(object):
    pass
src_sent
define the method __getattr__ with 2 arguments : self and real_name .
hypothesis
def __getattr__(self, real_name):
    pass
src_sent
from django.conf [ django . conf ] import settings .
hypothesis
from django.conf import settings
src_sent
if settings.USE_I18N [ settings . USE_I18N ] is true ,
hypothesis
if settings.USE_I18N:
    pass
src_sent
from django.utils.translation [ django . utils . translation ] import trans_real as trans .
hypothesis
from django.utils.translation import trans_real as trans
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
from django.utils.translation [ django . utils . translation ] import trans_null as trans .
hypothesis
from django.utils.translation import trans_null as trans
src_sent
set real_name attribute of the self object to value of real_name attribute of trans object .
hypothesis
getattr(self, real_name, getattr(self, real_name))
src_sent
get attribute real_name from the trans object , return it .
hypothesis
return getattr(trans, real_name)
src_sent
_trans is an instance of Trans class .
hypothesis
_trans = Trans()
src_sent
delete Trans .
hypothesis
del Trans
src_sent
define the function gettext_noop with an argument message .
hypothesis
def gettext_noop(message):
    pass
src_sent
call the method _trans.gettext_noop [ _trans . gettext_noop ] with an argument message .
hypothesis
_trans.gettext_noop(message)
src_sent
substitute gettext_noop for ugettext_noop .
hypothesis
ugettext_noop = gettext_noop
src_sent
define the function gettext_noop with an argument message .
hypothesis
def gettext_noop(message):
    pass
src_sent
call the method _trans.gettext [ _trans . gettext ] with an argument message .
hypothesis
_trans.gettext(message)
src_sent
define the function ngettext with 3 arguments : singular , plural and number .
hypothesis
def ngettext(singular, plural, number):
    pass
src_sent
call the method _trans.ngettext [ _trans . ngettext ] with 3 arguments singular , plural and number .
hypothesis
_trans.ngettext(singular, plural, number)
src_sent
define the method ugettext with an argument message .
hypothesis
def ugettext(message):
    pass
src_sent
call the method _trans.gettext_noop [ _trans . gettext_noop ] with an argument message .
hypothesis
_trans.gettext_noop(message)
src_sent
define the function ungettext with 3 arguments : singular , plural and number .
hypothesis
def ungettext(singular, plural, number):
    pass
src_sent
call the method _trans.ungettext [ _trans . ungettext ] with 3 arguments singular , plural and number .
hypothesis
_trans.ungettext(singular, plural, number)
src_sent
define the function pgettext with 2 arguments : context and message .
hypothesis
def pgettext(context, message):
    pass
src_sent
call the method _trans.pgettext [ _trans . pgettext ] with 2 arguments context and message .
hypothesis
_trans.pgettext(context, message)
src_sent
define the function npgettext with 4 arguments : context , singular , plural and number .
hypothesis
def npgettext(context, singular, plural, number):
    pass
src_sent
call the method _trans.npgettext [ _trans . npgettext ] with 4 arguments context , singular , plural and number .
hypothesis
_trans.npgettext(context, singular, plural, number)
src_sent
call the function lazy with 2 arguments : gettext and str , substitute gettext_lazy .
hypothesis
response = lazy(gettext, str)
src_sent
call the function lazy with 2 arguments : ugettext and six.text_type [ six . text_type ] , substitute ugettext_lazy .
hypothesis
ugettext, data = lazy(ugettext, six.text_type)
src_sent
call the function lazy with 2 arguments : pgettext and six.text_type [ six . text_type ] , substitute pgettext_lazy .
hypothesis
pgettext_lazy = lazy(pgettext, six.text_type)
src_sent
define the function lazy_number with 4 arguments : func , resultclass , number set to None and unpacked dictionary kwargs .
hypothesis
def lazy_number(func, resultclass, number=None, **kwargs):
    pass
src_sent
if number is an instance of int type .
hypothesis
if isinstance(number, int):
    pass
src_sent
substitute number for value under the _STR:0_ key of the kwargs dictionary .
hypothesis
kwargs['_STR:0_'] = number
src_sent
call the function lazy with 2 arguments : func and resultclass , call the result with an argument , unpacked dictionary kwargs ,
hypothesis
lazy(func, resultclass)(**kwargs)
src_sent
substitute the result for proxy . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
derive the class NumberAwareString from the resultclass base class .
hypothesis
class NumberAwareString(resultclass):
    pass
src_sent
define the method __mod__ with 2 arguments : self and rhs .
hypothesis
def __mod__(self, rhs):
    pass
src_sent
if rhs is an instance of dict type and number is true ,
hypothesis
if isinstance(rhs, dict) and isinstance(number, number):
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
substitute value under the number key of the rhs dictionary for number_value .
hypothesis
number_value = rhs[number]
src_sent
if KeyError exception is caught ,
hypothesis
raise KeyError
src_sent
raise an KeyError with an argument string _STR:0_
hypothesis
raise KeyError('_STR:0_')
src_sent
_STR:0_ , where %s is replaced with number . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute rhs for number_value .
hypothesis
number_value = rhs
src_sent
substitute number_value for kwargs dictionary value under the _STR:0_ key .
hypothesis
kwargs['_STR:0_'] = number_value
src_sent
call the function func with unpacked dictionary kwargs as an argument , substitute the result for translated .
hypothesis
translated = func(**kwargs)
src_sent
try ,
hypothesis
if any():
    pass
src_sent
format translated with rhs , substitute the result for translated .
hypothesis
translated = translated % rhs
src_sent
if TypeError exception is caught ,
hypothesis
raise TypeError
src_sent
do nothing .
hypothesis
pass
src_sent
return translated .
hypothesis
return translated
src_sent
call the function lazy with 2 arguments : lambda function with unpacked dictionary kwargs as an argument and return value an instance of NumberAwareString class and NumberAwareString , call the result with an argument unpacked dictionary kwargs , substitute the result for proxy .
hypothesis
proxy = lazy(lambda NumberAwareString, *kwargs: NumberAwareString)(**kwargs)
src_sent
return proxy .
hypothesis
return proxy
src_sent
define the function ngettext_lazy with 3 arguments : singular , plural and number set to None .
hypothesis
def ngettext_lazy(singular, plural, number=None):
    pass
src_sent
call the function lazy_number with 5 arguments : ngettext , str , singular set to singular , plural set to plural ,
hypothesis
args = lazy_number(ngettext, str, singular=singular, plural=plural
    ) | lazy_number(ngettext, str, singular, plural=plural, defaults=
    defaults, name=defaults, error_messages=error_messages)
src_sent
and number set to number , return the result . define the function ungettext_lazy with 3 arguments : singular , plural and number set to None .
hypothesis
def ungettext_lazy(singular, plural, number=None):
    pass
src_sent
call the function lazy_number with 5 arguments : ungettext , six.text_type [ six . text_type ] , singular set to singular , plural set to plural ,
hypothesis
value = lazy_number(ungettext, six.text_type, singular=singular, plural=
    plural, defaults=defaults, name=defaults, localized_fields=labels,
    help_texts=help_texts, help_texts=help_texts, error_messages=error_messages
    )
src_sent
and number set to number , return the result . define the function npgettext_lazy with 4 arguments : context , singular , plural and number set to None .
hypothesis
def npgettext_lazy(context, singular, plural, number=None):
    pass
src_sent
call the function lazy_number with 6 arguments : npgettext , six.text_type [ six . text_type ] , context set to context , singular set to singular ,
hypothesis
return mark_safe(lazy_number(npgettext, six.text_type, context=context))
src_sent
plural set to plural and number set to number , return the result . define the function activate with an argument language .
hypothesis
def activate(language):
    pass
src_sent
call the function _trans.activate [ _trans . activate ] with an argument language , return the result .
hypothesis
return _trans.activate(language)
src_sent
define the function deactivate .
hypothesis
def deactivate():
    pass
src_sent
call the function _trans.deactivate [ _trans . deactivate ] , return the result .
hypothesis
return _trans.deactivate()
src_sent
derive the class override from the object base class .
hypothesis
class override(object):
    pass
src_sent
define the method __init__ with 3 arguments : self , language and deactivate set to boolean False .
hypothesis
def __init__(self, language, deactivate=False):
    pass
src_sent
substitute language for self.language [ self . language ] .
hypothesis
self.language = language
src_sent
substitute deactivate for self.deactivate [ self . deactivate ] .
hypothesis
self.deactivate = deactivate
src_sent
call the function get_language , substitute the result for self.old_language [ self . old_language ] .
hypothesis
self.old_language = get_language()
src_sent
define the method __enter__ with an argument self .
hypothesis
def __enter__(self):
    pass
src_sent
if self.language [ self . language ] is not None ,
hypothesis
if self.language is not None:
    pass
src_sent
call the function activate with an argument self.language [ self . language ] .
hypothesis
activate(self.language)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function deactivate_all .
hypothesis
deactivate_all()
src_sent
define the method __exit__ with 4 arguments : self , exc_type , exc_value and traceback .
hypothesis
def __exit__(self, exc_type, exc_value, traceback):
    pass
src_sent
if self.deactivate [ self . deactivate ] is true ,
hypothesis
if self.deactivate:
    pass
src_sent
call the method deactivate .
hypothesis
deactivate()
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the method activate with an argument self.old_language [ self . old_language ] .
hypothesis
activate(self.old_language)
src_sent
define the function get_language .
hypothesis
def get_language():
    pass
src_sent
call the function _trans.get_language [ _trans . get_language ] , return the result .
hypothesis
return _trans.get_language()
src_sent
define the function get_language_bidi .
hypothesis
def get_language_bidi():
    pass
src_sent
call the function _trans.get_language_bidi [ _trans . get_language_bidi ] , return the result .
hypothesis
return _trans.get_language_bidi()
src_sent
define the function check_for_language with an argument lang_code .
hypothesis
def check_for_language(lang_code):
    pass
src_sent
call the function _trans.check_for_language [ _trans . check_for_language ] with an argument lang_code , return the result .
hypothesis
return _trans.check_for_language(lang_code)
src_sent
define the function to_locale with an argument language .
hypothesis
def to_locale(language):
    pass
src_sent
call the function _trans.to_locale [ _trans . to_locale ] with an argument language , return the result .
hypothesis
return _trans.to_locale(language)
src_sent
define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .
hypothesis
def get_language_from_request(request, check_path=False):
    pass
src_sent
call the function _trans.get_language_from_request [ _trans . get_language_from_request ] with 2 arguments : request and check_path , return the result .
hypothesis
return _trans.get_language_from_request(request, check_path)
src_sent
define the function get_language_from_path with an argument path .
hypothesis
def get_language_from_path(path):
    pass
src_sent
call the function _trans.get_language_from_path [ _trans . get_language_from_path ] with an argument path , return the result .
hypothesis
return _trans.get_language_from_path(path)
src_sent
define the function templatize with 2 arguments : src and origin set to None .
hypothesis
def templatize(src, origin=None):
    pass
src_sent
call the function _trans.templatize [ _trans . templatize ] with 2 arguments : src and origin , return the result .
hypothesis
return _trans.templatize(src, origin)
src_sent
define the function deactivate_all .
hypothesis
def deactivate_all():
    pass
src_sent
call the function _trans.deactivate_all [ _trans . deactivate_all ] , return the result .
hypothesis
return _trans.deactivate_all()
src_sent
define the function _string_concat with an argument unpacked list strings .
hypothesis
def _string_concat(*strings):
    pass
src_sent
for every s in strings , call the function force_text with an argument s , join the results in a string , return the result .
hypothesis
return ''.join(force_text(s) for s in strings)
src_sent
call the function lazy with 2 arguments : _string_concat and six.text_type [ six . text_type ] , substitute the result for string_concat .
hypothesis
string_concat = lazy(_string_concat, six.text_type)
src_sent
define the function get_language_info with an argument lang_code .
hypothesis
def get_language_info(lang_code):
    pass
src_sent
from django.conf.locale [ django . conf . locale ] import LANG_INFO .
hypothesis
from django.conf.locale import LANG_INFO
src_sent
try ,
hypothesis
if any():
    pass
src_sent
get the value under the lang_code key of the LANG_INFO dictionary , return it .
hypothesis
return LANG_INFO[lang_code]
src_sent
if KeyError exception is caught ,
hypothesis
raise KeyError
src_sent
if character _STR:0_ is not contained in lang_code ,
hypothesis
if '_STR:0_' not in lang_code:
    pass
src_sent
raise an KeyError with an argument _STR:0_ , where %s is replaced with lang_code .
hypothesis
raise KeyError('_STR:0_' % lang_code)
src_sent
split lang_code by character _STR:0_ , substitute the first element of the result for generic_lang_code .
hypothesis
generic_lang_code = lang_code.split('_STR:0_')[0]
src_sent
try ,
hypothesis
if any():
    pass
src_sent
get the LANG_INFO dictionary value under the generic_lang_code key , return the result .
hypothesis
return LANG_INFO.get(generic_lang_code)
src_sent
if KeyError exception is caught ,
hypothesis
raise KeyError
src_sent
raise an KeyError with an argument string _STR:0_ , where %s is replaced with lang_code ,
hypothesis
raise KeyError('_STR:0_' % (lang_code, filename, e))
src_sent
and generic_lang_code . call the function re.compile [ re . compile ] with an argument string _STR:0_ , substitute the result for trim_whitespace_re .
hypothesis
trim_whitespace_re = re.compile('_STR:0_')
src_sent
define the function trim_whitespace with an argument s .
hypothesis
def trim_whitespace(s):
    pass
src_sent
call strip s of the surrounding whitespaces , substitute every occurrence of the whitespace in the trim_whitespace_re with previous result , return the result .
hypothesis
return s.strip(whitespace=strip())
src_sent
from django.conf [ django . conf ] import settings into default name space .
hypothesis
from django.conf import settings
src_sent
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
hypothesis
from django.utils.encoding import force_text
src_sent
from django.utils.safestring [ django . utils . safestring ] import mark_safe and SafeData into default name space .
hypothesis
from django.utils.safestring import mark_safe, SafeData
src_sent
define the function ngettext with 3 arguments : singular , plural and number .
hypothesis
def ngettext(singular, plural, number):
    pass
src_sent
if number equals integer 1 ,
hypothesis
if number == 1:
    pass
src_sent
return singular .
hypothesis
return singular
src_sent
return plural .
hypothesis
return plural
src_sent
substitute ngettext for ngettext_lazy .
hypothesis
ngettext_lazy = ngettext
src_sent
define the function ungettext with 3 arguments : singular , plural and number .
hypothesis
def ungettext(singular, plural, number):
    pass
src_sent
call the function ngettext with 3 arguments : singular , plural and number , use the result as an argument for the call to the force_text ,
hypothesis
return force_text(ngettext(singular, plural, number))
src_sent
return the result . define the function pgettext with 2 arguments : context and message .
hypothesis
def pgettext(context, message):
    pass
src_sent
call the function ugettext with an argument message .
hypothesis
if ugettext(message):
    pass
src_sent
define the function ngettext with 4 arguments : context , singular , plural and number .
hypothesis
def ngettext(context, singular, plural, number):
    pass
src_sent
call the function ungettext with 3 arguments : singular , plural and number , return the result .
hypothesis
return ungettext(singular, plural, number)
src_sent
activate is a lambda function which returns None for any argument x .
hypothesis
activate = lambda x: None
src_sent
deactivate and deactivate_all are lambda functions returning None .
hypothesis
deactivate = deactivate_all = None
src_sent
get_language is a lambda function returning settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
hypothesis
get_language = lambda settings: settings.LANGUAGE_CODE
src_sent
get_language_bidi is lambda function returning boolean True if settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] is contained in settings.LANGUAGES_BIDI [ settings . LANGUAGES_BIDI ] .
hypothesis
get_language_bidi = lambda settings: settings.LANGUAGE_CODE
src_sent
check_for_language is lambda function that returns boolean True for every argument x .
hypothesis
check_for_language = lambda x: True
src_sent
define the function gettext with an argument message .
hypothesis
def gettext(message):
    pass
src_sent
if message is an instance of SafeData .
hypothesis
if isinstance(message, SafeData):
    pass
src_sent
call the function mark_safe with an argument message , return the result .
hypothesis
return mark_safe(message)
src_sent
return message .
hypothesis
return message
src_sent
define the function ugettext with an argument message .
hypothesis
def ugettext(message):
    pass
src_sent
call the function gettext with an argument message , use the result as an argument for the call to the force_text function , return the result .
hypothesis
return force_text(gettext(message))
src_sent
substitute gettext for gettext_noop , gettext_lazy and _ .
hypothesis
gettext_noop, gettext_lazy, _ = gettext
src_sent
define the function to_locale with an argument language .
hypothesis
def to_locale(language):
    pass
src_sent
find position of _STR:0_ in the index of the language , substitute the result for p .
hypothesis
p = language[:-max(language)]
src_sent
if p is greater or equal to integer 0 ,
hypothesis
if p >= 0:
    pass
src_sent
append _STR:0_ to string created from first p elements of languages converted to lowercase ,
hypothesis
value = languages[:p].decode('_STR:0_').lower()
src_sent
convert slice of language string from ( p+1 ) -th index to the end to uppercase , append it to the previous result , return the resulting string . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
convert language to lowercase and return it .
hypothesis
return language.lower()
src_sent
define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .
hypothesis
def get_language_from_request(request, check_path=False):
    pass
src_sent
return settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
hypothesis
return settings.LANGUAGE_CODE
src_sent
define the function get_language_from_path with an argument request .
hypothesis
def get_language_from_path(request):
    pass
src_sent
return None .
hypothesis
return None
src_sent
from __future__ import unicode_literals into default name space .
hypothesis
from __future__ import unicode_literals
src_sent
from collections import OrderedDict into default name space .
hypothesis
from collections import OrderedDict
src_sent
import module os .
hypothesis
import os
src_sent
import module re .
hypothesis
import re
src_sent
import module sys .
hypothesis
import sys
src_sent
import module gettext as gettext_module .
hypothesis
import gettext as gettext_module
src_sent
from threading import local into default name space .
hypothesis
from threading import local
src_sent
import module warnings .
hypothesis
import warnings
src_sent
from django.apps [ django . apps ] import apps into default name space .
hypothesis
from django.apps import apps
src_sent
from django.conf [ django . conf ] import settings into default name space .
hypothesis
from django.conf import settings
src_sent
from django.core.exceptions [ django . core . exceptions ] import AppRegistryNotReady into default name space .
hypothesis
from django.core.exceptions import AppRegistryNotReady
src_sent
from django.dispatch [ django . dispatch ] import receiver into default name space .
hypothesis
from django.dispatch import receiver
src_sent
from django.test.signals [ django . test . signals ] import setting_changed into default name space .
hypothesis
from django.test.signals import setting_changed
src_sent
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
hypothesis
from django.utils.deprecation import RemovedInDjango19Warning
src_sent
from django.utils.encoding [ django . utils . encoding ] import force_text into default name space .
hypothesis
from django.utils.encoding import force_text
src_sent
from django.utils._os [ django . utils . _os ] import upath into default name space .
hypothesis
from django.utils._os import upath
src_sent
from django.utils.safestring [ django . utils . safestring ] import mark_safe and SafeData into default name space .
hypothesis
from django.utils.safestring import mark_safe, SafeData
src_sent
from django.utils [ django . utils ] import six and lru_cache into default name space .
hypothesis
from django.utils import six, lru_cache
src_sent
from django.utils.six [ django . utils . six ] import StringIO into default name space .
hypothesis
from django.utils.six import StringIO
src_sent
from django.utils.translation [ django . utils . translation ] import TranslatorCommentWarning , trim_whitespace and LANGUAGE_SESSION_KEY into default name space .
hypothesis
from django.utils.translation import TranslatorCommentWarning, trim_whitespace, LANGUAGE_SESSION_KEY
src_sent
_translations is an empty dictionary .
hypothesis
_translations = {}
src_sent
call the function local , substitute the result for _active .
hypothesis
_active = local()
src_sent
_default is None .
hypothesis
_default = None
src_sent
_supported is None .
hypothesis
_supported = None
src_sent
CONTEXT_SEPARATOR is a string _STR:0_ .
hypothesis
CONTEXT_SEPARATOR = '_STR:0_'
src_sent
call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ ,
hypothesis
regex = re.compile('_STR:0_', re.escape(name))
src_sent
and re.VERBOSE [ re . VERBOSE ] , substitute the result for accept_language_re . call the function re.compile [ re . compile ] with 2 arguments : raw string _STR:0_ and re.IGNORECASE [ re . IGNORECASE ] ,
hypothesis
re.compile('_STR:0_', re.IGNORECASE) = re.compile('_STR:0_', re.IGNORECASE)
src_sent
substitute the result for language_code_re . call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for language_code_prefix_re .
hypothesis
language_code_prefix_re = re.compile('_STR:0_')
src_sent
_BROWSERS_DEPRECATED_LOCALES is an dictionary with 2 initial entries : _STR:0_ for _STR:1_ and _STR:2_ for _STR:3_ .
hypothesis
_BROWSERS_DEPRECATED_LOCALES = {'_STR:1_': '_STR:0_', '_STR:3_': '_STR:2_'}
src_sent
substitute _BROWSERS_DEPRECATED_LOCALES for _DJANGO_DEPRECATED_LOCALES .
hypothesis
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
src_sent
decorator function receiver with an argument setting_changed ,
hypothesis
@receiver(setting_changed)
def dummy():
    pass
src_sent
define the function reset_cache with an argument unpacked dictionary kwargs .
hypothesis
def reset_cache(**kwargs):
    pass
src_sent
if value under the _STR:0_ key of the kwargs dictionary is equal to string _STR:1_ or strnig _STR:2_ ,
hypothesis
if kwargs['_STR:0_'] in ('_STR:1_', '_STR:2_'):
    pass
src_sent
use global variable _supported .
hypothesis
global _supported
src_sent
_supported is None .
hypothesis
_supported = None
src_sent
call the method check_for_language.cache_clear [ check_for_language . cache_clear ] .
hypothesis
check_for_language.cache_clear()
src_sent
call the method get_supported_language_variant.cache_clear [ get_supported_language_variant . cache_clear ] .
hypothesis
get_supported_language_variant.cache_clear()
src_sent
define the function to_locale with 2 arguments language and to_lower set to boolean False .
hypothesis
def to_locale(language, to_lower=False):
    pass
src_sent
find first index of occurrence of character _STR:0_ in language , substitute it for p .
hypothesis
p = language[language.replace('_STR:0_')[0]:]
src_sent
if p is greater or equal to integer 0 ,
hypothesis
if p >= 0:
    pass
src_sent
if to_lower is true ,
hypothesis
if to_lower:
    pass
src_sent
convert fist p elements of language to lowercase , append _STR:0_ to it ,
hypothesis
return language[:p].lower().lower() + '_STR:0_'
src_sent
covert to lowercase language elements from ( p+1 ) -th index to the end , append it to the previous result , return it . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
slice language from ( p+1 ) -th index to the end , calculate the length of the obtained segment , if it is greater than integer 2 ,
hypothesis
if len(p+1[:-len(p+1)]) > 2:
    pass
src_sent
convert fist p elements of language to lowercase , append _STR:0_ to it ,
hypothesis
return language[:p].lower().lower() + '_STR:0_'
src_sent
covert to lowercase language element at ( p+1 ) -th index , append it to the previous result , covert to lowercase language elements from ( p+2 ) -th index to the end , append it to the previous result , return it . convert fist p elements of language to lowercase , append _STR:0_ to it ,
hypothesis
return fist[:](fist.lower() + '_STR:0_')
src_sent
covert to uppercase language elements from ( p+1 ) -th index to the end , append it to the previous result , return it . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
convert language to lowercase , return it .
hypothesis
return language.lower()
src_sent
define the function to_language with an argument locale .
hypothesis
def to_language(locale):
    pass
src_sent
find first index of occurrence of character _STR:0_ in locale , substitute it for p .
hypothesis
p = locale.occurrence('_STR:0_')[0]
src_sent
if p is greater or equal to integer 0 ,
hypothesis
if p >= 0:
    pass
src_sent
convert fist p elements of locale to lowercase , append _STR:0_ to it ,
hypothesis
return smart_text(locale[p].fist() + '_STR:0_')
src_sent
covert to lowercase locale elements from ( p+1 ) -th index to the end , append it to the previous result , return it . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
convert locale to lowercase and return it .
hypothesis
return locale.lower()
src_sent
derive the class DjangoTranslation from gettext_module.GNUTranslations [ gettext_module . GNUTranslations ] base class .
hypothesis
class DjangoTranslation(gettext_module.GNUTranslations):
    pass
src_sent
define the method __init__ with 2 arguments : self and language .
hypothesis
def __init__(self, language):
    pass
src_sent
call the method gettext_module.GNUTranslations.__init__ [ gettext_module . GNUTranslations . __init__ ] with an argument self .
hypothesis
gettext_module.GNUTranslations.__init__(self)
src_sent
substitute language for self.__language [ self . __language ] .
hypothesis
self.__language = language
src_sent
call the function to_language with an argument language , substitute it for self.__to_language [ self . __to_language ] .
hypothesis
self.__to_language = to_language(language)
src_sent
call the function to_locale with an argument language , substitute it for self.__locale [ self . __locale ] .
hypothesis
self.__locale = to_locale(language)
src_sent
self.plural [ self . plural ] is an lambda function with an argument n , which returns result of boolean expression n not equal to integer 1 ,
hypothesis
self.plural = lambda n, n: (n.startswith(n), 1)
src_sent
converted to an integer . call the method self._init_translation_catalog [ self . _init_translation_catalog ] .
hypothesis
self._init_translation_catalog()
src_sent
call the method self._add_installed_apps_translations [ self . _add_installed_apps_translations ] .
hypothesis
self._add_installed_apps_translations()
src_sent
call the method self._add_local_translations [ self . _add_local_translations ] .
hypothesis
self._add_local_translations()
src_sent
call the method self._add_fallback [ self . _add_fallback ] .
hypothesis
self._add_fallback()
src_sent
define the method __repr__ with an argument self .
hypothesis
def __repr__(self):
    pass
src_sent
return a string _STR:0_ , where %s is replaced with self.__language [ self . __language ] .
hypothesis
return '_STR:0_' % self.__language
src_sent
define the method _new_gnu_trans with 3 arguments : self , localedir and use_null_fallback set to boolean True .
hypothesis
def _new_gnu_trans(self, localedir, use_null_fallback=True):
    pass
src_sent
call the method gettext_module.translation [ gettext_module . translation ] with 5 arguments : domain set to string _STR:0_ , localedir set to localedir ,
hypothesis
gettext_module.translation(domain='_STR:0_', localedir=localedir, verbosity
    =defaults, verbosity=verbosity, interactive=interactive, using=db)
src_sent
languages set to a list with an element self.__locale [ self . __locale ] , codeset set to a string _STR:0_ and fallback set to use_null_fallback , substitute the result for translation . if translation has an attribute _STR:1_ ,
hypothesis
if hasattr(translation, '_STR:1_'):
    pass
src_sent
translation._catalog [ translation . _catalog ] is an empty dictionary .
hypothesis
translation._catalog = {}
src_sent
translation._info [ translation . _info ] is an empty dictionary .
hypothesis
translation._info = {}
src_sent
return translation .
hypothesis
return translation
src_sent
define the method _init_translation_catalog with an argument self .
hypothesis
def _init_translation_catalog(self):
    pass
src_sent
get the value under the settings.__module__ [ settings . __module__ ] key of the sys.modules [ sys . modules ] dictionary ,
hypothesis
sys.modules[settings.__module__] = None
src_sent
use its __file__ field as an argument for the call to the function upath , substitute the result for settingsfile . call the function os.path.dirname [ os . path . dirname ] with an argument settingsfile , join the result an string _STR:0_ into a file path ,
hypothesis
self.stdout.write(os.path.join(os.path.dirname(settingsfile)))
src_sent
substitute it for localedir . use_null_fallback is boolean True .
hypothesis
use_null_fallback = True
src_sent
if self.__language [ self . __language ] equals settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] ,
hypothesis
if self.__language == settings.LANGUAGE_CODE:
    pass
src_sent
use_null_fallback is boolean False .
hypothesis
use_null_fallback = False
src_sent
call the function self._new_gnu_trans [ self . _new_gnu_trans ] with 2 arguments : localedir and use_null_fallback , substitute the result for translation .
hypothesis
translation = self._new_gnu_trans(localedir, use_null_fallback)
src_sent
call the method translation._info.copy [ translation . _info . copy ] , substitute the result for self._info [ self . _info ] .
hypothesis
self._info = translation._info.copy()
src_sent
call the method translation._catalog.copy [ translation . _catalog . copy ] , substitute the result for self._catalog [ self . _catalog ] .
hypothesis
self._catalog = translation._catalog.copy()
src_sent
define the method _add_installed_apps_translations with an argument self .
hypothesis
def _add_installed_apps_translations(self):
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the method apps.get_app_configs [ apps . get_app_configs ] , convert the result in a list , reverse the order of elements , substitute the result for app_configs .
hypothesis
app_configs = reversed(apps.get_app_configs())
src_sent
if AppRegistryNotReady exception is caught ,
hypothesis
raise AppRegistryNotReady
src_sent
rais an AppRegistryNotReady exception with an argument string _STR:0_
hypothesis
raise AppRegistryNotReady('_STR:0_' % (config['_STR:0_'], token['_STR:0_':], e)
    )
src_sent
_STR:0_ . for every app_config in app_configs ,
hypothesis
for app_config in app_configs:
    pass
src_sent
join app_config.path [ app_config . path ] and string _STR:0_ into a file path , substitute it for localedir .
hypothesis
localedir = os.path.join(app_config.path, '_STR:0_')
src_sent
call the method self._new_gnu_trans [ self . _new_gnu_trans ] with an argument localedir , substitute the result for translation .
hypothesis
translation = self._new_gnu_trans(localedir)
src_sent
call the method self.merge [ self . merge ] with an argument translation .
hypothesis
self.merge(translation)
src_sent
define the method _add_local_translations with an argument self .
hypothesis
def _add_local_translations(self):
    pass
src_sent
reverse settings.LOCALE_PATHS [ settings . LOCALE_PATHS ] element order , for every localedir in the result ,
hypothesis
for localedir in reversed(settings.LOCALE_PATHS):
    pass
src_sent
call the function self._new_gnu_trans [ self . _new_gnu_trans ] with an argument localedir , substitute the result for translation .
hypothesis
translation = self._new_gnu_trans(localedir)
src_sent
call the method self.merge [ self . merge ] with an argument translation .
hypothesis
self.merge(translation)
src_sent
define the method _add_fallback with an argument self .
hypothesis
def _add_fallback(self):
    pass
src_sent
if self.__language [ self . __language ] equals settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] or self.__language [ self . __language ] equals a string _STR:0_ ,
hypothesis
if self.__language == settings.LANGUAGE_CODE or self.__language == '_STR:0_':
    pass
src_sent
return .
hypothesis
return
src_sent
call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for default_translation .
hypothesis
default_translation = translation(settings.LANGUAGE_CODE)
src_sent
call the method self.add_fallback [ self . add_fallback ] with an argument default_translation .
hypothesis
self.add_fallback(default_translation)
src_sent
define the method merge with 2 arguments self and other .
hypothesis
def merge(self, other):
    pass
src_sent
update the self._catalog [ self . _catalog ] dictionary with other._catalog [ other . _catalog ] .
hypothesis
self._catalog.update(other._catalog)
src_sent
define the method language with an argument self .
hypothesis
def language(self):
    pass
src_sent
return self.__language [ self . __language ] .
hypothesis
return self.__language
src_sent
define the method to_language with an argument self .
hypothesis
def to_language(self):
    pass
src_sent
return self.__to_language [ self . __to_language ] .
hypothesis
return self.__to_language
src_sent
define the function translation with an argument language .
hypothesis
def translation(language):
    pass
src_sent
use global variable _translations .
hypothesis
global _translations
src_sent
if language is not contained in _translations ,
hypothesis
if language not in _translations:
    pass
src_sent
_translations dictionary value , under the language key is an instance of DjangoTranslation class , created with an argument language .
hypothesis
key[language] = DjangoTranslation(language)
src_sent
return _translations dictionary value , under the language key .
hypothesis
return _translations[language]
src_sent
define the function activate with an argument language .
hypothesis
def activate(language):
    pass
src_sent
if language is contained in _DJANGO_DEPRECATED_LOCALES ,
hypothesis
if language in _DJANGO_DEPRECATED_LOCALES:
    pass
src_sent
msg is a string _STR:0_ .
hypothesis
msg = '_STR:0_'
src_sent
call the method call the function warnings.warn [ warnings . warn ] with 3 arguments : msg formatted with language and value under the language key ,
hypothesis
warnings.warn(msg, language[language])
src_sent
of the _DJANGO_DEPRECATED_LOCALES dictionary , RemovedInDjango19Warning and stacklevel set to integer 2. call the function translation with an argument language , substitute the result for _active.value [ _active . value ] .
hypothesis
_active.value = translation(language)
src_sent
define the function deactivate .
hypothesis
def deactivate():
    pass
src_sent
if _active has an attribute _STR:0_ ,
hypothesis
if hasattr(_active, '_STR:0_'):
    pass
src_sent
delete _active.value [ _active . value ] .
hypothesis
del _active.value
src_sent
define the function deactivate_all .
hypothesis
def deactivate_all():
    pass
src_sent
call the method gettext_module.NullTranslations [ gettext_module . NullTranslations ] , substitute the result for _active.value [ _active . value ] .
hypothesis
_active.value = gettext_module.NullTranslations()
src_sent
define the function get_language .
hypothesis
def get_language():
    pass
src_sent
get _STR:0_ attribute of the _active object , if it exists substitute it for t , if not t is None .
hypothesis
t = getattr(_active, '_STR:0_', None)
src_sent
if t is not None ,
hypothesis
if t is not None:
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the method t.to_language [ t . to_language ] , return the result .
hypothesis
return t.to_language()
src_sent
if AttributeError exception is caught ,
hypothesis
if AttributeError:
    pass
src_sent
do nothing .
hypothesis
pass
src_sent
return settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
hypothesis
return settings.LANGUAGE_CODE
src_sent
define the function get_language_bidi .
hypothesis
def get_language_bidi():
    pass
src_sent
call the function get_language , split the result by _STR:0_ , substitute the first element of the result for base_lang .
hypothesis
base_lang = get_language().split('_STR:0_')[0]
src_sent
if base_lang is contained in settings.LANGUAGES_BIDI [ settings . LANGUAGES_BIDI ] , return boolean True , if not , return boolean False .
hypothesis
return base_lang in settings.LANGUAGES_BIDI
src_sent
define the function catalog .
hypothesis
def catalog():
    pass
src_sent
use global variable _default .
hypothesis
global _default
src_sent
get _STR:0_ attribute of the _active object , if it exists substitute it for t , if not t is None .
hypothesis
t = getattr(_active, '_STR:0_', None)
src_sent
if t is not None
hypothesis
if t is not None:
    pass
src_sent
return t .
hypothesis
return t
src_sent
if _default is None
hypothesis
if _default is None:
    pass
src_sent
call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for _default .
hypothesis
_default = translation(settings.LANGUAGE_CODE)
src_sent
return _default .
hypothesis
return _default
src_sent
define the function do_translate with 2 arguments : message and translation_function .
hypothesis
def do_translate(message, translation_function):
    pass
src_sent
use global variable _default .
hypothesis
global _default
src_sent
replace every occurrence of string _STR:0_ in message with _STR:1_ , replace every occurrence of string _STR:2_ ,
hypothesis
return message.replace('_STR:0_', '_STR:1_').replace('_STR:0_', '_STR:1_')
src_sent
in the previous result for with string _STR:0_ , substitute the result for eol_message . get _STR:1_ attribute of the _active object , if it exists substitute it for t , if not t is None .
hypothesis
t = getattr(_active, '_STR:1_', None)
src_sent
if t is not None ,
hypothesis
if t is not None:
    pass
src_sent
get translation_function attribute of the object t , call the result with an argument eol_message , substitute the result for result .
hypothesis
result = getattr(t, translation_function)(eol_message)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
if _default is None ,
hypothesis
if _default is None:
    pass
src_sent
call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for _default .
hypothesis
_default = translation(settings.LANGUAGE_CODE)
src_sent
get translation_function attribute of the object _default , call the result with an argument eol_message , substitute the result for result .
hypothesis
result = getattr(_default, translation_function)(eol_message)
src_sent
if message is an instance of SafeData ,
hypothesis
if isinstance(message, SafeData):
    pass
src_sent
call the function mark_safe with an argument result , return it .
hypothesis
return mark_safe(result)
src_sent
return result .
hypothesis
return result
src_sent
define the function gettext with an argument message .
hypothesis
def gettext(message):
    pass
src_sent
call the function do_translate with 2 arguments : message and string _STR:0_ , return the result .
hypothesis
return do_translate(message, '_STR:0_')
src_sent
if six.PY3 [ six . PY3 ] is true ,
hypothesis
if six.PY3:
    pass
src_sent
substitute gettext for ugettext .
hypothesis
ugettext = gettext
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
define the function ugettext with an argument message .
hypothesis
def ugettext(message):
    pass
src_sent
call the function do_translate with 2 arguments : message and string _STR:0_ , return the result .
hypothesis
return do_translate(message, '_STR:0_')
src_sent
define the function pgettext with 2 arguments : context and message .
hypothesis
def pgettext(context, message):
    pass
src_sent
convert to strings and concatenate context , CONTEXT_SEPARATOR and message , substitute the result for msg_with_ctxt .
hypothesis
msg_with_ctxt = 'value' % (context, context, message)
src_sent
call the function ugettext with an argument msg_with_ctxt , substitute the result for result .
hypothesis
result = ugettext(msg_with_ctxt)
src_sent
if CONTEXT_SEPARATOR is contained in result ,
hypothesis
if CONTEXT_SEPARATOR in result:
    pass
src_sent
call the function force_text with an argument message , return the result .
hypothesis
return force_text(message)
src_sent
return result .
hypothesis
return result
src_sent
define the function locale with an argument locale .
hypothesis
def locale(locale):
    pass
src_sent
return message .
hypothesis
return message
src_sent
define the function do_ntranslate with 4 arguments : singular , plural , number and translation_function .
hypothesis
def do_ntranslate(singular, plural, number, translation_function):
    pass
src_sent
use global variable _default .
hypothesis
global _default
src_sent
get _STR:0_ attribute of the _active object , if it exists substitute it for t , if not t is None .
hypothesis
t = getattr(_active, '_STR:0_', None)
src_sent
if t is not None ,
hypothesis
if t is not None:
    pass
src_sent
get translation_function attribute of the t object , call the result with 3 arguments : singular , plural and number , return the result .
hypothesis
return getattr(t, translation_function)(singular, plural, number)
src_sent
if _default is None ,
hypothesis
if _default is None:
    pass
src_sent
call the function translation with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , substitute the result for _default .
hypothesis
_default = translation(settings.LANGUAGE_CODE)
src_sent
get translation_function attribute of the _default object , call the result with 3 arguments : singular , plural and number , return the result .
hypothesis
return getattr(_default, translation_function)(singular, plural, number)
src_sent
define the function ngettext with 3 arguments : singular , plural and number .
hypothesis
def ngettext(singular, plural, number):
    pass
src_sent
call the function do_ntranslate with 3 arguments : singular , plural , number and string _STR:0_ , return the result .
hypothesis
return do_ntranslate(singular, plural, number, '_STR:0_')
src_sent
if six.PY3 [ six . PY3 ] is true ,
hypothesis
if six.PY3:
    pass
src_sent
substitute ngettext for ungettext .
hypothesis
ungettext = ngettext
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
define the function ungettext with 3 arguments : singular , plural and number .
hypothesis
def ungettext(singular, plural, number):
    pass
src_sent
call the function do_ntranslate with 3 arguments : singular , plural , number and string _STR:0_ , return the result .
hypothesis
return do_ntranslate(singular, plural, number, '_STR:0_')
src_sent
define the function npgettext with 4 arguments : context , singular , plural and number .
hypothesis
def npgettext(context, singular, plural, number):
    pass
src_sent
msgs_with_ctxt is a tuple containing 2 elements : string created by concatenating context , CONTEXT_SEPARATOR and singular ,
hypothesis
msgs_with_ctxt = 'context' % (len(context), len(singular), singular
    ), attrs.items()
src_sent
string created by concatenating context , CONTEXT_SEPARATOR and plural and number . call the function ungettext with unpacked dictionary msgs_with_ctxt , substitute the result for result .
hypothesis
result = ungettext(**msgs_with_ctxt)
src_sent
if CONTEXT_SEPARATOR is contained in result ,
hypothesis
if CONTEXT_SEPARATOR in result:
    pass
src_sent
call the function ungettext with 3 arguments : singular , plural and number , substitute the result for result .
hypothesis
result = ungettext(singular, plural, number)
src_sent
return result .
hypothesis
return result
src_sent
define the function all_locale_paths .
hypothesis
def all_locale_paths():
    pass
src_sent
get the value under the settings.__module__ [ settings . __module__ ] key of the sys.modules [ sys . modules ] dictionary , use its __file__ field as an argument ,
hypothesis
field = sys.modules[settings.__module__].get(settings.__module__)[0]
src_sent
for the call to the function upath , get the directory name of the resulting system path , join the result and string _STR:0_ , into a valid file path , substitute it for globalpath . append settings.LOCALE_PATHS [ settings . LOCALE_PATHS ] converted into a list to a list containing an element globalpath , return it .
hypothesis
return [settings.LOCALE_PATHS] + upath(settings.LOCALE_PATHS)
src_sent
decorator function lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to integer 1000 .
hypothesis
@lru_cache.lru_cache(maxsize=1000)
def dummy():
    pass
src_sent
define the function check_for_language with an argument lang_code .
hypothesis
def check_for_language(lang_code):
    pass
src_sent
call the method language_code_re.search [ language_code_re . search ] with an argument lang_code , if it evaluates to false ,
hypothesis
if not language_code_re.search(lang_code):
    pass
src_sent
return boolean False .
hypothesis
return False
src_sent
call the function all_locale_paths , for every path is the result ,
hypothesis
for path in all_locale_paths():
    pass
src_sent
call the method gettext_module.find [ gettext_module . find ] with 3 arguments : string _STR:0_ , path and list with an element : result of the function ,
hypothesis
return gettext_module.find('_STR:0_', path).time(*errors)
src_sent
to_locale called with an argument lang_code , if the result is not None , return boolean True .
hypothesis
return len(lang_code) is not None
src_sent
return boolean False .
hypothesis
return False
src_sent
decorator function lru_cache.lru_cache [ lru_cache . lru_cache ] with an argument maxsize set to integer 1000 .
hypothesis
@lru_cache.lru_cache(maxsize=1000)
def dummy():
    pass
src_sent
define the function get_supported_language_variant with 2 arguments : lang_code and strict set to boolean False .
hypothesis
def get_supported_language_variant(lang_code, strict=False):
    pass
src_sent
use global variable _supported .
hypothesis
global _supported
src_sent
if _supported is None ,
hypothesis
if _supported is None:
    pass
src_sent
_supported is an instance of OrderedDict class , created with an argument settings.LANGUAGES [ settings . LANGUAGES ] .
hypothesis
_supported = OrderedDict(settings.LANGUAGES)
src_sent
if lang_code is true ,
hypothesis
if lang_code:
    pass
src_sent
get the value under the lang_code key of the _BROWSERS_DEPRECATED_LOCALES dictionary , substitute it for replacement .
hypothesis
replacement = _BROWSERS_DEPRECATED_LOCALES.get(lang_code)
src_sent
if lang_code is not contained in _supported and replacement is contained in _supported ,
hypothesis
if lang_code not in _supported and replacement in _supported:
    pass
src_sent
return replacement .
hypothesis
return replacement
src_sent
split lang_code by _STR:0_ , substitute the first element of the result for generic_lang_code .
hypothesis
generic_lang_code = lang_code.split('_STR:0_')[0]
src_sent
for every code in tuple with 2 elements : lang_code and generic_lang_code ,
hypothesis
for code in (lang_code, generic_lang_code):
    pass
src_sent
if code is contained in _supported and call to the function check_for_language with an argument code evaluates to true ,
hypothesis
if code in _supported and check_for_language(code):
    pass
src_sent
return code .
hypothesis
return code
src_sent
if strict is false ,
hypothesis
if not strict:
    pass
src_sent
for every supported_code in _supported ,
hypothesis
for supported_code in _supported:
    pass
src_sent
append _STR:0_ to generic_lang_code , if supported_code starts with it ,
hypothesis
with supported_code(supported_code + '_STR:0_') as generic_lang_code:
    pass
src_sent
return supported_code .
hypothesis
return supported_code
src_sent
raise an LookupError with an argument lang_code .
hypothesis
raise LookupError(lang_code)
src_sent
define the function get_language_from_path with 2 arguments : path and strict set to boolean False .
hypothesis
def get_language_from_path(path, strict=False):
    pass
src_sent
call the function language_code_prefix_re.match [ language_code_prefix_re . match ] with an argument path , substitute it for regex_match .
hypothesis
regex_match = language_code_prefix_re.match(path)
src_sent
if regex_match is false ,
hypothesis
if not regex_match:
    pass
src_sent
return None .
hypothesis
return None
src_sent
call the method regex_match.group [ regex_match . group ] with an argument integer 1 , substitute the result for lang_code .
hypothesis
lang_code = regex_match.group(1)
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the function get_supported_language_variant with 2 arguments : lang_code and strict set to strict , return the result .
hypothesis
return get_supported_language_variant(lang_code, strict=strict)
src_sent
if LookupError exception is caught ,
hypothesis
raise LookupError
src_sent
return None .
hypothesis
return None
src_sent
define the function get_language_from_request with 2 arguments : request and check_path set to boolean False .
hypothesis
def get_language_from_request(request, check_path=False):
    pass
src_sent
use global variable _supported .
hypothesis
global _supported
src_sent
if _supported is None ,
hypothesis
if _supported is None:
    pass
src_sent
_supported is an instance of OrderedDict class , created with an argument settings.LANGUAGES [ settings . LANGUAGES ] .
hypothesis
_supported = OrderedDict(settings.LANGUAGES)
src_sent
if check_path is true ,
hypothesis
if check_path:
    pass
src_sent
call the function get_language_from_path with an argument request.path_info [ request . path_info ] , substitute it for lang_code .
hypothesis
lang_code = get_language_from_path(request.path_info)
src_sent
if lang_code is not None ,
hypothesis
if lang_code is not None:
    pass
src_sent
return lang_code .
hypothesis
return lang_code
src_sent
if request has an attribute _STR:0_ ,
hypothesis
if hasattr(request, '_STR:0_'):
    pass
src_sent
get the value under the LANGUAGE_SESSION_KEY key of the request.session [ request . session ] dictionary , substitute it for lang_code .
hypothesis
lang_code = request.session[LANGUAGE_SESSION_KEY]
src_sent
if lang_code is contained in _supported and lang_code is not None and result of the function check_for_language ,
hypothesis
if lang_code in _supported and lang_code is not None and check_for_language(
    lang_code):
    pass
src_sent
called with an argument lang_code is true , return lang_code .
hypothesis
return lang_code
src_sent
get the value under the settings.LANGUAGE_COOKIE_NAME [ settings . LANGUAGE_COOKIE_NAME ] key of the request.COOKIES [ request . COOKIES ] dictionary , substitute it for lang_code .
hypothesis
lang_code = request.COOKIES[settings.LANGUAGE_COOKIE_NAME]
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the function get_supported_language_variant with an argument lang_code , return the result .
hypothesis
return get_supported_language_variant(lang_code)
src_sent
if LookupError exception is caught ,
hypothesis
raise LookupError
src_sent
do nothing .
hypothesis
pass
src_sent
get the value under the _STR:0_ key of the request.META [ request . META ] dictionary , if it exists substitute it for accept ,
hypothesis
accept = request.META.get('_STR:0_', None)
src_sent
if not accept is an empty string . call the function parse_accept_lang_header with an argument accept , for every accept_lang and unused in the result ,
hypothesis
value = enumerate(parse_accept_lang_header(accept) for accept_lang, unused in
    self.items())
src_sent
if accept_lang equals _STR:0_ ,
hypothesis
if accept_lang == '_STR:0_':
    pass
src_sent
break from the loop execution .
hypothesis
break
src_sent
call the method language_code_re.search [ language_code_re . search ] with an argument accept_lang , if it evaluates to false ,
hypothesis
if not language_code_re.search(accept_lang):
    pass
src_sent
skip this loop iteration .
hypothesis
continue
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the function get_supported_language_variant with an argument accept_lang , return the result .
hypothesis
return get_supported_language_variant(accept_lang)
src_sent
if LookupError exception is caught ,
hypothesis
raise LookupError
src_sent
skip this loop iteration .
hypothesis
continue
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the function get_supported_language_variant with an argument settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] , return the result .
hypothesis
return get_supported_language_variant(settings.LANGUAGE_CODE)
src_sent
if LookupError exception is caught ,
hypothesis
raise LookupError
src_sent
return settings.LANGUAGE_CODE [ settings . LANGUAGE_CODE ] .
hypothesis
return settings.LANGUAGE_CODE
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute it for dot_re .
hypothesis
dot_re = re.compile('_STR:0_')
src_sent
define the function blankout with 2 arguments : src and char .
hypothesis
def blankout(src, char):
    pass
src_sent
call the method dot_re.sub [ dot_re . sub ] with 2 arguments : char and src , return the result .
hypothesis
return dot_re.sub(char, src)
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ [ ^_STR:1_ ) | ( ? : _STR:2_ ] * ? ' ) ) \s* '' , substitute the result for context_re .
hypothesis
context_re = re.compile('_STR:0_' % ' '.join(^_STR:1_))
src_sent
call the function re.compile [ re . compile ] with an argument string _STR:0_ [ ^_STR:1_ ) | ( ? : _STR:2_ ] * ? ' ) ) ( \s+.*context\s+ [ \s+ . *context\s+ ] ( ( ? : '' [ ^_STR:1_ ) | ( ? : _STR:2_ ] * ? ' ) ) ) ? \s* '' , substitute the result for inline_re .
hypothesis
inline_re = re.compile('_STR:0_' % ' '.join(^_STR:1_))
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ [ ^_STR:1_ ) | ( ? : _STR:2_ ] * ? ' ) ) ) ? ( ? : \s+| $ ) '' ,
hypothesis
message = re.compile('_STR:0_' % (re.escape(p), re.escape($)))
src_sent
substitute the result for block_re . call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for endblock_re .
hypothesis
endblock_re = re.compile('_STR:0_')
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for plural_re .
hypothesis
plural_re = re.compile('_STR:0_')
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ . * ? _STR:1_ , substitute the result for constant_re .
hypothesis
constant_re = re.compile('_STR:0_', '')
src_sent
call the function re.compile [ re . compile ] with an argument raw string _STR:0_ , substitute the result for one_percent_re .
hypothesis
one_percent_re = re.compile('_STR:0_')
src_sent
define the function templatize with 2 arguments : src and origin set to None .
hypothesis
def templatize(src, origin=None):
    pass
src_sent
from django.template [ django . template ] import Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT and TRANSLATOR_COMMENT_MARK .
hypothesis
from django.template import Lexer, TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK, TOKEN_COMMENT, TRANSLATOR_COMMENT_MARK
src_sent
call the function force_text with 2 arguments : src and settings.FILE_CHARSET [ settings . FILE_CHARSET ] .
hypothesis
force_text(src, settings.FILE_CHARSET)
src_sent
out is an instance of StringIO class , created with an empty string as an argument .
hypothesis
out = StringIO('')
src_sent
message_context is None .
hypothesis
message_context = None
src_sent
intrans is boolean False .
hypothesis
intrans = False
src_sent
inplural is boolean False .
hypothesis
inplural = False
src_sent
trimmed is boolean False .
hypothesis
trimmed = False
src_sent
singular is an empty list .
hypothesis
singular = []
src_sent
plural is an empty list .
hypothesis
plural = []
src_sent
incomment is boolean False .
hypothesis
incomment = False
src_sent
comment is an empty list .
hypothesis
comment = []
src_sent
lineno_comment_map is an dictionary .
hypothesis
lineno_comment_map = {}
src_sent
comment_lineno_cache is None .
hypothesis
comment_lineno_cache = None
src_sent
define the function join_tokens with 2 arguments : tokens and trim set to boolean False .
hypothesis
def join_tokens(tokens, trim=False):
    pass
src_sent
join tokens elements into a string , substitute it for message .
hypothesis
message = ''.join(tokens)
src_sent
if trim is true ,
hypothesis
if trim:
    pass
src_sent
call the function trim_whitespace with an argument message , substitute the result for message .
hypothesis
message = trim_whitespace(message)
src_sent
return message .
hypothesis
return message
src_sent
instantiate Lexer class with 2 argumets src and origin , call the method tokenize from it , for every t in the result ,
hypothesis
for t in Lexer('src', origin).tokenize():
    pass
src_sent
if incomment is true ,
hypothesis
if incomment:
    pass
src_sent
if t.token_type [ t . token_type ] equals TOKEN_BLOCK and t.contents [ t . contents ] equals _STR:0_ ,
hypothesis
if t.token_type == TOKEN_BLOCK and t.contents == '_STR:0_':
    pass
src_sent
join comment elements into a string , substitute it for content .
hypothesis
content = ''.join(comment)
src_sent
translators_comment_start is None .
hypothesis
translators_comment_start = None
src_sent
for every lineno and line is enumerated result of the method content.splitlines [ content . splitlines ] , called with an argument boolean True ,
hypothesis
for lineno, line in content.splitlines(True):
    pass
src_sent
call the method line.lstrip [ line . lstrip ] , if the result starts with TRANSLATOR_COMMENT_MARK ,
hypothesis
if line.lstrip().startswith(TRANSLATOR_COMMENT_MARK):
    pass
src_sent
substitute lineno for translators_comment_start .
hypothesis
translators_comment_start = lineno
src_sent
for every lineno and line is enumerated result of the method content.splitlines [ content . splitlines ] , called with an argument boolean True ,
hypothesis
for lineno, line in content.splitlines(True):
    pass
src_sent
if translators_comment_start is not None and lineno is greater than or equal to translators_comment_start ,
hypothesis
if translators_comment_start is not None and lineno >= translators_comment_start:
    pass
src_sent
substitute %s in string _STR:0_ with line , write it to out file .
hypothesis
out.write('_STR:0_' % line)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
write string _STR:0_ to out file .
hypothesis
out.write('_STR:0_')
src_sent
incomment is boolean False .
hypothesis
incomment = False
src_sent
comment is an empty list .
hypothesis
comment = []
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
append t.contents [ t . contents ] to comment .
hypothesis
comment.append(t.contents)
src_sent
otherwise if intrans is true ,
hypothesis
if True:
    pass
elif intrans:
    pass
src_sent
if t.token_type [ t . token_type ] equals TOKEN_BLOCK ,
hypothesis
if t.token_type == TOKEN_BLOCK:
    pass
src_sent
call the function endblock_re.match [ endblock_re . match ] with an argument t.contents [ t . contents ] , substitute the result for endbmatch .
hypothesis
endbmatch = endblock_re.match(t.contents)
src_sent
call the function plural_re.match [ plural_re . match ] with an argument t.contents [ t . contents ] , substitute the result for pluralmatch .
hypothesis
pluralmatch = plural_re.match(t.contents)
src_sent
if endbmatch is true ,
hypothesis
if endbmatch:
    pass
src_sent
if inplural is true ,
hypothesis
if inplural:
    pass
src_sent
if message_context is true ,
hypothesis
if message_context:
    pass
src_sent
substitute _STR:0_ in string _STR:1_ with message_context , result of the function join_tokens ,
hypothesis
output.append('_STR:1_' % (message_context, join_tokens('_STR:0_' % (
    message_context, join_tokens(message_context))), message_context))
src_sent
called with 2 arguments : singular and trimmed and result of the function join_tokens called with 2 arguments : plural and trimmed , write the result to out . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute _STR:0_ in string _STR:1_ with result of the function join_tokens , called with 2 arguments : singular ,
hypothesis
warnings.warn('_STR:1_' % (join_tokens(singular), e))
src_sent
and trimmed and result of the function join_tokens called with 2 arguments : plural and trimmed , write the result to out . for every part in singular ,
hypothesis
for part in singular:
    pass
src_sent
call the method blankout with 2 arguments : part and _STR:0_ , write the result to out .
hypothesis
out.write(blankout(part, '_STR:0_'))
src_sent
for every part in plural ,
hypothesis
for part in plural:
    pass
src_sent
call the method blankout with 2 arguments : part and _STR:0_ , write the result to out .
hypothesis
out.write(blankout(part, '_STR:0_'))
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
if message_context is true ,
hypothesis
if message_context:
    pass
src_sent
substitute _STR:0_ in string _STR:1_ with message_context and result of the function join_tokens ,
hypothesis
output.append(('_STR:1_', message_context, join_tokens(), join_tokens(
    message_context), join_tokens(message_context), join_tokens(
    message_context)))
src_sent
called with 2 arguments : singular and trimmed , write the result to out . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
substitute _STR:0_ in string _STR:1_ with result of the function join_tokens , called with 2 arguments : singular ,
hypothesis
warnings.warn('_STR:1_' % (join_tokens(singular), e))
src_sent
and trimmed , write the result to out . for every part in singular ,
hypothesis
for part in singular:
    pass
src_sent
call the method blankout with 2 arguments : part and _STR:0_ , write the result to out .
hypothesis
out.write(blankout(part, '_STR:0_'))
src_sent
message_context is None .
hypothesis
message_context = None
src_sent
intrans is boolean False .
hypothesis
intrans = False
src_sent
inplural is boolean False .
hypothesis
inplural = False
src_sent
singular is an empty list .
hypothesis
singular = []
src_sent
plural is an empty list .
hypothesis
plural = []
src_sent
otherwise if pluralmatch is true ,
hypothesis
if True:
    pass
elif pluralmatch:
    pass
src_sent
inplural is boolean True .
hypothesis
inplural = True
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
filemsg is an empty string .
hypothesis
filemsg = ''
src_sent
if origin is true ,
hypothesis
if origin:
    pass
src_sent
filemsg is a string _STR:0_ , where %s is replaced with origin .
hypothesis
filemsg = '_STR:0_' % origin
src_sent
raise an SyntaxError with an argument string _STR:0_ ,
hypothesis
raise SyntaxError('_STR:0_' % (token[upto:], token))
src_sent
formated with t.contents [ t . contents ] , filemsg and t.lineno [ t . lineno ] . otherwise if t.token_type [ t . token_type ] equals TOKEN_VAR ,
hypothesis
if True:
    pass
elif t.token_type == TOKEN_VAR:
    pass
src_sent
if inplural is true ,
hypothesis
if inplural:
    pass
src_sent
append string _STR:0_ to plural , where %s is replaced with t.contents [ t . contents ] .
hypothesis
plural += '_STR:0_' % t.contents
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
append string _STR:0_ to singular , where %s is replaced with t.contents [ t . contents ] .
hypothesis
singular += '_STR:0_' % t.contents
src_sent
if t.token_type [ t . token_type ] == TOKEN_TEXT :
hypothesis
if t.token_type == None:
    pass
src_sent
call the method one_percent_re.sub [ one_percent_re . sub ] with 2 arguments : string _STR:0_ and t.contents [ t . contents ] , substitute the result for contents .
hypothesis
contents = one_percent_re.sub('_STR:0_', t.contents)
src_sent
if inplural is true ,
hypothesis
if inplural:
    pass
src_sent
append contents to plural .
hypothesis
plural.append(contents)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
append contents to singular .
hypothesis
singular.append(contents)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
if comment_lineno_cache is not None ,
hypothesis
if comment_lineno_cache is not None:
    pass
src_sent
count occurrences of _STR:0_ in t.contents [ t . contents ] , add the result to t.lineno [ t . lineno ] , substitute the result for cur_lineno .
hypothesis
cur_lineno = t.contents + str('_STR:0_') + t.contents
src_sent
if comment_lineno_cache equals cur_lineno .
hypothesis
if comment_lineno_cache == cur_lineno:
    pass
src_sent
if t.token_type [ t . token_type ] is not equal to TOKEN_COMMENT ,
hypothesis
if t.token_type != TOKEN_COMMENT:
    pass
src_sent
for every c in lineno_comment_map dictionary value under the comment_lineno_cache key ,
hypothesis
for c in lineno_comment_map[comment_lineno_cache]:
    pass
src_sent
filemsg is an empty string .
hypothesis
filemsg = ''
src_sent
if origin is true ,
hypothesis
if origin:
    pass
src_sent
filemsg is a string _STR:0_ , where %s is replaced with origin .
hypothesis
filemsg = '_STR:0_' % origin
src_sent
warn_msg is a string _STR:0_ ,
hypothesis
warn_msg = '_STR:0_'
src_sent
formated with c , filemsg and comment_lineno_cache . call the function warnings.warn [ warnings . warn ] with 2 arguments : warn_msg and TranslatorCommentWarning .
hypothesis
warnings.warn(warn_msg, TranslatorCommentWarning)
src_sent
value under the comment_lineno_cache key of the lineno_comment_map dictionary is an empty string .
hypothesis
lineno_comment_map[comment_lineno_cache] = ''
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
join lineno_comment_map dictionary value under the comment_lineno_cache key into a string , separated with _STR:0_ ,
hypothesis
return '_STR:0_'.join(lineno_comment_map[comment_lineno_cache])
src_sent
format with it a string _STR:0_ , write it to out . comment_lineno_cache is None ,
hypothesis
out.write('_STR:0_' % None)
src_sent
if t.token_type [ t . token_type ] equals TOKEN_BLOCK ,
hypothesis
if t.token_type == TOKEN_BLOCK:
    pass
src_sent
call the function inline_re.match [ inline_re . match ] with an argument t.contents [ t . contents ] , substitute the result for imatch .
hypothesis
imatch = inline_re.match(t.contents)
src_sent
call the function block_re.match [ block_re . match ] with an argument t.contents [ t . contents ] , substitute the result for bmatch .
hypothesis
bmatch = block_re.match(t.contents)
src_sent
call the function constant_re.findall [ constant_re . findall ] with an argument t.contents [ t . contents ] , substitute the result for cmatches .
hypothesis
cmatches = constant_re.findall(t.contents)
src_sent
if imatch is true ,
hypothesis
if imatch:
    pass
src_sent
call the method imatch.group [ imatch . group ] with an argument integer 1 , substitute the result for g .
hypothesis
g = imatch.group(1)
src_sent
if first element of g equals a string _STR:0_ ,
hypothesis
if g[0] == '_STR:0_':
    pass
src_sent
strip g of _STR:0_ from both ends ,
hypothesis
both.strip()
src_sent
otherwise if first element of g equals a string _STR:0_ ,
hypothesis
if True:
    pass
elif g[0] == '_STR:0_':
    pass
src_sent
strip g of _STR:0_ from both ends ,
hypothesis
both.strip()
src_sent
call the method one_percent_re.sub [ one_percent_re . sub ] with 2 arguments : string _STR:0_ and g , substitute the result for .
hypothesis
. = one_percent_re.sub('_STR:0_', g)
src_sent
call the method imatch.group [ imatch . group ] with an argument integer 1 , if it evaluates to true ,
hypothesis
if imatch.group(1):
    pass
src_sent
call the method imatch.group [ imatch . group ] with an argument integer 2 , use the result as an argument for the call to the method context_re.match [ context_re . match ] ,
hypothesis
kw = context_re.match(imatch.match(2))
src_sent
substitute the result for context_match . call the method context_match.group [ context_match . group ] with an argument integer 1 , substitute the result for message_context .
hypothesis
message_context = context_match.group(1)
src_sent
if first element of message_context equals to character _STR:0_ ,
hypothesis
if message_context[0] == '_STR:0_':
    pass
src_sent
strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
hypothesis
message_context = message_context.strip('_STR:0_')
src_sent
otherwise if , first element of message_context is equal to _STR:0_ ,
hypothesis
if True:
    pass
elif message_context[0] == '_STR:0_' and message_context[0] == '_STR:0_':
    pass
src_sent
strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
hypothesis
message_context = message_context.strip('_STR:0_')
src_sent
format string _STR:0_ with message_context and g , write it to out .
hypothesis
out.write('_STR:0_' % (message_context, g))
src_sent
message_context is None .
hypothesis
message_context = None
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
format string _STR:0_ with g , write it to out .
hypothesis
out.write('_STR:0_' % g)
src_sent
otherwise if bmatch is true ,
hypothesis
if True:
    pass
elif bmatch:
    pass
src_sent
call the method constant_re.findall [ constant_re . findall ] with an argument t.contents [ t . contents ] , for every fmatch in the result ,
hypothesis
for fmatch in constant_re.findall(t.contents):
    pass
src_sent
format string _STR:0_ , with fmatch , write it to out .
hypothesis
out.write('_STR:0_' % fmatch)
src_sent
call the method bmatch.group [ bmatch . group ] with an argument integer 1 , if it evaluates to true ,
hypothesis
if bmatch.group(1):
    pass
src_sent
call the method bmatch.group [ bmatch . group ] with an argument integer 1 , use the result as an argument for the call to the function context_re.match [ context_re . match ] ,
hypothesis
kw = context_re.match(bmatch.match(1))
src_sent
substitute the result for context_match . call the method context_match.group [ context_match . group ] with an argument integer 1 , substitute the result for message_context .
hypothesis
message_context = context_match.group(1)
src_sent
if first element of message_context equals to character _STR:0_ ,
hypothesis
if message_context[0] == '_STR:0_':
    pass
src_sent
strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
hypothesis
message_context = message_context.strip('_STR:0_')
src_sent
otherwise if first element of message_context equals to character _STR:0_ ,
hypothesis
if True:
    pass
elif message_context[0] == '_STR:0_':
    pass
src_sent
strip message_context of _STR:0_ characters from both ends , substitute the result for message_context .
hypothesis
message_context = message_context.strip('_STR:0_')
src_sent
intrans is boolean True .
hypothesis
intrans = True
src_sent
inplural is boolean False .
hypothesis
inplural = False
src_sent
if string _STR:0_ is contained in result of the method t.split_contents [ t . split_contents ] , trimmed is boolean True , otherwise is boolean False .
hypothesis
trimmed = '_STR:0_' in t.split_contents()
src_sent
singular is an empty list .
hypothesis
singular = []
src_sent
plural is an empty list .
hypothesis
plural = []
src_sent
otherwise if cmatches is true ,
hypothesis
if True:
    pass
elif cmatches:
    pass
src_sent
for every cmatch in cmatches ,
hypothesis
for cmatch in cmatches:
    pass
src_sent
format string _STR:0_ , with fmatch , write it to out .
hypothesis
out.write('_STR:0_' % fmatch)
src_sent
otherwise if t.contents [ t . contents ] equals a string _STR:0_ ,
hypothesis
if True:
    pass
elif t.contents == '_STR:0_':
    pass
src_sent
incomment is boolean True .
hypothesis
incomment = True
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function blankout with 2 arguments : t.contents [ t . contents ] and _STR:0_ , write the result to out .
hypothesis
out.write(blankout(t.contents, '_STR:0_'))
src_sent
otherwise if t.token_type [ t . token_type ] equals TOKEN_VAR ,
hypothesis
if True:
    pass
elif t.token_type == TOKEN_VAR:
    pass
src_sent
split t.contents [ t . contents ] by _STR:0_ symbol , substitute the result for parts ,
hypothesis
parts = t.contents.split('_STR:0_', symbol)
src_sent
call the method constant_re.match [ constant_re . match ] with first element of parts as an argument , substitute the result for cmatch .
hypothesis
cmatch = constant_re.match(parts[0])
src_sent
if cmatch is true ,
hypothesis
if cmatch:
    pass
src_sent
call the method cmatch.group [ cmatch . group ] with an argument integer 1 , format with the result string _STR:0_ , write it to out .
hypothesis
out.write(cmatch.group(1) % cmatch.group(1))
src_sent
for every p in parts without the first element ,
hypothesis
for p in parts[1:]:
    pass
src_sent
find index of the occurrence of string _STR:0_ in p , if its greater or equal to integer 0 ,
hypothesis
if p._STR:0_('_STR:0_') >= 0:
    pass
src_sent
split p into two parts at the first _STR:0_ , use the second element of the result to format string _STR:1_ , write it to out .
hypothesis
out.write(p.split('_STR:0_', 1)[1])
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function blankout with 2 arguments : p and _STR:0_ , write the result to out .
hypothesis
out.write(blankout(p, '_STR:0_'))
src_sent
otherwise if t.token_type [ t . token_type ] equals TOKEN_COMMENT ,
hypothesis
if True:
    pass
elif t.token_type == TOKEN_COMMENT:
    pass
src_sent
strip t.contents [ t . contents ] from the left side of whitespaces , if the result starts with TRANSLATOR_COMMENT_MARK ,
hypothesis
if getattr(left, t.contents).startswith(TRANSLATOR_COMMENT_MARK):
    pass
src_sent
call the method lineno_comment_map.setdefault [ lineno_comment_map . setdefault ] with 2 arguments : t.lineno [ t . lineno ] and an empty list , append t.contents [ t . contents ] to the result .
hypothesis
lineno_comment_map.setdefault(t.lineno, []).append(t.contents)
src_sent
substitute t.lineno [ t . lineno ] for comment_lineno_cache .
hypothesis
comment_lineno_cache = t.lineno
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function blankout with 2 arguments : t.contents [ t . contents ] and _STR:0_ , write the result to out .
hypothesis
out.write(blankout(t.contents, '_STR:0_'))
src_sent
call the method out.getvalue [ out . getvalue ] , return the result .
hypothesis
return out.getvalue()
src_sent
define the function parse_accept_lang_header with an argument lang_string .
hypothesis
def parse_accept_lang_header(lang_string):
    pass
src_sent
result is an empty list .
hypothesis
result = []
src_sent
convert lang_string to lowercase , split by the result string accept_language_re , substitute the result for pieces .
hypothesis
pieces = lang_string.split(lang_string.lower())
src_sent
if last element of pieces is true ,
hypothesis
if pieces[-1]:
    pass
src_sent
return an empty list .
hypothesis
return []
src_sent
for every i in range of integers from integer 0 to the length of pieces decremented by one , with step of integer 3 ,
hypothesis
i += 0 ** (pieces // 3)
src_sent
substitute 3 successive elements starting from the i-th index of pieces for first , lang and priority , respectively .
hypothesis
pieces[i], lang, priority = pieces[p:i]
src_sent
if first is true ,
hypothesis
if first:
    pass
src_sent
return an empty list .
hypothesis
return []
src_sent
if priority is true ,
hypothesis
if priority:
    pass
src_sent
try ,
hypothesis
if any():
    pass
src_sent
convert priority into a floating point integer , substitute it for priority .
hypothesis
priority = int(priority)
src_sent
if ValueError exception is caught ,
hypothesis
raise ValueError
src_sent
return an empty list .
hypothesis
return []
src_sent
if priority is false ,
hypothesis
if not priority:
    pass
src_sent
priority is floating point number 1.0 [ 1 . 0 ] .
hypothesis
priority = priority % 1.0
src_sent
append a tuple with 2 entries lang and priority to result .
hypothesis
result.append((lang, priority))
src_sent
sort result in reversed order by the key as lambda function with an argument k and reeturn value second element of k .
hypothesis
reversed.sort(key=lambda k, **1: k[1])
src_sent
return result .
hypothesis
return result
src_sent
import module copy .
hypothesis
import copy
src_sent
derive the class Node from object base class .
hypothesis
class Node(object):
    pass
src_sent
default is a string _STR:0_ .
hypothesis
default = '_STR:0_'
src_sent
define the method __init__ with 4 arguments : self , children set to None , connector set to None and negated set to boolean False .
hypothesis
def __init__(self, children=None, connector=None, negated=False):
    pass
src_sent
if children is true , copy children list to self.children [ self . children ] , otherwise self.children [ self . children ] is an empty list .
hypothesis
self.children = children or []
src_sent
if connector is true , substitute it for self.connector [ self . connector ] , otherwise substitute self.default [ self . default ] for self.connector [ self . connector ] .
hypothesis
self.connector = connector or self.default
src_sent
substitute negated for self.negated [ self . negated ] .
hypothesis
self.negated = negated
src_sent
decorator classmethod ,
hypothesis
@classmethod
def dummy():
    pass
src_sent
define the method _new_instance with 4 arguments : ( cls , children set to None , connector set to None and negated set to boolean False .
hypothesis
def _new_instance(cls, children=None, connector=None, negated=False):
    pass
src_sent
obj is an instance of Node class , created with 3 arguments : children , connector and negated .
hypothesis
obj = Node(children, connector, negated)
src_sent
substitute cls for obj.__class__ [ obj . __class__ ] .
hypothesis
obj.__class__ = cls
src_sent
return obj .
hypothesis
return obj
src_sent
define the method __str__ with an argument self .
hypothesis
def __str__(self):
    pass
src_sent
if self.negated [ self . negated ] ,
hypothesis
if self.negated:
    pass
src_sent
return string _STR:0_ , formated with self.connector [ self . connector ] and string created by joining c into a string , separated by _STR:1_ ,
hypothesis
return '_STR:0_' % ('_STR:1_'.join(c), '_STR:1_' % (self.connector(c), self
    .connector(c)))
src_sent
for every c in self.children [ self . children ] . return string _STR:0_ , formated with self.connector [ self . connector ] and string created by joining c into a string , separated by _STR:1_ ,
hypothesis
return '_STR:0_' % ('_STR:1_'.join(c), '_STR:0_' % (self.connector, escape(c)))
src_sent
for every c in self.children [ self . children ] . define the method __repr__ with an argument self .
hypothesis
def __repr__(self):
    pass
src_sent
return string _STR:0_ , formated with self.__class__.__name__ [ self . __class__ . __name__ ] and self .
hypothesis
return '_STR:0_' % (self.__class__.__name__, self)
src_sent
define the method __deepcopy__ with 2 arguments : self and memodict .
hypothesis
def __deepcopy__(self, memodict):
    pass
src_sent
obj is an instance of Node class , created with 2 arguments : connector set to self.connector [ self . connector ] and negated set to self.negated [ self . negated ] .
hypothesis
obj = Node(connector=self.connector, negated=self.negated)
src_sent
substitute self.__class__ [ self . __class__ ] for obj.__class__ [ obj . __class__ ] .
hypothesis
obj.__class__ = self.__class__
src_sent
call the function copy.deepcopy [ copy . deepcopy ] with 2 arguments : self.children [ self . children ] and memodict , substitute the result for obj.children [ obj . children ] .
hypothesis
obj.children = copy.deepcopy(self.children, memodict)
src_sent
return obj .
hypothesis
return obj
src_sent
define the method __len__ with an argument self .
hypothesis
def __len__(self):
    pass
src_sent
return the length of self.children [ self . children ] .
hypothesis
return len(self.children)
src_sent
define the method __bool__ with an argument self .
hypothesis
def __bool__(self):
    pass
src_sent
convert self.children [ self . children ] into an boolean , return it .
hypothesis
return bool(self.children)
src_sent
define the method __nonzero__ with an argument self .
hypothesis
def __nonzero__(self):
    pass
src_sent
get the type of the self object , on the result call the __bool__ method with an argument self , return the result .
hypothesis
return type(self).__bool__(self)
src_sent
define the method __contains__ with 2 arguments : self and other .
hypothesis
def __contains__(self, other):
    pass
src_sent
if other is contained in self.children [ self . children ] , return boolean True , otherwise return boolean False .
hypothesis
return len(self.children) in self.children
src_sent
define the method _prepare_data with 2 arguments : self and data .
hypothesis
def _prepare_data(self, data):
    pass
src_sent
return data .
hypothesis
return data
src_sent
define the method add with 4 arguments : self , data , conn_type and squash set to boolean True .
hypothesis
def add(self, data, conn_type, squash=True):
    pass
src_sent
if data is contained in self.children [ self . children ] ,
hypothesis
if data in self.children:
    pass
src_sent
return data .
hypothesis
return data
src_sent
call the method self._prepare_data [ self . _prepare_data ] with an argument data , substitute the result for data .
hypothesis
data = self._prepare_data(data)
src_sent
if squash is false ,
hypothesis
if not squash:
    pass
src_sent
append data to self.children [ self . children ] .
hypothesis
self.children.append(data)
src_sent
return data .
hypothesis
return data
src_sent
if self.connector [ self . connector ] equals conn_type ,
hypothesis
if self.connector == conn_type:
    pass
src_sent
if data is instance of Node and data.negated [ data . negated ] is false , and if data.connector [ data . connector ] equals conn_type or length of data equals integer 1 ,
hypothesis
if isinstance(data, Node) and (not data.negated and len(data) == 1):
    pass
src_sent
extend self.children [ self . children ] list with data.children [ data . children ] .
hypothesis
self.children.extend(data.children)
src_sent
return self .
hypothesis
return self
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
append data to self.children [ self . children ] .
hypothesis
self.children.append(data)
src_sent
return data .
hypothesis
return data
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the method self._new_instance [ self . _new_instance ] with 3 arguments : self.children [ self . children ] , self.connector [ self . connector ] and self.negated [ self . negated ] , substitute the result for obj .
hypothesis
obj = self._new_instance(self.children, self.connector, self.negated)
src_sent
substitute conn_type for self.connector [ self . connector ] .
hypothesis
self.connector = conn_type
src_sent
self.children [ self . children ] is an list with 2 elements : obj and data .
hypothesis
self.children = [obj, data]
src_sent
return data .
hypothesis
return data
src_sent
define the method negate with an argument self .
hypothesis
def negate(self):
    pass
src_sent
invert self.negated [ self . negated ] .
hypothesis
self.negated.invert()
src_sent
from __future__ import unicode_literals into default name space .
hypothesis
from __future__ import unicode_literals
src_sent
from datetime import timedelta and tzinfo into default name space .
hypothesis
from datetime import timedelta, tzinfo
src_sent
import module time .
hypothesis
import time
src_sent
import module warnings .
hypothesis
import warnings
src_sent
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
hypothesis
from django.utils.deprecation import RemovedInDjango19Warning
src_sent
from django.utils.encoding [ django . utils . encoding ] import force_str , force_text and DEFAULT_LOCALE_ENCODING into default name space .
hypothesis
from django.utils.encoding import force_str, force_text, DEFAULT_LOCALE_ENCODING
src_sent
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_
hypothesis
warnings.warn('_STR:0_', RemovedInDjango19Warning, 2)
src_sent
_STR:0_ , RemovedInDjango19Warning and stacklevel set to 2. derive the class FixedOffset from the tzinfo base class .
hypothesis
class FixedOffset(tzinfo):
    pass
src_sent
define the method __init__ with 2 arguments : self and offset .
hypothesis
def __init__(self, offset):
    pass
src_sent
call the function warnings.warn [ warnings . warn ] with 2 arguments : _STR:0_
hypothesis
warnings.warn('_STR:0_', RemovedInDjango19Warning)
src_sent
_STR:0_ and RemovedInDjango19Warning . if offset is an instance of timedelta class ,
hypothesis
if isinstance(offset, timedelta):
    pass
src_sent
substitute offset for self.__offset [ self . __offset ] .
hypothesis
self.__offset = offset
src_sent
substitute self.__offset.seconds [ self . __offset . seconds ] for offset .
hypothesis
offset = self.__offset.seconds
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function timedelta with an argument minutes set to offset , substitute the result for self.__offset [ self . __offset ] .
hypothesis
self.__offset = timedelta(minutes=offset)
src_sent
if offset is lesser than integer 0 , sign is set to _STR:0_ , otherwise sign is _STR:1_ ,
hypothesis
sign = '_STR:0_' if offset < 0 else '_STR:0_'
src_sent
self.__name [ self . __name ] is a string _STR:0_ , replace %s with sign , _STR:1_ is replaced with absolute value of offset divided by 60 ,
hypothesis
self.__name = '_STR:0_' % (sign % sign)
src_sent
and placed into 2 character spaces , and _STR:0_ is replaced with reminder of the division of absolute offset by integer 60 , and placed into 2 character spaces . define the method __repr__ with an argument self .
hypothesis
def __repr__(self):
    pass
src_sent
return self.__name [ self . __name ] .
hypothesis
return self.__name
src_sent
define the method __getinitargs__ with an argument self .
hypothesis
def __getinitargs__(self):
    pass
src_sent
return a tuple with an element self.__offset [ self . __offset ] .
hypothesis
return self.__offset[self.__offset],
src_sent
define the method utcoffset with 2 arguments self and dt .
hypothesis
def utcoffset(self, dt):
    pass
src_sent
return self.__offset [ self . __offset ] .
hypothesis
return self.__offset
src_sent
define the method tzname with 2 arguments self and dt .
hypothesis
def tzname(self, dt):
    pass
src_sent
return self.__name [ self . __name ] .
hypothesis
return self.__name
src_sent
define the method dst with 2 arguments self and dt .
hypothesis
def dst(self, dt):
    pass
src_sent
call the function timedelta with an argument integer 0 , return the result .
hypothesis
return timedelta(0)
src_sent
derive the class LocalTimezone from the tzinfo base class .
hypothesis
class LocalTimezone(tzinfo):
    pass
src_sent
define the method __init__ with 2 arguments self and dt .
hypothesis
def __init__(self, dt):
    pass
src_sent
call the function warnings.warn [ warnings . warn ] with 2 arguments : string _STR:0_
hypothesis
warnings.warn('_STR:0_', RemovedInDjango19Warning)
src_sent
_STR:0_ and RemovedInDjango19Warning . call the method tzinfo.__init__ [ tzinfo . __init__ ] with an argument self .
hypothesis
tzinfo.__init__(self)
src_sent
substitute dt for self.__dt [ self . __dt ] .
hypothesis
self.__dt = dt
src_sent
call the method self.tzname [ self . tzname ] with an argument dt , substitute the result for self._tzname [ self . _tzname ] .
hypothesis
self._tzname = self.tzname(dt)
src_sent
define the method __repr__ with an argument self .
hypothesis
def __repr__(self):
    pass
src_sent
call the function force_str with an argument self._tzname [ self . _tzname ] , return the result .
hypothesis
return force_str(self._tzname)
src_sent
define the method __getinitargs__ with an argument self .
hypothesis
def __getinitargs__(self):
    pass
src_sent
return a tuple with an element self.__dt [ self . __dt ] .
hypothesis
return self.__dt[self.__dt],
src_sent
define the method utcoffset with 2 arguments self and dt .
hypothesis
def utcoffset(self, dt):
    pass
src_sent
call the nethod self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
hypothesis
if self._isdst(dt):
    pass
src_sent
call the function timedelta with an argument seconds as negative time.altzone [ time . altzone ] , return the result .
hypothesis
return timedelta(seconds=time.altzone)
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function timedelta with an argument seconds as negative time.timezone [ time . timezone ] , return the result .
hypothesis
return timedelta(seconds=time.timezone)
src_sent
define the method dst with 2 arguments self and dt .
hypothesis
def dst(self, dt):
    pass
src_sent
call the nethod self._isdst [ self . _isdst ] with an argument dt , if it evaluates to true ,
hypothesis
if self._isdst(dt):
    pass
src_sent
call the function timedelta with an argument seconds as negative time.timezone [ time . timezone ] , subtract the result from the result of the call ,
hypothesis
value = timedelta(seconds=time.timezone).subtract()
src_sent
to the function timedelta called with an argument seconds as negative time.altzone [ time . altzone ] , return the result . if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the function timedelta with an argument integer 0 , return the result .
hypothesis
return timedelta(0)
src_sent
define the method tzname with 2 arguments self and dt .
hypothesis
def tzname(self, dt):
    pass
src_sent
if dt is None is_dst is boolean False , otherwise call the method self._isdst [ self . _isdst ] with an argument dt , substitute the result for is_dst .
hypothesis
is_dst = False if dt is None else self._isdst(dt)
src_sent
try ,
hypothesis
if any():
    pass
src_sent
call the function force_text with 2 arguments : value under the is_dst key of the time.tzname [ time . tzname ] and DEFAULT_LOCALE_ENCODING ,
hypothesis
return force_text(time.tzname[is_dst], DEFAULT_LOCALE_ENCODING)
src_sent
return the result . if UnicodeDecodeError exception is caught ,
hypothesis
return UnicodeDecodeError
src_sent
return None .
hypothesis
return None
src_sent
define the method _isdst with 2 arguments self and dt .
hypothesis
def _isdst(self, dt):
    pass
src_sent
tt is an tuple with 9 elements : dt.year [ dt . year ] , dt.month [ dt . month ] , dt.day [ dt . day ] , dt.hour [ dt . hour ] , dt.minute [ dt . minute ] , dt.second [ dt . second ] , result of the function dt.weekday [ dt . weekday ] ,
hypothesis
tt = dt.year, dt.month, dt.day, dt.hour, dt.weekday(), dt.error_class()
src_sent
integer 0 and integer 0. try ,
hypothesis
dirs(0, (0)(0, 0.0) + 0.0)
src_sent
call the method time.mktime [ time . mktime ] with an argument tt , substitute the result for stamp .
hypothesis
stamp = time.mktime(tt)
src_sent
if OverflowError or ValueError exceptions are caught ,
hypothesis
if OverflowError:
    pass
src_sent
create a tuple out a tuple with an element integer 2037 and a list tt elements without the first element , substitute the result for tt .
hypothesis
tt = type((2037, tt[1:]))
src_sent
call the method time.mktime [ time . mktime ] with an argument tt , substitute the result for stamp .
hypothesis
stamp = time.mktime(tt)
src_sent
call the method time.localtime [ time . localtime ] with an argument stamp , substitute the result for tt .
hypothesis
tt = time.localtime(stamp)
src_sent
if tt.tm_isdst [ tt . tm_isdst ] is greater than intger 0 , return boolean True , otherwise return boolean False .
hypothesis
return tt.tm_isdst > 0
src_sent
from __future__ import absolute_import into default name space .
hypothesis
from __future__ import absolute_import
src_sent
import module warnings .
hypothesis
import warnings
src_sent
from django.utils.deprecation [ django . utils . deprecation ] import RemovedInDjango19Warning into default name space .
hypothesis
from django.utils.deprecation import RemovedInDjango19Warning
src_sent
call the function warnings.warn [ warnings . warn ] with 3 arguments : string _STR:0_ ,
hypothesis
warnings.warn('_STR:0_', RemovedInDjango19Warning, 2)
src_sent
RemovedInDjango19Warning and stacklevel as integer 2. try ,
hypothesis
def dummy():
    pass
src_sent
from unittest2 import everything .
hypothesis
from unittest2 import everything
src_sent
if ImportError exception is caught ,
hypothesis
if ImportError:
    pass
src_sent
from unittest import import everything .
hypothesis
from unittest import everything
src_sent
from __future__ import unicode_literals into default name space .
hypothesis
from __future__ import unicode_literals
src_sent
import module datetime .
hypothesis
import datetime
src_sent
import module os .
hypothesis
import os
src_sent
import module subprocess .
hypothesis
import subprocess
src_sent
define the function get_version with version set to None as argument .
hypothesis
def get_version(version=None):
    pass
src_sent
call the get_complete_version function with version as argument , store the result in version .
hypothesis
version = get_complete_version(version)
src_sent
call the get_major_version wit version as argument , store the result in major .
hypothesis
major = get_major_version(version)
src_sent
sub is an empty string .
hypothesis
sub = ''
src_sent
if fourth element of version equals to string _STR:0_ and fight element of version equals to integer 0 ,
hypothesis
if version[4] == '_STR:0_' and version[encoding] == 0:
    pass
src_sent
call the function get_git_changeset , store the result in git_changeset .
hypothesis
git_changeset = get_git_changeset()
src_sent
if git_changeset is true ,
hypothesis
if git_changeset:
    pass
src_sent
convert git_changeset to string , append it to the string _STR:0_ , replace it for sub .
hypothesis
sub.replace(str(git_changeset))
src_sent
otherwise if fourth element of version does not equals to _STR:0_ ,
hypothesis
if True:
    pass
elif version[4] != '_STR:0_':
    pass
src_sent
mapping is a dictionary with 3 initial entries : _STR:0_ for _STR:1_ , _STR:2_ for _STR:3_ and _STR:4_ for _STR:5_ .
hypothesis
mapping = {'_STR:1_': '_STR:0_', '_STR:3_': '_STR:2_', '_STR:4_': '_STR:4_'}
src_sent
use fourth element of version as a key to get the value from mapping dictionary , append to it fourth element of version converted to string , substitute it for sub .
hypothesis
sub = mapping[str(version)] + version[3]
src_sent
sum major and sub , return the result converted to string .
hypothesis
return major + sub
src_sent
define the function get_major_version with an argument version defaulting to None .
hypothesis
def get_major_version(version=None):
    pass
src_sent
call the get_complete_version with an argument version , store the result in version .
hypothesis
version = get_complete_version(version)
src_sent
assign integer 2 to parts if third element of version equals to zero , otherwise assign it integer 3 .
hypothesis
parts = zero if version[2] == zero else 3
src_sent
convert x into a string for every x in list of version elements up to the parts index , join the previous into a string separated by _STR:0_ , assign the result to major .
hypothesis
major = '_STR:0_'.join(x for x in version[:parts])
src_sent
return major .
hypothesis
return major
src_sent
define the function get_complete_version with in argument version , defaulting to None .
hypothesis
def get_complete_version(version=None):
    pass
src_sent
if version is None ,
hypothesis
if version is None:
    pass
src_sent
from django import VERSION as version into default name space .
hypothesis
from django import VERSION as version
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
if length of version does not equals to integer 5 , raise an exception .
hypothesis
assert len(version) == 5
src_sent
if fourth element of version does not equals to string _STR:0_ or _STR:1_ or _STR:2_ or _STR:3_ , raise an exception .
hypothesis
assert version[4] in ('_STR:0_', '_STR:1_', '_STR:2_')
src_sent
return version
hypothesis
return version
src_sent
define the function get_git_changeset .
hypothesis
def get_git_changeset():
    pass
src_sent
if get_git_changeset has an attribute _STR:0_ ,
hypothesis
if hasattr(get_git_changeset, '_STR:0_'):
    pass
src_sent
return get_git_changeset.cache [ get_git_changeset . cache ] .
hypothesis
return get_git_changeset.cache
src_sent
get the absolute path of the __file__ , repo_dir is name of the directory two leveles above it .
hypothesis
directory[3] = os.path.abspath(__file__)
src_sent
call the subprocess.Popen [ subprocess . Popen ] function with , _STR:0_ , stdout set to subprocess.PIPE [ subprocess . PIPE ] ,
hypothesis
d = subprocess.Popen('_STR:0_', stdout=subprocess.PIPE, app=connection.render)
src_sent
stderr set to subprocess.PIPE [ subprocess . PIPE ] , shell set to boolean True , cwd set to repo_dir and universal_newlines set to boolean True , as arguments , substitute the result for git_log . evaluate the method git_log.communicate [ git_log . communicate ] , substitute first element of the result for timestamp .
hypothesis
timestamp = git_log.communicate()[0]
src_sent
try
hypothesis
raise
src_sent
call the datetime.datetime.utcfromtimestamp [ datetime . datetime . utcfromtimestamp ] with timestamp converted to an integer as argument , substitute result for timestamp .
hypothesis
timestamp = datetime.datetime.utcfromtimestamp(int(timestamp))
src_sent
if ValueError exception is caught ,
hypothesis
raise ValueError
src_sent
changeset is None .
hypothesis
changeset = None
src_sent
if not ,
hypothesis
if True:
    pass
else:
    pass
src_sent
call the timestamp.strftime [ timestamp . strftime ] with string _STR:0_ as an argument , substitute the result for changeset .
hypothesis
changeset = timestamp.strftime('_STR:0_')
src_sent
substitute changeset for get_git_changeset.cache [ get_git_changeset . cache ] .
hypothesis
get_git_changeset.cache = changeset
src_sent
return changeset .
hypothesis
return changeset
src_sent
from xml.sax.saxutils [ xml . sax . saxutils ] import XMLGenerator into default name space .
hypothesis
from xml.sax.saxutils import XMLGenerator
src_sent
derive the class SimplerXMLGenerator form the XMLGenerator base class .
hypothesis
class SimplerXMLGenerator(XMLGenerator):
    pass
src_sent
define the method addQuickElement with 4 arguments : self , name , contents set to None and attrs set to None .
hypothesis
def addQuickElement(self, name, contents=None, attrs=None):
    pass
src_sent
if attrs is None ,
hypothesis
if attrs is None:
    pass
src_sent
attrs is an empty dictionary .
hypothesis
attrs = {}
src_sent
cal the method self.startElement [ self . startElement ] with 2 arguments : name and attrs .
hypothesis
self.startElement(name, attrs)
src_sent
if contents is not None ,
hypothesis
if contents is not None:
    pass
src_sent
call the method self.characters [ self . characters ] with an argument contents .
hypothesis
self.characters(contents)
src_sent
call the method self.endElement [ self . endElement ] with an argument name .
hypothesis
self.endElement(name)
