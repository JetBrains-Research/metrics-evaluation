[{"snippet": "def open_pathname(pathname, verbose=0): DCNL  DCSP try: DCNL DCSP  DCSP refno = Res.FSOpenResourceFile(pathname, u'', 1) DCNL DCSP except Res.Error as arg: DCNL DCSP  DCSP if (arg[0] != (-199)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP return refno DCNL DCSP pathname = _decode(pathname, verbose=verbose) DCNL DCSP refno = Res.FSOpenResourceFile(pathname, u'', 1)\n", "intent": "open a resource file given by pathname .\n", "question_id": 0}, {"snippet": "@control_command(args=[(u'task_name', text_t), (u'rate_limit', text_t)], signature=u'<task_name> DCSP <rate_limit DCSP (e.g., DCSP 5/s DCSP | DCSP 5/m DCSP | DCSP 5/h)>') DCNL def rate_limit(state, task_name, rate_limit, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP rate(rate_limit) DCNL DCSP except ValueError as exc: DCNL DCSP  DCSP return nok(u'Invalid DCSP rate DCSP limit DCSP string: DCSP {0!r}'.format(exc)) DCNL DCSP try: DCNL DCSP  DCSP state.app.tasks[task_name].rate_limit = rate_limit DCNL DCSP except KeyError: DCNL DCSP  DCSP logger.error(u'Rate DCSP limit DCSP attempt DCSP for DCSP unknown DCSP task DCSP %s', task_name, exc_info=True) DCNL DCSP  DCSP return nok(u'unknown DCSP task') DCNL DCSP state.consumer.reset_rate_limits() DCNL DCSP if (not rate_limit): DCNL DCSP  DCSP logger.info(u'Rate DCSP limits DCSP disabled DCSP for DCSP tasks DCSP of DCSP type DCSP %s', task_name) DCNL DCSP  DCSP return ok(u'rate DCSP limit DCSP disabled DCSP successfully') DCNL DCSP logger.info(u'New DCSP rate DCSP limit DCSP for DCSP tasks DCSP of DCSP type DCSP %s: DCSP %s.', task_name, rate_limit) DCNL DCSP return ok(u'new DCSP rate DCSP limit DCSP set DCSP successfully')\n", "intent": "tell worker(s) to modify the rate limit for a task by type .\n", "question_id": 1}, {"snippet": "def getPath(edges, pathIndexes, loop, z): DCNL  DCSP path = [] DCNL DCSP for pathIndexIndex in xrange(len(pathIndexes)): DCNL DCSP  DCSP pathIndex = pathIndexes[pathIndexIndex] DCNL DCSP  DCSP edge = edges[pathIndex] DCNL DCSP  DCSP carveIntersection = getCarveIntersectionFromEdge(edge, loop, z) DCNL DCSP  DCSP path.append(carveIntersection) DCNL DCSP return path\n", "intent": "get the path from the edge intersections .\n", "question_id": 2}, {"snippet": "def clips_array(array, rows_widths=None, cols_widths=None, bg_color=None): DCNL  DCSP array = np.array(array) DCNL DCSP sizes_array = np.array([[c.size for c in line] for line in array]) DCNL DCSP if (rows_widths is None): DCNL DCSP  DCSP rows_widths = sizes_array[:, :, 1].max(axis=1) DCNL DCSP if (cols_widths is None): DCNL DCSP  DCSP cols_widths = sizes_array[:, :, 0].max(axis=0) DCNL DCSP xx = np.cumsum(([0] + list(cols_widths))) DCNL DCSP yy = np.cumsum(([0] + list(rows_widths))) DCNL DCSP for (j, (x, cw)) in list(enumerate(zip(xx[:(-1)], cols_widths))): DCNL DCSP  DCSP for (i, (y, rw)) in list(enumerate(zip(yy[:(-1)], rows_widths))): DCNL DCSP  DCSP  DCSP clip = array[(i, j)] DCNL DCSP  DCSP  DCSP (w, h) = clip.size DCNL DCSP  DCSP  DCSP if ((w < cw) or (h < rw)): DCNL DCSP  DCSP  DCSP  DCSP clip = CompositeVideoClip([clip.set_pos('center')], size=(cw, rw), bg_color=bg_color).set_duration(clip.duration) DCNL DCSP  DCSP  DCSP array[(i, j)] = clip.set_pos((x, y)) DCNL DCSP return CompositeVideoClip(array.flatten(), size=(xx[(-1)], yy[(-1)]), bg_color=bg_color)\n", "intent": "rows_widths widths of the different rows in pixels .\n", "question_id": 3}, {"snippet": "def install_optimal_reactor(verbose=False): DCNL  DCSP log = txaio.make_logger() DCNL DCSP import sys DCNL DCSP from twisted.python import reflect DCNL DCSP if ('twisted.internet.reactor' in sys.modules): DCNL DCSP  DCSP current_reactor = reflect.qual(sys.modules['twisted.internet.reactor'].__class__).split('.')[(-1)] DCNL DCSP else: DCNL DCSP  DCSP current_reactor = None DCNL DCSP if (('bsd' in sys.platform) or sys.platform.startswith('darwin')): DCNL DCSP  DCSP if (current_reactor != 'KQueueReactor'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from twisted.internet import kqreactor DCNL DCSP  DCSP  DCSP  DCSP kqreactor.install() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP log.critical('Running DCSP on DCSP *BSD DCSP or DCSP MacOSX, DCSP but DCSP cannot DCSP install DCSP kqueue DCSP Twisted DCSP reactor') DCNL DCSP  DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP log.debug('Running DCSP on DCSP *BSD DCSP or DCSP MacOSX DCSP and DCSP optimal DCSP reactor DCSP (kqueue) DCSP was DCSP installed.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.debug('Running DCSP on DCSP *BSD DCSP or DCSP MacOSX DCSP and DCSP optimal DCSP reactor DCSP (kqueue) DCSP already DCSP installed.') DCNL DCSP elif (sys.platform in ['win32']): DCNL DCSP  DCSP if (current_reactor != 'IOCPReactor'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from twisted.internet.iocpreactor import reactor as iocpreactor DCNL DCSP  DCSP  DCSP  DCSP iocpreactor.install() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP log.critical('Running DCSP on DCSP Windows, DCSP but DCSP cannot DCSP install DCSP IOCP DCSP Twisted DCSP reactor') DCNL DCSP  DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP log.debug('Running DCSP on DCSP Windows DCSP and DCSP optimal DCSP reactor DCSP (ICOP) DCSP was DCSP installed.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.debug('Running DCSP on DCSP Windows DCSP and DCSP optimal DCSP reactor DCSP (ICOP) DCSP already DCSP installed.') DCNL DCSP elif sys.platform.startswith('linux'): DCNL DCSP  DCSP if (current_reactor != 'EPollReactor'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from twisted.internet import epollreactor DCNL DCSP  DCSP  DCSP  DCSP epollreactor.install() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP log.critical('Running DCSP on DCSP Linux, DCSP but DCSP cannot DCSP install DCSP Epoll DCSP Twisted DCSP reactor') DCNL DCSP  DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP log.debug('Running DCSP on DCSP Linux DCSP and DCSP optimal DCSP reactor DCSP (epoll) DCSP was DCSP installed.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.debug('Running DCSP on DCSP Linux DCSP and DCSP optimal DCSP reactor DCSP (epoll) DCSP already DCSP installed.') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from twisted.internet import default as defaultreactor DCNL DCSP  DCSP  DCSP defaultreactor.install() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP log.critical('Could DCSP not DCSP install DCSP default DCSP Twisted DCSP reactor DCSP for DCSP this DCSP platform') DCNL DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP from twisted.internet import reactor DCNL DCSP txaio.config.loop = reactor\n", "intent": "try to install the optimal twisted reactor for this platform .\n", "question_id": 4}, {"snippet": "def expandvars(path): DCNL  DCSP global _varprog DCNL DCSP if ('$' not in path): DCNL DCSP  DCSP return path DCNL DCSP if (not _varprog): DCNL DCSP  DCSP import re DCNL DCSP  DCSP _varprog = re.compile('\\\\$(\\\\w+|\\\\{[^}]*\\\\})') DCNL DCSP i = 0 DCNL DCSP while True: DCNL DCSP  DCSP m = _varprog.search(path, i) DCNL DCSP  DCSP if (not m): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (i, j) = m.span(0) DCNL DCSP  DCSP name = m.group(1) DCNL DCSP  DCSP if (name.startswith('{') and name.endswith('}')): DCNL DCSP  DCSP  DCSP name = name[1:(-1)] DCNL DCSP  DCSP if (name in os.environ): DCNL DCSP  DCSP  DCSP tail = path[j:] DCNL DCSP  DCSP  DCSP path = (path[:i] + os.environ[name]) DCNL DCSP  DCSP  DCSP i = len(path) DCNL DCSP  DCSP  DCSP path += tail DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i = j DCNL DCSP return path\n", "intent": "expand shell variables of form $var and ${var} .\n", "question_id": 5}, {"snippet": "def anderson(x, dist='norm'): DCNL  DCSP if (dist not in ['norm', 'expon', 'gumbel', 'gumbel_l', 'gumbel_r', 'extreme1', 'logistic']): DCNL DCSP  DCSP raise ValueError(\"Invalid DCSP distribution; DCSP dist DCSP must DCSP be DCSP 'norm', DCSP 'expon', DCSP 'gumbel', DCSP 'extreme1' DCSP or DCSP 'logistic'.\") DCNL DCSP y = sort(x) DCNL DCSP xbar = np.mean(x, axis=0) DCNL DCSP N = len(y) DCNL DCSP if (dist == 'norm'): DCNL DCSP  DCSP s = np.std(x, ddof=1, axis=0) DCNL DCSP  DCSP w = ((y - xbar) / s) DCNL DCSP  DCSP logcdf = distributions.norm.logcdf(w) DCNL DCSP  DCSP logsf = distributions.norm.logsf(w) DCNL DCSP  DCSP sig = array([15, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = around((_Avals_norm / ((1.0 + (4.0 / N)) - ((25.0 / N) / N))), 3) DCNL DCSP elif (dist == 'expon'): DCNL DCSP  DCSP w = (y / xbar) DCNL DCSP  DCSP logcdf = distributions.expon.logcdf(w) DCNL DCSP  DCSP logsf = distributions.expon.logsf(w) DCNL DCSP  DCSP sig = array([15, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = around((_Avals_expon / (1.0 + (0.6 / N))), 3) DCNL DCSP elif (dist == 'logistic'): DCNL DCSP  DCSP def rootfunc(ab, xj, N): DCNL DCSP  DCSP  DCSP (a, b) = ab DCNL DCSP  DCSP  DCSP tmp = ((xj - a) / b) DCNL DCSP  DCSP  DCSP tmp2 = exp(tmp) DCNL DCSP  DCSP  DCSP val = [(np.sum((1.0 / (1 + tmp2)), axis=0) - (0.5 * N)), (np.sum(((tmp * (1.0 - tmp2)) / (1 + tmp2)), axis=0) + N)] DCNL DCSP  DCSP  DCSP return array(val) DCNL DCSP  DCSP sol0 = array([xbar, np.std(x, ddof=1, axis=0)]) DCNL DCSP  DCSP sol = optimize.fsolve(rootfunc, sol0, args=(x, N), xtol=1e-05) DCNL DCSP  DCSP w = ((y - sol[0]) / sol[1]) DCNL DCSP  DCSP logcdf = distributions.logistic.logcdf(w) DCNL DCSP  DCSP logsf = distributions.logistic.logsf(w) DCNL DCSP  DCSP sig = array([25, 10, 5, 2.5, 1, 0.5]) DCNL DCSP  DCSP critical = around((_Avals_logistic / (1.0 + (0.25 / N))), 3) DCNL DCSP elif (dist == 'gumbel_r'): DCNL DCSP  DCSP (xbar, s) = distributions.gumbel_r.fit(x) DCNL DCSP  DCSP w = ((y - xbar) / s) DCNL DCSP  DCSP logcdf = distributions.gumbel_r.logcdf(w) DCNL DCSP  DCSP logsf = distributions.gumbel_r.logsf(w) DCNL DCSP  DCSP sig = array([25, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = around((_Avals_gumbel / (1.0 + (0.2 / sqrt(N)))), 3) DCNL DCSP else: DCNL DCSP  DCSP (xbar, s) = distributions.gumbel_l.fit(x) DCNL DCSP  DCSP w = ((y - xbar) / s) DCNL DCSP  DCSP logcdf = distributions.gumbel_l.logcdf(w) DCNL DCSP  DCSP logsf = distributions.gumbel_l.logsf(w) DCNL DCSP  DCSP sig = array([25, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = around((_Avals_gumbel / (1.0 + (0.2 / sqrt(N)))), 3) DCNL DCSP i = arange(1, (N + 1)) DCNL DCSP A2 = ((- N) - np.sum(((((2 * i) - 1.0) / N) * (logcdf + logsf[::(-1)])), axis=0)) DCNL DCSP return AndersonResult(A2, critical, sig)\n", "intent": "anderson-darling test for data coming from a particular distribution the anderson-darling test is a modification of the kolmogorov- smirnov test kstest for the null hypothesis that a sample is drawn from a population that follows a particular distribution .\n", "question_id": 6}, {"snippet": "def follow_link(connection, link): DCNL  DCSP if link: DCNL DCSP  DCSP return connection.follow_link(link) DCNL DCSP else: DCNL DCSP  DCSP return None\n", "intent": "this method returns the entity of the element which link points to .\n", "question_id": 7}, {"snippet": "@task DCNL def mongorestore(ctx, path, drop=False): DCNL  DCSP db = settings.DB_NAME DCNL DCSP port = settings.DB_PORT DCNL DCSP cmd = 'mongorestore DCSP --db DCSP {db} DCSP --port DCSP {port}'.format(db=db, port=port, pty=True) DCNL DCSP if settings.DB_USER: DCNL DCSP  DCSP cmd += ' DCSP --username DCSP {0}'.format(settings.DB_USER) DCNL DCSP if settings.DB_PASS: DCNL DCSP  DCSP cmd += ' DCSP --password DCSP {0}'.format(settings.DB_PASS) DCNL DCSP if drop: DCNL DCSP  DCSP cmd += ' DCSP --drop' DCNL DCSP cmd += (' DCSP ' + path) DCNL DCSP ctx.run(cmd, echo=True)\n", "intent": "restores the running osf database with the contents of the database at the location given its argument .\n", "question_id": 8}, {"snippet": "def test_hash(): DCNL  DCSP d0 = dict(a=dict(a=0.1, b='fo', c=1), b=[1, 'b'], c=(), d=np.ones(3), e=None) DCNL DCSP d0[1] = None DCNL DCSP d0[2.0] = '123' DCNL DCSP d1 = deepcopy(d0) DCNL DCSP assert_true((len(object_diff(d0, d1)) == 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) == 0)) DCNL DCSP assert_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1['data'] = np.ones(3, int) DCNL DCSP d1['d'][0] = 0 DCNL DCSP assert_not_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP assert_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1['a']['a'] = 0.11 DCNL DCSP assert_true((len(object_diff(d0, d1)) > 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) > 0)) DCNL DCSP assert_not_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP assert_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1['a']['d'] = 0 DCNL DCSP assert_true((len(object_diff(d0, d1)) > 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) > 0)) DCNL DCSP assert_not_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP assert_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1['b'].append(0) DCNL DCSP assert_true((len(object_diff(d0, d1)) > 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) > 0)) DCNL DCSP assert_not_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP assert_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1['e'] = 'foo' DCNL DCSP assert_true((len(object_diff(d0, d1)) > 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) > 0)) DCNL DCSP assert_not_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP d2 = deepcopy(d0) DCNL DCSP d1['e'] = StringIO() DCNL DCSP d2['e'] = StringIO() DCNL DCSP d2['e'].write('foo') DCNL DCSP assert_true((len(object_diff(d0, d1)) > 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) > 0)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP d1[1] = 2 DCNL DCSP assert_true((len(object_diff(d0, d1)) > 0)) DCNL DCSP assert_true((len(object_diff(d1, d0)) > 0)) DCNL DCSP assert_not_equal(object_hash(d0), object_hash(d1)) DCNL DCSP d1 = deepcopy(d0) DCNL DCSP d2 = deepcopy(d0) DCNL DCSP d1[1] = (x for x in d0) DCNL DCSP d2[1] = (x for x in d0) DCNL DCSP assert_raises(RuntimeError, object_diff, d1, d2) DCNL DCSP assert_raises(RuntimeError, object_hash, d1) DCNL DCSP x = sparse.eye(2, 2, format='csc') DCNL DCSP y = sparse.eye(2, 2, format='csr') DCNL DCSP assert_true(('type DCSP mismatch' in object_diff(x, y))) DCNL DCSP y = sparse.eye(2, 2, format='csc') DCNL DCSP assert_equal(len(object_diff(x, y)), 0) DCNL DCSP y[(1, 1)] = 2 DCNL DCSP assert_true(('elements' in object_diff(x, y))) DCNL DCSP y = sparse.eye(3, 3, format='csc') DCNL DCSP assert_true(('shape' in object_diff(x, y))) DCNL DCSP y = 0 DCNL DCSP assert_true(('type DCSP mismatch' in object_diff(x, y)))\n", "intent": "test dictionary hashing and comparison functions .\n", "question_id": 9}, {"snippet": "def CommandLine(args=None, arglist=None): DCNL  DCSP help_text = '\\nCommands:\\n\\ntrain DCSP - DCSP give DCSP size DCSP of DCSP training DCSP set DCSP to DCSP use, DCSP as DCSP argument\\npredict DCSP - DCSP give DCSP input DCSP sequence DCSP as DCSP argument DCSP (or DCSP specify DCSP inputs DCSP via DCSP --from-file DCSP <filename>)\\n\\n' DCNL DCSP parser = argparse.ArgumentParser(description=help_text, formatter_class=argparse.RawTextHelpFormatter) DCNL DCSP parser.add_argument('cmd', help='command') DCNL DCSP parser.add_argument('cmd_input', nargs='*', help='input DCSP to DCSP command') DCNL DCSP parser.add_argument('-v', '--verbose', nargs=0, help='increase DCSP output DCSP verbosity DCSP (add DCSP more DCSP -v DCSP to DCSP increase DCSP versbosity)', action=VAction, dest='verbose') DCNL DCSP parser.add_argument('-m', '--model', help='seq2seq DCSP model DCSP name: DCSP either DCSP embedding_rnn DCSP (default) DCSP or DCSP embedding_attention', default=None) DCNL DCSP parser.add_argument('-r', '--learning-rate', type=float, help='learning DCSP rate DCSP (default DCSP 0.0001)', default=0.0001) DCNL DCSP parser.add_argument('-e', '--epochs', type=int, help='number DCSP of DCSP trainig DCSP epochs', default=10) DCNL DCSP parser.add_argument('-i', '--input-weights', type=str, help='tflearn DCSP file DCSP with DCSP network DCSP weights DCSP to DCSP load', default=None) DCNL DCSP parser.add_argument('-o', '--output-weights', type=str, help='new DCSP tflearn DCSP file DCSP where DCSP network DCSP weights DCSP are DCSP to DCSP be DCSP saved', default=None) DCNL DCSP parser.add_argument('-p', '--pattern-name', type=str, help='name DCSP of DCSP pattern DCSP to DCSP use DCSP for DCSP sequence', default=None) DCNL DCSP parser.add_argument('-n', '--name', type=str, help='name DCSP of DCSP model, DCSP used DCSP when DCSP generating DCSP default DCSP weights DCSP filenames', default=None) DCNL DCSP parser.add_argument('--in-len', type=int, help='input DCSP sequence DCSP length DCSP (default DCSP 10)', default=None) DCNL DCSP parser.add_argument('--out-len', type=int, help='output DCSP sequence DCSP length DCSP (default DCSP 10)', default=None) DCNL DCSP parser.add_argument('--from-file', type=str, help='name DCSP of DCSP file DCSP to DCSP take DCSP input DCSP data DCSP sequences DCSP from DCSP (json DCSP format)', default=None) DCNL DCSP parser.add_argument('--iter-num', type=int, help='training DCSP iteration DCSP number; DCSP specify DCSP instead DCSP of DCSP input- DCSP or DCSP output-weights DCSP to DCSP use DCSP generated DCSP filenames', default=None) DCNL DCSP parser.add_argument('--data-dir', help='directory DCSP to DCSP use DCSP for DCSP storing DCSP checkpoints DCSP (also DCSP used DCSP when DCSP generating DCSP default DCSP weights DCSP filenames)', default=None) DCNL DCSP parser.add_argument('-L', '--num-layers', type=int, help='number DCSP of DCSP RNN DCSP layers DCSP to DCSP use DCSP in DCSP the DCSP model DCSP (default DCSP 1)', default=1) DCNL DCSP parser.add_argument('--cell-size', type=int, help='size DCSP of DCSP RNN DCSP cell DCSP to DCSP use DCSP (default DCSP 32)', default=32) DCNL DCSP parser.add_argument('--cell-type', type=str, help='type DCSP of DCSP RNN DCSP cell DCSP to DCSP use DCSP (default DCSP BasicLSTMCell)', default='BasicLSTMCell') DCNL DCSP parser.add_argument('--embedding-size', type=int, help='size DCSP of DCSP embedding DCSP to DCSP use DCSP (default DCSP 20)', default=20) DCNL DCSP parser.add_argument('--tensorboard-verbose', type=int, help='tensorboard DCSP verbosity DCSP level DCSP (default DCSP 0)', default=0) DCNL DCSP if (not args): DCNL DCSP  DCSP args = parser.parse_args(arglist) DCNL DCSP if (args.iter_num is not None): DCNL DCSP  DCSP args.input_weights = args.iter_num DCNL DCSP  DCSP args.output_weights = (args.iter_num + 1) DCNL DCSP model_params = dict(num_layers=args.num_layers, cell_size=args.cell_size, cell_type=args.cell_type, embedding_size=args.embedding_size, learning_rate=args.learning_rate, tensorboard_verbose=args.tensorboard_verbose) DCNL DCSP if (args.cmd == 'train'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP num_points = int(args.cmd_input[0]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Exception('Please DCSP specify DCSP the DCSP number DCSP of DCSP datapoints DCSP to DCSP use DCSP for DCSP training, DCSP as DCSP the DCSP first DCSP argument') DCNL DCSP  DCSP sp = SequencePattern(args.pattern_name, in_seq_len=args.in_len, out_seq_len=args.out_len) DCNL DCSP  DCSP ts2s = TFLearnSeq2Seq(sp, seq2seq_model=args.model, data_dir=args.data_dir, name=args.name, verbose=args.verbose) DCNL DCSP  DCSP ts2s.train(num_epochs=args.epochs, num_points=num_points, weights_output_fn=args.output_weights, weights_input_fn=args.input_weights, model_params=model_params) DCNL DCSP  DCSP return ts2s DCNL DCSP elif (args.cmd == 'predict'): DCNL DCSP  DCSP if args.from_file: DCNL DCSP  DCSP  DCSP inputs = json.loads(args.from_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP input_x = map(int, args.cmd_input) DCNL DCSP  DCSP  DCSP inputs = [input_x] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Exception('Please DCSP provide DCSP a DCSP space-delimited DCSP input DCSP sequence DCSP as DCSP the DCSP argument') DCNL DCSP  DCSP sp = SequencePattern(args.pattern_name, in_seq_len=args.in_len, out_seq_len=args.out_len) DCNL DCSP  DCSP ts2s = TFLearnSeq2Seq(sp, seq2seq_model=args.model, data_dir=args.data_dir, name=args.name, verbose=args.verbose) DCNL DCSP  DCSP results = [] DCNL DCSP  DCSP for x in inputs: DCNL DCSP  DCSP  DCSP (prediction, y) = ts2s.predict(x, weights_input_fn=args.input_weights, model_params=model_params) DCNL DCSP  DCSP  DCSP print(('==> DCSP For DCSP input DCSP %s, DCSP prediction=%s DCSP (expected=%s)' % (x, prediction, sp.generate_output_sequence(x)))) DCNL DCSP  DCSP  DCSP results.append([prediction, y]) DCNL DCSP  DCSP ts2s.prediction_results = results DCNL DCSP  DCSP return ts2s DCNL DCSP else: DCNL DCSP  DCSP print(('Unknown DCSP command DCSP %s' % args.cmd))\n", "intent": "main command line .\n", "question_id": 10}, {"snippet": "def withClass(classname, namespace=''): DCNL  DCSP classattr = (('%s:class' % namespace) if namespace else 'class') DCNL DCSP return withAttribute(**{classattr: classname})\n", "intent": "simplified version of c{l{withattribute}} when matching on a div class - made difficult because c{class} is a reserved word in python .\n", "question_id": 11}, {"snippet": "def isunauthenticated(f): DCNL  DCSP return getattr(f, 'unauthenticated', False)\n", "intent": "checks to see if the function is marked as not requiring authentication with the @unauthenticated decorator .\n", "question_id": 12}, {"snippet": "def has_change_path_cmd(sql): DCNL  DCSP return (u'set DCSP search_path' in sql.lower())\n", "intent": "determines if the search_path should be refreshed by checking if the sql has set search_path .\n", "question_id": 13}, {"snippet": "def get_reader(identity): DCNL  DCSP global FORMAT_READERS DCNL DCSP if (FORMAT_READERS is None): DCNL DCSP  DCSP _import_readers() DCNL DCSP return FORMAT_READERS.get(identity, None)\n", "intent": "returns none if no reader is found for the identity .\n", "question_id": 14}, {"snippet": "def serve_file(load, fnd): DCNL  DCSP if ('env' in load): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', \"Parameter DCSP 'env' DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen.\") DCNL DCSP  DCSP load.pop('env') DCNL DCSP ret = {'data': '', 'dest': ''} DCNL DCSP if (('path' not in load) or ('loc' not in load) or ('saltenv' not in load)): DCNL DCSP  DCSP return ret DCNL DCSP if (not fnd['path']): DCNL DCSP  DCSP return ret DCNL DCSP ret['dest'] = fnd['rel'] DCNL DCSP gzip = load.get('gzip', None) DCNL DCSP with salt.utils.fopen(os.path.normpath(fnd['path']), 'rb') as fp_: DCNL DCSP  DCSP fp_.seek(load['loc']) DCNL DCSP  DCSP data = fp_.read(__opts__['file_buffer_size']) DCNL DCSP  DCSP if (gzip and data): DCNL DCSP  DCSP  DCSP data = salt.utils.gzip_util.compress(data, gzip) DCNL DCSP  DCSP  DCSP ret['gzip'] = gzip DCNL DCSP  DCSP ret['data'] = data DCNL DCSP return ret\n", "intent": "return a chunk from a file based on the data received .\n", "question_id": 15}, {"snippet": "def get_data_files(dirs): DCNL  DCSP results = [] DCNL DCSP for directory in dirs: DCNL DCSP  DCSP for (root, dirs, files) in os.walk(directory): DCNL DCSP  DCSP  DCSP files = [os.path.join(root, file_) for file_ in files] DCNL DCSP  DCSP  DCSP results.append((root, files)) DCNL DCSP return results\n", "intent": "recursively include data directories .\n", "question_id": 16}, {"snippet": "def test_cnn_fit(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_equal(cnn.min_c_, 0) DCNL DCSP assert_equal(cnn.maj_c_, 2) DCNL DCSP assert_equal(cnn.stats_c_[0], 2) DCNL DCSP assert_equal(cnn.stats_c_[1], 6) DCNL DCSP assert_equal(cnn.stats_c_[2], 12)\n", "intent": "test the fitting method .\n", "question_id": 17}, {"snippet": "def check_classification_targets(y): DCNL  DCSP y_type = type_of_target(y) DCNL DCSP if (y_type not in ['binary', 'multiclass', 'multiclass-multioutput', 'multilabel-indicator', 'multilabel-sequences']): DCNL DCSP  DCSP raise ValueError(('Unknown DCSP label DCSP type: DCSP %r' % y_type))\n", "intent": "ensure that target y is of a non-regression type .\n", "question_id": 18}, {"snippet": "def get_qualifier(module): DCNL  DCSP qualifier = None DCNL DCSP if (module.params['version'] > 0): DCNL DCSP  DCSP qualifier = str(module.params['version']) DCNL DCSP elif module.params['alias']: DCNL DCSP  DCSP qualifier = str(module.params['alias']) DCNL DCSP return qualifier\n", "intent": "returns the function qualifier as a version or alias or none .\n", "question_id": 19}, {"snippet": "def nginx_restart(nginx_ctl, nginx_conf='/etc/nginx.conf'): DCNL  DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen([nginx_ctl, '-c', nginx_conf, '-s', 'reload'], stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP (stdout, stderr) = proc.communicate() DCNL DCSP  DCSP if (proc.returncode != 0): DCNL DCSP  DCSP  DCSP nginx_proc = subprocess.Popen([nginx_ctl, '-c', nginx_conf], stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP  DCSP (stdout, stderr) = nginx_proc.communicate() DCNL DCSP  DCSP  DCSP if (nginx_proc.returncode != 0): DCNL DCSP  DCSP  DCSP  DCSP raise errors.MisconfigurationError(('nginx DCSP restart DCSP failed:\\n%s\\n%s' % (stdout, stderr))) DCNL DCSP except (OSError, ValueError): DCNL DCSP  DCSP raise errors.MisconfigurationError('nginx DCSP restart DCSP failed') DCNL DCSP time.sleep(1)\n", "intent": "restarts the nginx server .\n", "question_id": 20}, {"snippet": "def validate_exps_in_collection_are_public(collection): DCNL  DCSP for exploration_id in collection.exploration_ids: DCNL DCSP  DCSP if rights_manager.is_exploration_private(exploration_id): DCNL DCSP  DCSP  DCSP raise utils.ValidationError(('Cannot DCSP reference DCSP a DCSP private DCSP exploration DCSP within DCSP a DCSP public DCSP collection, DCSP exploration DCSP ID: DCSP %s' % exploration_id))\n", "intent": "validates that explorations in a given collection are public .\n", "question_id": 21}, {"snippet": "def show(module): DCNL  DCSP ret = {} DCNL DCSP ret['name'] = module DCNL DCSP cmd = 'cpan DCSP -D DCSP {0}'.format(module) DCNL DCSP out = __salt__['cmd.run'](cmd).splitlines() DCNL DCSP mode = 'skip' DCNL DCSP info = [] DCNL DCSP for line in out: DCNL DCSP  DCSP if line.startswith('-------------'): DCNL DCSP  DCSP  DCSP mode = 'parse' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (mode == 'skip'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP info.append(line) DCNL DCSP if (len(info) == 6): DCNL DCSP  DCSP info.insert(2, '') DCNL DCSP if (len(info) < 6): DCNL DCSP  DCSP ret['error'] = 'This DCSP package DCSP does DCSP not DCSP seem DCSP to DCSP exist' DCNL DCSP  DCSP return ret DCNL DCSP ret['description'] = info[0].strip() DCNL DCSP ret['cpan DCSP file'] = info[1].strip() DCNL DCSP if info[2].strip(): DCNL DCSP  DCSP ret['installed DCSP file'] = info[2].strip() DCNL DCSP else: DCNL DCSP  DCSP ret['installed DCSP file'] = None DCNL DCSP comps = info[3].split(':') DCNL DCSP if (len(comps) > 1): DCNL DCSP  DCSP ret['installed DCSP version'] = comps[1].strip() DCNL DCSP if (('installed DCSP version' not in ret) or (not ret['installed DCSP version'])): DCNL DCSP  DCSP ret['installed DCSP version'] = None DCNL DCSP comps = info[4].split(':') DCNL DCSP comps = comps[1].split() DCNL DCSP ret['cpan DCSP version'] = comps[0].strip() DCNL DCSP ret['author DCSP name'] = info[5].strip() DCNL DCSP ret['author DCSP email'] = info[6].strip() DCNL DCSP config = show_config() DCNL DCSP build_dir = config.get('build_dir', None) DCNL DCSP if (build_dir is not None): DCNL DCSP  DCSP ret['cpan DCSP build DCSP dirs'] = [] DCNL DCSP  DCSP builds = os.listdir(build_dir) DCNL DCSP  DCSP pfile = module.replace('::', '-') DCNL DCSP  DCSP for file_ in builds: DCNL DCSP  DCSP  DCSP if file_.startswith(pfile): DCNL DCSP  DCSP  DCSP  DCSP ret['cpan DCSP build DCSP dirs'].append(os.path.join(build_dir, file_)) DCNL DCSP return ret\n", "intent": "show information about a specific perl module cli example: .\n", "question_id": 22}, {"snippet": "def deserialize_contributors(node, user_dicts, auth, validate=False): DCNL  DCSP contribs = [] DCNL DCSP for contrib_dict in user_dicts: DCNL DCSP  DCSP fullname = contrib_dict['fullname'] DCNL DCSP  DCSP visible = contrib_dict['visible'] DCNL DCSP  DCSP email = contrib_dict.get('email') DCNL DCSP  DCSP if (validate is True): DCNL DCSP  DCSP  DCSP fullname = sanitize.strip_html(fullname) DCNL DCSP  DCSP  DCSP if (not fullname): DCNL DCSP  DCSP  DCSP  DCSP raise ValidationValueError('Full DCSP name DCSP field DCSP cannot DCSP be DCSP empty') DCNL DCSP  DCSP  DCSP if email: DCNL DCSP  DCSP  DCSP  DCSP validate_email(email) DCNL DCSP  DCSP if contrib_dict['id']: DCNL DCSP  DCSP  DCSP contributor = User.load(contrib_dict['id']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP contributor = User.create_unregistered(fullname=fullname, email=email) DCNL DCSP  DCSP  DCSP  DCSP contributor.save() DCNL DCSP  DCSP  DCSP except ValidationError: DCNL DCSP  DCSP  DCSP  DCSP contributor = get_user(email=email) DCNL DCSP  DCSP if ((not contributor.is_registered) and (node._primary_key not in contributor.unclaimed_records)): DCNL DCSP  DCSP  DCSP contributor.add_unclaimed_record(node=node, referrer=auth.user, given_name=fullname, email=email) DCNL DCSP  DCSP  DCSP contributor.save() DCNL DCSP  DCSP contribs.append({'user': contributor, 'visible': visible, 'permissions': expand_permissions(contrib_dict.get('permission'))}) DCNL DCSP return contribs\n", "intent": "view helper that returns a list of user objects from a list of serialized users .\n", "question_id": 23}, {"snippet": "def package_relationship_create(context, data_dict): DCNL  DCSP model = context['model'] DCNL DCSP user = context['user'] DCNL DCSP schema = (context.get('schema') or ckan.logic.schema.default_create_relationship_schema()) DCNL DCSP api = context.get('api_version') DCNL DCSP ref_package_by = ('id' if (api == 2) else 'name') DCNL DCSP (id, id2, rel_type) = _get_or_bust(data_dict, ['subject', 'object', 'type']) DCNL DCSP comment = data_dict.get('comment', u'') DCNL DCSP pkg1 = model.Package.get(id) DCNL DCSP pkg2 = model.Package.get(id2) DCNL DCSP if (not pkg1): DCNL DCSP  DCSP raise NotFound(('Subject DCSP package DCSP %r DCSP was DCSP not DCSP found.' % id)) DCNL DCSP if (not pkg2): DCNL DCSP  DCSP return NotFound(('Object DCSP package DCSP %r DCSP was DCSP not DCSP found.' % id2)) DCNL DCSP (data, errors) = _validate(data_dict, schema, context) DCNL DCSP if errors: DCNL DCSP  DCSP model.Session.rollback() DCNL DCSP  DCSP raise ValidationError(errors) DCNL DCSP _check_access('package_relationship_create', context, data_dict) DCNL DCSP existing_rels = pkg1.get_relationships_with(pkg2, rel_type) DCNL DCSP if existing_rels: DCNL DCSP  DCSP return _update_package_relationship(existing_rels[0], comment, context) DCNL DCSP rev = model.repo.new_revision() DCNL DCSP rev.author = user DCNL DCSP rev.message = (_(u'REST DCSP API: DCSP Create DCSP package DCSP relationship: DCSP %s DCSP %s DCSP %s') % (pkg1, rel_type, pkg2)) DCNL DCSP rel = pkg1.add_relationship(rel_type, pkg2, comment=comment) DCNL DCSP if (not context.get('defer_commit')): DCNL DCSP  DCSP model.repo.commit_and_remove() DCNL DCSP context['relationship'] = rel DCNL DCSP relationship_dicts = rel.as_dict(ref_package_by=ref_package_by) DCNL DCSP return relationship_dicts\n", "intent": "create a relationship between two datasets .\n", "question_id": 24}, {"snippet": "def isAddedPointOnPathFree(path, pixelTable, point, pointIndex, width): DCNL  DCSP if ((pointIndex > 0) and (pointIndex < len(path))): DCNL DCSP  DCSP if isSharpCorner(path[(pointIndex - 1)], point, path[pointIndex]): DCNL DCSP  DCSP  DCSP return False DCNL DCSP pointIndexMinusOne = (pointIndex - 1) DCNL DCSP if (pointIndexMinusOne >= 0): DCNL DCSP  DCSP maskTable = {} DCNL DCSP  DCSP begin = path[pointIndexMinusOne] DCNL DCSP  DCSP if (pointIndex < len(path)): DCNL DCSP  DCSP  DCSP end = path[pointIndex] DCNL DCSP  DCSP  DCSP euclidean.addValueSegmentToPixelTable(begin, end, maskTable, None, width) DCNL DCSP  DCSP segmentTable = {} DCNL DCSP  DCSP euclidean.addSegmentToPixelTable(point, begin, segmentTable, 0.0, 2.0, width) DCNL DCSP  DCSP if euclidean.isPixelTableIntersecting(pixelTable, segmentTable, maskTable): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if isAddedPointOnPathIntersectingPath(begin, path, point, pointIndexMinusOne): DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (pointIndex < len(path)): DCNL DCSP  DCSP maskTable = {} DCNL DCSP  DCSP begin = path[pointIndex] DCNL DCSP  DCSP if (pointIndexMinusOne >= 0): DCNL DCSP  DCSP  DCSP end = path[pointIndexMinusOne] DCNL DCSP  DCSP  DCSP euclidean.addValueSegmentToPixelTable(begin, end, maskTable, None, width) DCNL DCSP  DCSP segmentTable = {} DCNL DCSP  DCSP euclidean.addSegmentToPixelTable(point, begin, segmentTable, 0.0, 2.0, width) DCNL DCSP  DCSP if euclidean.isPixelTableIntersecting(pixelTable, segmentTable, maskTable): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if isAddedPointOnPathIntersectingPath(begin, path, point, pointIndex): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True\n", "intent": "determine if the point added to a path is intersecting the pixel table or the path .\n", "question_id": 25}, {"snippet": "def record_magic(dct, magic_kind, magic_name, func): DCNL  DCSP if (magic_kind == 'line_cell'): DCNL DCSP  DCSP dct['line'][magic_name] = dct['cell'][magic_name] = func DCNL DCSP else: DCNL DCSP  DCSP dct[magic_kind][magic_name] = func\n", "intent": "utility function to store a function as a magic of a specific kind .\n", "question_id": 26}, {"snippet": "def shift_multi(x, wrg=0.1, hrg=0.1, is_random=False, row_index=0, col_index=1, channel_index=2, fill_mode='nearest', cval=0.0): DCNL  DCSP (h, w) = (x[0].shape[row_index], x[0].shape[col_index]) DCNL DCSP if is_random: DCNL DCSP  DCSP tx = (np.random.uniform((- hrg), hrg) * h) DCNL DCSP  DCSP ty = (np.random.uniform((- wrg), wrg) * w) DCNL DCSP else: DCNL DCSP  DCSP (tx, ty) = ((hrg * h), (wrg * w)) DCNL DCSP translation_matrix = np.array([[1, 0, tx], [0, 1, ty], [0, 0, 1]]) DCNL DCSP transform_matrix = translation_matrix DCNL DCSP results = [] DCNL DCSP for data in x: DCNL DCSP  DCSP results.append(apply_transform(data, transform_matrix, channel_index, fill_mode, cval)) DCNL DCSP return np.asarray(results)\n", "intent": "shift images with the same arguments .\n", "question_id": 27}, {"snippet": "def boxplot_stats(X, whis=1.5, bootstrap=None, labels=None, autorange=False): DCNL  DCSP def _bootstrap_median(data, N=5000): DCNL DCSP  DCSP M = len(data) DCNL DCSP  DCSP percentiles = [2.5, 97.5] DCNL DCSP  DCSP bs_index = np.random.randint(M, size=(N, M)) DCNL DCSP  DCSP bsData = data[bs_index] DCNL DCSP  DCSP estimate = np.median(bsData, axis=1, overwrite_input=True) DCNL DCSP  DCSP CI = np.percentile(estimate, percentiles) DCNL DCSP  DCSP return CI DCNL DCSP def _compute_conf_interval(data, med, iqr, bootstrap): DCNL DCSP  DCSP if (bootstrap is not None): DCNL DCSP  DCSP  DCSP CI = _bootstrap_median(data, N=bootstrap) DCNL DCSP  DCSP  DCSP notch_min = CI[0] DCNL DCSP  DCSP  DCSP notch_max = CI[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP N = len(data) DCNL DCSP  DCSP  DCSP notch_min = (med - ((1.57 * iqr) / np.sqrt(N))) DCNL DCSP  DCSP  DCSP notch_max = (med + ((1.57 * iqr) / np.sqrt(N))) DCNL DCSP  DCSP return (notch_min, notch_max) DCNL DCSP bxpstats = [] DCNL DCSP X = _reshape_2D(X) DCNL DCSP ncols = len(X) DCNL DCSP if (labels is None): DCNL DCSP  DCSP labels = repeat(None) DCNL DCSP elif (len(labels) != ncols): DCNL DCSP  DCSP raise ValueError(u'Dimensions DCSP of DCSP labels DCSP and DCSP X DCSP must DCSP be DCSP compatible') DCNL DCSP input_whis = whis DCNL DCSP for (ii, (x, label)) in enumerate(zip(X, labels), start=0): DCNL DCSP  DCSP stats = {} DCNL DCSP  DCSP if (label is not None): DCNL DCSP  DCSP  DCSP stats[u'label'] = label DCNL DCSP  DCSP whis = input_whis DCNL DCSP  DCSP bxpstats.append(stats) DCNL DCSP  DCSP if (len(x) == 0): DCNL DCSP  DCSP  DCSP stats[u'fliers'] = np.array([]) DCNL DCSP  DCSP  DCSP stats[u'mean'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'med'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'q1'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'q3'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'cilo'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'cihi'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'whislo'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'whishi'] = np.nan DCNL DCSP  DCSP  DCSP stats[u'med'] = np.nan DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP x = np.asarray(x) DCNL DCSP  DCSP stats[u'mean'] = np.mean(x) DCNL DCSP  DCSP (q1, med, q3) = np.percentile(x, [25, 50, 75]) DCNL DCSP  DCSP stats[u'iqr'] = (q3 - q1) DCNL DCSP  DCSP if ((stats[u'iqr'] == 0) and autorange): DCNL DCSP  DCSP  DCSP whis = u'range' DCNL DCSP  DCSP (stats[u'cilo'], stats[u'cihi']) = _compute_conf_interval(x, med, stats[u'iqr'], bootstrap) DCNL DCSP  DCSP if np.isscalar(whis): DCNL DCSP  DCSP  DCSP if np.isreal(whis): DCNL DCSP  DCSP  DCSP  DCSP loval = (q1 - (whis * stats[u'iqr'])) DCNL DCSP  DCSP  DCSP  DCSP hival = (q3 + (whis * stats[u'iqr'])) DCNL DCSP  DCSP  DCSP elif (whis in [u'range', u'limit', u'limits', u'min/max']): DCNL DCSP  DCSP  DCSP  DCSP loval = np.min(x) DCNL DCSP  DCSP  DCSP  DCSP hival = np.max(x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP whismsg = u'whis DCSP must DCSP be DCSP a DCSP float, DCSP valid DCSP string, DCSP or DCSP list DCSP of DCSP percentiles' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(whismsg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP loval = np.percentile(x, whis[0]) DCNL DCSP  DCSP  DCSP hival = np.percentile(x, whis[1]) DCNL DCSP  DCSP wiskhi = np.compress((x <= hival), x) DCNL DCSP  DCSP if ((len(wiskhi) == 0) or (np.max(wiskhi) < q3)): DCNL DCSP  DCSP  DCSP stats[u'whishi'] = q3 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stats[u'whishi'] = np.max(wiskhi) DCNL DCSP  DCSP wisklo = np.compress((x >= loval), x) DCNL DCSP  DCSP if ((len(wisklo) == 0) or (np.min(wisklo) > q1)): DCNL DCSP  DCSP  DCSP stats[u'whislo'] = q1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stats[u'whislo'] = np.min(wisklo) DCNL DCSP  DCSP stats[u'fliers'] = np.hstack([np.compress((x < stats[u'whislo']), x), np.compress((x > stats[u'whishi']), x)]) DCNL DCSP  DCSP (stats[u'q1'], stats[u'med'], stats[u'q3']) = (q1, med, q3) DCNL DCSP return bxpstats\n", "intent": "returns list of dictionaries of statistics used to draw a series of box and whisker plots .\n", "question_id": 28}, {"snippet": "def init_config(): DCNL  DCSP config = (os.path.dirname(__file__) + '/colorset/config') DCNL DCSP try: DCNL DCSP  DCSP data = load_config(config) DCNL DCSP  DCSP for d in data: DCNL DCSP  DCSP  DCSP c[d] = data[d] DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP rainbow_config = ((os.path.expanduser('~') + os.sep) + '.rainbow_config.json') DCNL DCSP try: DCNL DCSP  DCSP data = load_config(rainbow_config) DCNL DCSP  DCSP for d in data: DCNL DCSP  DCSP  DCSP c[d] = data[d] DCNL DCSP except (IOError, ValueError) as e: DCNL DCSP  DCSP c['USER_JSON_ERROR'] = str(e) DCNL DCSP theme_file = (((os.path.dirname(__file__) + '/colorset/') + c['THEME']) + '.json') DCNL DCSP try: DCNL DCSP  DCSP data = load_config(theme_file) DCNL DCSP  DCSP for d in data: DCNL DCSP  DCSP  DCSP c[d] = data[d] DCNL DCSP except: DCNL DCSP  DCSP pass\n", "intent": "init configuration .\n", "question_id": 29}, {"snippet": "def solve_sylvester(a, b, q): DCNL  DCSP (r, u) = schur(a, output='real') DCNL DCSP (s, v) = schur(b.conj().transpose(), output='real') DCNL DCSP f = np.dot(np.dot(u.conj().transpose(), q), v) DCNL DCSP (trsyl,) = get_lapack_funcs(('trsyl',), (r, s, f)) DCNL DCSP if (trsyl is None): DCNL DCSP  DCSP raise RuntimeError('LAPACK DCSP implementation DCSP does DCSP not DCSP contain DCSP a DCSP proper DCSP Sylvester DCSP equation DCSP solver DCSP (TRSYL)') DCNL DCSP (y, scale, info) = trsyl(r, s, f, tranb='C') DCNL DCSP y = (scale * y) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise LinAlgError(('Illegal DCSP value DCSP encountered DCSP in DCSP the DCSP %d DCSP term' % ((- info),))) DCNL DCSP return np.dot(np.dot(u, y), v.conj().transpose())\n", "intent": "computes a solution (x) to the sylvester equation :math:ax + xb = q .\n", "question_id": 30}, {"snippet": "def make_icindervolumemanager_tests(client_factory): DCNL  DCSP class Tests(ICinderVolumeManagerTestsMixin, TestCase, ): DCNL DCSP  DCSP def setUp(self): DCNL DCSP  DCSP  DCSP super(Tests, self).setUp() DCNL DCSP  DCSP  DCSP self.client = client_factory(test_case=self) DCNL DCSP return Tests\n", "intent": "build a testcase for verifying that an implementation of icindervolumemanager adheres to that interface .\n", "question_id": 31}, {"snippet": "def ebSentMessage(err): DCNL  DCSP err.printTraceback() DCNL DCSP reactor.stop()\n", "intent": "called if the message cannot be sent .\n", "question_id": 32}, {"snippet": "def crc_update(crc, data): DCNL  DCSP if ((type(data) != array.array) or (data.itemsize != 1)): DCNL DCSP  DCSP buf = array.array('B', data) DCNL DCSP else: DCNL DCSP  DCSP buf = data DCNL DCSP crc = (crc ^ _MASK) DCNL DCSP for b in buf: DCNL DCSP  DCSP table_index = ((crc ^ b) & 255) DCNL DCSP  DCSP crc = ((CRC_TABLE[table_index] ^ (crc >> 8)) & _MASK) DCNL DCSP return (crc ^ _MASK)\n", "intent": "update crc-32c checksum with data .\n", "question_id": 33}, {"snippet": "def is_datetimelike(data): DCNL  DCSP try: DCNL DCSP  DCSP maybe_to_datetimelike(data) DCNL DCSP  DCSP return True DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP return False\n", "intent": "return a boolean if we can be successfully converted to a datetimelike .\n", "question_id": 34}, {"snippet": "@tasklets.tasklet DCNL def delete_multi_async(blob_keys, **options): DCNL  DCSP if isinstance(blob_keys, (basestring, BlobKey)): DCNL DCSP  DCSP raise TypeError(('Expected DCSP a DCSP list, DCSP got DCSP %r' % (blob_key,))) DCNL DCSP rpc = blobstore.create_rpc(**options) DCNL DCSP (yield blobstore.delete_async(blob_keys, rpc=rpc))\n", "intent": "async version of delete_multi() .\n", "question_id": 35}, {"snippet": "def headers_url_generator(resp, fuzzable_req): DCNL  DCSP resp_headers = resp.get_headers() DCNL DCSP for (parser, header_names) in URL_HEADERS.iteritems(): DCNL DCSP  DCSP for header_name in header_names: DCNL DCSP  DCSP  DCSP (header_value, _) = resp_headers.iget(header_name, None) DCNL DCSP  DCSP  DCSP if (header_value is not None): DCNL DCSP  DCSP  DCSP  DCSP header_value = smart_unicode(header_value, encoding=resp.charset) DCNL DCSP  DCSP  DCSP  DCSP for ref in parser(resp, header_name, header_value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (ref, fuzzable_req, resp, False))\n", "intent": "yields tuples containing: * newly found url * the fuzzablerequest instance passed as parameter * the httpresponse generated by the fuzzablerequest * boolean indicating if we trust this reference or not the newly found urls are extracted from the http response headers such as \"location\" .\n", "question_id": 36}, {"snippet": "def get_ranges(headervalue, content_length): DCNL  DCSP if (not headervalue): DCNL DCSP  DCSP return None DCNL DCSP result = [] DCNL DCSP (bytesunit, byteranges) = headervalue.split('=', 1) DCNL DCSP for brange in byteranges.split(','): DCNL DCSP  DCSP (start, stop) = [x.strip() for x in brange.split('-', 1)] DCNL DCSP  DCSP if start: DCNL DCSP  DCSP  DCSP if (not stop): DCNL DCSP  DCSP  DCSP  DCSP stop = (content_length - 1) DCNL DCSP  DCSP  DCSP (start, stop) = (int(start), int(stop)) DCNL DCSP  DCSP  DCSP if (start >= content_length): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (stop < start): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result.append((start, (stop + 1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not stop): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP if (int(stop) > content_length): DCNL DCSP  DCSP  DCSP  DCSP result.append((0, content_length)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.append(((content_length - int(stop)), content_length)) DCNL DCSP return result\n", "intent": "return a list of  indices from a range header .\n", "question_id": 37}, {"snippet": "def _breakdown_point(n_samples, n_subsamples): DCNL  DCSP return (1 - (((((0.5 ** (1 / n_subsamples)) * ((n_samples - n_subsamples) + 1)) + n_subsamples) - 1) / n_samples))\n", "intent": "approximation of the breakdown point .\n", "question_id": 38}, {"snippet": "def brightness_state(value): DCNL  DCSP if (value.data > 0): DCNL DCSP  DCSP return (((value.data / 99) * 255), STATE_ON) DCNL DCSP else: DCNL DCSP  DCSP return (0, STATE_OFF)\n", "intent": "return the brightness and state .\n", "question_id": 39}, {"snippet": "@pytest.fixture DCNL def win_registry(): DCNL  DCSP helper = WinRegistryHelper() DCNL DCSP helper.add_window(0) DCNL DCSP (yield helper) DCNL DCSP helper.cleanup()\n", "intent": "fixture providing a window registry for win_id 0 and 1 .\n", "question_id": 40}, {"snippet": "def test_make_imbalance_2(): DCNL  DCSP (X_, y_) = make_imbalance(X, Y, ratio=0.25, min_c_=1) DCNL DCSP counter = Counter(y_) DCNL DCSP assert_equal(counter[0], 500) DCNL DCSP assert_equal(counter[1], 125) DCNL DCSP assert_true(np.all([(X_i in X) for X_i in X_]))\n", "intent": "test make_imbalance .\n", "question_id": 41}, {"snippet": "def merge_insert(ins_chunks, doc): DCNL  DCSP (unbalanced_start, balanced, unbalanced_end) = split_unbalanced(ins_chunks) DCNL DCSP doc.extend(unbalanced_start) DCNL DCSP if (doc and (not doc[(-1)].endswith(' DCSP '))): DCNL DCSP  DCSP doc[(-1)] += ' DCSP ' DCNL DCSP doc.append('<ins>') DCNL DCSP if (balanced and balanced[(-1)].endswith(' DCSP ')): DCNL DCSP  DCSP balanced[(-1)] = balanced[(-1)][:(-1)] DCNL DCSP doc.extend(balanced) DCNL DCSP doc.append('</ins> DCSP ') DCNL DCSP doc.extend(unbalanced_end)\n", "intent": "doc is the already-handled document ; here we add <ins>ins_chunks</ins> to the end of that .\n", "question_id": 42}, {"snippet": "def is_hex(value): DCNL  DCSP try: DCNL DCSP  DCSP int(value, 16) DCNL DCSP  DCSP return True DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return False\n", "intent": "returns true if value is a hexidecimal string .\n", "question_id": 43}, {"snippet": "def submit_rescore_problem_for_student(request, usage_key, student, only_if_higher=False): DCNL  DCSP check_arguments_for_rescoring(usage_key) DCNL DCSP task_type = ('rescore_problem_if_higher' if only_if_higher else 'rescore_problem') DCNL DCSP task_class = rescore_problem DCNL DCSP (task_input, task_key) = encode_problem_and_student_input(usage_key, student) DCNL DCSP task_input.update({'only_if_higher': only_if_higher}) DCNL DCSP return submit_task(request, task_type, task_class, usage_key.course_key, task_input, task_key)\n", "intent": "request a problem to be rescored as a background task .\n", "question_id": 44}, {"snippet": "def display(filename=''): DCNL  DCSP if (filename == ''): DCNL DCSP  DCSP displayFiles(getGCodeFilesWhichAreNotLogFiles()) DCNL DCSP  DCSP return DCNL DCSP displayFile(filename)\n", "intent": "parse a gcode file and display the commands .\n", "question_id": 45}, {"snippet": "def guess_repo(path=None): DCNL  DCSP global repodir DCNL DCSP if path: DCNL DCSP  DCSP repodir = path DCNL DCSP if (not repodir): DCNL DCSP  DCSP repodir = os.environ.get('BUP_DIR') DCNL DCSP  DCSP if (not repodir): DCNL DCSP  DCSP  DCSP repodir = os.path.expanduser('~/.bup')\n", "intent": "set the path value in the global variable \"repodir\" .\n", "question_id": 46}, {"snippet": "@assignment_tag(takes_context=True) DCNL def page_permissions(context, page): DCNL  DCSP if (u'user_page_permissions' not in context): DCNL DCSP  DCSP context[u'user_page_permissions'] = UserPagePermissionsProxy(context[u'request'].user) DCNL DCSP return context[u'user_page_permissions'].for_page(page)\n", "intent": "usage: {% page_permissions page as page_perms %} sets the variable page_perms to a pagepermissiontester object that can be queried to find out what actions the current logged-in user can perform on the given page .\n", "question_id": 47}, {"snippet": "def get_normalized_file_path(file_path): DCNL  DCSP if hasattr(sys, 'frozen'): DCNL DCSP  DCSP file_path = ('logging%s__init__%s' % (os.sep, file_path[(-4):])) DCNL DCSP elif (file_path[(-4):].lower() in ['.pyc', '.pyo']): DCNL DCSP  DCSP file_path = (file_path[:(-4)] + '.py') DCNL DCSP else: DCNL DCSP  DCSP file_path = file_path DCNL DCSP file_path = os.path.normcase(file_path) DCNL DCSP return file_path\n", "intent": "return a full normalized file path for the provided path string .\n", "question_id": 48}, {"snippet": "def matchmark(colitem, markexpr): DCNL  DCSP return eval(markexpr, {}, MarkMapping(colitem.keywords))\n", "intent": "tries to match on any marker names .\n", "question_id": 49}, {"snippet": "def _embl_convert_fasta(in_handle, out_handle, alphabet=None): DCNL  DCSP from Bio.GenBank.Scanner import EmblScanner DCNL DCSP records = EmblScanner().parse_records(in_handle, do_features=False) DCNL DCSP return SeqIO.write(records, out_handle, 'fasta')\n", "intent": "fast embl to fasta .\n", "question_id": 50}, {"snippet": "def lookupNameservers(name, timeout=None): DCNL  DCSP return getResolver().lookupNameservers(name, timeout)\n", "intent": "perform an ns record lookup .\n", "question_id": 51}, {"snippet": "def stop(name, call=None): DCNL  DCSP datacenter_id = get_datacenter_id() DCNL DCSP conn = get_conn() DCNL DCSP node = get_node(conn, name) DCNL DCSP conn.stop_server(datacenter_id=datacenter_id, server_id=node['id']) DCNL DCSP return True\n", "intent": "stop a machine by name .\n", "question_id": 52}, {"snippet": "def textDiff(a, b): DCNL  DCSP out = [] DCNL DCSP (a, b) = (html2list(a), html2list(b)) DCNL DCSP s = difflib.SequenceMatcher(None, a, b) DCNL DCSP for e in s.get_opcodes(): DCNL DCSP  DCSP if (e[0] == 'replace'): DCNL DCSP  DCSP  DCSP out.append((((('<del>' + ''.join(a[e[1]:e[2]])) + '</del><ins>') + ''.join(b[e[3]:e[4]])) + '</ins>')) DCNL DCSP  DCSP elif (e[0] == 'delete'): DCNL DCSP  DCSP  DCSP out.append((('<del DCSP >' + ''.join(a[e[1]:e[2]])) + '</del>')) DCNL DCSP  DCSP elif (e[0] == 'insert'): DCNL DCSP  DCSP  DCSP out.append((('<ins DCSP >' + ''.join(b[e[3]:e[4]])) + '</ins>')) DCNL DCSP  DCSP elif (e[0] == 'equal'): DCNL DCSP  DCSP  DCSP out.append(''.join(b[e[3]:e[4]])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ((\"Um, DCSP something's DCSP broken. DCSP I DCSP didn't DCSP expect DCSP a DCSP '\" + `e[0]`) + \"'.\") DCNL DCSP return ''.join(out)\n", "intent": "takes in strings a and b and returns a human-readable html diff .\n", "question_id": 53}, {"snippet": "def zero_one_loss(y_true, y_pred, normalize=True, sample_weight=None): DCNL  DCSP score = accuracy_score(y_true, y_pred, normalize=normalize, sample_weight=sample_weight) DCNL DCSP if normalize: DCNL DCSP  DCSP return (1 - score) DCNL DCSP else: DCNL DCSP  DCSP if (sample_weight is not None): DCNL DCSP  DCSP  DCSP n_samples = np.sum(sample_weight) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n_samples = _num_samples(y_true) DCNL DCSP  DCSP return (n_samples - score)\n", "intent": "zero-one classification loss .\n", "question_id": 54}, {"snippet": "@register.tag DCNL def annotate_form_field(parser, token): DCNL  DCSP args = token.split_contents() DCNL DCSP if (len(args) < 2): DCNL DCSP  DCSP raise template.TemplateSyntaxError('annotate_form_field DCSP tag DCSP requires DCSP a DCSP form DCSP field DCSP to DCSP be DCSP passed') DCNL DCSP return FormFieldNode(args[1])\n", "intent": "set an attribute on a form field with the widget type this means templates can use the widget type to render things differently if they want to .\n", "question_id": 55}, {"snippet": "def setup_axes1(fig, rect): DCNL  DCSP tr = Affine2D().scale(2, 1).rotate_deg(30) DCNL DCSP grid_helper = floating_axes.GridHelperCurveLinear(tr, extremes=((-0.5), 3.5, 0, 4)) DCNL DCSP ax1 = floating_axes.FloatingSubplot(fig, rect, grid_helper=grid_helper) DCNL DCSP fig.add_subplot(ax1) DCNL DCSP aux_ax = ax1.get_aux_axes(tr) DCNL DCSP grid_helper.grid_finder.grid_locator1._nbins = 4 DCNL DCSP grid_helper.grid_finder.grid_locator2._nbins = 4 DCNL DCSP return (ax1, aux_ax)\n", "intent": "a simple one .\n", "question_id": 56}, {"snippet": "def _should_retry_response(resp_status, content): DCNL  DCSP if (resp_status >= 500): DCNL DCSP  DCSP return True DCNL DCSP if (resp_status == _TOO_MANY_REQUESTS): DCNL DCSP  DCSP return True DCNL DCSP if (resp_status == six.moves.http_client.FORBIDDEN): DCNL DCSP  DCSP if (not content): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = json.loads(content.decode('utf-8')) DCNL DCSP  DCSP  DCSP reason = data['error']['errors'][0]['reason'] DCNL DCSP  DCSP except (UnicodeDecodeError, ValueError, KeyError): DCNL DCSP  DCSP  DCSP LOGGER.warning('Invalid DCSP JSON DCSP content DCSP from DCSP response: DCSP %s', content) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP LOGGER.warning('Encountered DCSP 403 DCSP Forbidden DCSP with DCSP reason DCSP \"%s\"', reason) DCNL DCSP  DCSP if (reason in ('userRateLimitExceeded', 'rateLimitExceeded')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "determines whether a response should be retried .\n", "question_id": 57}, {"snippet": "@require_context DCNL def virtual_interface_delete_by_instance(context, instance_uuid): DCNL  DCSP _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).delete()\n", "intent": "delete virtual interface records that are associated with the instance given by instance_id .\n", "question_id": 58}, {"snippet": "def files_with_suffix(base_path, suffix): DCNL  DCSP if os.path.isfile(base_path): DCNL DCSP  DCSP if base_path.endswith(suffix): DCNL DCSP  DCSP  DCSP (yield base_path) DCNL DCSP else: DCNL DCSP  DCSP for (root, _, files) in os.walk(base_path): DCNL DCSP  DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP  DCSP if filename.endswith(suffix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield os.path.join(root, filename))\n", "intent": "iterates over files in a given directory .\n", "question_id": 59}, {"snippet": "def assert_same_dict(data, expected_data): DCNL  DCSP diffs = diff_dicts(data, expected_data) DCNL DCSP if diffs: DCNL DCSP  DCSP raise DiffAssertionError(diffs)\n", "intent": "asserts two dicts are the same .\n", "question_id": 60}, {"snippet": "@skip('silverlight') DCNL @skip('netstandard') DCNL def test_xequals_call_for_optimization(): DCNL  DCSP import clr DCNL DCSP clr.AddReference('System.Configuration') DCNL DCSP from System.Configuration import ConfigurationManager DCNL DCSP c = ConfigurationManager.ConnectionStrings DCNL DCSP for i in xrange(3): DCNL DCSP  DCSP if is_posix: DCNL DCSP  DCSP  DCSP AreEqual(2, c.Count) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP AreEqual(1, c.Count) DCNL DCSP for i in xrange(3): DCNL DCSP  DCSP count = c.Count DCNL DCSP  DCSP if is_posix: DCNL DCSP  DCSP  DCSP AreEqual(2, count) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP AreEqual(1, count) DCNL DCSP  DCSP AreEqual(c.Count, count) DCNL DCSP for i in xrange(3): DCNL DCSP  DCSP c[0].Name DCNL DCSP c.Count DCNL DCSP c.Count\n", "intent": "testing specifically for system .\n", "question_id": 61}, {"snippet": "@set_database DCNL def get_download_youtube_ids(paths=None, downloaded=False, **kwargs): DCNL  DCSP if paths: DCNL DCSP  DCSP youtube_ids = dict() DCNL DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP selector = (((Item.kind != 'Topic') & Item.path.contains(path)) & Item.youtube_id.is_null(False)) DCNL DCSP  DCSP  DCSP if downloaded: DCNL DCSP  DCSP  DCSP  DCSP selector &= (Item.files_complete > 0) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP selector &= (Item.files_complete == 0) DCNL DCSP  DCSP  DCSP youtube_ids.update(dict([item for item in Item.select(Item.youtube_id, Item.title).where(selector).tuples() if item[0]])) DCNL DCSP  DCSP return youtube_ids\n", "intent": "convenience function for taking a list of content ids and returning all associated youtube_ids for downloads .\n", "question_id": 62}, {"snippet": "def runmodule(name='__main__', **kw): DCNL  DCSP main(defaultTest=name, **kw)\n", "intent": "collect and run tests in a single module only .\n", "question_id": 63}, {"snippet": "@with_setup(prepare_stdout) DCNL def test_output_with_success_colorless(): DCNL  DCSP runner = Runner(join(abspath(dirname(__file__)), 'output_features', 'many_successful_scenarios'), verbosity=3, no_color=True) DCNL DCSP runner.run() DCNL DCSP assert_stdout_lines('\\nFeature: DCSP Dumb DCSP feature DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/first.feature:1\\n DCSP  DCSP In DCSP order DCSP to DCSP test DCSP success DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/first.feature:2\\n DCSP  DCSP As DCSP a DCSP programmer DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/first.feature:3\\n DCSP  DCSP I DCSP want DCSP to DCSP see DCSP that DCSP the DCSP output DCSP is DCSP green DCSP # DCSP tests/functional/output_features/many_successful_scenarios/first.feature:4\\n\\n DCSP  DCSP Scenario: DCSP Do DCSP nothing DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/first.feature:6\\n DCSP  DCSP  DCSP  DCSP Given DCSP I DCSP do DCSP nothing DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/dumb_steps.py:6\\n\\n DCSP  DCSP Scenario: DCSP Do DCSP nothing DCSP (again) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/first.feature:9\\n DCSP  DCSP  DCSP  DCSP Given DCSP I DCSP do DCSP nothing DCSP (again) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/output_features/many_successful_scenarios/dumb_steps.py:6\\n\\n1 DCSP feature DCSP (1 DCSP passed)\\n2 DCSP scenarios DCSP (2 DCSP passed)\\n2 DCSP steps DCSP (2 DCSP passed)\\n')\n", "intent": "a feature with two scenarios should separate the two scenarios with a new line .\n", "question_id": 64}, {"snippet": "def p_field_id(p): DCNL  DCSP p[0] = p[1]\n", "intent": "field_id : intconstant : .\n", "question_id": 65}, {"snippet": "def default(ruby=None, runas=None): DCNL  DCSP if ruby: DCNL DCSP  DCSP _rbenv_exec(['global', ruby], runas=runas) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP ret = _rbenv_exec(['global'], runas=runas) DCNL DCSP  DCSP return ('' if (ret is False) else ret.strip())\n", "intent": "returns or sets the currently defined default ruby ruby the version to set as the default .\n", "question_id": 66}, {"snippet": "def list_apps(): DCNL  DCSP if ((not request.vars.username) or (not request.vars.password)): DCNL DCSP  DCSP raise HTTP(400) DCNL DCSP client = ServerProxy(('https://%(username)s:%(password)s@%(username)s.pythonanywhere.com/admin/webservices/call/jsonrpc' % request.vars)) DCNL DCSP regex = re.compile('^\\\\w+$') DCNL DCSP local = [f for f in os.listdir(apath(r=request)) if regex.match(f)] DCNL DCSP try: DCNL DCSP  DCSP pythonanywhere = client.list_apps() DCNL DCSP except ProtocolError as error: DCNL DCSP  DCSP raise HTTP(error.errcode) DCNL DCSP return response.json({'local': local, 'pythonanywhere': pythonanywhere})\n", "intent": "get a list of apps both remote and local .\n", "question_id": 67}, {"snippet": "def create_upload_url(success_path, max_bytes_per_blob=None, max_bytes_total=None, **options): DCNL  DCSP fut = create_upload_url_async(success_path, max_bytes_per_blob=max_bytes_per_blob, max_bytes_total=max_bytes_total, **options) DCNL DCSP return fut.get_result()\n", "intent": "create upload url for post form .\n", "question_id": 68}, {"snippet": "def wrap_with_safe_string(value, no_wrap_classes=None): DCNL  DCSP def __do_wrap(value): DCNL DCSP  DCSP if isinstance(value, SafeStringWrapper): DCNL DCSP  DCSP  DCSP return value DCNL DCSP  DCSP if isinstance(value, collections.Callable): DCNL DCSP  DCSP  DCSP safe_class = CallableSafeStringWrapper DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP safe_class = SafeStringWrapper DCNL DCSP  DCSP if isinstance(value, no_wrap_classes): DCNL DCSP  DCSP  DCSP return value DCNL DCSP  DCSP if isinstance(value, __DONT_WRAP_TYPES__): DCNL DCSP  DCSP  DCSP return sanitize_lists_to_string(value, valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP) DCNL DCSP  DCSP if isinstance(value, __WRAP_NO_SUBCLASS__): DCNL DCSP  DCSP  DCSP return safe_class(value, safe_string_wrapper_function=__do_wrap) DCNL DCSP  DCSP for this_type in (__WRAP_SEQUENCES__ + __WRAP_SETS__): DCNL DCSP  DCSP  DCSP if isinstance(value, this_type): DCNL DCSP  DCSP  DCSP  DCSP return this_type(map(__do_wrap, value)) DCNL DCSP  DCSP for this_type in __WRAP_MAPPINGS__: DCNL DCSP  DCSP  DCSP if isinstance(value, this_type): DCNL DCSP  DCSP  DCSP  DCSP return this_type(((__do_wrap(x[0]), __do_wrap(x[1])) for x in value.items())) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wrapped_class_name = value.__name__ DCNL DCSP  DCSP  DCSP wrapped_class = value DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP wrapped_class_name = value.__class__.__name__ DCNL DCSP  DCSP  DCSP wrapped_class = value.__class__ DCNL DCSP  DCSP value_mod = inspect.getmodule(value) DCNL DCSP  DCSP if value_mod: DCNL DCSP  DCSP  DCSP wrapped_class_name = ('%s.%s' % (value_mod.__name__, wrapped_class_name)) DCNL DCSP  DCSP wrapped_class_name = ('SafeStringWrapper(%s:%s)' % (wrapped_class_name, ','.join(sorted(map(str, no_wrap_classes))))) DCNL DCSP  DCSP do_wrap_func_name = ('__do_wrap_%s' % wrapped_class_name) DCNL DCSP  DCSP do_wrap_func = __do_wrap DCNL DCSP  DCSP global_dict = globals() DCNL DCSP  DCSP if (wrapped_class_name in global_dict): DCNL DCSP  DCSP  DCSP wrapped_class = global_dict.get(wrapped_class_name) DCNL DCSP  DCSP  DCSP do_wrap_func = global_dict.get(do_wrap_func_name, __do_wrap) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP wrapped_class = type(wrapped_class_name, (safe_class, wrapped_class), {}) DCNL DCSP  DCSP  DCSP except TypeError as e: DCNL DCSP  DCSP  DCSP  DCSP log.warning('Unable DCSP to DCSP create DCSP dynamic DCSP subclass DCSP for DCSP %s, DCSP %s: DCSP %s', type(value), value, e) DCNL DCSP  DCSP  DCSP  DCSP wrapped_class = type(wrapped_class_name, (safe_class,), {}) DCNL DCSP  DCSP  DCSP if (wrapped_class not in (SafeStringWrapper, CallableSafeStringWrapper)): DCNL DCSP  DCSP  DCSP  DCSP global_dict[wrapped_class_name] = wrapped_class DCNL DCSP  DCSP  DCSP  DCSP do_wrap_func.__name__ = do_wrap_func_name DCNL DCSP  DCSP  DCSP  DCSP global_dict[do_wrap_func_name] = do_wrap_func DCNL DCSP  DCSP  DCSP  DCSP def pickle_safe_object(safe_object): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (wrapped_class, (safe_object.unsanitized, do_wrap_func)) DCNL DCSP  DCSP  DCSP  DCSP copy_reg.pickle(wrapped_class, pickle_safe_object, do_wrap_func) DCNL DCSP  DCSP return wrapped_class(value, safe_string_wrapper_function=do_wrap_func) DCNL DCSP if no_wrap_classes: DCNL DCSP  DCSP if (not isinstance(no_wrap_classes, (tuple, list))): DCNL DCSP  DCSP  DCSP no_wrap_classes = [no_wrap_classes] DCNL DCSP  DCSP no_wrap_classes = ((list(no_wrap_classes) + list(__DONT_SANITIZE_TYPES__)) + [SafeStringWrapper]) DCNL DCSP else: DCNL DCSP  DCSP no_wrap_classes = (list(__DONT_SANITIZE_TYPES__) + [SafeStringWrapper]) DCNL DCSP no_wrap_classes = tuple(set(sorted(no_wrap_classes, key=str))) DCNL DCSP return __do_wrap(value)\n", "intent": "recursively wrap values that should be wrapped .\n", "question_id": 69}, {"snippet": "def reboot(zone, single=False, altinit=None, smf_options=None): DCNL  DCSP ret = {'status': True} DCNL DCSP boot_options = '' DCNL DCSP if single: DCNL DCSP  DCSP boot_options = '-s DCSP {0}'.format(boot_options) DCNL DCSP if altinit: DCNL DCSP  DCSP boot_options = '-i DCSP {0} DCSP {1}'.format(altinit, boot_options) DCNL DCSP if smf_options: DCNL DCSP  DCSP boot_options = '-m DCSP {0} DCSP {1}'.format(smf_options, boot_options) DCNL DCSP if (boot_options != ''): DCNL DCSP  DCSP boot_options = ' DCSP -- DCSP {0}'.format(boot_options.strip()) DCNL DCSP res = __salt__['cmd.run_all']('zoneadm DCSP {zone} DCSP reboot{boot_opts}'.format(zone=('-u DCSP {0}'.format(zone) if _is_uuid(zone) else '-z DCSP {0}'.format(zone)), boot_opts=boot_options)) DCNL DCSP ret['status'] = (res['retcode'] == 0) DCNL DCSP ret['message'] = (res['stdout'] if ret['status'] else res['stderr']) DCNL DCSP ret['message'] = ret['message'].replace('zoneadm: DCSP ', '') DCNL DCSP if (ret['message'] == ''): DCNL DCSP  DCSP del ret['message'] DCNL DCSP return ret\n", "intent": "restart the zone .\n", "question_id": 70}, {"snippet": "def CreateCGate(name, latexname=None): DCNL  DCSP if (not latexname): DCNL DCSP  DCSP latexname = name DCNL DCSP onequbitgate = CreateOneQubitGate(name, latexname) DCNL DCSP def ControlledGate(ctrls, target): DCNL DCSP  DCSP return CGate(tuple(ctrls), onequbitgate(target)) DCNL DCSP return ControlledGate\n", "intent": "use a lexical closure to make a controlled gate .\n", "question_id": 71}, {"snippet": "def main(): DCNL  DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP writeOutput(' DCSP '.join(sys.argv[1:])) DCNL DCSP else: DCNL DCSP  DCSP settings.startMainLoopFromConstructor(getNewRepository())\n", "intent": "display the outset dialog .\n", "question_id": 72}, {"snippet": "@treeio_login_required DCNL def widget_index(request, response_format='html'): DCNL  DCSP tickets = Object.filter_by_request(request, Ticket.objects.filter(status__hidden=False)) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'tickets': tickets}) DCNL DCSP return render_to_response('services/widgets/index', context, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "all active tickets .\n", "question_id": 73}, {"snippet": "def residplot(x, y, data=None, lowess=False, x_partial=None, y_partial=None, order=1, robust=False, dropna=True, label=None, color=None, scatter_kws=None, line_kws=None, ax=None): DCNL  DCSP plotter = _RegressionPlotter(x, y, data, ci=None, order=order, robust=robust, x_partial=x_partial, y_partial=y_partial, dropna=dropna, color=color, label=label) DCNL DCSP if (ax is None): DCNL DCSP  DCSP ax = plt.gca() DCNL DCSP (_, yhat, _) = plotter.fit_regression(grid=plotter.x) DCNL DCSP plotter.y = (plotter.y - yhat) DCNL DCSP if lowess: DCNL DCSP  DCSP plotter.lowess = True DCNL DCSP else: DCNL DCSP  DCSP plotter.fit_reg = False DCNL DCSP ax.axhline(0, ls=':', c='.2') DCNL DCSP scatter_kws = ({} if (scatter_kws is None) else scatter_kws) DCNL DCSP line_kws = ({} if (line_kws is None) else line_kws) DCNL DCSP plotter.plot(ax, scatter_kws, line_kws) DCNL DCSP return ax\n", "intent": "plot the residuals of a linear regression .\n", "question_id": 74}, {"snippet": "def flatten_dict(d, parent_key='', sep='.'): DCNL  DCSP items = [] DCNL DCSP for (k, v) in d.items(): DCNL DCSP  DCSP new_key = (((parent_key + sep) + k) if parent_key else k) DCNL DCSP  DCSP if isinstance(v, collections.MutableMapping): DCNL DCSP  DCSP  DCSP items.extend(flatten_dict(v, new_key, sep=sep).items()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP items.append((new_key, v)) DCNL DCSP return dict(items)\n", "intent": "based on URL .\n", "question_id": 75}, {"snippet": "def load_standard_extensions(ext_mgr, logger, path, package, ext_list=None): DCNL  DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs\n", "intent": "registers all standard api extensions .\n", "question_id": 76}, {"snippet": "def downcaseTokens(s, l, t): DCNL  DCSP return map(str.lower, t)\n", "intent": "helper parse action to convert tokens to lower case .\n", "question_id": 77}, {"snippet": "def managed(name, ppa=None, **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP if ('pkg.get_repo' not in __salt__): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Repo DCSP management DCSP not DCSP implemented DCSP on DCSP this DCSP platform' DCNL DCSP  DCSP return ret DCNL DCSP if (('key_url' in kwargs) and (('keyid' in kwargs) or ('keyserver' in kwargs))): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'You DCSP may DCSP not DCSP use DCSP both DCSP \"keyid\"/\"keyserver\" DCSP and DCSP \"key_url\" DCSP argument.' DCNL DCSP if ('repo' in kwargs): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = \"'repo' DCSP is DCSP not DCSP a DCSP supported DCSP argument DCSP for DCSP this DCSP state. DCSP The DCSP 'name' DCSP argument DCSP is DCSP probably DCSP what DCSP was DCSP intended.\" DCNL DCSP  DCSP return ret DCNL DCSP if ('enabled' in kwargs): DCNL DCSP  DCSP salt.utils.warn_until('Nitrogen', 'The DCSP `enabled` DCSP argument DCSP has DCSP been DCSP deprecated DCSP in DCSP favor DCSP of DCSP `disabled`.') DCNL DCSP repo = name DCNL DCSP if (__grains__['os'] in ('Ubuntu', 'Mint')): DCNL DCSP  DCSP if (ppa is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP repo = ':'.join(('ppa', ppa)) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP repo = ':'.join(('ppa', str(ppa))) DCNL DCSP elif (__grains__['os_family'].lower() in ('redhat', 'suse')): DCNL DCSP  DCSP if ('humanname' in kwargs): DCNL DCSP  DCSP  DCSP kwargs['name'] = kwargs.pop('humanname') DCNL DCSP  DCSP _val = (lambda x: ('1' if salt.utils.is_true(x) else '0')) DCNL DCSP  DCSP if ('disabled' in kwargs): DCNL DCSP  DCSP  DCSP if ('enabled' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Only DCSP one DCSP of DCSP enabled/disabled DCSP is DCSP permitted' DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP _reverse = (lambda x: ('1' if (x == '0') else '0')) DCNL DCSP  DCSP  DCSP kwargs['enabled'] = _reverse(_val(kwargs.pop('disabled'))) DCNL DCSP  DCSP elif ('enabled' in kwargs): DCNL DCSP  DCSP  DCSP kwargs['enabled'] = _val(kwargs['enabled']) DCNL DCSP  DCSP if ('name' not in kwargs): DCNL DCSP  DCSP  DCSP kwargs['name'] = repo DCNL DCSP enabled = kwargs.pop('enabled', True) DCNL DCSP kwargs['disabled'] = (not salt.utils.is_true(enabled)) DCNL DCSP for kwarg in _STATE_INTERNAL_KEYWORDS: DCNL DCSP  DCSP kwargs.pop(kwarg, None) DCNL DCSP try: DCNL DCSP  DCSP pre = __salt__['pkg.get_repo'](repo, ppa_auth=kwargs.get('ppa_auth', None)) DCNL DCSP except CommandExecutionError as exc: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = \"Failed DCSP to DCSP examine DCSP repo DCSP '{0}': DCSP {1}\".format(name, exc) DCNL DCSP  DCSP return ret DCNL DCSP if ('pkg.expand_repo_def' in __salt__): DCNL DCSP  DCSP sanitizedkwargs = __salt__['pkg.expand_repo_def'](repo=repo, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP sanitizedkwargs = kwargs DCNL DCSP if (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP repo = _strip_uri(repo) DCNL DCSP if pre: DCNL DCSP  DCSP needs_update = False DCNL DCSP  DCSP for kwarg in sanitizedkwargs: DCNL DCSP  DCSP  DCSP if (kwarg not in pre): DCNL DCSP  DCSP  DCSP  DCSP if (kwarg == 'enabled'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (__grains__['os_family'] == 'RedHat'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not salt.utils.is_true(sanitizedkwargs[kwarg])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP  DCSP elif (kwarg == 'comps'): DCNL DCSP  DCSP  DCSP  DCSP if (sorted(sanitizedkwargs[kwarg]) != sorted(pre[kwarg])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP  DCSP elif ((kwarg == 'line') and (__grains__['os_family'] == 'Debian')): DCNL DCSP  DCSP  DCSP  DCSP sanitizedsplit = sanitizedkwargs[kwarg].split() DCNL DCSP  DCSP  DCSP  DCSP sanitizedsplit[3:] = sorted(sanitizedsplit[3:]) DCNL DCSP  DCSP  DCSP  DCSP reposplit = pre[kwarg].split() DCNL DCSP  DCSP  DCSP  DCSP reposplit[3:] = sorted(reposplit[3:]) DCNL DCSP  DCSP  DCSP  DCSP if (sanitizedsplit != reposplit): DCNL DCSP  DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP  DCSP  DCSP if ('comments' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _line = pre[kwarg].split('#') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (str(kwargs['comments']) not in _line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP  DCSP elif (str(sanitizedkwargs[kwarg]) != str(pre[kwarg])): DCNL DCSP  DCSP  DCSP  DCSP needs_update = True DCNL DCSP  DCSP if (not needs_update): DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = \"Package DCSP repo DCSP '{0}' DCSP already DCSP configured\".format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = \"Package DCSP repo DCSP '{0}' DCSP will DCSP be DCSP configured. DCSP This DCSP may DCSP cause DCSP pkg DCSP states DCSP to DCSP behave DCSP differently DCSP than DCSP stated DCSP if DCSP this DCSP action DCSP is DCSP repeated DCSP without DCSP test=True, DCSP due DCSP to DCSP the DCSP differences DCSP in DCSP the DCSP configured DCSP repositories.\".format(name) DCNL DCSP  DCSP return ret DCNL DCSP if kwargs.get('clean_file', False): DCNL DCSP  DCSP with salt.utils.fopen(kwargs['file'], 'w'): DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP if (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP  DCSP __salt__['pkg.mod_repo'](repo, saltenv=__env__, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP __salt__['pkg.mod_repo'](repo, **kwargs) DCNL DCSP except Exception as exc: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = \"Failed DCSP to DCSP configure DCSP repo DCSP '{0}': DCSP {1}\".format(name, exc) DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP post = __salt__['pkg.get_repo'](repo, ppa_auth=kwargs.get('ppa_auth', None)) DCNL DCSP  DCSP if pre: DCNL DCSP  DCSP  DCSP for kwarg in sanitizedkwargs: DCNL DCSP  DCSP  DCSP  DCSP if (post.get(kwarg) != pre.get(kwarg)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP change = {'new': post[kwarg], 'old': pre.get(kwarg)} DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'][kwarg] = change DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['changes'] = {'repo': repo} DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = \"Configured DCSP package DCSP repo DCSP '{0}'\".format(name) DCNL DCSP except Exception as exc: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = \"Failed DCSP to DCSP confirm DCSP config DCSP of DCSP repo DCSP '{0}': DCSP {1}\".format(name, exc) DCNL DCSP if ret['changes']: DCNL DCSP  DCSP sys.modules[__salt__['test.ping'].__module__].__context__.pop('pkg._avail', None) DCNL DCSP return ret\n", "intent": "this state manages software package repositories .\n", "question_id": 78}, {"snippet": "def get_project_hierarchy(context, project_id, subtree_as_ids=False, parents_as_ids=False, is_admin_project=False): DCNL  DCSP keystone = _keystone_client(context) DCNL DCSP generic_project = GenericProjectInfo(project_id, keystone.version) DCNL DCSP if (keystone.version == 'v3'): DCNL DCSP  DCSP project = keystone.projects.get(project_id, subtree_as_ids=subtree_as_ids, parents_as_ids=parents_as_ids) DCNL DCSP  DCSP generic_project.parent_id = None DCNL DCSP  DCSP if (project.parent_id != project.domain_id): DCNL DCSP  DCSP  DCSP generic_project.parent_id = project.parent_id DCNL DCSP  DCSP generic_project.subtree = (project.subtree if subtree_as_ids else None) DCNL DCSP  DCSP generic_project.parents = None DCNL DCSP  DCSP if parents_as_ids: DCNL DCSP  DCSP  DCSP generic_project.parents = _filter_domain_id_from_parents(project.domain_id, project.parents) DCNL DCSP  DCSP generic_project.is_admin_project = is_admin_project DCNL DCSP return generic_project\n", "intent": "a helper method to get the project hierarchy .\n", "question_id": 79}, {"snippet": "def episode_by_id(episode_id, session=None): DCNL  DCSP return session.query(Episode).filter((Episode.id == episode_id)).one()\n", "intent": "return an instance of an episode by querying its id .\n", "question_id": 80}, {"snippet": "def multiply_timedelta(interval, number): DCNL  DCSP return timedelta(seconds=(timedelta_total_seconds(interval) * number))\n", "intent": "timedeltas can not normally be multiplied by floating points .\n", "question_id": 81}, {"snippet": "def send_event(event, users): DCNL  DCSP queue_json_publish('notify_tornado', dict(event=event, users=users), send_notification_http)\n", "intent": "users is a list of user ids .\n", "question_id": 82}, {"snippet": "def handleFileCollision(fileName, fileCollisionMethod): DCNL  DCSP if (fileCollisionMethod == 'overwrite'): DCNL DCSP  DCSP logging.warning(('Data DCSP file, DCSP %s, DCSP will DCSP be DCSP overwritten' % fileName)) DCNL DCSP elif (fileCollisionMethod == 'fail'): DCNL DCSP  DCSP msg = 'Data DCSP file DCSP %s DCSP already DCSP exists. DCSP Set DCSP argument DCSP fileCollisionMethod DCSP to DCSP overwrite.' DCNL DCSP  DCSP raise IOError((msg % fileName)) DCNL DCSP elif (fileCollisionMethod == 'rename'): DCNL DCSP  DCSP (rootName, extension) = os.path.splitext(fileName) DCNL DCSP  DCSP matchingFiles = glob.glob(('%s*%s' % (rootName, extension))) DCNL DCSP  DCSP if (not matchingFiles): DCNL DCSP  DCSP  DCSP fileName = ('%s%s' % (rootName, extension)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fileName = ('%s_%d%s' % (rootName, len(matchingFiles), extension)) DCNL DCSP  DCSP if os.path.exists(fileName): DCNL DCSP  DCSP  DCSP msg = 'New DCSP fileName DCSP %s DCSP has DCSP already DCSP been DCSP taken. DCSP Something DCSP is DCSP wrong DCSP with DCSP the DCSP append DCSP counter.' DCNL DCSP  DCSP  DCSP raise IOError((msg % fileName)) DCNL DCSP else: DCNL DCSP  DCSP msg = 'Argument DCSP fileCollisionMethod DCSP was DCSP invalid: DCSP %s' DCNL DCSP  DCSP raise ValueError((msg % str(fileCollisionMethod))) DCNL DCSP return fileName\n", "intent": "handle filename collisions by overwriting .\n", "question_id": 83}, {"snippet": "@click.command(name='delete_snapshots') DCNL @click.option('--repository', type=str, required=True, help='Snapshot DCSP repository DCSP name') DCNL @click.option('--retry_count', type=int, help='Number DCSP of DCSP times DCSP to DCSP retry DCSP (max DCSP 3)') DCNL @click.option('--retry_interval', type=int, help='Time DCSP in DCSP seconds DCSP between DCSP retries') DCNL @click.option('--ignore_empty_list', is_flag=True, help='Do DCSP not DCSP raise DCSP exception DCSP if DCSP there DCSP are DCSP no DCSP actionable DCSP snapshots') DCNL @click.option('--filter_list', callback=validate_filter_json, help='JSON DCSP string DCSP representing DCSP an DCSP array DCSP of DCSP filters.', required=True) DCNL @click.pass_context DCNL def delete_snapshots_singleton(ctx, repository, retry_count, retry_interval, ignore_empty_list, filter_list): DCNL  DCSP action = 'delete_snapshots' DCNL DCSP action_class = CLASS_MAP[action] DCNL DCSP c_args = ctx.obj['config']['client'] DCNL DCSP client = get_client(**c_args) DCNL DCSP logger = logging.getLogger(__name__) DCNL DCSP raw_options = {'repository': repository, 'retry_count': retry_count, 'retry_interval': retry_interval} DCNL DCSP logger.debug('Validating DCSP provided DCSP options: DCSP {0}'.format(raw_options)) DCNL DCSP mykwargs = option_schema_check(action, raw_options) DCNL DCSP del mykwargs['repository'] DCNL DCSP logger.debug('Validating DCSP provided DCSP filters: DCSP {0}'.format(filter_list)) DCNL DCSP clean_filters = {'filters': filter_schema_check(action, filter_list)} DCNL DCSP slo = SnapshotList(client, repository=repository) DCNL DCSP _do_filters(slo, clean_filters, ignore_empty_list) DCNL DCSP action_obj = action_class(slo, **mykwargs) DCNL DCSP _actionator(action, action_obj, dry_run=ctx.parent.params['dry_run'])\n", "intent": "delete snapshots .\n", "question_id": 84}, {"snippet": "def mine_on_chain(chain, parent=None, transactions=[], coinbase=None): DCNL  DCSP if (not parent): DCNL DCSP  DCSP parent = chain.head DCNL DCSP if coinbase: DCNL DCSP  DCSP chain.coinbase = coinbase DCNL DCSP chain._update_head(parent) DCNL DCSP for t in transactions: DCNL DCSP  DCSP chain.add_transactions(t) DCNL DCSP assert (chain.head_candidate.difficulty == 1) DCNL DCSP m = ethpow.Miner(chain.head_candidate) DCNL DCSP rounds = 100 DCNL DCSP nonce = 0 DCNL DCSP while True: DCNL DCSP  DCSP b = m.mine(rounds=rounds, start_nonce=nonce) DCNL DCSP  DCSP if b: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP nonce += rounds DCNL DCSP assert b.header.check_pow() DCNL DCSP chain.add_block(b) DCNL DCSP return b\n", "intent": "mine the next block on a chain .\n", "question_id": 85}, {"snippet": "def disallow(nodes): DCNL  DCSP def disallowed(cls): DCNL DCSP  DCSP cls.unsupported_nodes = () DCNL DCSP  DCSP for node in nodes: DCNL DCSP  DCSP  DCSP new_method = _node_not_implemented(node, cls) DCNL DCSP  DCSP  DCSP name = 'visit_{0}'.format(node) DCNL DCSP  DCSP  DCSP cls.unsupported_nodes += (name,) DCNL DCSP  DCSP  DCSP setattr(cls, name, new_method) DCNL DCSP  DCSP return cls DCNL DCSP return disallowed\n", "intent": "decorator to disallow certain nodes from parsing .\n", "question_id": 86}, {"snippet": "def _get_filter_query(args): DCNL  DCSP query = Q() DCNL DCSP for arg in args: DCNL DCSP  DCSP if (hasattr(Task, arg) and args[arg]): DCNL DCSP  DCSP  DCSP kwargs = {str((arg + '__id')): long(args[arg])} DCNL DCSP  DCSP  DCSP query = (query & Q(**kwargs)) DCNL DCSP return query\n", "intent": "creates a query to filter tasks based on filterform arguments .\n", "question_id": 87}, {"snippet": "def inline_markdown_extension(pelicanobj, config): DCNL  DCSP try: DCNL DCSP  DCSP pelicanobj.settings['MD_EXTENSIONS'].append(PelicanInlineMarkdownExtension(config)) DCNL DCSP except: DCNL DCSP  DCSP sys.excepthook(*sys.exc_info()) DCNL DCSP  DCSP sys.stderr.write('\\nError DCSP - DCSP the DCSP pelican DCSP Markdown DCSP extension DCSP failed DCSP to DCSP configure. DCSP Inline DCSP Markdown DCSP extension DCSP is DCSP non-functional.\\n') DCNL DCSP  DCSP sys.stderr.flush()\n", "intent": "instantiates a customized markdown extension .\n", "question_id": 88}, {"snippet": "@handle_response_format DCNL @treeio_login_required DCNL def ticket_view(request, ticket_id, response_format='html'): DCNL  DCSP context = _get_default_context(request) DCNL DCSP agent = context['agent'] DCNL DCSP profile = request.user.profile DCNL DCSP ticket = get_object_or_404(Ticket, pk=ticket_id) DCNL DCSP if (not profile.has_permission(ticket)): DCNL DCSP  DCSP return user_denied(request, message=\"You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Ticket\") DCNL DCSP if ticket.message: DCNL DCSP  DCSP ticket.message.read_by.add(profile) DCNL DCSP if profile.has_permission(ticket, mode='x'): DCNL DCSP  DCSP if request.POST: DCNL DCSP  DCSP  DCSP record = TicketRecord(sender=profile.get_contact()) DCNL DCSP  DCSP  DCSP record.record_type = 'manual' DCNL DCSP  DCSP  DCSP if ticket.message: DCNL DCSP  DCSP  DCSP  DCSP record.message = ticket.message DCNL DCSP  DCSP  DCSP form = TicketRecordForm(agent, ticket, request.POST, instance=record) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP record = form.save() DCNL DCSP  DCSP  DCSP  DCSP record.save() DCNL DCSP  DCSP  DCSP  DCSP record.set_user_from_request(request) DCNL DCSP  DCSP  DCSP  DCSP record.about.add(ticket) DCNL DCSP  DCSP  DCSP  DCSP ticket.set_last_updated() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('services_ticket_view', args=[ticket.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = TicketRecordForm(agent, ticket) DCNL DCSP else: DCNL DCSP  DCSP form = None DCNL DCSP context.update({'ticket': ticket, 'record_form': form}) DCNL DCSP return render_to_response('services/ticket_view', context, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "ticket view .\n", "question_id": 89}, {"snippet": "@register.filter DCNL def external_url(url): DCNL  DCSP return urlresolvers.get_outgoing_url(unicode(url))\n", "intent": "bounce a url off outgoing .\n", "question_id": 90}, {"snippet": "def _update_configuration_context(context, configuration): DCNL  DCSP config_key = configuration_helpers.get_value('domain_prefix') DCNL DCSP config = configuration.get('microsites', {}) DCNL DCSP if (config_key and config): DCNL DCSP  DCSP context.update(config.get(config_key, {}))\n", "intent": "site configuration will need to be able to override any hard coded content that was put into the context in the _update_certificate_context() call above .\n", "question_id": 91}, {"snippet": "def add_modulo(image1, image2): DCNL  DCSP image1.load() DCNL DCSP image2.load() DCNL DCSP return image1._new(image1.im.chop_add_modulo(image2.im))\n", "intent": "add two images .\n", "question_id": 92}, {"snippet": "def all(): DCNL  DCSP return MIGRATIONS.values()\n", "intent": "return all registred migrations .\n", "question_id": 93}, {"snippet": "def from_text(rdclass, rdtype, ttl, *text_rdatas): DCNL  DCSP return from_text_list(rdclass, rdtype, ttl, text_rdatas)\n", "intent": "create an rdataset with the specified class .\n", "question_id": 94}, {"snippet": "def get_train_test(reviews=None, random_state=None): DCNL  DCSP import numpy as np DCNL DCSP import random DCNL DCSP r = random.Random(random_state) DCNL DCSP if (reviews is None): DCNL DCSP  DCSP reviews = load() DCNL DCSP (U, M) = np.where(reviews) DCNL DCSP test_idxs = np.array(r.sample(range(len(U)), (len(U) // 10))) DCNL DCSP train = reviews.copy() DCNL DCSP train[(U[test_idxs], M[test_idxs])] = 0 DCNL DCSP test = np.zeros_like(reviews) DCNL DCSP test[(U[test_idxs], M[test_idxs])] = reviews[(U[test_idxs], M[test_idxs])] DCNL DCSP return (train, test)\n", "intent": "split data into training & testing parameters reviews : ndarray .\n", "question_id": 95}, {"snippet": "@cronjobs.register DCNL def reload_question_traffic_stats(): DCNL  DCSP if settings.STAGE: DCNL DCSP  DCSP return DCNL DCSP QuestionVisits.reload_from_analytics(verbose=settings.DEBUG)\n", "intent": "reload question views from the analytics .\n", "question_id": 96}, {"snippet": "def wrap_valid_longitude(lon): DCNL  DCSP return (((lon + 180.0) % 360.0) - 180.0)\n", "intent": "wrap a longitude value around to always have a value in the range [-180 .\n", "question_id": 97}, {"snippet": "def main(): DCNL  DCSP pwd = getpass() DCNL DCSP ip_addr = raw_input('Enter DCSP Juniper DCSP SRX DCSP IP: DCSP ') DCNL DCSP ip_addr = ip_addr.strip() DCNL DCSP juniper_srx = {'host': ip_addr, 'user': 'pyclass', 'password': pwd} DCNL DCSP print '\\n\\nConnecting DCSP to DCSP Juniper DCSP SRX...\\n' DCNL DCSP a_device = Device(**juniper_srx) DCNL DCSP a_device.open() DCNL DCSP pprint(a_device.facts) DCNL DCSP print\n", "intent": "connect to juniper device using pyez .\n", "question_id": 98}, {"snippet": "def get_recommended_content_for_user(account, settings, record_views=False, src=SRC_EXPLORE): DCNL  DCSP prefs = AccountSRPrefs.for_user(account) DCNL DCSP recs = get_recommended_content(prefs, src, settings) DCNL DCSP if record_views: DCNL DCSP  DCSP sr_data = {r.sr: r.src for r in recs} DCNL DCSP  DCSP AccountSRFeedback.record_views(account, sr_data) DCNL DCSP return recs\n", "intent": "wrapper around get_recommended_content() that fills in user info .\n", "question_id": 99}, {"snippet": "@contextlib.contextmanager DCNL def archive_context(filename): DCNL  DCSP tmpdir = tempfile.mkdtemp() DCNL DCSP log.warn('Extracting DCSP in DCSP %s', tmpdir) DCNL DCSP old_wd = os.getcwd() DCNL DCSP try: DCNL DCSP  DCSP os.chdir(tmpdir) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with ContextualZipFile(filename) as archive: DCNL DCSP  DCSP  DCSP  DCSP archive.extractall() DCNL DCSP  DCSP except zipfile.BadZipfile as err: DCNL DCSP  DCSP  DCSP if (not err.args): DCNL DCSP  DCSP  DCSP  DCSP err.args = ('',) DCNL DCSP  DCSP  DCSP err.args = (err.args + (MEANINGFUL_INVALID_ZIP_ERR_MSG.format(filename),)) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP subdir = os.path.join(tmpdir, os.listdir(tmpdir)[0]) DCNL DCSP  DCSP os.chdir(subdir) DCNL DCSP  DCSP log.warn('Now DCSP working DCSP in DCSP %s', subdir) DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP os.chdir(old_wd) DCNL DCSP  DCSP shutil.rmtree(tmpdir)\n", "intent": "unzip filename to a temporary directory .\n", "question_id": 100}, {"snippet": "def rootAuthority(xri): DCNL  DCSP if xri.startswith('xri://'): DCNL DCSP  DCSP xri = xri[6:] DCNL DCSP authority = xri.split('/', 1)[0] DCNL DCSP if (authority[0] == '('): DCNL DCSP  DCSP root = authority[:(authority.index(')') + 1)] DCNL DCSP elif (authority[0] in XRI_AUTHORITIES): DCNL DCSP  DCSP root = authority[0] DCNL DCSP else: DCNL DCSP  DCSP segments = authority.split('!') DCNL DCSP  DCSP segments = reduce(list.__add__, map((lambda s: s.split('*')), segments)) DCNL DCSP  DCSP root = segments[0] DCNL DCSP return XRI(root)\n", "intent": "return the root authority for an xri .\n", "question_id": 101}, {"snippet": "def _add_new_repo(alias, uri, compressed, enabled=True): DCNL  DCSP repostr = ('# DCSP ' if (not enabled) else '') DCNL DCSP repostr += ('src/gz DCSP ' if compressed else 'src DCSP ') DCNL DCSP repostr += (((alias + ' DCSP ') + uri) + '\\n') DCNL DCSP conffile = os.path.join(OPKG_CONFDIR, (alias + '.conf')) DCNL DCSP with open(conffile, 'a') as fhandle: DCNL DCSP  DCSP fhandle.write(repostr)\n", "intent": "add a new repo entry .\n", "question_id": 102}, {"snippet": "def __methods(cls): DCNL  DCSP _dict = {} DCNL DCSP __methodDict(cls, _dict) DCNL DCSP return _dict.keys()\n", "intent": "helper function for scrolled canvas .\n", "question_id": 103}, {"snippet": "def register_command(command, callback, **kwargs): DCNL  DCSP return get_parser().add_subparser(command, parent_defaults={u'cli_command_callback': callback}, **kwargs)\n", "intent": "register a callback function to be executed when flexget is launched with the given command .\n", "question_id": 104}, {"snippet": "def _get_dev_port_var(backend, instance=None): DCNL  DCSP port_var = ('BACKEND_PORT.%s' % str(backend).lower()) DCNL DCSP if (instance is not None): DCNL DCSP  DCSP port_var = ('%s.%d' % (port_var, instance)) DCNL DCSP return port_var\n", "intent": "return the environment variable for a backend port .\n", "question_id": 105}, {"snippet": "@register.filter(is_safe=True) DCNL @stringfilter DCNL def safe(value): DCNL  DCSP return mark_safe(value)\n", "intent": "marks the value as a string that should not be auto-escaped .\n", "question_id": 106}, {"snippet": "def thing_type_present(name, thingTypeName, thingTypeDescription, searchableAttributesList, region=None, key=None, keyid=None, profile=None): DCNL  DCSP ret = {'name': thingTypeName, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP r = __salt__['boto_iot.thing_type_exists'](thingTypeName=thingTypeName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in r): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP thing DCSP type: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP if r.get('exists'): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Thing DCSP type DCSP with DCSP given DCSP name DCSP {0} DCSP already DCSP exists'.format(thingTypeName) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Thing DCSP type DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP created.'.format(thingTypeName) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP r = __salt__['boto_iot.create_thing_type'](thingTypeName=thingTypeName, thingTypeDescription=thingTypeDescription, searchableAttributesList=searchableAttributesList, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not r.get('created')): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP thing DCSP type: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP _describe = __salt__['boto_iot.describe_thing_type'](thingTypeName=thingTypeName, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP ret['changes']['old'] = {'thing_type': None} DCNL DCSP ret['changes']['new'] = _describe DCNL DCSP ret['comment'] = 'Thing DCSP Type DCSP {0} DCSP created.'.format(thingTypeName) DCNL DCSP return ret\n", "intent": "ensure thing type exists .\n", "question_id": 107}, {"snippet": "def sinica_parse(s): DCNL  DCSP tokens = re.split(u'([()| DCSP ])', s) DCNL DCSP for i in range(len(tokens)): DCNL DCSP  DCSP if (tokens[i] == u'('): DCNL DCSP  DCSP  DCSP (tokens[(i - 1)], tokens[i]) = (tokens[i], tokens[(i - 1)]) DCNL DCSP  DCSP elif (u':' in tokens[i]): DCNL DCSP  DCSP  DCSP fields = tokens[i].split(u':') DCNL DCSP  DCSP  DCSP if (len(fields) == 2): DCNL DCSP  DCSP  DCSP  DCSP tokens[i] = fields[1] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tokens[i] = ((((u'(' + fields[(-2)]) + u' DCSP ') + fields[(-1)]) + u')') DCNL DCSP  DCSP elif (tokens[i] == u'|'): DCNL DCSP  DCSP  DCSP tokens[i] = u'' DCNL DCSP treebank_string = u' DCSP '.join(tokens) DCNL DCSP return Tree.fromstring(treebank_string, remove_empty_top_bracketing=True)\n", "intent": "parse a sinica treebank string and return a tree .\n", "question_id": 108}, {"snippet": "def _api_eval_sort(name, output, kwargs): DCNL  DCSP import sabnzbd.tvsort DCNL DCSP name = kwargs.get('name', '') DCNL DCSP value = kwargs.get('value', '') DCNL DCSP title = kwargs.get('title') DCNL DCSP multipart = kwargs.get('movieextra', '') DCNL DCSP path = sabnzbd.tvsort.eval_sort(value, title, name, multipart) DCNL DCSP if (path is None): DCNL DCSP  DCSP return report(output, _MSG_NOT_IMPLEMENTED) DCNL DCSP else: DCNL DCSP  DCSP return report(output, keyword='result', data=path)\n", "intent": "api: evaluate sorting expression .\n", "question_id": 109}, {"snippet": "def cr_check_population_availability(unit_id, table): DCNL  DCSP T = current.T DCNL DCSP db = current.db DCNL DCSP response = current.response DCNL DCSP record = db((table.id == unit_id)).select(table.capacity_day, table.population_day, table.capacity_night, table.population_night, limitby=(0, 1)).first() DCNL DCSP day_and_night = current.deployment_settings.get_cr_day_and_night() DCNL DCSP warning = None DCNL DCSP full_day = full_night = False DCNL DCSP capacity_day = record.capacity_day DCNL DCSP population_day = record.population_day DCNL DCSP if ((capacity_day is not None) and population_day and (population_day >= capacity_day)): DCNL DCSP  DCSP full_day = True DCNL DCSP if day_and_night: DCNL DCSP  DCSP capacity_night = record.capacity_night DCNL DCSP  DCSP population_night = record.population_night DCNL DCSP  DCSP if ((capacity_night is not None) and population_night and (population_night >= capacity_night)): DCNL DCSP  DCSP  DCSP full_night = True DCNL DCSP tablename = table._tablename DCNL DCSP if (((not day_and_night) and full_day) or (full_day and full_night)): DCNL DCSP  DCSP if (tablename == 'cr_shelter'): DCNL DCSP  DCSP  DCSP warning = T('Warning: DCSP this DCSP shelter DCSP is DCSP full') DCNL DCSP  DCSP elif (tablename == 'cr_shelter_unit'): DCNL DCSP  DCSP  DCSP warning = T('Warning: DCSP this DCSP housing DCSP unit DCSP is DCSP full') DCNL DCSP elif full_day: DCNL DCSP  DCSP if (tablename == 'cr_shelter'): DCNL DCSP  DCSP  DCSP warning = T('Warning: DCSP this DCSP shelter DCSP is DCSP full DCSP for DCSP daytime') DCNL DCSP  DCSP elif (tablename == 'cr_shelter_unit'): DCNL DCSP  DCSP  DCSP warning = T('Warning: DCSP this DCSP housing DCSP unit DCSP is DCSP full DCSP for DCSP daytime') DCNL DCSP elif full_night: DCNL DCSP  DCSP if (tablename == 'cr_shelter'): DCNL DCSP  DCSP  DCSP warning = T('Warning: DCSP this DCSP shelter DCSP is DCSP full DCSP for DCSP the DCSP night') DCNL DCSP  DCSP elif (tablename == 'cr_shelter_unit'): DCNL DCSP  DCSP  DCSP warning = T('Warning: DCSP this DCSP housing DCSP unit DCSP is DCSP full DCSP for DCSP the DCSP night') DCNL DCSP if warning: DCNL DCSP  DCSP response = current.response DCNL DCSP  DCSP response_warning = response.warning DCNL DCSP  DCSP if response_warning: DCNL DCSP  DCSP  DCSP response.warning = ('%s DCSP - DCSP %s' % (response_warning, warning)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response.warning = warning\n", "intent": "evaluate the population capacity availability .\n", "question_id": 110}, {"snippet": "def _is_number_matching_desc(national_number, number_desc): DCNL  DCSP if (number_desc is None): DCNL DCSP  DCSP return False DCNL DCSP national_re = re.compile((number_desc.national_number_pattern or U_EMPTY_STRING)) DCNL DCSP return (_is_number_possible_for_desc(national_number, number_desc) and fullmatch(national_re, national_number))\n", "intent": "determine if the number matches the given phonenumberdesc .\n", "question_id": 111}, {"snippet": "def fisher_z_transform(r): DCNL  DCSP if (abs(r) >= 1): DCNL DCSP  DCSP return nan DCNL DCSP return (0.5 * log(((1.0 + r) / (1.0 - r))))\n", "intent": "calculate the fisher z transform of a correlation coefficient .\n", "question_id": 112}, {"snippet": "def disconnectNetToMs(Facility_presence=0, ProgressIndicator_presence=0, UserUser_presence=0, AllowedActions_presence=0): DCNL  DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=37) DCNL DCSP c = Cause() DCNL DCSP packet = ((a / b) / c) DCNL DCSP if (Facility_presence is 1): DCNL DCSP  DCSP d = FacilityHdr(ieiF=28, eightBitF=0) DCNL DCSP  DCSP packet = (packet / d) DCNL DCSP if (ProgressIndicator_presence is 1): DCNL DCSP  DCSP e = ProgressIndicatorHdr(ieiPI=30, eightBitPI=0) DCNL DCSP  DCSP packet = (packet / e) DCNL DCSP if (UserUser_presence is 1): DCNL DCSP  DCSP f = UserUserHdr(ieiUU=126, eightBitUU=0) DCNL DCSP  DCSP packet = (packet / f) DCNL DCSP if (AllowedActions_presence is 1): DCNL DCSP  DCSP g = AllowedActionsHdr(ieiAA=123, eightBitAA=0) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP return packet\n", "intent": "disconnect section 9 .\n", "question_id": 113}, {"snippet": "def p_const_list_seq(p): DCNL  DCSP _parse_seq(p)\n", "intent": "const_list_seq : const_value sep const_list_seq | const_value const_list_seq .\n", "question_id": 114}, {"snippet": "def isPrime(N): DCNL  DCSP if (N == 1): DCNL DCSP  DCSP return 0 DCNL DCSP if (N in sieve): DCNL DCSP  DCSP return 1 DCNL DCSP for i in sieve: DCNL DCSP  DCSP if ((N % i) == 0): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP if (_fastmath is not None): DCNL DCSP  DCSP return _fastmath.isPrime(N) DCNL DCSP N1 = (N - 1L) DCNL DCSP n = 1L DCNL DCSP while (n < N): DCNL DCSP  DCSP n = (n << 1L) DCNL DCSP n = (n >> 1L) DCNL DCSP for c in sieve[:7]: DCNL DCSP  DCSP a = long(c) DCNL DCSP  DCSP d = 1L DCNL DCSP  DCSP t = n DCNL DCSP  DCSP while t: DCNL DCSP  DCSP  DCSP x = ((d * d) % N) DCNL DCSP  DCSP  DCSP if ((x == 1L) and (d != 1L) and (d != N1)): DCNL DCSP  DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP  DCSP if (N1 & t): DCNL DCSP  DCSP  DCSP  DCSP d = ((x * a) % N) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP d = x DCNL DCSP  DCSP  DCSP t = (t >> 1L) DCNL DCSP  DCSP if (d != 1L): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP return 1\n", "intent": "isprime:bool return true if n is prime .\n", "question_id": 115}, {"snippet": "@check_job_access_permission() DCNL @check_job_edition_permission() DCNL def create_coordinator_data(request, coordinator, data_type): DCNL  DCSP if (data_type == 'input'): DCNL DCSP  DCSP data_instance = DataInput(coordinator=coordinator) DCNL DCSP  DCSP DataForm = DataInputForm DCNL DCSP else: DCNL DCSP  DCSP data_instance = DataOutput(coordinator=coordinator) DCNL DCSP  DCSP DataForm = DataOutputForm DCNL DCSP response = {'status': (-1), 'data': 'None'} DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP data_form = DataForm(request.POST, instance=data_instance, coordinator=coordinator, prefix=data_type) DCNL DCSP  DCSP if data_form.is_valid(): DCNL DCSP  DCSP  DCSP data_form.save() DCNL DCSP  DCSP  DCSP response['status'] = 0 DCNL DCSP  DCSP  DCSP response['data'] = reverse('oozie:edit_coordinator', kwargs={'coordinator': coordinator.id}) DCNL DCSP  DCSP  DCSP request.info(_('Coordinator DCSP data DCSP created')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response['data'] = data_form.errors DCNL DCSP else: DCNL DCSP  DCSP response['data'] = _('A DCSP POST DCSP request DCSP is DCSP required.') DCNL DCSP return JsonResponse(response)\n", "intent": "returns {status 0/1 .\n", "question_id": 116}, {"snippet": "def fmt(docstr): DCNL  DCSP docstr = docstr.replace('\\n', ' DCSP ') DCNL DCSP docstr = docstr.strip() DCNL DCSP return docstr\n", "intent": "format a docstring for use as documentation in sample config .\n", "question_id": 117}, {"snippet": "def list_bundled_profiles(): DCNL  DCSP path = os.path.join(get_ipython_package_dir(), u'core', u'profile') DCNL DCSP files = os.listdir(path) DCNL DCSP profiles = [] DCNL DCSP for profile in files: DCNL DCSP  DCSP full_path = os.path.join(path, profile) DCNL DCSP  DCSP if (os.path.isdir(full_path) and (profile != '__pycache__')): DCNL DCSP  DCSP  DCSP profiles.append(profile) DCNL DCSP return profiles\n", "intent": "list profiles that are bundled with ipython .\n", "question_id": 118}, {"snippet": "def error_from_serialization_exception(exception, included=False): DCNL  DCSP type_ = collection_name(get_model(exception.instance)) DCNL DCSP id_ = primary_key_value(exception.instance) DCNL DCSP if (exception.message is not None): DCNL DCSP  DCSP detail = exception.message DCNL DCSP else: DCNL DCSP  DCSP resource = ('included DCSP resource' if included else 'resource') DCNL DCSP  DCSP detail = 'Failed DCSP to DCSP serialize DCSP {0} DCSP of DCSP type DCSP {1} DCSP and DCSP ID DCSP {2}' DCNL DCSP  DCSP detail = detail.format(resource, type_, id_) DCNL DCSP return error(status=500, detail=detail)\n", "intent": "returns an error dictionary .\n", "question_id": 119}, {"snippet": "@contextmanager DCNL def pushd(directory): DCNL  DCSP cwd = os.getcwd() DCNL DCSP os.chdir(directory) DCNL DCSP try: DCNL DCSP  DCSP (yield directory) DCNL DCSP finally: DCNL DCSP  DCSP os.chdir(cwd)\n", "intent": "a with-context that encapsulates pushd/popd .\n", "question_id": 120}, {"snippet": "def encode_entity_table_key(key): DCNL  DCSP if (not isinstance(key, entity_pb.Reference)): DCNL DCSP  DCSP key = entity_pb.Reference(key) DCNL DCSP prefix = dbconstants.KEY_DELIMITER.join([key.app(), key.name_space()]) DCNL DCSP return get_entity_key(prefix, key.path())\n", "intent": "create a key that can be used for the entities table .\n", "question_id": 121}, {"snippet": "def getEvaluatedDictionary(evaluationKeys, xmlElement): DCNL  DCSP evaluatedDictionary = {} DCNL DCSP zeroLength = (len(evaluationKeys) == 0) DCNL DCSP for key in xmlElement.attributeDictionary.keys(): DCNL DCSP  DCSP if ((key in evaluationKeys) or zeroLength): DCNL DCSP  DCSP  DCSP value = getEvaluatedValueObliviously(key, xmlElement) DCNL DCSP  DCSP  DCSP if (value == None): DCNL DCSP  DCSP  DCSP  DCSP valueString = str(xmlElement.attributeDictionary[key]) DCNL DCSP  DCSP  DCSP  DCSP print 'Warning, DCSP getEvaluatedDictionary DCSP in DCSP evaluate DCSP can DCSP not DCSP get DCSP a DCSP value DCSP for:' DCNL DCSP  DCSP  DCSP  DCSP print valueString DCNL DCSP  DCSP  DCSP  DCSP evaluatedDictionary[(key + '__Warning__')] = ('Can DCSP not DCSP evaluate: DCSP ' + valueString.replace('\"', ' DCSP ').replace(\"'\", ' DCSP ')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP evaluatedDictionary[key] = value DCNL DCSP return evaluatedDictionary\n", "intent": "get the evaluated dictionary .\n", "question_id": 122}, {"snippet": "def test_history_import_relpath_in_metadata(): DCNL  DCSP with HistoryArchive() as history_archive: DCNL DCSP  DCSP history_archive.write_metafiles(dataset_file_name='../outside.txt') DCNL DCSP  DCSP history_archive.write_file('datasets/Pasted_Entry_1.txt', 'foo') DCNL DCSP  DCSP history_archive.write_outside() DCNL DCSP  DCSP _run_jihaw_cleanup(history_archive, 'Relative DCSP parent DCSP path DCSP in DCSP datasets_attrs.txt DCSP allowed')\n", "intent": "ensure that dataset_attrs .\n", "question_id": 123}, {"snippet": "def preprocess(*_unused, **processors): DCNL  DCSP if _unused: DCNL DCSP  DCSP raise TypeError(\"preprocess() DCSP doesn't DCSP accept DCSP positional DCSP arguments\") DCNL DCSP def _decorator(f): DCNL DCSP  DCSP (args, varargs, varkw, defaults) = argspec = getargspec(f) DCNL DCSP  DCSP if (defaults is None): DCNL DCSP  DCSP  DCSP defaults = () DCNL DCSP  DCSP no_defaults = ((NO_DEFAULT,) * (len(args) - len(defaults))) DCNL DCSP  DCSP args_defaults = list(zip(args, (no_defaults + defaults))) DCNL DCSP  DCSP if varargs: DCNL DCSP  DCSP  DCSP args_defaults.append((varargs, NO_DEFAULT)) DCNL DCSP  DCSP if varkw: DCNL DCSP  DCSP  DCSP args_defaults.append((varkw, NO_DEFAULT)) DCNL DCSP  DCSP argset = (set(args) | ({varargs, varkw} - {None})) DCNL DCSP  DCSP if (not all((isinstance(arg, str) for arg in args))): DCNL DCSP  DCSP  DCSP raise TypeError((\"Can't DCSP validate DCSP functions DCSP using DCSP tuple DCSP unpacking: DCSP %s\" % (argspec,))) DCNL DCSP  DCSP bad_names = (viewkeys(processors) - argset) DCNL DCSP  DCSP if bad_names: DCNL DCSP  DCSP  DCSP raise TypeError(('Got DCSP processors DCSP for DCSP unknown DCSP arguments: DCSP %s.' % bad_names)) DCNL DCSP  DCSP return _build_preprocessed_function(f, processors, args_defaults, varargs, varkw) DCNL DCSP return _decorator\n", "intent": "decorator that applies pre-processors to the arguments of a function before calling the function .\n", "question_id": 124}, {"snippet": "def relative_wildcard_glob(dirname, pattern): DCNL  DCSP if (not dirname): DCNL DCSP  DCSP dirname = os.curdir DCNL DCSP try: DCNL DCSP  DCSP if ('**' in pattern): DCNL DCSP  DCSP  DCSP names = list(_iter_relative_dirs(dirname)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP names = os.listdir(dirname) DCNL DCSP except OSError: DCNL DCSP  DCSP return [] DCNL DCSP result = [] DCNL DCSP pattern = os.path.normcase(pattern) DCNL DCSP match = re.compile(translate(pattern)).match DCNL DCSP for name in names: DCNL DCSP  DCSP if match(os.path.normcase(name)): DCNL DCSP  DCSP  DCSP result.append(name) DCNL DCSP return result\n", "intent": "non-recursive glob for one directory .\n", "question_id": 125}, {"snippet": "def stopcron(): DCNL  DCSP global _cron_stopping DCNL DCSP _cron_stopping = True DCNL DCSP while _cron_subprocs: DCNL DCSP  DCSP proc = _cron_subprocs.pop() DCNL DCSP  DCSP if (proc.poll() is None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP proc.terminate() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP import traceback DCNL DCSP  DCSP  DCSP  DCSP traceback.print_exc()\n", "intent": "graceful shutdown of cron .\n", "question_id": 126}, {"snippet": "def choose_include_text(s, params, source_path): DCNL  DCSP lines = s.splitlines() DCNL DCSP start_after = None DCNL DCSP start_at = None DCNL DCSP end_before = None DCNL DCSP end_at = None DCNL DCSP for term in params.split(u'&'): DCNL DCSP  DCSP if (u'=' in term): DCNL DCSP  DCSP  DCSP (param, value) = [p.strip() for p in term.split(u'=', 1)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (param, value) = (term.strip(), u'') DCNL DCSP  DCSP if (not param): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (param == u'start-after'): DCNL DCSP  DCSP  DCSP start_after = value DCNL DCSP  DCSP elif (param == u'start-at'): DCNL DCSP  DCSP  DCSP start_at = value DCNL DCSP  DCSP elif (param == u'end-before'): DCNL DCSP  DCSP  DCSP end_before = value DCNL DCSP  DCSP elif (param == u'end-at'): DCNL DCSP  DCSP  DCSP end_at = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TaskError(u'Invalid DCSP include DCSP directive DCSP \"{0}\" DCSP in DCSP {1}'.format(params, source_path)) DCNL DCSP chosen_lines = [] DCNL DCSP for line_ix in range(0, len(lines)): DCNL DCSP  DCSP line = lines[line_ix] DCNL DCSP  DCSP if ((not start_at) and (not start_after)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((start_at is not None) and (start_at in line)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((start_after is not None) and (start_after in line)): DCNL DCSP  DCSP  DCSP line_ix += 1 DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return u'' DCNL DCSP for line_ix in range(line_ix, len(lines)): DCNL DCSP  DCSP line = lines[line_ix] DCNL DCSP  DCSP if ((end_before is not None) and (end_before in line)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP chosen_lines.append(line) DCNL DCSP  DCSP if ((end_at is not None) and (end_at in line)): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP if (end_before or end_at): DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP return u'\\n'.join(chosen_lines)\n", "intent": "given the contents of a file and !inc[these params] .\n", "question_id": 127}, {"snippet": "def put_lifecycle_configuration(Bucket, Rules, region=None, key=None, keyid=None, profile=None): DCNL  DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP if ((Rules is not None) and isinstance(Rules, six.string_types)): DCNL DCSP  DCSP  DCSP Rules = json.loads(Rules) DCNL DCSP  DCSP conn.put_bucket_lifecycle_configuration(Bucket=Bucket, LifecycleConfiguration={'Rules': Rules}) DCNL DCSP  DCSP return {'updated': True, 'name': Bucket} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'updated': False, 'error': __utils__['boto3.get_error'](e)}\n", "intent": "given a valid config .\n", "question_id": 128}, {"snippet": "def scale(X, axis=0, with_mean=True, with_std=True, copy=True): DCNL  DCSP X = check_array(X, accept_sparse='csc', copy=copy, ensure_2d=False, warn_on_dtype=True, estimator='the DCSP scale DCSP function', dtype=FLOAT_DTYPES) DCNL DCSP if sparse.issparse(X): DCNL DCSP  DCSP if with_mean: DCNL DCSP  DCSP  DCSP raise ValueError('Cannot DCSP center DCSP sparse DCSP matrices: DCSP pass DCSP `with_mean=False` DCSP instead DCSP See DCSP docstring DCSP for DCSP motivation DCSP and DCSP alternatives.') DCNL DCSP  DCSP if (axis != 0): DCNL DCSP  DCSP  DCSP raise ValueError(('Can DCSP only DCSP scale DCSP sparse DCSP matrix DCSP on DCSP axis=0, DCSP  DCSP got DCSP axis=%d' % axis)) DCNL DCSP  DCSP if with_std: DCNL DCSP  DCSP  DCSP (_, var) = mean_variance_axis(X, axis=0) DCNL DCSP  DCSP  DCSP var = _handle_zeros_in_scale(var, copy=False) DCNL DCSP  DCSP  DCSP inplace_column_scale(X, (1 / np.sqrt(var))) DCNL DCSP else: DCNL DCSP  DCSP X = np.asarray(X) DCNL DCSP  DCSP if with_mean: DCNL DCSP  DCSP  DCSP mean_ = np.mean(X, axis) DCNL DCSP  DCSP if with_std: DCNL DCSP  DCSP  DCSP scale_ = np.std(X, axis) DCNL DCSP  DCSP Xr = np.rollaxis(X, axis) DCNL DCSP  DCSP if with_mean: DCNL DCSP  DCSP  DCSP Xr -= mean_ DCNL DCSP  DCSP  DCSP mean_1 = Xr.mean(axis=0) DCNL DCSP  DCSP  DCSP if (not np.allclose(mean_1, 0)): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn('Numerical DCSP issues DCSP were DCSP encountered DCSP when DCSP centering DCSP the DCSP data DCSP and DCSP might DCSP not DCSP be DCSP solved. DCSP Dataset DCSP may DCSP contain DCSP too DCSP large DCSP values. DCSP You DCSP may DCSP need DCSP to DCSP prescale DCSP your DCSP features.') DCNL DCSP  DCSP  DCSP  DCSP Xr -= mean_1 DCNL DCSP  DCSP if with_std: DCNL DCSP  DCSP  DCSP scale_ = _handle_zeros_in_scale(scale_, copy=False) DCNL DCSP  DCSP  DCSP Xr /= scale_ DCNL DCSP  DCSP  DCSP if with_mean: DCNL DCSP  DCSP  DCSP  DCSP mean_2 = Xr.mean(axis=0) DCNL DCSP  DCSP  DCSP  DCSP if (not np.allclose(mean_2, 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn('Numerical DCSP issues DCSP were DCSP encountered DCSP when DCSP scaling DCSP the DCSP data DCSP and DCSP might DCSP not DCSP be DCSP solved. DCSP The DCSP standard DCSP deviation DCSP of DCSP the DCSP data DCSP is DCSP probably DCSP very DCSP close DCSP to DCSP 0. DCSP ') DCNL DCSP  DCSP  DCSP  DCSP  DCSP Xr -= mean_2 DCNL DCSP return X\n", "intent": "standardize a dataset along any axis center to the mean and component wise scale to unit variance .\n", "question_id": 129}, {"snippet": "def delete_entity_from_table(key, datastore): DCNL  DCSP datastore.batch_delete(APP_ENTITY_TABLE, [key])\n", "intent": "performs a hard delete on the app_entity_table for the given row key .\n", "question_id": 130}, {"snippet": "@_ignore_inferred DCNL def infer_parameter_objects(pyfunction): DCNL  DCSP object_info = pyfunction.pycore.object_info DCNL DCSP result = object_info.get_parameter_objects(pyfunction) DCNL DCSP if (result is None): DCNL DCSP  DCSP result = _parameter_objects(pyfunction) DCNL DCSP _handle_first_parameter(pyfunction, result) DCNL DCSP return result\n", "intent": "infer the pyobjects of parameters of this pyfunction .\n", "question_id": 131}, {"snippet": "def p_declaration_specifiers_1(t): DCNL  DCSP pass\n", "intent": "declaration_specifiers : storage_class_specifier declaration_specifiers .\n", "question_id": 132}, {"snippet": "def getMemorySize(): DCNL  DCSP try: DCNL DCSP  DCSP statm = open('/proc/self/statm').readline().split() DCNL DCSP except IOError: DCNL DCSP  DCSP return None DCNL DCSP return (int(statm[0]) * PAGE_SIZE)\n", "intent": "read currenet process memory size: size of available virtual memory .\n", "question_id": 133}, {"snippet": "def _format_info(data): DCNL  DCSP return {'gid': data.pw_gid, 'groups': list_groups(data.pw_name), 'home': data.pw_dir, 'name': data.pw_name, 'shell': data.pw_shell, 'uid': data.pw_uid, 'fullname': data.pw_gecos}\n", "intent": "return user information in a pretty way .\n", "question_id": 134}, {"snippet": "def enable_pretty_logging(options=None, logger=None): DCNL  DCSP if (options is None): DCNL DCSP  DCSP from tornado.options import options DCNL DCSP if ((options.logging is None) or (options.logging.lower() == 'none')): DCNL DCSP  DCSP return DCNL DCSP if (logger is None): DCNL DCSP  DCSP logger = logging.getLogger() DCNL DCSP logger.setLevel(getattr(logging, options.logging.upper())) DCNL DCSP if options.log_file_prefix: DCNL DCSP  DCSP channel = logging.handlers.RotatingFileHandler(filename=options.log_file_prefix, maxBytes=options.log_file_max_size, backupCount=options.log_file_num_backups) DCNL DCSP  DCSP channel.setFormatter(LogFormatter(color=False)) DCNL DCSP  DCSP logger.addHandler(channel) DCNL DCSP if (options.log_to_stderr or ((options.log_to_stderr is None) and (not logger.handlers))): DCNL DCSP  DCSP channel = logging.StreamHandler() DCNL DCSP  DCSP channel.setFormatter(LogFormatter()) DCNL DCSP  DCSP logger.addHandler(channel)\n", "intent": "turns on formatted logging output as configured .\n", "question_id": 135}, {"snippet": "@register.tag DCNL def get_static_prefix(parser, token): DCNL  DCSP return PrefixNode.handle_token(parser, token, 'STATIC_URL')\n", "intent": "populates a template variable with the static prefix .\n", "question_id": 136}, {"snippet": "def writeToMongo(): DCNL  DCSP sys.stderr.write('Saving DCSP to DCSP db.messages.errors, DCSP will DCSP not DCSP check DCSP for DCSP duplicates!') DCNL DCSP from pymongo import Connection DCNL DCSP connection = Connection() DCNL DCSP db = connection['messages'] DCNL DCSP errorcodes = db['errors'] DCNL DCSP for errCode in messages.keys(): DCNL DCSP  DCSP sys.stderr.write('Inserting DCSP code: DCSP {}\\n'.format(errCode)) DCNL DCSP  DCSP result = errorcodes.insert(messages[errCode]) DCNL DCSP  DCSP sys.stderr.write('Result: DCSP {}\\n'.format(result))\n", "intent": "pipe the messages array into mongodb .\n", "question_id": 137}, {"snippet": "def rm(path, service_names=None): DCNL  DCSP project = __load_project(path) DCNL DCSP if isinstance(project, dict): DCNL DCSP  DCSP return project DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP project.remove_stopped(service_names) DCNL DCSP  DCSP except Exception as inst: DCNL DCSP  DCSP  DCSP return __handle_except(inst) DCNL DCSP return __standardize_result(True, 'Removing DCSP stopped DCSP containers DCSP via DCSP docker-compose', None, None)\n", "intent": "remove stopped containers in the docker-compose file .\n", "question_id": 138}, {"snippet": "def touch(ui, repo, basedir): DCNL  DCSP do_touch(ui, repo, basedir)\n", "intent": "touch generated files that are older than their sources after an update .\n", "question_id": 139}, {"snippet": "def dyld_find(name, executable_path=None, env=None, loader_path=None): DCNL  DCSP name = _ensure_utf8(name) DCNL DCSP executable_path = _ensure_utf8(executable_path) DCNL DCSP for path in dyld_image_suffix_search(chain(dyld_override_search(name, env), dyld_executable_path_search(name, executable_path), dyld_loader_search(name, loader_path), dyld_default_search(name, env)), env): DCNL DCSP  DCSP if os.path.isfile(path): DCNL DCSP  DCSP  DCSP return path DCNL DCSP raise ValueError(('dylib DCSP %s DCSP could DCSP not DCSP be DCSP found' % (name,)))\n", "intent": "find a library or framework using dyld semantics .\n", "question_id": 140}, {"snippet": "def match(wrong, candidates): DCNL  DCSP assert (len(candidates) > 0) DCNL DCSP def score(w1, w2): DCNL DCSP  DCSP w1 = w1.lower() DCNL DCSP  DCSP w2 = w2.lower() DCNL DCSP  DCSP def phi(w): DCNL DCSP  DCSP  DCSP rval = {} DCNL DCSP  DCSP  DCSP for i in xrange(len(w)): DCNL DCSP  DCSP  DCSP  DCSP l = w[i] DCNL DCSP  DCSP  DCSP  DCSP rval[l] = (rval.get(l, 0.0) + 1.0) DCNL DCSP  DCSP  DCSP  DCSP if (i < (len(w) - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP b = w[i:(i + 2)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP rval[b] = (rval.get(b, 0.0) + 1.0) DCNL DCSP  DCSP  DCSP return rval DCNL DCSP  DCSP def mul(d1, d2): DCNL DCSP  DCSP  DCSP rval = 0 DCNL DCSP  DCSP  DCSP for key in set(d1).union(d2): DCNL DCSP  DCSP  DCSP  DCSP rval += (d1.get(key, 0) * d2.get(key, 0)) DCNL DCSP  DCSP  DCSP return rval DCNL DCSP  DCSP tot_score = (((mul(phi(w1), phi(w2)) / float((len(w1) * len(w2)))) + (0.1 * mul(phi(w1[0:1]), phi(w2[0:1])))) + (0.1 * mul(phi(w1[(-1):]), phi(w2[(-1):])))) DCNL DCSP  DCSP return tot_score DCNL DCSP scored_candidates = [((- score(wrong, candidate)), candidate) for candidate in candidates] DCNL DCSP scored_candidates.sort() DCNL DCSP return scored_candidates[0][1]\n", "intent": "returns a guess of which candidate is the right one based on the wrong word .\n", "question_id": 141}, {"snippet": "def RemoveELBInstance(region, instance_id, node_type): DCNL  DCSP balancers = GetLoadBalancers(region, node_types=[node_type]) DCNL DCSP assert balancers, ('No DCSP %s DCSP load DCSP balancer DCSP in DCSP region DCSP %s' % (node_type, region)) DCNL DCSP assert (len(balancers) == 1) DCNL DCSP b = balancers[0] DCNL DCSP balancer_instances = set([i.id for i in b.instances]) DCNL DCSP if (instance_id not in balancer_instances): DCNL DCSP  DCSP print ('Instance DCSP %s DCSP not DCSP found DCSP in DCSP %s DCSP load DCSP balancer DCSP in DCSP regions DCSP %s' % (instance_id, node_type, region)) DCNL DCSP  DCSP return DCNL DCSP b.deregister_instances([instance_id]) DCNL DCSP print ('Removed DCSP instance DCSP %s DCSP from DCSP %s DCSP load DCSP balancer DCSP in DCSP region DCSP %s' % (instance_id, node_type, region))\n", "intent": "add an instance to the load balancer in region .\n", "question_id": 142}, {"snippet": "def visstd(a, s=0.1): DCNL  DCSP return ((((a - a.mean()) / max(a.std(), 0.0001)) * s) + 0.5)\n", "intent": "normalize the image range for visualization .\n", "question_id": 143}, {"snippet": "def _aspect_preserving_resize(image, smallest_side): DCNL  DCSP smallest_side = tf.convert_to_tensor(smallest_side, dtype=tf.int32) DCNL DCSP shape = tf.shape(image) DCNL DCSP height = shape[0] DCNL DCSP width = shape[1] DCNL DCSP (new_height, new_width) = _smallest_size_at_least(height, width, smallest_side) DCNL DCSP image = tf.expand_dims(image, 0) DCNL DCSP resized_image = tf.image.resize_bilinear(image, [new_height, new_width], align_corners=False) DCNL DCSP resized_image = tf.squeeze(resized_image) DCNL DCSP resized_image.set_shape([None, None, 3]) DCNL DCSP return resized_image\n", "intent": "resize images preserving the original aspect ratio .\n", "question_id": 144}, {"snippet": "def group_by_video(list_results): DCNL  DCSP result = defaultdict(list) DCNL DCSP for (video, subtitles) in list_results: DCNL DCSP  DCSP result[video] += (subtitles or []) DCNL DCSP return result\n", "intent": "group the results of :class:listtasks <subliminal .\n", "question_id": 145}, {"snippet": "def walk(top, func, arg): DCNL  DCSP try: DCNL DCSP  DCSP names = os.listdir(top) DCNL DCSP except os.error: DCNL DCSP  DCSP return DCNL DCSP func(arg, top, names) DCNL DCSP exceptions = ('.', '..') DCNL DCSP for name in names: DCNL DCSP  DCSP if (name not in exceptions): DCNL DCSP  DCSP  DCSP name = join(top, name) DCNL DCSP  DCSP  DCSP if isdir(name): DCNL DCSP  DCSP  DCSP  DCSP walk(name, func, arg)\n", "intent": "directory tree walk with callback function .\n", "question_id": 146}, {"snippet": "def fileobj_is_binary(f): DCNL  DCSP if hasattr(f, 'binary'): DCNL DCSP  DCSP return f.binary DCNL DCSP if ((io is not None) and isinstance(f, io.TextIOBase)): DCNL DCSP  DCSP return False DCNL DCSP mode = fileobj_mode(f) DCNL DCSP if mode: DCNL DCSP  DCSP return ('b' in mode) DCNL DCSP else: DCNL DCSP  DCSP return True\n", "intent": "returns true if the give file or file-like object has a file open in binary mode .\n", "question_id": 147}, {"snippet": "def alias_details(client, module): DCNL  DCSP lambda_facts = dict() DCNL DCSP function_name = module.params.get('function_name') DCNL DCSP if function_name: DCNL DCSP  DCSP params = dict() DCNL DCSP  DCSP if module.params.get('max_items'): DCNL DCSP  DCSP  DCSP params['MaxItems'] = module.params.get('max_items') DCNL DCSP  DCSP if module.params.get('next_marker'): DCNL DCSP  DCSP  DCSP params['Marker'] = module.params.get('next_marker') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lambda_facts.update(aliases=client.list_aliases(FunctionName=function_name, **params)['Aliases']) DCNL DCSP  DCSP except ClientError as e: DCNL DCSP  DCSP  DCSP if (e.response['Error']['Code'] == 'ResourceNotFoundException'): DCNL DCSP  DCSP  DCSP  DCSP lambda_facts.update(aliases=[]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP module.fail_json(msg='Unable DCSP to DCSP get DCSP {0} DCSP aliases, DCSP error: DCSP {1}'.format(function_name, e)) DCNL DCSP else: DCNL DCSP  DCSP module.fail_json(msg='Parameter DCSP function_name DCSP required DCSP for DCSP query=aliases.') DCNL DCSP return {function_name: camel_dict_to_snake_dict(lambda_facts)}\n", "intent": "returns list of aliases for a specified function .\n", "question_id": 148}, {"snippet": "def verify_grad(op, pt, n_tests=2, rng=None, *args, **kwargs): DCNL  DCSP if (rng is None): DCNL DCSP  DCSP seed_rng() DCNL DCSP  DCSP rng = numpy.random DCNL DCSP T.verify_grad(op, pt, n_tests, rng, *args, **kwargs)\n", "intent": "wrapper for tensor/basic .\n", "question_id": 149}, {"snippet": "def _avi_screen_size(filename): DCNL  DCSP try: DCNL DCSP  DCSP if (not filename.endswith(u'.avi')): DCNL DCSP  DCSP  DCSP with io.open(filename, u'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP header = f.read(72) DCNL DCSP  DCSP  DCSP x = binascii.hexlify(header[68:72]) DCNL DCSP  DCSP  DCSP height = int((((x[6:8] + x[4:6]) + x[2:4]) + x[0:2]), 16) DCNL DCSP  DCSP  DCSP assert (100 < height < 4320) DCNL DCSP  DCSP  DCSP x = binascii.hexlify(header[64:68]) DCNL DCSP  DCSP  DCSP width = int((((x[6:8] + x[4:6]) + x[2:4]) + x[0:2]), 16) DCNL DCSP  DCSP  DCSP assert (100 < width < 7680) DCNL DCSP  DCSP  DCSP return (width, height) DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP return (None, None)\n", "intent": "parses avi file header for width and height .\n", "question_id": 150}, {"snippet": "def test_gemm_opt0(): DCNL  DCSP (X, Y, Z, a, b) = XYZab() DCNL DCSP just_gemm([X, Y, Z, a, b], [((T.dot(X, Y) * a) + (Z * b))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((a * T.dot(X, Y)) + (b * Z))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((b * Z) + (a * T.dot(X, Y)))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((T.dot(X, Y) * a) - (Z * b))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((a * T.dot(X, Y)) - (b * Z))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((b * Z) - (a * T.dot(X, Y)))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((b * Z.T) - (a * T.dot(Y.T, X.T)))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((b * Z.T) + ((a * b) * T.dot(X, Y).T))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((b * Z) + (a * T.dot(X, Y).T))], ishapes=[(5, 3), (3, 4), (4, 5), (), ()]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((((b * b) * Z) * a) + (((a * a) * T.dot(X, Y)) * b))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [(Z + T.dot(X, Y))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((Z * b) + T.dot(X, Y))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [(Z + (((a * b) * a) * T.dot(X, Y)))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((((b * b) * Z) * a) - (((a * a) * T.dot(X, Y)) * b))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [(Z - T.dot(X, Y))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [((Z * b) - T.dot(X, Y))]) DCNL DCSP just_gemm([X, Y, Z, a, b], [(Z - (((a * b) * a) * T.dot(X, Y)))])\n", "intent": "many subgraphs whose dots can be eliminated .\n", "question_id": 151}, {"snippet": "def mp_icon(filename): DCNL  DCSP try: DCNL DCSP  DCSP import pkg_resources DCNL DCSP  DCSP name = __name__ DCNL DCSP  DCSP if (name == '__main__'): DCNL DCSP  DCSP  DCSP name = 'MAVProxy.modules.mavproxy_map.mp_tile' DCNL DCSP  DCSP stream = pkg_resources.resource_stream(name, ('data/%s' % filename)).read() DCNL DCSP  DCSP raw = np.fromstring(stream, dtype=np.uint8) DCNL DCSP except Exception: DCNL DCSP  DCSP stream = open(os.path.join(__file__, 'data', filename)).read() DCNL DCSP  DCSP raw = np.fromstring(stream, dtype=np.uint8) DCNL DCSP img = cv2.imdecode(raw, cv2.IMREAD_COLOR) DCNL DCSP return img\n", "intent": "load an icon from the data directory .\n", "question_id": 152}, {"snippet": "def window_none(x): DCNL  DCSP return x\n", "intent": "no window function; simply return x .\n", "question_id": 153}, {"snippet": "def hfloat(f, p=5): DCNL  DCSP i = int(f) DCNL DCSP return (i if (i == f) else u'{0:.{p}}'.format(f, p=p))\n", "intent": "convert float to value suitable for humans .\n", "question_id": 154}, {"snippet": "def direct_put_object(node, part, account, container, name, contents, content_length=None, etag=None, content_type=None, headers=None, conn_timeout=5, response_timeout=15, resp_chunk_size=None): DCNL  DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP if etag: DCNL DCSP  DCSP headers['ETag'] = etag.strip('\"') DCNL DCSP if (content_length is not None): DCNL DCSP  DCSP headers['Content-Length'] = str(content_length) DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP headers['Content-Type'] = content_type DCNL DCSP else: DCNL DCSP  DCSP headers['Content-Type'] = 'application/octet-stream' DCNL DCSP if (not contents): DCNL DCSP  DCSP headers['Content-Length'] = '0' DCNL DCSP if isinstance(contents, basestring): DCNL DCSP  DCSP contents = [contents] DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'PUT', path, headers=headers) DCNL DCSP for chunk in contents: DCNL DCSP  DCSP conn.send(chunk) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP PUT DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP return resp.getheader('etag').strip('\"')\n", "intent": "put object directly from the object server .\n", "question_id": 155}, {"snippet": "def get_non_generated_file_lines(): DCNL  DCSP lines_to_copy = [] DCNL DCSP flag_found = False DCNL DCSP with open('./plotly/graph_objs/graph_objs.py', 'r') as f: DCNL DCSP  DCSP for line_to_copy in f: DCNL DCSP  DCSP  DCSP if line_to_copy.startswith(FLAG): DCNL DCSP  DCSP  DCSP  DCSP flag_found = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP lines_to_copy.append(line_to_copy) DCNL DCSP if (not flag_found): DCNL DCSP  DCSP raise ValueError('Failed DCSP to DCSP find DCSP flag:\\n\"{}\"\\nin DCSP graph_objs_tools.py.'.format(FLAG)) DCNL DCSP return lines_to_copy\n", "intent": "copy each line up to our special flag line and return .\n", "question_id": 156}, {"snippet": "def min_cost_flow_cost(G, demand='demand', capacity='capacity', weight='weight'): DCNL  DCSP return nx.network_simplex(G, demand=demand, capacity=capacity, weight=weight)[0]\n", "intent": "find the cost of a minimum cost flow satisfying all demands in digraph g .\n", "question_id": 157}, {"snippet": "def setAggregationMethod(path, aggregationMethod, xFilesFactor=None): DCNL  DCSP with open(path, 'r+b', BUFFERING) as fh: DCNL DCSP  DCSP if LOCK: DCNL DCSP  DCSP  DCSP fcntl.flock(fh.fileno(), fcntl.LOCK_EX) DCNL DCSP  DCSP packedMetadata = fh.read(metadataSize) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (aggregationType, maxRetention, xff, archiveCount) = struct.unpack(metadataFormat, packedMetadata) DCNL DCSP  DCSP except (struct.error, ValueError): DCNL DCSP  DCSP  DCSP raise CorruptWhisperFile('Unable DCSP to DCSP read DCSP header', fh.name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP newAggregationType = struct.pack(longFormat, aggregationMethodToType[aggregationMethod]) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise InvalidAggregationMethod(('Unrecognized DCSP aggregation DCSP method: DCSP %s' % aggregationMethod)) DCNL DCSP  DCSP if (xFilesFactor is not None): DCNL DCSP  DCSP  DCSP xff = struct.pack(floatFormat, float(xFilesFactor)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xff = struct.pack(floatFormat, xff) DCNL DCSP  DCSP maxRetention = struct.pack(longFormat, maxRetention) DCNL DCSP  DCSP archiveCount = struct.pack(longFormat, archiveCount) DCNL DCSP  DCSP packedMetadata = (((newAggregationType + maxRetention) + xff) + archiveCount) DCNL DCSP  DCSP fh.seek(0) DCNL DCSP  DCSP fh.write(packedMetadata) DCNL DCSP  DCSP if AUTOFLUSH: DCNL DCSP  DCSP  DCSP fh.flush() DCNL DCSP  DCSP  DCSP os.fsync(fh.fileno()) DCNL DCSP  DCSP  DCSP if (CACHE_HEADERS and (fh.name in __headerCache)): DCNL DCSP  DCSP  DCSP  DCSP del __headerCache[fh.name] DCNL DCSP return aggregationTypeToMethod.get(aggregationType, 'average')\n", "intent": "setaggregationmethod path is a string aggregationmethod specifies the method to use when propagating data  xfilesfactor specifies the fraction of data points in a propagation interval that must have known values for a propagation to occur .\n", "question_id": 158}, {"snippet": "def _parallel_poly_from_expr(exprs, opt): DCNL  DCSP from sympy.functions.elementary.piecewise import Piecewise DCNL DCSP if (len(exprs) == 2): DCNL DCSP  DCSP (f, g) = exprs DCNL DCSP  DCSP if (isinstance(f, Poly) and isinstance(g, Poly)): DCNL DCSP  DCSP  DCSP f = f.__class__._from_poly(f, opt) DCNL DCSP  DCSP  DCSP g = g.__class__._from_poly(g, opt) DCNL DCSP  DCSP  DCSP (f, g) = f.unify(g) DCNL DCSP  DCSP  DCSP opt.gens = f.gens DCNL DCSP  DCSP  DCSP opt.domain = f.domain DCNL DCSP  DCSP  DCSP if (opt.polys is None): DCNL DCSP  DCSP  DCSP  DCSP opt.polys = True DCNL DCSP  DCSP  DCSP return ([f, g], opt) DCNL DCSP (origs, exprs) = (list(exprs), []) DCNL DCSP (_exprs, _polys) = ([], []) DCNL DCSP failed = False DCNL DCSP for (i, expr) in enumerate(origs): DCNL DCSP  DCSP expr = sympify(expr) DCNL DCSP  DCSP if isinstance(expr, Basic): DCNL DCSP  DCSP  DCSP if expr.is_Poly: DCNL DCSP  DCSP  DCSP  DCSP _polys.append(i) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _exprs.append(i) DCNL DCSP  DCSP  DCSP  DCSP if opt.expand: DCNL DCSP  DCSP  DCSP  DCSP  DCSP expr = expr.expand() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP failed = True DCNL DCSP  DCSP exprs.append(expr) DCNL DCSP if failed: DCNL DCSP  DCSP raise PolificationFailed(opt, origs, exprs, True) DCNL DCSP if _polys: DCNL DCSP  DCSP for i in _polys: DCNL DCSP  DCSP  DCSP exprs[i] = exprs[i].as_expr() DCNL DCSP (reps, opt) = _parallel_dict_from_expr(exprs, opt) DCNL DCSP if (not opt.gens): DCNL DCSP  DCSP raise PolificationFailed(opt, origs, exprs, True) DCNL DCSP for k in opt.gens: DCNL DCSP  DCSP if isinstance(k, Piecewise): DCNL DCSP  DCSP  DCSP raise PolynomialError('Piecewise DCSP generators DCSP do DCSP not DCSP make DCSP sense') DCNL DCSP (coeffs_list, lengths) = ([], []) DCNL DCSP all_monoms = [] DCNL DCSP all_coeffs = [] DCNL DCSP for rep in reps: DCNL DCSP  DCSP (monoms, coeffs) = list(zip(*list(rep.items()))) DCNL DCSP  DCSP coeffs_list.extend(coeffs) DCNL DCSP  DCSP all_monoms.append(monoms) DCNL DCSP  DCSP lengths.append(len(coeffs)) DCNL DCSP domain = opt.domain DCNL DCSP if (domain is None): DCNL DCSP  DCSP (opt.domain, coeffs_list) = construct_domain(coeffs_list, opt=opt) DCNL DCSP else: DCNL DCSP  DCSP coeffs_list = list(map(domain.from_sympy, coeffs_list)) DCNL DCSP for k in lengths: DCNL DCSP  DCSP all_coeffs.append(coeffs_list[:k]) DCNL DCSP  DCSP coeffs_list = coeffs_list[k:] DCNL DCSP polys = [] DCNL DCSP for (monoms, coeffs) in zip(all_monoms, all_coeffs): DCNL DCSP  DCSP rep = dict(list(zip(monoms, coeffs))) DCNL DCSP  DCSP poly = Poly._from_dict(rep, opt) DCNL DCSP  DCSP polys.append(poly) DCNL DCSP if (opt.polys is None): DCNL DCSP  DCSP opt.polys = bool(_polys) DCNL DCSP return (polys, opt)\n", "intent": "construct polynomials from expressions .\n", "question_id": 159}, {"snippet": "def get_converter(map, name, args): DCNL  DCSP if (not (name in map.converters)): DCNL DCSP  DCSP raise LookupError(('the DCSP converter DCSP %r DCSP does DCSP not DCSP exist' % name)) DCNL DCSP if args: DCNL DCSP  DCSP (args, kwargs) = parse_converter_args(args) DCNL DCSP else: DCNL DCSP  DCSP args = () DCNL DCSP  DCSP kwargs = {} DCNL DCSP return map.converters[name](map, *args, **kwargs)\n", "intent": "create a new converter for the given arguments or raise exception if the converter does not exist .\n", "question_id": 160}, {"snippet": "def validate_kwargs(fname, kwargs, compat_args): DCNL  DCSP kwds = kwargs.copy() DCNL DCSP _check_for_invalid_keys(fname, kwargs, compat_args) DCNL DCSP _check_for_default_values(fname, kwds, compat_args)\n", "intent": "checks whether parameters passed to the **kwargs argument in a function fname are valid parameters as specified in *compat_args and whether or not they are set to their default values .\n", "question_id": 161}, {"snippet": "@keep_lazy(str, SafeText) DCNL def escape(text): DCNL  DCSP return mark_safe(force_text(text).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('\"', '&quot;').replace(\"'\", '&#39;'))\n", "intent": "returns the given text with ampersands .\n", "question_id": 162}, {"snippet": "def load_check_from_places(check_config, check_name, checks_places, agentConfig): DCNL  DCSP (load_success, load_failure) = ({}, {}) DCNL DCSP for check_path_builder in checks_places: DCNL DCSP  DCSP check_path = check_path_builder(check_name) DCNL DCSP  DCSP if (not os.path.exists(check_path)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (check_is_valid, check_class, load_failure) = get_valid_check_class(check_name, check_path) DCNL DCSP  DCSP if (not check_is_valid): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (load_success, load_failure) = _initialize_check(check_config, check_name, check_class, agentConfig) DCNL DCSP  DCSP _update_python_path(check_config) DCNL DCSP  DCSP log.debug(('Loaded DCSP %s' % check_path)) DCNL DCSP  DCSP break DCNL DCSP return (load_success, load_failure)\n", "intent": "find a check named check_name in the given checks_places and try to initialize it with the given check_config .\n", "question_id": 163}, {"snippet": "def timezone_today(): DCNL  DCSP if settings.USE_TZ: DCNL DCSP  DCSP return timezone.localtime(timezone.now()).date() DCNL DCSP else: DCNL DCSP  DCSP return datetime.date.today()\n", "intent": "return the current date in the current time zone .\n", "question_id": 164}, {"snippet": "def _get_volume_realpath(volume_file, volume_id): DCNL  DCSP try: DCNL DCSP  DCSP volume_path = os.path.realpath(volume_file.name) DCNL DCSP  DCSP volume_mode = os.stat(volume_path).st_mode DCNL DCSP  DCSP if stat.S_ISBLK(volume_mode): DCNL DCSP  DCSP  DCSP backup_mode = 'image' DCNL DCSP  DCSP elif stat.S_ISREG(volume_mode): DCNL DCSP  DCSP  DCSP backup_mode = 'file' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err = (_('backup: DCSP %(vol_id)s DCSP failed. DCSP %(path)s DCSP is DCSP unexpected DCSP file DCSP type. DCSP Block DCSP or DCSP regular DCSP files DCSP supported, DCSP actual DCSP file DCSP mode DCSP is DCSP %(vol_mode)s.') % {'vol_id': volume_id, 'path': volume_path, 'vol_mode': volume_mode}) DCNL DCSP  DCSP  DCSP LOG.error(err) DCNL DCSP  DCSP  DCSP raise exception.InvalidBackup(reason=err) DCNL DCSP except AttributeError: DCNL DCSP  DCSP err = (_('backup: DCSP %(vol_id)s DCSP failed. DCSP Cannot DCSP obtain DCSP real DCSP path DCSP to DCSP volume DCSP at DCSP %(path)s.') % {'vol_id': volume_id, 'path': volume_file}) DCNL DCSP  DCSP LOG.error(err) DCNL DCSP  DCSP raise exception.InvalidBackup(reason=err) DCNL DCSP except OSError: DCNL DCSP  DCSP err = (_('backup: DCSP %(vol_id)s DCSP failed. DCSP %(path)s DCSP is DCSP not DCSP a DCSP file.') % {'vol_id': volume_id, 'path': volume_path}) DCNL DCSP  DCSP LOG.error(err) DCNL DCSP  DCSP raise exception.InvalidBackup(reason=err) DCNL DCSP return (volume_path, backup_mode)\n", "intent": "get the real path for the volume block device .\n", "question_id": 165}, {"snippet": "@pytest.fixture DCNL def english_tutorial(english, tutorial): DCNL  DCSP return _require_tp(english, tutorial)\n", "intent": "require english tutorial .\n", "question_id": 166}, {"snippet": "def getDictionaryWithoutList(dictionary, withoutList): DCNL  DCSP dictionaryWithoutList = {} DCNL DCSP for key in dictionary: DCNL DCSP  DCSP if (key not in withoutList): DCNL DCSP  DCSP  DCSP dictionaryWithoutList[key] = dictionary[key] DCNL DCSP return dictionaryWithoutList\n", "intent": "get the dictionary without the keys in the list .\n", "question_id": 167}, {"snippet": "def to_progress_instance(progress): DCNL  DCSP if callable(progress): DCNL DCSP  DCSP return CallableRemoteProgress(progress) DCNL DCSP elif (progress is None): DCNL DCSP  DCSP return RemoteProgress() DCNL DCSP else: DCNL DCSP  DCSP return progress\n", "intent": "given the progress return a suitable object derived from remoteprogress() .\n", "question_id": 168}, {"snippet": "def bind_arguments(func, args, kwargs): DCNL  DCSP (args, kwargs, missing, extra, extra_positional, arg_spec, vararg_var, kwarg_var) = _parse_signature(func)(args, kwargs) DCNL DCSP values = {} DCNL DCSP for ((name, has_default, default), value) in zip(arg_spec, args): DCNL DCSP  DCSP values[name] = value DCNL DCSP if (vararg_var is not None): DCNL DCSP  DCSP values[vararg_var] = tuple(extra_positional) DCNL DCSP elif extra_positional: DCNL DCSP  DCSP raise TypeError('too DCSP many DCSP positional DCSP arguments') DCNL DCSP if (kwarg_var is not None): DCNL DCSP  DCSP multikw = (set(extra) & set([x[0] for x in arg_spec])) DCNL DCSP  DCSP if multikw: DCNL DCSP  DCSP  DCSP raise TypeError(('got DCSP multiple DCSP values DCSP for DCSP keyword DCSP argument DCSP ' + repr(next(iter(multikw))))) DCNL DCSP  DCSP values[kwarg_var] = extra DCNL DCSP elif extra: DCNL DCSP  DCSP raise TypeError(('got DCSP unexpected DCSP keyword DCSP argument DCSP ' + repr(next(iter(extra))))) DCNL DCSP return values\n", "intent": "bind the arguments provided into a dict .\n", "question_id": 169}, {"snippet": "@_noconds_(True) DCNL def _hankel_transform(f, r, k, nu, name, simplify=True): DCNL  DCSP from sympy import besselj DCNL DCSP F = integrate(((f * besselj(nu, (k * r))) * r), (r, 0, oo)) DCNL DCSP if (not F.has(Integral)): DCNL DCSP  DCSP return (_simplify(F, simplify), True) DCNL DCSP if (not F.is_Piecewise): DCNL DCSP  DCSP raise IntegralTransformError(name, f, 'could DCSP not DCSP compute DCSP integral') DCNL DCSP (F, cond) = F.args[0] DCNL DCSP if F.has(Integral): DCNL DCSP  DCSP raise IntegralTransformError(name, f, 'integral DCSP in DCSP unexpected DCSP form') DCNL DCSP return (_simplify(F, simplify), cond)\n", "intent": "compute a general hankel transform .\n", "question_id": 170}, {"snippet": "def test_protocol_relative(): DCNL  DCSP html = 'bad DCSP <a DCSP href=\"//ex.mp\">link</a>' DCNL DCSP expect = 'bad DCSP link' DCNL DCSP eq_(expect, bleach.delinkify(html)) DCNL DCSP eq_(expect, bleach.delinkify(html, allow_relative=True)) DCNL DCSP eq_(html, bleach.delinkify(html, allow_domains='ex.mp'))\n", "intent": "protocol-relative links arent relative .\n", "question_id": 171}, {"snippet": "def HT_TRENDMODE(ds, count): DCNL  DCSP return call_talib_with_ds(ds, count, talib.HT_TRENDMODE)\n", "intent": "hilbert transform - trend vs cycle mode .\n", "question_id": 172}, {"snippet": "def clear_session(request, *names): DCNL  DCSP for name in names: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del request.session[name] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass\n", "intent": "removes values for the given session variables names if they exist .\n", "question_id": 173}, {"snippet": "def is_ignored(path, ignore_patterns=[]): DCNL  DCSP for pattern in ignore_patterns: DCNL DCSP  DCSP if fnmatch.fnmatchcase(path, pattern): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "return true or false depending on whether the path should be ignored .\n", "question_id": 174}, {"snippet": "def writeOutput(fileName, shouldAnalyze=True): DCNL  DCSP skeinforge_craft.writeChainTextWithNounMessage(fileName, 'preface', shouldAnalyze)\n", "intent": "preface the carving of a gcode file .\n", "question_id": 175}, {"snippet": "def miller(points): DCNL  DCSP N = np.cross((points[1] - points[0]), (points[2] - points[0])) DCNL DCSP O = np.array([0, 0, 0]) DCNL DCSP P = points[0] DCNL DCSP Ccs = map(np.array, [[1.0, 0, 0], [0, 1.0, 0], [0, 0, 1.0]]) DCNL DCSP segments = [((np.dot((P - O), N) / np.dot(ort, N)) if (np.dot(ort, N) != 0) else np.nan) for ort in Ccs] DCNL DCSP if any(((x == 0) for x in segments)): DCNL DCSP  DCSP vertices = [np.array([1.0, 1.0, 1.0]), np.array([0.0, 0.0, 1.0]), np.array([1.0, 0.0, 1.0]), np.array([0.0, 1.0, 1.0]), np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]), np.array([1.0, 1.0, 1.0])] DCNL DCSP  DCSP for vertex in vertices: DCNL DCSP  DCSP  DCSP if (np.dot((vertex - O), N) != 0): DCNL DCSP  DCSP  DCSP  DCSP new_origin = vertex DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP X = np.array([(1 - new_origin[0]), new_origin[1], new_origin[2]]) DCNL DCSP  DCSP Y = np.array([new_origin[0], (1 - new_origin[1]), new_origin[2]]) DCNL DCSP  DCSP Z = np.array([new_origin[0], new_origin[1], (1 - new_origin[2])]) DCNL DCSP  DCSP new_Ccs = [(X - new_origin), (Y - new_origin), (Z - new_origin)] DCNL DCSP  DCSP segments = [((np.dot((P - new_origin), N) / np.dot(ort, N)) if (np.dot(ort, N) != 0) else np.nan) for ort in new_Ccs] DCNL DCSP  DCSP segments = ((1 - (2 * new_origin)) * segments) DCNL DCSP return sub_miller(segments)\n", "intent": "calculates miller indices from points .\n", "question_id": 176}, {"snippet": "def _ar_transparams(params): DCNL  DCSP newparams = ((1 - np.exp((- params))) / (1 + np.exp((- params)))).copy() DCNL DCSP tmp = ((1 - np.exp((- params))) / (1 + np.exp((- params)))).copy() DCNL DCSP for j in range(1, len(params)): DCNL DCSP  DCSP a = newparams[j] DCNL DCSP  DCSP for kiter in range(j): DCNL DCSP  DCSP  DCSP tmp[kiter] -= (a * newparams[((j - kiter) - 1)]) DCNL DCSP  DCSP newparams[:j] = tmp[:j] DCNL DCSP return newparams\n", "intent": "transforms params to induce stationarity/invertability .\n", "question_id": 177}, {"snippet": "def result_headers(cl): DCNL  DCSP lookup_opts = cl.lookup_opts DCNL DCSP for (i, field_name) in enumerate(cl.list_display): DCNL DCSP  DCSP (header, attr) = label_for_field(field_name, cl.model, model_admin=cl.model_admin, return_attr=True) DCNL DCSP  DCSP if attr: DCNL DCSP  DCSP  DCSP if (field_name == 'action_checkbox'): DCNL DCSP  DCSP  DCSP  DCSP (yield {'text': header, 'class_attrib': mark_safe(' DCSP class=\"action-checkbox-column\"')}) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP admin_order_field = getattr(attr, 'admin_order_field', None) DCNL DCSP  DCSP  DCSP if (not admin_order_field): DCNL DCSP  DCSP  DCSP  DCSP (yield {'text': header}) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP admin_order_field = None DCNL DCSP  DCSP th_classes = [] DCNL DCSP  DCSP new_order_type = 'asc' DCNL DCSP  DCSP if ((field_name == cl.order_field) or (admin_order_field == cl.order_field)): DCNL DCSP  DCSP  DCSP th_classes.append(('sorted DCSP %sending' % cl.order_type.lower())) DCNL DCSP  DCSP  DCSP new_order_type = {'asc': 'desc', 'desc': 'asc'}[cl.order_type.lower()] DCNL DCSP  DCSP (yield {'text': header, 'sortable': True, 'url': cl.get_query_string({ORDER_VAR: i, ORDER_TYPE_VAR: new_order_type}), 'class_attrib': mark_safe(((th_classes and (' DCSP class=\"%s\"' % ' DCSP '.join(th_classes))) or ''))})\n", "intent": "generates the list column headers .\n", "question_id": 178}, {"snippet": "def process_memory_map(attrs=None, where=None): DCNL  DCSP if (__grains__['os_family'] in ['RedHat', 'Debian']): DCNL DCSP  DCSP return _osquery_cmd(table='process_memory_map', attrs=attrs, where=where) DCNL DCSP return {'result': False, 'comment': 'Only DCSP available DCSP on DCSP Red DCSP Hat DCSP or DCSP Debian DCSP based DCSP systems.'}\n", "intent": "return process_memory_map information from osquery cli example: .\n", "question_id": 179}, {"snippet": "def _patch_stopall(): DCNL  DCSP for patch in list(_patch._active_patches): DCNL DCSP  DCSP patch.stop()\n", "intent": "stop all active patches .\n", "question_id": 180}, {"snippet": "def compute_likelihood_given_logz(nsamples, psamples, batch_size, energy_fn, inference_fn, log_z, test_x): DCNL  DCSP i = 0.0 DCNL DCSP likelihood = 0 DCNL DCSP for i in xrange(0, len(test_x), batch_size): DCNL DCSP  DCSP x = numpy.array(test_x[i:numpy.minimum(test_x.shape[0], (i + batch_size)), :], dtype=floatX) DCNL DCSP  DCSP batch_size0 = len(x) DCNL DCSP  DCSP if (len(x) < batch_size): DCNL DCSP  DCSP  DCSP x = numpy.concatenate((x, numpy.zeros(((batch_size - len(x)), x.shape[1]), dtype=floatX)), axis=0) DCNL DCSP  DCSP inference_fn(x) DCNL DCSP  DCSP hq = 0 DCNL DCSP  DCSP for psample in psamples[1:]: DCNL DCSP  DCSP  DCSP temp = (((- psample.get_value()) * numpy.log((1e-05 + psample.get_value()))) - ((1.0 - psample.get_value()) * numpy.log(((1.0 - psample.get_value()) + 1e-05)))) DCNL DCSP  DCSP  DCSP hq += numpy.sum(temp, axis=1) DCNL DCSP  DCSP nsamples[0].set_value(x) DCNL DCSP  DCSP for (ii, psample) in enumerate(psamples): DCNL DCSP  DCSP  DCSP if (ii > 0): DCNL DCSP  DCSP  DCSP  DCSP nsamples[ii].set_value(psample.get_value()) DCNL DCSP  DCSP x_likelihood = numpy.sum((((- energy_fn(1.0)) + hq) - log_z)[:batch_size0]) DCNL DCSP  DCSP likelihood = (((i * likelihood) + x_likelihood) / (i + batch_size0)) DCNL DCSP return likelihood\n", "intent": "compute test set likelihood as below .\n", "question_id": 181}, {"snippet": "def exists(container): DCNL  DCSP try: DCNL DCSP  DCSP _get_container_infos(container) DCNL DCSP  DCSP return True DCNL DCSP except Exception: DCNL DCSP  DCSP return False\n", "intent": "check if a given container exists container container id returns true if container exists otherwise returns false cli example: .\n", "question_id": 182}, {"snippet": "def compose(): DCNL  DCSP vars = request.vars DCNL DCSP if ('hrm_id' in vars): DCNL DCSP  DCSP id = vars.hrm_id DCNL DCSP  DCSP fieldname = 'hrm_id' DCNL DCSP  DCSP table = s3db.pr_person DCNL DCSP  DCSP htable = s3db.hrm_human_resource DCNL DCSP  DCSP pe_id_query = ((htable.id == id) & (htable.person_id == table.id)) DCNL DCSP  DCSP title = T('Send DCSP a DCSP message DCSP to DCSP this DCSP person') DCNL DCSP else: DCNL DCSP  DCSP session.error = T('Record DCSP not DCSP found') DCNL DCSP  DCSP redirect(URL(f='index')) DCNL DCSP pe = db(pe_id_query).select(table.pe_id, limitby=(0, 1)).first() DCNL DCSP if (not pe): DCNL DCSP  DCSP session.error = T('Record DCSP not DCSP found') DCNL DCSP  DCSP redirect(URL(f='index')) DCNL DCSP pe_id = pe.pe_id DCNL DCSP table = s3db.pr_contact DCNL DCSP contact = db((table.pe_id == pe_id)).select(table.contact_method, orderby='priority', limitby=(0, 1)).first() DCNL DCSP if contact: DCNL DCSP  DCSP s3db.msg_outbox.contact_method.default = contact.contact_method DCNL DCSP else: DCNL DCSP  DCSP session.error = T('No DCSP contact DCSP method DCSP found') DCNL DCSP  DCSP redirect(URL(f='index')) DCNL DCSP url = URL(c=module, f='compose', vars={fieldname: id}) DCNL DCSP output = msg.compose(recipient=pe_id, url=url) DCNL DCSP output['title'] = title DCNL DCSP response.view = 'msg/compose.html' DCNL DCSP return output\n", "intent": "send message to people/teams .\n", "question_id": 183}, {"snippet": "def data_profiling_required(f): DCNL  DCSP @wraps(f) DCNL DCSP def decorated_function(*args, **kwargs): DCNL DCSP  DCSP if (current_app.config['LOGIN_DISABLED'] or ((not current_user.is_anonymous()) and current_user.data_profiling())): DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flash('This DCSP page DCSP requires DCSP data DCSP profiling DCSP privileges', 'error') DCNL DCSP  DCSP  DCSP return redirect(url_for('admin.index')) DCNL DCSP return decorated_function\n", "intent": "decorator for views requiring data profiling access .\n", "question_id": 184}, {"snippet": "def metadef_object_count(context, namespace_name, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP return metadef_object_api.count(context, namespace_name, session)\n", "intent": "get count of properties for a namespace .\n", "question_id": 185}, {"snippet": "def categorical_order(values, order=None): DCNL  DCSP if (order is None): DCNL DCSP  DCSP if hasattr(values, 'categories'): DCNL DCSP  DCSP  DCSP order = values.categories DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP order = values.cat.categories DCNL DCSP  DCSP  DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP order = values.unique() DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP order = pd.unique(values) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP np.asarray(values).astype(np.float) DCNL DCSP  DCSP  DCSP  DCSP  DCSP order = np.sort(order) DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP order = order DCNL DCSP  DCSP order = filter(pd.notnull, order) DCNL DCSP return list(order)\n", "intent": "return a list of unique data values .\n", "question_id": 186}, {"snippet": "def list_queues(runas=None, *args): DCNL  DCSP if ((runas is None) and (not salt.utils.is_windows())): DCNL DCSP  DCSP runas = salt.utils.get_user() DCNL DCSP cmd = [__context__['rabbitmqctl'], 'list_queues', '-q'] DCNL DCSP cmd.extend(args) DCNL DCSP res = __salt__['cmd.run_all'](cmd, runas=runas, python_shell=False) DCNL DCSP _check_response(res) DCNL DCSP return _output_to_dict(res['stdout'])\n", "intent": "returns queue details of the / virtual host cli example: .\n", "question_id": 187}, {"snippet": "def discretize(X, method='ef', nbins=None): DCNL  DCSP nobs = len(X) DCNL DCSP if (nbins == None): DCNL DCSP  DCSP nbins = np.floor(np.sqrt(nobs)) DCNL DCSP if (method == 'ef'): DCNL DCSP  DCSP discrete = np.ceil(((nbins * stats.rankdata(X)) / nobs)) DCNL DCSP if (method == 'ew'): DCNL DCSP  DCSP width = (np.max(X) - np.min(X)) DCNL DCSP  DCSP width = np.floor((width / nbins)) DCNL DCSP  DCSP (svec, ivec) = stats.fastsort(X) DCNL DCSP  DCSP discrete = np.zeros(nobs) DCNL DCSP  DCSP binnum = 1 DCNL DCSP  DCSP base = svec[0] DCNL DCSP  DCSP discrete[ivec[0]] = binnum DCNL DCSP  DCSP for i in range(1, nobs): DCNL DCSP  DCSP  DCSP if (svec[i] < (base + width)): DCNL DCSP  DCSP  DCSP  DCSP discrete[ivec[i]] = binnum DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP base = svec[i] DCNL DCSP  DCSP  DCSP  DCSP binnum += 1 DCNL DCSP  DCSP  DCSP  DCSP discrete[ivec[i]] = binnum DCNL DCSP return discrete\n", "intent": "discretize x parameters bins : int .\n", "question_id": 188}, {"snippet": "def request(method, url, **kwargs): DCNL  DCSP if (kwargs.get('json', None) is not None): DCNL DCSP  DCSP raise exceptions.PlotlyError('V1 DCSP API DCSP does DCSP not DCSP handle DCSP arbitrary DCSP json.') DCNL DCSP kwargs['headers'] = dict(kwargs.get('headers', {}), **get_headers()) DCNL DCSP kwargs['verify'] = config.get_config()['plotly_ssl_verification'] DCNL DCSP try: DCNL DCSP  DCSP response = requests.request(method, url, **kwargs) DCNL DCSP except RequestException as e: DCNL DCSP  DCSP message = str(getattr(e, 'message', 'No DCSP message')) DCNL DCSP  DCSP response = getattr(e, 'response', None) DCNL DCSP  DCSP status_code = (response.status_code if response else None) DCNL DCSP  DCSP content = (response.content if response else 'No DCSP content') DCNL DCSP  DCSP raise exceptions.PlotlyRequestError(message, status_code, content) DCNL DCSP validate_response(response) DCNL DCSP return response\n", "intent": "central place to make any v1 api request .\n", "question_id": 189}, {"snippet": "def filter_bad_releases(name, parse=True, show=None): DCNL  DCSP try: DCNL DCSP  DCSP if parse: DCNL DCSP  DCSP  DCSP NameParser().parse(name) DCNL DCSP except InvalidNameException as error: DCNL DCSP  DCSP logger.log(u'{0}'.format(error), logger.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP except InvalidShowException: DCNL DCSP  DCSP pass DCNL DCSP ignore_words = list(resultFilters) DCNL DCSP if (show and show.rls_ignore_words): DCNL DCSP  DCSP ignore_words.extend(show.rls_ignore_words.split(',')) DCNL DCSP elif sickbeard.IGNORE_WORDS: DCNL DCSP  DCSP ignore_words.extend(sickbeard.IGNORE_WORDS.split(',')) DCNL DCSP if (show and show.rls_require_words): DCNL DCSP  DCSP ignore_words = list(set(ignore_words).difference((x.strip() for x in show.rls_require_words.split(',') if x.strip()))) DCNL DCSP elif (sickbeard.REQUIRE_WORDS and (not (show and show.rls_ignore_words))): DCNL DCSP  DCSP ignore_words = list(set(ignore_words).difference((x.strip() for x in sickbeard.REQUIRE_WORDS.split(',') if x.strip()))) DCNL DCSP word = containsAtLeastOneWord(name, ignore_words) DCNL DCSP if word: DCNL DCSP  DCSP logger.log(((((u'Release: DCSP ' + name) + ' DCSP contains DCSP ') + word) + ', DCSP ignoring DCSP it'), logger.INFO) DCNL DCSP  DCSP return False DCNL DCSP require_words = [] DCNL DCSP if (show and show.rls_require_words): DCNL DCSP  DCSP require_words.extend(show.rls_require_words.split(',')) DCNL DCSP elif sickbeard.REQUIRE_WORDS: DCNL DCSP  DCSP require_words.extend(sickbeard.REQUIRE_WORDS.split(',')) DCNL DCSP if (show and show.rls_ignore_words): DCNL DCSP  DCSP require_words = list(set(require_words).difference((x.strip() for x in show.rls_ignore_words.split(',') if x.strip()))) DCNL DCSP elif (sickbeard.IGNORE_WORDS and (not (show and show.rls_require_words))): DCNL DCSP  DCSP require_words = list(set(require_words).difference((x.strip() for x in sickbeard.IGNORE_WORDS.split(',') if x.strip()))) DCNL DCSP if (require_words and (not containsAtLeastOneWord(name, require_words))): DCNL DCSP  DCSP logger.log(((((u'Release: DCSP ' + name) + \" DCSP doesn't DCSP contain DCSP any DCSP of DCSP \") + ', DCSP '.join(set(require_words))) + ', DCSP ignoring DCSP it'), logger.INFO) DCNL DCSP  DCSP return False DCNL DCSP return True\n", "intent": "filters out non-english and just all-around stupid releases by comparing them to the resultfilters contents .\n", "question_id": 190}, {"snippet": "@task() DCNL def manage(ctx, cmd_str): DCNL  DCSP manage_cmd = os.path.join(HERE, '..', 'manage.py') DCNL DCSP env = 'DJANGO_SETTINGS_MODULE=\"admin.base.settings\"' DCNL DCSP cmd = '{} DCSP python DCSP {} DCSP {}'.format(env, manage_cmd, cmd_str) DCNL DCSP ctx.run(cmd, echo=True, pty=True)\n", "intent": "take command string for manage commands .\n", "question_id": 191}, {"snippet": "@_refresh_mine_cache DCNL @_api_version(1.12) DCNL @_ensure_exists DCNL def pause(name): DCNL  DCSP orig_state = state(name) DCNL DCSP if (orig_state == 'stopped'): DCNL DCSP  DCSP return {'result': False, 'state': {'old': orig_state, 'new': orig_state}, 'comment': \"Container DCSP '{0}' DCSP is DCSP stopped, DCSP cannot DCSP pause\".format(name)} DCNL DCSP return _change_state(name, 'pause', 'paused')\n", "intent": "pauses a container name container name or id **return data** a dictionary will be returned .\n", "question_id": 192}, {"snippet": "def relevant_issues(issues, after): DCNL  DCSP logging.info('finding DCSP relevant DCSP issues DCSP after DCSP {}...'.format(after)) DCNL DCSP seen = set() DCNL DCSP for issue in issues: DCNL DCSP  DCSP if (relevent_issue(issue, after) and (issue['title'] not in seen)): DCNL DCSP  DCSP  DCSP seen.add(issue['title']) DCNL DCSP  DCSP  DCSP (yield issue)\n", "intent": "yields relevant closed issues  given a list of issues .\n", "question_id": 193}, {"snippet": "def _parse_optional(fh): DCNL  DCSP optional = {'StartKernData': _parse_kern_pairs, 'StartComposites': _parse_composites} DCNL DCSP d = {'StartKernData': {}, 'StartComposites': {}} DCNL DCSP for line in fh: DCNL DCSP  DCSP line = line.rstrip() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP key = line.split()[0] DCNL DCSP  DCSP if (key in optional): DCNL DCSP  DCSP  DCSP d[key] = optional[key](fh) DCNL DCSP l = (d['StartKernData'], d['StartComposites']) DCNL DCSP return l\n", "intent": "parse the optional fields for kern pair data and composites return value is a  which are the return values from :func:_parse_kern_pairs .\n", "question_id": 194}, {"snippet": "@task DCNL def server(ctx, host=None, port=5000, debug=True, gitlogs=False): DCNL  DCSP if ((os.environ.get('WERKZEUG_RUN_MAIN') == 'true') or (not debug)): DCNL DCSP  DCSP if os.environ.get('WEB_REMOTE_DEBUG', None): DCNL DCSP  DCSP  DCSP import pydevd DCNL DCSP  DCSP  DCSP remote_parts = os.environ.get('WEB_REMOTE_DEBUG').split(':') DCNL DCSP  DCSP  DCSP pydevd.settrace(remote_parts[0], port=int(remote_parts[1]), suspend=False, stdoutToServer=True, stderrToServer=True) DCNL DCSP  DCSP if gitlogs: DCNL DCSP  DCSP  DCSP git_logs(ctx) DCNL DCSP  DCSP from website.app import init_app DCNL DCSP  DCSP os.environ['DJANGO_SETTINGS_MODULE'] = 'api.base.settings' DCNL DCSP  DCSP app = init_app(set_backends=True, routes=True) DCNL DCSP  DCSP settings.API_SERVER_PORT = port DCNL DCSP else: DCNL DCSP  DCSP from framework.flask import app DCNL DCSP context = None DCNL DCSP if settings.SECURE_MODE: DCNL DCSP  DCSP context = (settings.OSF_SERVER_CERT, settings.OSF_SERVER_KEY) DCNL DCSP app.run(host=host, port=port, debug=debug, threaded=debug, extra_files=[settings.ASSET_HASH_PATH], ssl_context=context)\n", "intent": "run the app server .\n", "question_id": 195}, {"snippet": "def verify_challenge(uri): DCNL  DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP resp = urlopen(uri) DCNL DCSP  DCSP  DCSP challenge_status = json.loads(resp.read().decode('utf8')) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP raise ValueError('Error DCSP checking DCSP challenge: DCSP {0} DCSP {1}'.format(e.code, json.loads(e.read().decode('utf8')))) DCNL DCSP  DCSP if (challenge_status['status'] == 'pending'): DCNL DCSP  DCSP  DCSP time.sleep(2) DCNL DCSP  DCSP elif (challenge_status['status'] == 'valid'): DCNL DCSP  DCSP  DCSP LOGGER.info('Domain DCSP verified!') DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('Domain DCSP challenge DCSP did DCSP not DCSP pass: DCSP {0}'.format(challenge_status))\n", "intent": "loop until our challenge is verified .\n", "question_id": 196}, {"snippet": "def _nsort(roots, separated=False): DCNL  DCSP if (not all((r.is_number for r in roots))): DCNL DCSP  DCSP raise NotImplementedError DCNL DCSP key = [[i.n(2).as_real_imag()[0] for i in r.as_real_imag()] for r in roots] DCNL DCSP if any(((i._prec == 1) for k in key for i in k)): DCNL DCSP  DCSP raise NotImplementedError('could DCSP not DCSP compute DCSP root DCSP with DCSP precision') DCNL DCSP key = [((1 if i else 0), r, i) for (r, i) in key] DCNL DCSP key = sorted(zip(key, roots)) DCNL DCSP if separated: DCNL DCSP  DCSP r = [] DCNL DCSP  DCSP i = [] DCNL DCSP  DCSP for ((im, _, _), v) in key: DCNL DCSP  DCSP  DCSP if im: DCNL DCSP  DCSP  DCSP  DCSP i.append(v) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP r.append(v) DCNL DCSP  DCSP return (r, i) DCNL DCSP (_, roots) = zip(*key) DCNL DCSP return list(roots)\n", "intent": "sort the numerical roots putting the real roots first .\n", "question_id": 197}, {"snippet": "def print_usage(actions): DCNL  DCSP _deprecated() DCNL DCSP actions = sorted(iteritems(actions)) DCNL DCSP print(('usage: DCSP %s DCSP <action> DCSP [<options>]' % basename(sys.argv[0]))) DCNL DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s DCSP --help' % basename(sys.argv[0]))) DCNL DCSP print() DCNL DCSP print('actions:') DCNL DCSP for (name, (func, doc, arguments)) in actions: DCNL DCSP  DCSP print((' DCSP  DCSP %s:' % name)) DCNL DCSP  DCSP for line in doc.splitlines(): DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP %s' % line)) DCNL DCSP  DCSP if arguments: DCNL DCSP  DCSP  DCSP print() DCNL DCSP  DCSP for (arg, shortcut, default, argtype) in arguments: DCNL DCSP  DCSP  DCSP if isinstance(default, bool): DCNL DCSP  DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP %s' % ((((shortcut and ('-%s, DCSP ' % shortcut)) or '') + '--') + arg))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP %-30s%-10s%s' % (((((shortcut and ('-%s, DCSP ' % shortcut)) or '') + '--') + arg), argtype, default))) DCNL DCSP  DCSP print()\n", "intent": "print the usage information .\n", "question_id": 198}, {"snippet": "def filesizeformat(bytes): DCNL  DCSP try: DCNL DCSP  DCSP bytes = float(bytes) DCNL DCSP except (TypeError, ValueError, UnicodeDecodeError): DCNL DCSP  DCSP return (ungettext('%(size)d DCSP byte', '%(size)d DCSP bytes', 0) % {'size': 0}) DCNL DCSP filesize_number_format = (lambda value: formats.number_format(round(value, 1), 1)) DCNL DCSP if (bytes < 1024): DCNL DCSP  DCSP return (ungettext('%(size)d DCSP byte', '%(size)d DCSP bytes', bytes) % {'size': bytes}) DCNL DCSP if (bytes < (1024 * 1024)): DCNL DCSP  DCSP return (ugettext('%s DCSP KB') % filesize_number_format((bytes / 1024))) DCNL DCSP if (bytes < ((1024 * 1024) * 1024)): DCNL DCSP  DCSP return (ugettext('%s DCSP MB') % filesize_number_format((bytes / (1024 * 1024)))) DCNL DCSP return (ugettext('%s DCSP GB') % filesize_number_format((bytes / ((1024 * 1024) * 1024))))\n", "intent": "formats the value like a human-readable file size .\n", "question_id": 199}, {"snippet": "def file_dict(*packages): DCNL  DCSP errors = [] DCNL DCSP ret = {} DCNL DCSP cmd = ['pacman', '-Ql'] DCNL DCSP if ((len(packages) > 0) and os.path.exists(packages[0])): DCNL DCSP  DCSP packages = list(packages) DCNL DCSP  DCSP cmd.extend(('-r', packages.pop(0))) DCNL DCSP cmd.extend(packages) DCNL DCSP out = __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False) DCNL DCSP for line in salt.utils.itertools.split(out, '\\n'): DCNL DCSP  DCSP if line.startswith('error'): DCNL DCSP  DCSP  DCSP errors.append(line) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP comps = line.split() DCNL DCSP  DCSP  DCSP if (not (comps[0] in ret)): DCNL DCSP  DCSP  DCSP  DCSP ret[comps[0]] = [] DCNL DCSP  DCSP  DCSP ret[comps[0]].append(' DCSP '.join(comps[1:])) DCNL DCSP return {'errors': errors, 'packages': ret}\n", "intent": "list the files that belong to a package .\n", "question_id": 200}, {"snippet": "def device_memset(dst, val, size, stream=0): DCNL  DCSP varargs = [] DCNL DCSP if stream: DCNL DCSP  DCSP assert isinstance(stream, Stream) DCNL DCSP  DCSP fn = driver.cuMemsetD8Async DCNL DCSP  DCSP varargs.append(stream.handle) DCNL DCSP else: DCNL DCSP  DCSP fn = driver.cuMemsetD8 DCNL DCSP fn(device_pointer(dst), val, size, *varargs)\n", "intent": "memset on the device .\n", "question_id": 201}, {"snippet": "def success_installation(domains): DCNL  DCSP z_util(interfaces.IDisplay).notification('Congratulations! DCSP You DCSP have DCSP successfully DCSP enabled DCSP {0}{1}{1}You DCSP should DCSP test DCSP your DCSP configuration DCSP at:{1}{2}'.format(_gen_https_names(domains), os.linesep, os.linesep.join(_gen_ssl_lab_urls(domains))), pause=False)\n", "intent": "display a box confirming the installation of https .\n", "question_id": 202}, {"snippet": "def _fastq_sanger_convert_qual(in_handle, out_handle, alphabet=None): DCNL  DCSP mapping = dict(((chr((q + 33)), str(q)) for q in range(0, (93 + 1)))) DCNL DCSP return _fastq_convert_qual(in_handle, out_handle, mapping)\n", "intent": "fast sanger fastq to qual conversion .\n", "question_id": 203}, {"snippet": "def getBottomPaths(paths): DCNL  DCSP bottom = 999999999.9 DCNL DCSP for path in paths: DCNL DCSP  DCSP for point in path: DCNL DCSP  DCSP  DCSP bottom = min(bottom, point.z) DCNL DCSP return bottom\n", "intent": "get the bottom of the paths .\n", "question_id": 204}, {"snippet": "def detect_snappy(contents): DCNL  DCSP try: DCNL DCSP  DCSP import snappy DCNL DCSP  DCSP return snappy.isValidCompressed(contents) DCNL DCSP except: DCNL DCSP  DCSP logging.exception('failed DCSP to DCSP detect DCSP snappy') DCNL DCSP  DCSP return False\n", "intent": "this is a silly small function which checks to see if the file is snappy .\n", "question_id": 205}, {"snippet": "def getLoopsDifference(importRadius, loopLists): DCNL  DCSP halfImportRadius = (0.5 * importRadius) DCNL DCSP radiusSide = (0.01 * importRadius) DCNL DCSP negativeLoops = getLoopsUnion(importRadius, loopLists[1:]) DCNL DCSP intercircle.directLoops(False, negativeLoops) DCNL DCSP positiveLoops = loopLists[0] DCNL DCSP intercircle.directLoops(True, positiveLoops) DCNL DCSP corners = getInsetPointsByInsetLoops(negativeLoops, True, positiveLoops, radiusSide) DCNL DCSP corners += getInsetPointsByInsetLoops(positiveLoops, False, negativeLoops, radiusSide) DCNL DCSP allPoints = corners[:] DCNL DCSP allPoints += getInsetPointsByInsetLoops(getInBetweenLoopsFromLoops(negativeLoops, halfImportRadius), True, positiveLoops, radiusSide) DCNL DCSP allPoints += getInsetPointsByInsetLoops(getInBetweenLoopsFromLoops(positiveLoops, halfImportRadius), False, negativeLoops, radiusSide) DCNL DCSP return triangle_mesh.getDescendingAreaOrientedLoops(allPoints, corners, importRadius)\n", "intent": "get difference loops .\n", "question_id": 206}, {"snippet": "def test_fontconfig_preamble(): DCNL  DCSP plt.rcParams[u'text.usetex'] = True DCNL DCSP tm1 = TexManager() DCNL DCSP font_config1 = tm1.get_font_config() DCNL DCSP plt.rcParams[u'text.latex.preamble'] = [u'\\\\usepackage{txfonts}'] DCNL DCSP tm2 = TexManager() DCNL DCSP font_config2 = tm2.get_font_config() DCNL DCSP assert (font_config1 != font_config2)\n", "intent": "test that the preamble is included in _fontconfig .\n", "question_id": 207}, {"snippet": "def _SendRecv(): DCNL  DCSP port = int(os.getenv(DEVSHELL_ENV, 0)) DCNL DCSP if (port == 0): DCNL DCSP  DCSP raise NoDevshellServer() DCNL DCSP import socket DCNL DCSP sock = socket.socket() DCNL DCSP sock.connect(('localhost', port)) DCNL DCSP data = CREDENTIAL_INFO_REQUEST_JSON DCNL DCSP msg = ('%s\\n%s' % (len(data), data)) DCNL DCSP sock.sendall(msg.encode()) DCNL DCSP header = sock.recv(6).decode() DCNL DCSP if ('\\n' not in header): DCNL DCSP  DCSP raise CommunicationError('saw DCSP no DCSP newline DCSP in DCSP the DCSP first DCSP 6 DCSP bytes') DCNL DCSP (len_str, json_str) = header.split('\\n', 1) DCNL DCSP to_read = (int(len_str) - len(json_str)) DCNL DCSP if (to_read > 0): DCNL DCSP  DCSP json_str += sock.recv(to_read, socket.MSG_WAITALL).decode() DCNL DCSP return CredentialInfoResponse(json_str)\n", "intent": "communicate with the developer shell server socket .\n", "question_id": 208}, {"snippet": "def validate_textbooks_json(text): DCNL  DCSP try: DCNL DCSP  DCSP textbooks = json.loads(text) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise TextbookValidationError('invalid DCSP JSON') DCNL DCSP if (not isinstance(textbooks, (list, tuple))): DCNL DCSP  DCSP raise TextbookValidationError('must DCSP be DCSP JSON DCSP list') DCNL DCSP for textbook in textbooks: DCNL DCSP  DCSP validate_textbook_json(textbook) DCNL DCSP all_ids = [textbook['id'] for textbook in textbooks if ('id' in textbook)] DCNL DCSP unique_ids = set(all_ids) DCNL DCSP if (len(all_ids) > len(unique_ids)): DCNL DCSP  DCSP raise TextbookValidationError('IDs DCSP must DCSP be DCSP unique') DCNL DCSP return textbooks\n", "intent": "validate the given text as representing a single pdf textbook .\n", "question_id": 209}, {"snippet": "def vdot(a, b): DCNL  DCSP if (a.size != b.size): DCNL DCSP  DCSP raise ValueError('Axis DCSP dimension DCSP mismatch') DCNL DCSP return core.tensordot_core(a, b, None, 1, 1, a.size, ())\n", "intent": "returns the dot product of two vectors .\n", "question_id": 210}, {"snippet": "def ValidHeadersRewriter(response): DCNL  DCSP for (key, value) in response.headers.items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP key.decode('ascii') DCNL DCSP  DCSP  DCSP value.decode('ascii') DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP del response.headers[key]\n", "intent": "remove invalid response headers .\n", "question_id": 211}, {"snippet": "@register.filter DCNL def sort_by(items, attr): DCNL  DCSP def key_func(item): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(item, attr) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return item[attr] DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP getattr(item, attr) DCNL DCSP return sorted(items, key=key_func)\n", "intent": "general sort filter - sorts by either attribute or key .\n", "question_id": 212}, {"snippet": "def test_oldclass_and_direct(): DCNL  DCSP class OldStyle: DCNL DCSP  DCSP def __getitem__(self, index): DCNL DCSP  DCSP  DCSP return index DCNL DCSP class OldStyleWithLen: DCNL DCSP  DCSP def __getitem__(self, index): DCNL DCSP  DCSP  DCSP return index DCNL DCSP  DCSP def __len__(self): DCNL DCSP  DCSP  DCSP return 10 DCNL DCSP class NewStyle(object, ): DCNL DCSP  DCSP def __getitem__(self, index): DCNL DCSP  DCSP  DCSP return index DCNL DCSP class OldStyleWithLenAndGetSlice: DCNL DCSP  DCSP def __getitem__(self, index): DCNL DCSP  DCSP  DCSP return index DCNL DCSP  DCSP def __len__(self): DCNL DCSP  DCSP  DCSP return 10 DCNL DCSP  DCSP def __getslice__(self, start, stop): DCNL DCSP  DCSP  DCSP return (start, stop) DCNL DCSP AreEqual(NewStyle()[slice(None, (-1), None)], slice(None, (-1), None)) DCNL DCSP AreEqual(OldStyleWithLen()[slice(None, (-1), None)], slice(None, (-1), None)) DCNL DCSP AreEqual(OldStyle()[slice(None, (-1), None)], slice(None, (-1), None)) DCNL DCSP AreEqual(OldStyleWithLenAndGetSlice()[slice(None, (-1), None)], slice(None, (-1), None)) DCNL DCSP AreEqual(NewStyle()[:(-1)], slice(None, (-1), None)) DCNL DCSP AreEqual(OldStyleWithLen()[:(-1)], slice(0, 9, None)) DCNL DCSP AreEqual(OldStyleWithLenAndGetSlice()[:(-1)], (0, 9)) DCNL DCSP AreEqual(OldStyle()[:(-1):1], slice(None, (-1), 1)) DCNL DCSP try: DCNL DCSP  DCSP (OldStyle()[:(-1)],) DCNL DCSP  DCSP AssertUnreachable() DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP (OldStyle()[(-1):],) DCNL DCSP  DCSP AssertUnreachable() DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP for (x, y) in [((-1), (-1)), ((-2), 0), (0, (-2)), ((-2), (-2))]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (OldStyle()[x:y],) DCNL DCSP  DCSP  DCSP AssertUnreachable() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP AreEqual(OldStyle()[:(-1):None], slice(None, (-1), None)) DCNL DCSP AreEqual(OldStyle()[(-1)::None], slice((-1), None, None)) DCNL DCSP AreEqual(OldStyle()[:(-1):None], slice(None, (-1), None)) DCNL DCSP AreEqual(OldStyle()[(-1)::None], slice((-1), None, None))\n", "intent": "tests slicing oldinstances and directly passing a slice object .\n", "question_id": 213}, {"snippet": "def S_ISGITLINK(m): DCNL  DCSP return (stat.S_IFMT(m) == S_IFGITLINK)\n", "intent": "check if a mode indicates a submodule .\n", "question_id": 214}, {"snippet": "def _full_live_path(cli_config, lineagename): DCNL  DCSP return os.path.join(cli_config.live_dir, lineagename)\n", "intent": "returns the full default live path for a lineagename .\n", "question_id": 215}, {"snippet": "def extraneous_whitespace(logical_line): DCNL  DCSP line = logical_line DCNL DCSP for match in EXTRANEOUS_WHITESPACE_REGEX.finditer(line): DCNL DCSP  DCSP text = match.group() DCNL DCSP  DCSP char = text.strip() DCNL DCSP  DCSP found = match.start() DCNL DCSP  DCSP if (text == (char + ' DCSP ')): DCNL DCSP  DCSP  DCSP (yield ((found + 1), (\"E201 DCSP whitespace DCSP after DCSP '%s'\" % char))) DCNL DCSP  DCSP elif (line[(found - 1)] != ','): DCNL DCSP  DCSP  DCSP code = ('E202' if (char in '}])') else 'E203') DCNL DCSP  DCSP  DCSP (yield (found, (\"%s DCSP whitespace DCSP before DCSP '%s'\" % (code, char))))\n", "intent": "avoid extraneous whitespace .\n", "question_id": 216}, {"snippet": "def cnv_NCName(attribute, arg, element): DCNL  DCSP if isinstance(arg, str): DCNL DCSP  DCSP return make_NCName(arg) DCNL DCSP else: DCNL DCSP  DCSP return arg.getAttrNS(STYLENS, 'name')\n", "intent": "ncname is defined in URL#nt-ncname essentially an xml name minus : .\n", "question_id": 217}, {"snippet": "def atq(tag=None): DCNL  DCSP jobs = [] DCNL DCSP res = __salt__['cmd.run_all']('atq') DCNL DCSP if (res['retcode'] > 0): DCNL DCSP  DCSP return {'error': res['stderr']} DCNL DCSP if (res['stdout'] == 'no DCSP files DCSP in DCSP queue.'): DCNL DCSP  DCSP return {'jobs': jobs} DCNL DCSP job_kw_regex = re.compile('^### DCSP SALT: DCSP (\\\\w+)') DCNL DCSP for line in res['stdout'].splitlines(): DCNL DCSP  DCSP job_tag = '' DCNL DCSP  DCSP if line.startswith(' DCSP Rank'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tmp = line.split() DCNL DCSP  DCSP timestr = ' DCSP '.join(tmp[1:5]) DCNL DCSP  DCSP job = tmp[6] DCNL DCSP  DCSP specs = datetime.datetime(*time.strptime(timestr, '%b DCSP %d, DCSP %Y DCSP %H:%M')[0:5]).isoformat().split('T') DCNL DCSP  DCSP specs.append(tmp[7]) DCNL DCSP  DCSP specs.append(tmp[5]) DCNL DCSP  DCSP job = str(job) DCNL DCSP  DCSP atjob_file = '/var/spool/cron/atjobs/{job}'.format(job=job) DCNL DCSP  DCSP if __salt__['file.file_exists'](atjob_file): DCNL DCSP  DCSP  DCSP with salt.utils.fopen(atjob_file, 'r') as atjob: DCNL DCSP  DCSP  DCSP  DCSP for line in atjob: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmp = job_kw_regex.match(line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if tmp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP job_tag = tmp.groups()[0] DCNL DCSP  DCSP if (not tag): DCNL DCSP  DCSP  DCSP jobs.append({'job': job, 'date': specs[0], 'time': specs[1], 'queue': specs[2], 'user': specs[3], 'tag': job_tag}) DCNL DCSP  DCSP elif (tag and (tag in [job_tag, job])): DCNL DCSP  DCSP  DCSP jobs.append({'job': job, 'date': specs[0], 'time': specs[1], 'queue': specs[2], 'user': specs[3], 'tag': job_tag}) DCNL DCSP return {'jobs': jobs}\n", "intent": "list all queued and running jobs or only those with an optional tag .\n", "question_id": 218}, {"snippet": "def empty_if_none(fn): DCNL  DCSP def wrapper(value): DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP return fn(value) DCNL DCSP return wrapper\n", "intent": "a wrapper for a value to return  if its none .\n", "question_id": 219}, {"snippet": "def _map_port_from_yaml_to_docker(port): DCNL  DCSP if isinstance(port, six.string_types): DCNL DCSP  DCSP (port, sep, protocol) = port.partition('/') DCNL DCSP  DCSP if protocol: DCNL DCSP  DCSP  DCSP return (int(port), protocol) DCNL DCSP  DCSP return int(port) DCNL DCSP return port\n", "intent": "docker-py interface is not very nice: while for port_bindings they support: .\n", "question_id": 220}, {"snippet": "@main.command() DCNL @url_option DCNL @click.option(u'--all', u'-a', is_flag=True, help=u'Empty DCSP all DCSP queues') DCNL @click.argument(u'queues', nargs=(-1)) DCNL def empty(url, all, queues): DCNL  DCSP conn = connect(url) DCNL DCSP if all: DCNL DCSP  DCSP queues = Queue.all(connection=conn) DCNL DCSP else: DCNL DCSP  DCSP queues = [Queue(queue, connection=conn) for queue in queues] DCNL DCSP if (not queues): DCNL DCSP  DCSP click.echo(u'Nothing DCSP to DCSP do') DCNL DCSP for queue in queues: DCNL DCSP  DCSP num_jobs = queue.empty() DCNL DCSP  DCSP click.echo(u'{0} DCSP jobs DCSP removed DCSP from DCSP {1} DCSP queue'.format(num_jobs, queue.name))\n", "intent": "empty given queues .\n", "question_id": 221}, {"snippet": "def qiime_open(fp, permission='U'): DCNL  DCSP if is_gzip(fp): DCNL DCSP  DCSP return gzip_open(fp) DCNL DCSP else: DCNL DCSP  DCSP return open(fp, permission)\n", "intent": "wrapper to allow opening of gzipped or non-compressed files read or write the contents of a file file_fp : file path permission : either r .\n", "question_id": 222}, {"snippet": "def _parse_settings_eth(opts, iface_type, enabled, iface): DCNL  DCSP adapters = salt.utils.odict.OrderedDict() DCNL DCSP adapters[iface] = salt.utils.odict.OrderedDict() DCNL DCSP adapters[iface]['type'] = iface_type DCNL DCSP adapters[iface]['data'] = salt.utils.odict.OrderedDict() DCNL DCSP iface_data = adapters[iface]['data'] DCNL DCSP iface_data['inet'] = salt.utils.odict.OrderedDict() DCNL DCSP iface_data['inet6'] = salt.utils.odict.OrderedDict() DCNL DCSP if enabled: DCNL DCSP  DCSP adapters[iface]['enabled'] = True DCNL DCSP if opts.get('hotplug', False): DCNL DCSP  DCSP adapters[iface]['hotplug'] = True DCNL DCSP def_addrfam = 'inet' DCNL DCSP dual_stack = False DCNL DCSP if (('enable_ipv6' in opts) and opts['enable_ipv6']): DCNL DCSP  DCSP iface_data['inet6']['addrfam'] = 'inet6' DCNL DCSP  DCSP iface_data['inet6']['netmask'] = '64' DCNL DCSP  DCSP def_addrfam = 'inet6' DCNL DCSP  DCSP if (('iface_type' in opts) and (opts['iface_type'] == 'vlan')): DCNL DCSP  DCSP  DCSP iface_data['inet6']['vlan_raw_device'] = re.sub('\\\\.\\\\d*', '', iface) DCNL DCSP  DCSP if (('ipaddr' in opts) and ('ipv6ipaddr' in opts)): DCNL DCSP  DCSP  DCSP iface_data['inet']['addrfam'] = 'inet' DCNL DCSP  DCSP  DCSP def_addrfam = 'inet' DCNL DCSP  DCSP  DCSP dual_stack = True DCNL DCSP else: DCNL DCSP  DCSP iface_data['inet']['addrfam'] = 'inet' DCNL DCSP if (iface_type not in ['bridge']): DCNL DCSP  DCSP tmp_ethtool = _parse_ethtool_opts(opts, iface) DCNL DCSP  DCSP if tmp_ethtool: DCNL DCSP  DCSP  DCSP ethtool = {} DCNL DCSP  DCSP  DCSP for item in tmp_ethtool: DCNL DCSP  DCSP  DCSP  DCSP ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item] DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['ethtool'] = ethtool DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['ethtool_keys'] = sorted(ethtool) DCNL DCSP if (iface_type == 'bridge'): DCNL DCSP  DCSP bridging = _parse_bridge_opts(opts, iface) DCNL DCSP  DCSP if bridging: DCNL DCSP  DCSP  DCSP opts.pop('mode', None) DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['bridging'] = bridging DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['bridging_keys'] = sorted(bridging) DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['addrfam'] = def_addrfam DCNL DCSP elif (iface_type == 'bond'): DCNL DCSP  DCSP bonding = _parse_settings_bond(opts, iface) DCNL DCSP  DCSP if bonding: DCNL DCSP  DCSP  DCSP opts.pop('mode', None) DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['bonding'] = bonding DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['bonding']['slaves'] = opts['slaves'] DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['bonding_keys'] = sorted(bonding) DCNL DCSP  DCSP  DCSP iface_data[def_addrfam]['addrfam'] = def_addrfam DCNL DCSP elif (iface_type == 'slave'): DCNL DCSP  DCSP adapters[iface]['master'] = opts['master'] DCNL DCSP  DCSP opts['proto'] = 'manual' DCNL DCSP  DCSP iface_data[def_addrfam]['master'] = adapters[iface]['master'] DCNL DCSP  DCSP iface_data[def_addrfam]['addrfam'] = def_addrfam DCNL DCSP elif (iface_type == 'vlan'): DCNL DCSP  DCSP iface_data[def_addrfam]['vlan_raw_device'] = re.sub('\\\\.\\\\d*', '', iface) DCNL DCSP  DCSP iface_data[def_addrfam]['addrfam'] = def_addrfam DCNL DCSP elif (iface_type == 'pppoe'): DCNL DCSP  DCSP tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface) DCNL DCSP  DCSP if tmp_ethtool: DCNL DCSP  DCSP  DCSP for item in tmp_ethtool: DCNL DCSP  DCSP  DCSP  DCSP adapters[iface]['data'][def_addrfam][_DEB_CONFIG_PPPOE_OPTS[item]] = tmp_ethtool[item] DCNL DCSP  DCSP iface_data[def_addrfam]['addrfam'] = def_addrfam DCNL DCSP for opt in opts: DCNL DCSP  DCSP if opt.startswith('ipv6'): DCNL DCSP  DCSP  DCSP optname = opt[4:] DCNL DCSP  DCSP  DCSP v6only = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP optname = opt DCNL DCSP  DCSP  DCSP v6only = False DCNL DCSP  DCSP _optname = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(optname, optname) DCNL DCSP  DCSP if _attrmaps_contain_attr(_optname): DCNL DCSP  DCSP  DCSP valuestr = opts[opt] DCNL DCSP  DCSP  DCSP if ((optname == 'proto') and (valuestr == 'none')): DCNL DCSP  DCSP  DCSP  DCSP valuestr = 'static' DCNL DCSP  DCSP  DCSP if v6only: DCNL DCSP  DCSP  DCSP  DCSP (valid, value, errmsg) = _validate_interface_option(_optname, valuestr, addrfam='inet6') DCNL DCSP  DCSP  DCSP  DCSP if (not valid): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _raise_error_iface(iface, \"'{0}' DCSP '{1}'\".format(opt, valuestr), [errmsg]) DCNL DCSP  DCSP  DCSP  DCSP _optname = _optname.replace('-', '_') DCNL DCSP  DCSP  DCSP  DCSP iface_data['inet6'][_optname] = value DCNL DCSP  DCSP  DCSP elif dual_stack: DCNL DCSP  DCSP  DCSP  DCSP valid_once = False DCNL DCSP  DCSP  DCSP  DCSP errmsg = None DCNL DCSP  DCSP  DCSP  DCSP for addrfam in ['inet', 'inet6']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (valid, value, errmsg) = _validate_interface_option(_optname, valuestr, addrfam=addrfam) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if valid: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP valid_once = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _optname = _optname.replace('-', '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((addrfam == 'inet') or (_optname not in iface_data['inet6'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iface_data[addrfam][_optname] = value DCNL DCSP  DCSP  DCSP  DCSP if (not valid_once): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _raise_error_iface(iface, \"'{0}' DCSP '{1}'\".format(opt, valuestr), [errmsg]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (valid, value, errmsg) = _validate_interface_option(_optname, valuestr, addrfam=def_addrfam) DCNL DCSP  DCSP  DCSP  DCSP if (not valid): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _raise_error_iface(iface, \"'{0}' DCSP '{1}'\".format(opt, valuestr), [errmsg]) DCNL DCSP  DCSP  DCSP  DCSP _optname = _optname.replace('-', '_') DCNL DCSP  DCSP  DCSP  DCSP iface_data[def_addrfam][_optname] = value DCNL DCSP for opt in ['up_cmds', 'pre_up_cmds', 'post_up_cmds', 'down_cmds', 'pre_down_cmds', 'post_down_cmds']: DCNL DCSP  DCSP if (opt in opts): DCNL DCSP  DCSP  DCSP iface_data['inet'][opt] = opts[opt] DCNL DCSP for addrfam in ['inet', 'inet6']: DCNL DCSP  DCSP if (('addrfam' in iface_data[addrfam]) and (iface_data[addrfam]['addrfam'] == addrfam)): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP iface_data.pop(addrfam) DCNL DCSP return adapters\n", "intent": "filters given options and outputs valid settings for a network interface .\n", "question_id": 223}, {"snippet": "def modify_cache_subnet_group(name, subnets=None, region=None, key=None, keyid=None, profile=None, **args): DCNL  DCSP if subnets: DCNL DCSP  DCSP if ('SubnetIds' not in args): DCNL DCSP  DCSP  DCSP args['SubnetIds'] = [] DCNL DCSP  DCSP if (not isinstance(subnets, list)): DCNL DCSP  DCSP  DCSP subnets = [subnets] DCNL DCSP  DCSP for subnet in subnets: DCNL DCSP  DCSP  DCSP sn = __salt__['boto_vpc.describe_subnets'](subnet_names=subnet, region=region, key=key, keyid=keyid, profile=profile).get('subnets') DCNL DCSP  DCSP  DCSP if (len(sn) == 1): DCNL DCSP  DCSP  DCSP  DCSP args['SubnetIds'] += [sn[0]['id']] DCNL DCSP  DCSP  DCSP elif (len(sn) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise CommandExecutionError('Subnet DCSP Name DCSP {0} DCSP returned DCSP more DCSP than DCSP one DCSP ID.'.format(subnet)) DCNL DCSP  DCSP  DCSP elif subnet.startswith('subnet-'): DCNL DCSP  DCSP  DCSP  DCSP args['SubnetIds'] += [subnet] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SaltInvocationError('Could DCSP not DCSP resolve DCSP Subnet DCSP Name DCSP {0} DCSP to DCSP an DCSP ID.'.format(subnet)) DCNL DCSP args = dict([(k, v) for (k, v) in args.items() if (not k.startswith('_'))]) DCNL DCSP return _modify_resource(name, name_param='CacheSubnetGroupName', desc='cache DCSP subnet DCSP group', res_type='cache_subnet_group', region=region, key=key, keyid=keyid, profile=profile, **args)\n", "intent": "modify an elasticache subnet group example: .\n", "question_id": 224}, {"snippet": "def convert_DateProperty(model, prop, kwargs): DCNL  DCSP if (prop.auto_now or prop.auto_now_add): DCNL DCSP  DCSP return None DCNL DCSP return f.DateField(format='%Y-%m-%d', **kwargs)\n", "intent": "returns a form field for a db .\n", "question_id": 225}, {"snippet": "def setup(product_name): DCNL  DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)\n", "intent": "setup logging .\n", "question_id": 226}, {"snippet": "def get_upload_pipeline(in_fd, out_fd, rate_limit=None, gpg_key=None, lzop=True): DCNL  DCSP commands = [] DCNL DCSP if (rate_limit is not None): DCNL DCSP  DCSP commands.append(PipeViewerRateLimitFilter(rate_limit)) DCNL DCSP if lzop: DCNL DCSP  DCSP commands.append(LZOCompressionFilter()) DCNL DCSP if (gpg_key is not None): DCNL DCSP  DCSP commands.append(GPGEncryptionFilter(gpg_key)) DCNL DCSP return Pipeline(commands, in_fd, out_fd)\n", "intent": "create a unix pipeline to process a file for uploading .\n", "question_id": 227}, {"snippet": "def episode_num(season=None, episode=None, **kwargs): DCNL  DCSP numbering = kwargs.pop(u'numbering', u'standard') DCNL DCSP if (numbering == u'standard'): DCNL DCSP  DCSP if ((season is not None) and episode): DCNL DCSP  DCSP  DCSP return u'S{0:0>2}E{1:02}'.format(season, episode) DCNL DCSP elif (numbering == u'absolute'): DCNL DCSP  DCSP if ((not (season and episode)) and (season or episode)): DCNL DCSP  DCSP  DCSP return u'{0:0>3}'.format((season or episode))\n", "intent": "convert season and episode into string .\n", "question_id": 228}, {"snippet": "@register.simple_tag(takes_context=True) DCNL def avatar_url(context, user, size, resolution=u'1x', service_id=None): DCNL  DCSP if (resolution not in (u'1x', u'2x')): DCNL DCSP  DCSP raise ValueError((u'resolution DCSP should DCSP be DCSP \"1x\" DCSP or DCSP \"2x\", DCSP not DCSP %r.' % resolution)) DCNL DCSP service = avatar_services.for_user(user, service_id) DCNL DCSP if (service is None): DCNL DCSP  DCSP logging.error(u'Could DCSP not DCSP get DCSP a DCSP suitable DCSP avatar DCSP service DCSP for DCSP user DCSP %s.', user) DCNL DCSP  DCSP return mark_safe(u'') DCNL DCSP urls = service.get_avatar_urls(request=context[u'request'], user=user, size=size) DCNL DCSP return urls[resolution]\n", "intent": "return the url of the requested avatar .\n", "question_id": 229}, {"snippet": "def _filter_nodes(superclass, all_nodes=_all_nodes): DCNL  DCSP node_names = (node.__name__ for node in all_nodes if issubclass(node, superclass)) DCNL DCSP return frozenset(node_names)\n", "intent": "filter out ast nodes that are subclasses of superclass .\n", "question_id": 230}, {"snippet": "def get_loaded_rules(rules_paths): DCNL  DCSP for path in rules_paths: DCNL DCSP  DCSP if (path.name != '__init__.py'): DCNL DCSP  DCSP  DCSP rule = Rule.from_path(path) DCNL DCSP  DCSP  DCSP if rule.is_enabled: DCNL DCSP  DCSP  DCSP  DCSP (yield rule)\n", "intent": "yields all available rules .\n", "question_id": 231}, {"snippet": "def _cond(condition, then_lambda, else_lambda): DCNL  DCSP try: DCNL DCSP  DCSP cond_fn = tf.cond DCNL DCSP except AttributeError: DCNL DCSP  DCSP from tensorflow.python.ops import control_flow_ops DCNL DCSP  DCSP cond_fn = control_flow_ops.cond DCNL DCSP return cond_fn(condition, then_lambda, else_lambda)\n", "intent": "backwards compatible interface to tf .\n", "question_id": 232}, {"snippet": "@pytest.fixture DCNL def config_tmpdir(monkeypatch, tmpdir): DCNL  DCSP confdir = (tmpdir / 'config') DCNL DCSP path = str(confdir) DCNL DCSP os.mkdir(path) DCNL DCSP monkeypatch.setattr('qutebrowser.utils.standarddir.config', (lambda : path)) DCNL DCSP return confdir\n", "intent": "set tmpdir/config as the configdir .\n", "question_id": 233}, {"snippet": "def _minpoly_exp(ex, x): DCNL  DCSP (c, a) = ex.args[0].as_coeff_Mul() DCNL DCSP p = sympify(c.p) DCNL DCSP q = sympify(c.q) DCNL DCSP if (a == (I * pi)): DCNL DCSP  DCSP if c.is_rational: DCNL DCSP  DCSP  DCSP if ((c.p == 1) or (c.p == (-1))): DCNL DCSP  DCSP  DCSP  DCSP if (q == 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (((x ** 2) - x) + 1) DCNL DCSP  DCSP  DCSP  DCSP if (q == 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ((x ** 4) + 1) DCNL DCSP  DCSP  DCSP  DCSP if (q == 6): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (((x ** 4) - (x ** 2)) + 1) DCNL DCSP  DCSP  DCSP  DCSP if (q == 8): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ((x ** 8) + 1) DCNL DCSP  DCSP  DCSP  DCSP if (q == 9): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (((x ** 6) - (x ** 3)) + 1) DCNL DCSP  DCSP  DCSP  DCSP if (q == 10): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (((((x ** 8) - (x ** 6)) + (x ** 4)) - (x ** 2)) + 1) DCNL DCSP  DCSP  DCSP  DCSP if q.is_prime: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i in range(q): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s += ((- x) ** i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return s DCNL DCSP  DCSP  DCSP factors = [cyclotomic_poly(i, x) for i in divisors((2 * q))] DCNL DCSP  DCSP  DCSP mp = _choose_factor(factors, x, ex) DCNL DCSP  DCSP  DCSP return mp DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise NotAlgebraic((\"%s DCSP doesn't DCSP seem DCSP to DCSP be DCSP an DCSP algebraic DCSP element\" % ex)) DCNL DCSP raise NotAlgebraic((\"%s DCSP doesn't DCSP seem DCSP to DCSP be DCSP an DCSP algebraic DCSP element\" % ex))\n", "intent": "returns the minimal polynomial of exp .\n", "question_id": 234}, {"snippet": "def constant_app(status, headers, body): DCNL  DCSP def application(unused_environ, start_response): DCNL DCSP  DCSP start_response(status, headers) DCNL DCSP  DCSP return [body] DCNL DCSP return application\n", "intent": "creates a wsgi application that produces a constant response .\n", "question_id": 235}, {"snippet": "def _update_exif_orientation(exif, orientation): DCNL  DCSP exif_dict = piexif.load(exif) DCNL DCSP if orientation: DCNL DCSP  DCSP exif_dict['0th'][piexif.ImageIFD.Orientation] = orientation DCNL DCSP return piexif.dump(exif_dict)\n", "intent": "given an exif value and an integer value 1-8 .\n", "question_id": 236}, {"snippet": "def is_package(directory): DCNL  DCSP for ext in ['.py', '.pyc']: DCNL DCSP  DCSP if os.path.exists(os.path.join(directory, ('__init__' + ext))): DCNL DCSP  DCSP  DCSP return True\n", "intent": "is the  directory a python package? .\n", "question_id": 237}, {"snippet": "def test_host_role_merge_deduping_off(): DCNL  DCSP @roles('r1', 'r2') DCNL DCSP @hosts('a') DCNL DCSP def command(): DCNL DCSP  DCSP pass DCNL DCSP with settings(dedupe_hosts=False): DCNL DCSP  DCSP true_eq_hosts(command, ['a', 'a', 'b', 'b', 'c'], env={'roledefs': fake_roles})\n", "intent": "allow turning deduping off .\n", "question_id": 238}, {"snippet": "def _convert_comp_data(res4): DCNL  DCSP if (res4['ncomp'] == 0): DCNL DCSP  DCSP return DCNL DCSP res4['comp'] = sorted(res4['comp'], key=_comp_sort_keys) DCNL DCSP _check_comp(res4['comp']) DCNL DCSP first = 0 DCNL DCSP kind = (-1) DCNL DCSP comps = list() DCNL DCSP for k in range(len(res4['comp'])): DCNL DCSP  DCSP if (res4['comp'][k]['coeff_type'] != kind): DCNL DCSP  DCSP  DCSP if (k > 0): DCNL DCSP  DCSP  DCSP  DCSP comps.append(_conv_comp(res4['comp'], first, (k - 1), res4['chs'])) DCNL DCSP  DCSP  DCSP kind = res4['comp'][k]['coeff_type'] DCNL DCSP  DCSP  DCSP first = k DCNL DCSP comps.append(_conv_comp(res4['comp'], first, k, res4['chs'])) DCNL DCSP return comps\n", "intent": "convert the compensation data into named matrices .\n", "question_id": 239}, {"snippet": "def _get_user_info(user=None): DCNL  DCSP if (not user): DCNL DCSP  DCSP user = __salt__['config.option']('user') DCNL DCSP userinfo = __salt__['user.info'](user) DCNL DCSP if (not userinfo): DCNL DCSP  DCSP if (user == 'salt'): DCNL DCSP  DCSP  DCSP userinfo = _get_user_info() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise SaltInvocationError('User DCSP {0} DCSP does DCSP not DCSP exist'.format(user)) DCNL DCSP return userinfo\n", "intent": "wrapper for user .\n", "question_id": 240}, {"snippet": "def expand_indent(line): DCNL  DCSP if (' DCTB ' not in line): DCNL DCSP  DCSP return (len(line) - len(line.lstrip())) DCNL DCSP result = 0 DCNL DCSP for char in line: DCNL DCSP  DCSP if (char == ' DCTB '): DCNL DCSP  DCSP  DCSP result = (((result // 8) * 8) + 8) DCNL DCSP  DCSP elif (char == ' DCSP '): DCNL DCSP  DCSP  DCSP result += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP return result\n", "intent": "return the amount of indentation .\n", "question_id": 241}, {"snippet": "def update_parent_status(doc): DCNL  DCSP if (doc.communication_type != u'Communication'): DCNL DCSP  DCSP return DCNL DCSP parent = doc.get_parent_doc() DCNL DCSP if (not parent): DCNL DCSP  DCSP return DCNL DCSP status_field = parent.meta.get_field(u'status') DCNL DCSP if status_field: DCNL DCSP  DCSP options = (status_field.options or u'').splitlines() DCNL DCSP  DCSP if (u'Replied' in options): DCNL DCSP  DCSP  DCSP to_status = (u'Open' if (doc.sent_or_received == u'Received') else u'Replied') DCNL DCSP  DCSP  DCSP if (to_status in options): DCNL DCSP  DCSP  DCSP  DCSP parent.db_set(u'status', to_status) DCNL DCSP update_mins_to_first_communication(parent, doc) DCNL DCSP parent.run_method(u'notify_communication', doc) DCNL DCSP parent.notify_update()\n", "intent": "update status of parent document based on who is replying .\n", "question_id": 242}, {"snippet": "def pythonize_path(path): DCNL  DCSP return path.replace('/', '.')\n", "intent": "replace argument to valid python dotted notation .\n", "question_id": 243}, {"snippet": "def test_sys_info(): DCNL  DCSP out = StringIO() DCNL DCSP sys_info(fid=out) DCNL DCSP out = out.getvalue() DCNL DCSP assert_true(('numpy:' in out))\n", "intent": "test info-showing utility .\n", "question_id": 244}, {"snippet": "def check_password(password, encoded, setter=None, preferred=u'default'): DCNL  DCSP if ((password is None) or (not is_password_usable(encoded))): DCNL DCSP  DCSP return False DCNL DCSP preferred = get_hasher(preferred) DCNL DCSP hasher = identify_hasher(encoded) DCNL DCSP must_update = (hasher.algorithm != preferred.algorithm) DCNL DCSP if (not must_update): DCNL DCSP  DCSP must_update = preferred.must_update(encoded) DCNL DCSP is_correct = hasher.verify(password, encoded) DCNL DCSP if (setter and is_correct and must_update): DCNL DCSP  DCSP setter(password) DCNL DCSP return is_correct\n", "intent": "returns a boolean of whether the raw password matches the three part encoded digest .\n", "question_id": 245}, {"snippet": "def _is_in_group(opt, group): DCNL  DCSP for (key, value) in group._opts.items(): DCNL DCSP  DCSP if (value['opt'] == opt): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "check if opt is in group .\n", "question_id": 246}, {"snippet": "def validate_name(pattern, multi=None, anime_type=None, file_only=False, abd=False, sports=False): DCNL  DCSP ep = generate_sample_ep(multi, abd, sports, anime_type) DCNL DCSP new_name = (ep.formatted_filename(pattern, multi, anime_type) + u'.ext') DCNL DCSP new_path = ep.formatted_dir(pattern, multi) DCNL DCSP if (not file_only): DCNL DCSP  DCSP new_name = ek(os.path.join, new_path, new_name) DCNL DCSP if (not new_name): DCNL DCSP  DCSP logger.log((u'Unable DCSP to DCSP create DCSP a DCSP name DCSP out DCSP of DCSP ' + pattern), logger.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP logger.log((u'Trying DCSP to DCSP parse DCSP ' + new_name), logger.DEBUG) DCNL DCSP try: DCNL DCSP  DCSP result = NameParser(True, showObj=ep.show, naming_pattern=True).parse(new_name) DCNL DCSP except (InvalidNameException, InvalidShowException) as error: DCNL DCSP  DCSP logger.log(u'{0}'.format(error), logger.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP logger.log((((u'The DCSP name DCSP ' + new_name) + u' DCSP parsed DCSP into DCSP ') + str(result)), logger.DEBUG) DCNL DCSP if (abd or sports): DCNL DCSP  DCSP if (result.air_date != ep.airdate): DCNL DCSP  DCSP  DCSP logger.log(u\"Air DCSP date DCSP incorrect DCSP in DCSP parsed DCSP episode, DCSP pattern DCSP isn't DCSP valid\", logger.DEBUG) DCNL DCSP  DCSP  DCSP return False DCNL DCSP elif (anime_type != 3): DCNL DCSP  DCSP if (len(result.ab_episode_numbers) and (result.ab_episode_numbers != [x.absolute_number for x in ([ep] + ep.relatedEps)])): DCNL DCSP  DCSP  DCSP logger.log(u\"Absolute DCSP numbering DCSP incorrect DCSP in DCSP parsed DCSP episode, DCSP pattern DCSP isn't DCSP valid\", logger.DEBUG) DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP if (result.season_number != ep.season): DCNL DCSP  DCSP  DCSP logger.log(u\"Season DCSP number DCSP incorrect DCSP in DCSP parsed DCSP episode, DCSP pattern DCSP isn't DCSP valid\", logger.DEBUG) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (result.episode_numbers != [x.episode for x in ([ep] + ep.relatedEps)]): DCNL DCSP  DCSP  DCSP logger.log(u\"Episode DCSP numbering DCSP incorrect DCSP in DCSP parsed DCSP episode, DCSP pattern DCSP isn't DCSP valid\", logger.DEBUG) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True\n", "intent": "see if we understand a name .\n", "question_id": 247}, {"snippet": "def sum(a, axis=None, dtype=None, out=None, keepdims=False): DCNL  DCSP return a.sum(axis, dtype, out, keepdims)\n", "intent": "returns the sum of an array along given axes .\n", "question_id": 248}, {"snippet": "def make_transient(instance): DCNL  DCSP state = attributes.instance_state(instance) DCNL DCSP s = _state_session(state) DCNL DCSP if s: DCNL DCSP  DCSP s._expunge_state(state) DCNL DCSP state.callables.clear() DCNL DCSP if state.key: DCNL DCSP  DCSP del state.key DCNL DCSP if state.deleted: DCNL DCSP  DCSP del state.deleted\n", "intent": "make the given instance transient .\n", "question_id": 249}, {"snippet": "@register.filter(is_safe=True, needs_autoescape=True) DCNL def join(value, arg, autoescape=True): DCNL  DCSP value = map(force_text, value) DCNL DCSP if autoescape: DCNL DCSP  DCSP value = [conditional_escape(v) for v in value] DCNL DCSP try: DCNL DCSP  DCSP data = conditional_escape(arg).join(value) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return value DCNL DCSP return mark_safe(data)\n", "intent": "joins a list with a string .\n", "question_id": 250}, {"snippet": "def GetServiceVersions(namespace): DCNL  DCSP def compare(a, b): DCNL DCSP  DCSP if (a == b): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP if (b in parentMap[a]): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP if (a in parentMap[b]): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP return ((a > b) - (a < b)) DCNL DCSP if PY3: DCNL DCSP  DCSP return sorted([v for (v, n) in iteritems(serviceNsMap) if (n == namespace)], key=cmp_to_key(compare)) DCNL DCSP else: DCNL DCSP  DCSP return sorted([v for (v, n) in iteritems(serviceNsMap) if (n == namespace)], compare)\n", "intent": "get all the versions for the service with specified namespace  ordered by compatibility .\n", "question_id": 251}, {"snippet": "def limited(items, request, max_limit=FLAGS.osapi_max_limit): DCNL  DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]\n", "intent": "return a slice of items according to requested offset and limit .\n", "question_id": 252}, {"snippet": "def test_sub_module(): DCNL  DCSP defs = jedi.Script('from DCSP jedi.api DCSP import DCSP classes; DCSP classes').goto_definitions() DCNL DCSP assert ([d.full_name for d in defs] == ['jedi.api.classes']) DCNL DCSP defs = jedi.Script('import DCSP jedi.api; DCSP jedi.api').goto_definitions() DCNL DCSP assert ([d.full_name for d in defs] == ['jedi.api'])\n", "intent": "full_name needs to check sys .\n", "question_id": 253}, {"snippet": "def delete_(*keyname): DCNL  DCSP mdata = _check_mdata_delete() DCNL DCSP valid_keynames = list_() DCNL DCSP ret = {} DCNL DCSP for k in keyname: DCNL DCSP  DCSP if (mdata and (k in valid_keynames)): DCNL DCSP  DCSP  DCSP cmd = '{0} DCSP {1}'.format(mdata, k) DCNL DCSP  DCSP  DCSP ret[k] = (__salt__['cmd.run_all'](cmd)['retcode'] == 0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret[k] = True DCNL DCSP return ret\n", "intent": "delete metadata prop : string name of property cli example: .\n", "question_id": 254}, {"snippet": "def create_user(name, password, admin=False, **client_args): DCNL  DCSP if user_exists(name, **client_args): DCNL DCSP  DCSP log.info(\"User DCSP '{0}' DCSP already DCSP exists\".format(name)) DCNL DCSP  DCSP return False DCNL DCSP client = _client(**client_args) DCNL DCSP client.create_user(name, password, admin) DCNL DCSP return True\n", "intent": "create a user .\n", "question_id": 255}, {"snippet": "def _CheckHtml(html): DCNL  DCSP return _ValidateString(html, 'html', MAXIMUM_FIELD_VALUE_LENGTH, empty_ok=True)\n", "intent": "checks the field html is a valid html string .\n", "question_id": 256}, {"snippet": "def run_from_args(command, log_command_filter=identity): DCNL  DCSP return Effect(Run.from_args(command, log_command_filter=log_command_filter))\n", "intent": "run a command on a remote host .\n", "question_id": 257}, {"snippet": "@handle_response_format DCNL @treeio_login_required DCNL def item_add_folder(request, folderPath, response_format='html'): DCNL  DCSP items = Object.filter_permitted(manager=KnowledgeItem.objects, user=request.user.profile, mode='r') DCNL DCSP try: DCNL DCSP  DCSP folder = KnowledgeFolder.by_path(folderPath) DCNL DCSP  DCSP knowledgeType_id = folder.id DCNL DCSP except KnowledgeFolder.DoesNotExist: DCNL DCSP  DCSP raise Http404 DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP item = KnowledgeItem() DCNL DCSP  DCSP  DCSP form = KnowledgeItemForm(request.user.profile, knowledgeType_id, request.POST, instance=item) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP item = form.save() DCNL DCSP  DCSP  DCSP  DCSP item.set_user_from_request(request) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('knowledge_item_view', args=[item.folder.treepath, item.treepath])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('knowledge')) DCNL DCSP else: DCNL DCSP  DCSP form = KnowledgeItemForm(request.user.profile, knowledgeType_id) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'items': items, 'form': form, 'folder': folder}) DCNL DCSP return render_to_response('knowledge/item_add_folder', context, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "add new knowledge item to preselected folder .\n", "question_id": 258}, {"snippet": "def mono_check(plugin, fmt='png'): DCNL  DCSP img = img_as_ubyte(data.moon()) DCNL DCSP r1 = roundtrip(img, plugin, fmt) DCNL DCSP testing.assert_allclose(img, r1) DCNL DCSP img2 = (img > 128) DCNL DCSP r2 = roundtrip(img2, plugin, fmt) DCNL DCSP testing.assert_allclose(img2.astype(np.uint8), r2) DCNL DCSP img3 = img_as_float(img) DCNL DCSP with expected_warnings(['precision|\\\\A\\\\Z']): DCNL DCSP  DCSP r3 = roundtrip(img3, plugin, fmt) DCNL DCSP if (r3.dtype.kind == 'f'): DCNL DCSP  DCSP testing.assert_allclose(img3, r3) DCNL DCSP else: DCNL DCSP  DCSP testing.assert_allclose(r3, img_as_uint(img)) DCNL DCSP with expected_warnings(['precision DCSP loss']): DCNL DCSP  DCSP img4 = img_as_int(img) DCNL DCSP if (fmt.lower() in ('tif', 'tiff')): DCNL DCSP  DCSP img4 -= 100 DCNL DCSP  DCSP with expected_warnings(['sign DCSP loss|\\\\A\\\\Z']): DCNL DCSP  DCSP  DCSP r4 = roundtrip(img4, plugin, fmt) DCNL DCSP  DCSP testing.assert_allclose(r4, img4) DCNL DCSP else: DCNL DCSP  DCSP with expected_warnings(['precision DCSP loss|sign DCSP loss']): DCNL DCSP  DCSP  DCSP r4 = roundtrip(img4, plugin, fmt) DCNL DCSP  DCSP  DCSP testing.assert_allclose(r4, img_as_uint(img4)) DCNL DCSP img5 = img_as_uint(img) DCNL DCSP r5 = roundtrip(img5, plugin, fmt) DCNL DCSP testing.assert_allclose(r5, img5)\n", "intent": "check the roundtrip behavior for images that support most types .\n", "question_id": 259}, {"snippet": "def render_plugin(values): DCNL  DCSP env = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(os.path.dirname(__file__), 'templates')), auto_reload=False, keep_trailing_newline=True, autoescape=True) DCNL DCSP template = env.get_template('new_plugin.py.tmpl') DCNL DCSP return template.render(**values)\n", "intent": "render the jinja template for the plugin with the given values .\n", "question_id": 260}, {"snippet": "def get(invalid_methods=('POST', 'PUT', 'DELETE'), debug=False, **kwargs): DCNL  DCSP request = cherrypy.serving.request DCNL DCSP response = cherrypy.serving.response DCNL DCSP if (not hasattr(cherrypy, '_cache')): DCNL DCSP  DCSP cherrypy._cache = kwargs.pop('cache_class', MemoryCache)() DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP setattr(cherrypy._cache, k, v) DCNL DCSP  DCSP cherrypy._cache.debug = debug DCNL DCSP if (request.method in invalid_methods): DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log(('request.method DCSP %r DCSP in DCSP invalid_methods DCSP %r' % (request.method, invalid_methods)), 'TOOLS.CACHING') DCNL DCSP  DCSP cherrypy._cache.delete() DCNL DCSP  DCSP request.cached = False DCNL DCSP  DCSP request.cacheable = False DCNL DCSP  DCSP return False DCNL DCSP if ('no-cache' in [e.value for e in request.headers.elements('Pragma')]): DCNL DCSP  DCSP request.cached = False DCNL DCSP  DCSP request.cacheable = True DCNL DCSP  DCSP return False DCNL DCSP cache_data = cherrypy._cache.get() DCNL DCSP request.cached = bool(cache_data) DCNL DCSP request.cacheable = (not request.cached) DCNL DCSP if request.cached: DCNL DCSP  DCSP max_age = cherrypy._cache.delay DCNL DCSP  DCSP for v in [e.value for e in request.headers.elements('Cache-Control')]: DCNL DCSP  DCSP  DCSP atoms = v.split('=', 1) DCNL DCSP  DCSP  DCSP directive = atoms.pop(0) DCNL DCSP  DCSP  DCSP if (directive == 'max-age'): DCNL DCSP  DCSP  DCSP  DCSP if ((len(atoms) != 1) or (not atoms[0].isdigit())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'Invalid DCSP Cache-Control DCSP header') DCNL DCSP  DCSP  DCSP  DCSP max_age = int(atoms[0]) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (directive == 'no-cache'): DCNL DCSP  DCSP  DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cherrypy.log('Ignoring DCSP cache DCSP due DCSP to DCSP Cache-Control: DCSP no-cache', 'TOOLS.CACHING') DCNL DCSP  DCSP  DCSP  DCSP request.cached = False DCNL DCSP  DCSP  DCSP  DCSP request.cacheable = True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log('Reading DCSP response DCSP from DCSP cache', 'TOOLS.CACHING') DCNL DCSP  DCSP (s, h, b, create_time) = cache_data DCNL DCSP  DCSP age = int((response.time - create_time)) DCNL DCSP  DCSP if (age > max_age): DCNL DCSP  DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP  DCSP cherrypy.log(('Ignoring DCSP cache DCSP due DCSP to DCSP age DCSP > DCSP %d' % max_age), 'TOOLS.CACHING') DCNL DCSP  DCSP  DCSP request.cached = False DCNL DCSP  DCSP  DCSP request.cacheable = True DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP response.headers = rh = httputil.HeaderMap() DCNL DCSP  DCSP for k in h: DCNL DCSP  DCSP  DCSP dict.__setitem__(rh, k, dict.__getitem__(h, k)) DCNL DCSP  DCSP response.headers['Age'] = str(age) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cptools.validate_since() DCNL DCSP  DCSP except cherrypy.HTTPRedirect as x: DCNL DCSP  DCSP  DCSP if (x.status == 304): DCNL DCSP  DCSP  DCSP  DCSP cherrypy._cache.tot_non_modified += 1 DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP response.status = s DCNL DCSP  DCSP response.body = b DCNL DCSP elif debug: DCNL DCSP  DCSP cherrypy.log('request DCSP is DCSP not DCSP cached', 'TOOLS.CACHING') DCNL DCSP return request.cached\n", "intent": "try to obtain cached output .\n", "question_id": 261}, {"snippet": "@handle_response_format DCNL @treeio_login_required DCNL @module_admin_required() DCNL def page_add(request, response_format='html'): DCNL  DCSP if request.POST: DCNL DCSP  DCSP form = PageForm(request.POST) DCNL DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP page = form.save() DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('core_admin_page_view', args=[page.id])) DCNL DCSP else: DCNL DCSP  DCSP form = PageForm() DCNL DCSP return render_to_response('core/administration/page_add', {'form': form}, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "static page add .\n", "question_id": 262}, {"snippet": "def unregister_file(path, pkg=None, conn=None): DCNL  DCSP if (conn is None): DCNL DCSP  DCSP conn = init() DCNL DCSP conn.execute('DELETE DCSP FROM DCSP files DCSP WHERE DCSP path=?', (path,))\n", "intent": "unregister a file from the package database .\n", "question_id": 263}, {"snippet": "def get_courses_accessible_to_user(request): DCNL  DCSP if GlobalStaff().has_user(request.user): DCNL DCSP  DCSP (courses, in_process_course_actions) = _accessible_courses_summary_list(request) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (courses, in_process_course_actions) = _accessible_courses_list_from_groups(request) DCNL DCSP  DCSP except AccessListFallback: DCNL DCSP  DCSP  DCSP (courses, in_process_course_actions) = _accessible_courses_summary_list(request) DCNL DCSP return (courses, in_process_course_actions)\n", "intent": "try to get all courses by first reversing django groups and fallback to old method if it fails note: overhead of pymongo reads will increase if getting courses from django groups fails .\n", "question_id": 264}, {"snippet": "def dump_processes(): DCNL  DCSP output_file = (PROFILING_OUTPUT_FMT % get_filename_fmt()) DCNL DCSP data = {} DCNL DCSP for child in multiprocessing.active_children(): DCNL DCSP  DCSP pid = child._popen.pid DCNL DCSP  DCSP child_data = {'name': child.name, 'daemon': child.daemon, 'exitcode': child.exitcode, 'target': child._target.__name__, 'args': [], 'kwargs': {}} DCNL DCSP  DCSP for arg in child._args: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP json.dumps(arg) DCNL DCSP  DCSP  DCSP except (TypeError, UnicodeDecodeError): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_data['args'].append(arg.__class__.__name__) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_data['args'].append('undefined') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP child_data['args'].append(arg) DCNL DCSP  DCSP for (key, value) in child._kwargs.iteritems(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP json.dumps(value) DCNL DCSP  DCSP  DCSP except (TypeError, UnicodeDecodeError): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_data['kwargs'][key] = value.__class__.__name__ DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP child_data['kwargs'][key] = 'undefined' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP child_data['kwargs'][key] = value DCNL DCSP  DCSP data[pid] = child_data DCNL DCSP json.dump(data, file(output_file, 'w'), indent=4)\n", "intent": "dumps sub-process information to a file .\n", "question_id": 265}, {"snippet": "def _defaultSysPathFactory(): DCNL  DCSP return sys.path\n", "intent": "provide the default behavior of pythonpaths sys .\n", "question_id": 266}, {"snippet": "@sync_performer DCNL def perform_sudo(dispatcher, intent): DCNL  DCSP return Effect(Run(command=('sudo DCSP ' + intent.command), log_command_filter=identity))\n", "intent": "default implementation of sudo .\n", "question_id": 267}, {"snippet": "def _AddConfigurationToMSVS(p, spec, tools, config, config_type, config_name): DCNL  DCSP attributes = _GetMSVSAttributes(spec, config, config_type) DCNL DCSP tool_list = _ConvertToolsToExpectedForm(tools) DCNL DCSP p.AddConfig(_ConfigFullName(config_name, config), attrs=attributes, tools=tool_list)\n", "intent": "add to the project file the configuration specified by config .\n", "question_id": 268}, {"snippet": "def _set_dig_kit(mrk, elp, hsp): DCNL  DCSP if isinstance(hsp, string_types): DCNL DCSP  DCSP hsp = _read_dig_points(hsp) DCNL DCSP n_pts = len(hsp) DCNL DCSP if (n_pts > KIT.DIG_POINTS): DCNL DCSP  DCSP hsp = _decimate_points(hsp, res=0.005) DCNL DCSP  DCSP n_new = len(hsp) DCNL DCSP  DCSP warn('The DCSP selected DCSP head DCSP shape DCSP contained DCSP {n_in} DCSP points, DCSP which DCSP is DCSP more DCSP than DCSP recommended DCSP ({n_rec}), DCSP and DCSP was DCSP automatically DCSP downsampled DCSP to DCSP {n_new} DCSP points. DCSP The DCSP preferred DCSP way DCSP to DCSP downsample DCSP is DCSP using DCSP FastScan.'.format(n_in=n_pts, n_rec=KIT.DIG_POINTS, n_new=n_new)) DCNL DCSP if isinstance(elp, string_types): DCNL DCSP  DCSP elp_points = _read_dig_points(elp) DCNL DCSP  DCSP if (len(elp_points) != 8): DCNL DCSP  DCSP  DCSP raise ValueError(('File DCSP %r DCSP should DCSP contain DCSP 8 DCSP points; DCSP got DCSP shape DCSP %s.' % (elp, elp_points.shape))) DCNL DCSP  DCSP elp = elp_points DCNL DCSP elif (len(elp) != 8): DCNL DCSP  DCSP raise ValueError(('ELP DCSP should DCSP contain DCSP 8 DCSP points; DCSP got DCSP shape DCSP %s.' % (elp.shape,))) DCNL DCSP if isinstance(mrk, string_types): DCNL DCSP  DCSP mrk = read_mrk(mrk) DCNL DCSP hsp = apply_trans(als_ras_trans, hsp) DCNL DCSP elp = apply_trans(als_ras_trans, elp) DCNL DCSP mrk = apply_trans(als_ras_trans, mrk) DCNL DCSP (nasion, lpa, rpa) = elp[:3] DCNL DCSP nmtrans = get_ras_to_neuromag_trans(nasion, lpa, rpa) DCNL DCSP elp = apply_trans(nmtrans, elp) DCNL DCSP hsp = apply_trans(nmtrans, hsp) DCNL DCSP trans = fit_matched_points(tgt_pts=elp[3:], src_pts=mrk, out='trans') DCNL DCSP (nasion, lpa, rpa) = elp[:3] DCNL DCSP elp = elp[3:] DCNL DCSP dig_points = _make_dig_points(nasion, lpa, rpa, elp, hsp) DCNL DCSP dev_head_t = Transform('meg', 'head', trans) DCNL DCSP return (dig_points, dev_head_t)\n", "intent": "add landmark points and head shape data to the kit instance .\n", "question_id": 269}, {"snippet": "def bulk_replace(values, existing_adapter, new_adapter): DCNL  DCSP if (not isinstance(values, list)): DCNL DCSP  DCSP values = list(values) DCNL DCSP idset = util.IdentitySet DCNL DCSP existing_idset = idset((existing_adapter or ())) DCNL DCSP constants = existing_idset.intersection((values or ())) DCNL DCSP additions = idset((values or ())).difference(constants) DCNL DCSP removals = existing_idset.difference(constants) DCNL DCSP for member in (values or ()): DCNL DCSP  DCSP if (member in additions): DCNL DCSP  DCSP  DCSP new_adapter.append_with_event(member) DCNL DCSP  DCSP elif (member in constants): DCNL DCSP  DCSP  DCSP new_adapter.append_without_event(member) DCNL DCSP if existing_adapter: DCNL DCSP  DCSP for member in removals: DCNL DCSP  DCSP  DCSP existing_adapter.remove_with_event(member)\n", "intent": "load a new collection .\n", "question_id": 270}, {"snippet": "def info(dev): DCNL  DCSP if ('sys' in dev): DCNL DCSP  DCSP qtype = 'path' DCNL DCSP else: DCNL DCSP  DCSP qtype = 'name' DCNL DCSP cmd = 'udevadm DCSP info DCSP --export DCSP --query=all DCSP --{0}={1}'.format(qtype, dev) DCNL DCSP udev_result = __salt__['cmd.run_all'](cmd, output_loglevel='quiet') DCNL DCSP if (udev_result['retcode'] != 0): DCNL DCSP  DCSP raise CommandExecutionError(udev_result['stderr']) DCNL DCSP return _parse_udevadm_info(udev_result['stdout'])[0]\n", "intent": "extract all info delivered by udevadm cli example: .\n", "question_id": 271}, {"snippet": "def process_mavlink(slave): DCNL  DCSP try: DCNL DCSP  DCSP buf = slave.recv() DCNL DCSP except socket.error: DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP if (slave.first_byte and opts.auto_protocol): DCNL DCSP  DCSP  DCSP slave.auto_mavlink_version(buf) DCNL DCSP  DCSP msgs = slave.mav.parse_buffer(buf) DCNL DCSP except mavutil.mavlink.MAVError as e: DCNL DCSP  DCSP mpstate.console.error(('Bad DCSP MAVLink DCSP slave DCSP message DCSP from DCSP %s: DCSP %s' % (slave.address, e.message))) DCNL DCSP  DCSP return DCNL DCSP if (msgs is None): DCNL DCSP  DCSP return DCNL DCSP if (mpstate.settings.mavfwd and (not mpstate.status.setup_mode)): DCNL DCSP  DCSP for m in msgs: DCNL DCSP  DCSP  DCSP if (mpstate.status.watch is not None): DCNL DCSP  DCSP  DCSP  DCSP if fnmatch.fnmatch(m.get_type().upper(), mpstate.status.watch.upper()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mpstate.console.writeln(('> DCSP ' + str(m))) DCNL DCSP  DCSP  DCSP mpstate.master().write(m.get_msgbuf()) DCNL DCSP mpstate.status.counters['Slave'] += 1\n", "intent": "process packets from mavlink slaves .\n", "question_id": 272}, {"snippet": "def _safe_log(log_func, msg, msg_data): DCNL  DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)\n", "intent": "sanitizes the msg_data field before logging .\n", "question_id": 273}, {"snippet": "def to_numpy_code(code): DCNL  DCSP code = code.lower() DCNL DCSP if (code is None): DCNL DCSP  DCSP return native_code DCNL DCSP if (code in aliases['little']): DCNL DCSP  DCSP return '<' DCNL DCSP elif (code in aliases['big']): DCNL DCSP  DCSP return '>' DCNL DCSP elif (code in aliases['native']): DCNL DCSP  DCSP return native_code DCNL DCSP elif (code in aliases['swapped']): DCNL DCSP  DCSP return swapped_code DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('We DCSP cannot DCSP handle DCSP byte DCSP order DCSP %s' % code))\n", "intent": "convert various order codings to numpy format .\n", "question_id": 274}, {"snippet": "def copy(source, destination, ignores=None): DCNL  DCSP def walk_error(err): DCNL DCSP  DCSP logger.warning(u'While DCSP copying DCSP %s: DCSP %s: DCSP %s', source_, err.filename, err.strerror) DCNL DCSP source_ = os.path.abspath(os.path.expanduser(source)) DCNL DCSP destination_ = os.path.abspath(os.path.expanduser(destination)) DCNL DCSP if (ignores is None): DCNL DCSP  DCSP ignores = [] DCNL DCSP if any((fnmatch.fnmatch(os.path.basename(source), ignore) for ignore in ignores)): DCNL DCSP  DCSP logger.info(u'Not DCSP copying DCSP %s DCSP due DCSP to DCSP ignores', source_) DCNL DCSP  DCSP return DCNL DCSP if os.path.isfile(source_): DCNL DCSP  DCSP dst_dir = os.path.dirname(destination_) DCNL DCSP  DCSP if (not os.path.exists(dst_dir)): DCNL DCSP  DCSP  DCSP logger.info(u'Creating DCSP directory DCSP %s', dst_dir) DCNL DCSP  DCSP  DCSP os.makedirs(dst_dir) DCNL DCSP  DCSP logger.info(u'Copying DCSP %s DCSP to DCSP %s', source_, destination_) DCNL DCSP  DCSP copy_file_metadata(source_, destination_) DCNL DCSP elif os.path.isdir(source_): DCNL DCSP  DCSP if (not os.path.exists(destination_)): DCNL DCSP  DCSP  DCSP logger.info(u'Creating DCSP directory DCSP %s', destination_) DCNL DCSP  DCSP  DCSP os.makedirs(destination_) DCNL DCSP  DCSP if (not os.path.isdir(destination_)): DCNL DCSP  DCSP  DCSP logger.warning(u'Cannot DCSP copy DCSP %s DCSP (a DCSP directory) DCSP to DCSP %s DCSP (a DCSP file)', source_, destination_) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP for (src_dir, subdirs, others) in os.walk(source_): DCNL DCSP  DCSP  DCSP dst_dir = os.path.join(destination_, os.path.relpath(src_dir, source_)) DCNL DCSP  DCSP  DCSP subdirs[:] = (s for s in subdirs if (not any((fnmatch.fnmatch(s, i) for i in ignores)))) DCNL DCSP  DCSP  DCSP others[:] = (o for o in others if (not any((fnmatch.fnmatch(o, i) for i in ignores)))) DCNL DCSP  DCSP  DCSP if (not os.path.isdir(dst_dir)): DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'Creating DCSP directory DCSP %s', dst_dir) DCNL DCSP  DCSP  DCSP  DCSP os.mkdir(dst_dir) DCNL DCSP  DCSP  DCSP for o in others: DCNL DCSP  DCSP  DCSP  DCSP src_path = os.path.join(src_dir, o) DCNL DCSP  DCSP  DCSP  DCSP dst_path = os.path.join(dst_dir, o) DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(src_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.info(u'Copying DCSP %s DCSP to DCSP %s', src_path, dst_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_file_metadata(src_path, dst_path) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warning(u'Skipped DCSP copy DCSP %s DCSP (not DCSP a DCSP file DCSP or DCSP directory) DCSP to DCSP %s', src_path, dst_path)\n", "intent": "recursively copy source into destination .\n", "question_id": 275}, {"snippet": "def createDatabase(): DCNL  DCSP global settings DCNL DCSP conn = lite.connect(settings['sqliteDB']) DCNL DCSP with conn: DCNL DCSP  DCSP cur = conn.cursor() DCNL DCSP  DCSP cur.execute('CREATE DCSP TABLE DCSP Clips(Id DCSP INTEGER DCSP PRIMARY DCSP KEY, DCSP Title DCSP TEXT, DCSP Subtitle DCSP TEXT, DCSP Url DCSP TEXT, DCSP AppUrl DCSP TEXT, DCSP Notes DCSP TEXT)')\n", "intent": "creates an empty database .\n", "question_id": 276}, {"snippet": "def print_line(line): DCNL  DCSP print line\n", "intent": "default retrlines callback to print a line .\n", "question_id": 277}, {"snippet": "@treeio_login_required DCNL @handle_response_format DCNL def account_delete(request, account_id, response_format='html'): DCNL  DCSP account = get_object_or_404(Account, pk=account_id) DCNL DCSP if (not request.user.profile.has_permission(account, mode='w')): DCNL DCSP  DCSP return user_denied(request, \"You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Account\", response_format) DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('delete' in request.POST): DCNL DCSP  DCSP  DCSP if ('trash' in request.POST): DCNL DCSP  DCSP  DCSP  DCSP account.trash = True DCNL DCSP  DCSP  DCSP  DCSP account.save() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP account.delete() DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('finance_index_accounts')) DCNL DCSP  DCSP elif ('cancel' in request.POST): DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('finance_account_view', args=[account.id])) DCNL DCSP return render_to_response('finance/account_delete', {'account': account}, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "account delete .\n", "question_id": 278}, {"snippet": "def element(cxel_str): DCNL  DCSP _xml = xml(cxel_str) DCNL DCSP return parse_xml(_xml)\n", "intent": "return an oxml element parsed from the xml generated from *cxel_str* .\n", "question_id": 279}, {"snippet": "def sortLoopsInOrderOfArea(isDescending, loops): DCNL  DCSP loops.sort(key=euclidean.getAreaLoopAbsolute, reverse=isDescending)\n", "intent": "sort the loops in the order of area according isdescending .\n", "question_id": 280}, {"snippet": "def test_show_fixtures_and_test(testdir): DCNL  DCSP p = testdir.makepyfile('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP pytest\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @pytest.fixture\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP arg():\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert DCSP False\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP test_arg(arg):\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert DCSP False\\n DCSP  DCSP  DCSP  DCSP ') DCNL DCSP result = testdir.runpytest('--setup-plan', p) DCNL DCSP assert (result.ret == 0) DCNL DCSP result.stdout.fnmatch_lines(['*SETUP DCSP  DCSP  DCSP  DCSP F DCSP arg*', '*test_arg DCSP (fixtures DCSP used: DCSP arg)', '*TEARDOWN DCSP F DCSP arg*'])\n", "intent": "verifies that fixtures are not executed .\n", "question_id": 281}, {"snippet": "def make_vals(val, klass, klass_inst=None, prop=None, part=False, base64encode=False): DCNL  DCSP cinst = None DCNL DCSP if isinstance(val, dict): DCNL DCSP  DCSP cinst = klass().loadd(val, base64encode=base64encode) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cinst = klass().set_text(val) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (not part): DCNL DCSP  DCSP  DCSP  DCSP cis = [make_vals(sval, klass, klass_inst, prop, True, base64encode) for sval in val] DCNL DCSP  DCSP  DCSP  DCSP setattr(klass_inst, prop, cis) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP if part: DCNL DCSP  DCSP return cinst DCNL DCSP elif cinst: DCNL DCSP  DCSP cis = [cinst] DCNL DCSP  DCSP setattr(klass_inst, prop, cis)\n", "intent": "creates a class instance with a specified value .\n", "question_id": 282}, {"snippet": "def _handle_post(gs_stub, filename, headers): DCNL  DCSP content_type = _ContentType(headers) DCNL DCSP token = gs_stub.post_start_creation(filename, headers) DCNL DCSP response_headers = {'location': ('https://storage.googleapis.com/%s?%s' % (filename, urllib.urlencode({'upload_id': token}))), 'content-type': content_type.value, 'content-length': 0} DCNL DCSP return _FakeUrlFetchResult(201, response_headers, '')\n", "intent": "handle post that starts object creation .\n", "question_id": 283}, {"snippet": "def validate_maintenance_window(window): DCNL  DCSP days = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun') DCNL DCSP day_re = '[A-Z]{1}[a-z]{2}' DCNL DCSP hour = '[01]?[0-9]|2[0-3]' DCNL DCSP minute = '[0-5][0-9]' DCNL DCSP r = ('(?P<start_day>%s):(?P<start_hour>%s):(?P<start_minute>%s)-(?P<end_day>%s):(?P<end_hour>%s):(?P<end_minute>%s)' % (day_re, hour, minute, day_re, hour, minute)) DCNL DCSP range_regex = re.compile(r) DCNL DCSP m = range_regex.match(window) DCNL DCSP if (not m): DCNL DCSP  DCSP raise ValueError('DBInstance DCSP PreferredMaintenanceWindow DCSP must DCSP be DCSP in DCSP the DCSP format: DCSP ddd:hh24:mi-ddd:hh24:mi') DCNL DCSP if ((m.group('start_day') not in days) or (m.group('end_day') not in days)): DCNL DCSP  DCSP raise ValueError(('DBInstance DCSP PreferredMaintenanceWindow DCSP day DCSP part DCSP of DCSP ranges DCSP must DCSP be DCSP one DCSP of: DCSP %s' % ', DCSP '.join(days))) DCNL DCSP start_ts = ((((days.index(m.group('start_day')) * 24) * 60) + (int(m.group('start_hour')) * 60)) + int(m.group('start_minute'))) DCNL DCSP end_ts = ((((days.index(m.group('end_day')) * 24) * 60) + (int(m.group('end_hour')) * 60)) + int(m.group('end_minute'))) DCNL DCSP if (abs((end_ts - start_ts)) < 30): DCNL DCSP  DCSP raise ValueError('DBInstance DCSP PreferredMaintenanceWindow DCSP must DCSP be DCSP at DCSP least DCSP 30 DCSP minutes DCSP long.') DCNL DCSP return window\n", "intent": "validate preferredmaintenancewindow for dbinstance .\n", "question_id": 284}, {"snippet": "def test_bc_fit_single_class(): DCNL  DCSP ratio = 'auto' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y_single_class)\n", "intent": "test either if an error when there is a single class .\n", "question_id": 285}, {"snippet": "def dmg_name(fullversion, pyver, osxver=None): DCNL  DCSP if (not osxver): DCNL DCSP  DCSP osxver = os.environ.get('MACOSX_DEPLOYMENT_TARGET', '10.3') DCNL DCSP return ('scipy-%s-py%s-python.org-macosx%s.dmg' % (fullversion, pyver, osxver))\n", "intent": "return name for dmg installer .\n", "question_id": 286}, {"snippet": "def _connected_chordal_graph_cliques(G): DCNL  DCSP if (G.number_of_nodes() == 1): DCNL DCSP  DCSP x = frozenset(G.nodes()) DCNL DCSP  DCSP return set([x]) DCNL DCSP else: DCNL DCSP  DCSP cliques = set() DCNL DCSP  DCSP unnumbered = set(G.nodes()) DCNL DCSP  DCSP v = random.choice(list(unnumbered)) DCNL DCSP  DCSP unnumbered.remove(v) DCNL DCSP  DCSP numbered = set([v]) DCNL DCSP  DCSP clique_wanna_be = set([v]) DCNL DCSP  DCSP while unnumbered: DCNL DCSP  DCSP  DCSP v = _max_cardinality_node(G, unnumbered, numbered) DCNL DCSP  DCSP  DCSP unnumbered.remove(v) DCNL DCSP  DCSP  DCSP numbered.add(v) DCNL DCSP  DCSP  DCSP new_clique_wanna_be = (set(G.neighbors(v)) & numbered) DCNL DCSP  DCSP  DCSP sg = G.subgraph(clique_wanna_be) DCNL DCSP  DCSP  DCSP if _is_complete_graph(sg): DCNL DCSP  DCSP  DCSP  DCSP new_clique_wanna_be.add(v) DCNL DCSP  DCSP  DCSP  DCSP if (not (new_clique_wanna_be >= clique_wanna_be)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cliques.add(frozenset(clique_wanna_be)) DCNL DCSP  DCSP  DCSP  DCSP clique_wanna_be = new_clique_wanna_be DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise nx.NetworkXError('Input DCSP graph DCSP is DCSP not DCSP chordal.') DCNL DCSP  DCSP cliques.add(frozenset(clique_wanna_be)) DCNL DCSP  DCSP return cliques\n", "intent": "return the set of maximal cliques of a connected chordal graph .\n", "question_id": 287}, {"snippet": "def verbose_print(arg): DCNL  DCSP if test_support.verbose: DCNL DCSP  DCSP with _print_mutex: DCNL DCSP  DCSP  DCSP print arg\n", "intent": "helper function for printing out debugging output .\n", "question_id": 288}, {"snippet": "def splitpasswd(user): DCNL  DCSP global _passwdprog DCNL DCSP if (_passwdprog is None): DCNL DCSP  DCSP import re DCNL DCSP  DCSP _passwdprog = re.compile('^([^:]*):(.*)$', re.S) DCNL DCSP match = _passwdprog.match(user) DCNL DCSP if match: DCNL DCSP  DCSP return match.group(1, 2) DCNL DCSP return (user, None)\n", "intent": "splitpasswd -> user .\n", "question_id": 289}, {"snippet": "def _send_new_pending_email(instance): DCNL  DCSP context = {'approval_url': urlunsplit((('https' if (settings.HTTPS == 'on') else 'http'), instance.site.domain, reverse('admin:api_admin_apiaccessrequest_change', args=(instance.id,)), '', '')), 'api_request': instance} DCNL DCSP message = render_to_string('api_admin/api_access_request_email_new_request.txt', context) DCNL DCSP try: DCNL DCSP  DCSP send_mail(_('API DCSP access DCSP request DCSP from DCSP {company}').format(company=instance.company_name), message, settings.API_ACCESS_FROM_EMAIL, [settings.API_ACCESS_MANAGER_EMAIL], fail_silently=False) DCNL DCSP except SMTPException: DCNL DCSP  DCSP log.exception('Error DCSP sending DCSP API DCSP user DCSP notification DCSP email DCSP for DCSP request DCSP [%s].', instance.id)\n", "intent": "send an email to settings .\n", "question_id": 290}, {"snippet": "def _generate_disk(session, instance, vm_ref, userdevice, name_label, disk_type, size_mb, fs_type): DCNL  DCSP sr_ref = safe_find_sr(session) DCNL DCSP ONE_MEG = (1024 * 1024) DCNL DCSP virtual_size = (size_mb * ONE_MEG) DCNL DCSP vdi_ref = create_vdi(session, sr_ref, instance, name_label, disk_type, virtual_size) DCNL DCSP try: DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP  DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP  DCSP  DCSP utils.execute('parted', '--script', dev_path, 'mklabel', 'msdos', run_as_root=True) DCNL DCSP  DCSP  DCSP partition_start = 0 DCNL DCSP  DCSP  DCSP partition_end = size_mb DCNL DCSP  DCSP  DCSP utils.execute('parted', '--script', dev_path, 'mkpart', 'primary', str(partition_start), str(partition_end), run_as_root=True) DCNL DCSP  DCSP  DCSP partition_path = utils.make_dev_path(dev, partition=1) DCNL DCSP  DCSP  DCSP if (fs_type == 'linux-swap'): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkswap', partition_path, run_as_root=True) DCNL DCSP  DCSP  DCSP elif (fs_type is not None): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkfs', '-t', fs_type, partition_path, run_as_root=True) DCNL DCSP  DCSP create_vbd(session, vm_ref, vdi_ref, userdevice, bootable=False) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref)\n", "intent": "steps to programmatically generate a disk: 1 .\n", "question_id": 291}, {"snippet": "def changequery(query=None, **kw): DCNL  DCSP if (query is None): DCNL DCSP  DCSP query = web.rawinput(method='get') DCNL DCSP for (k, v) in kw.iteritems(): DCNL DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP query.pop(k, None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query[k] = v DCNL DCSP out = web.ctx.path DCNL DCSP if query: DCNL DCSP  DCSP out += ('?' + urlencode(query, doseq=True)) DCNL DCSP return out\n", "intent": "imagine youre at /foo?a=1&b=2 .\n", "question_id": 292}, {"snippet": "def silverman_transform(bw, M, RANGE): DCNL  DCSP J = np.arange(((M / 2) + 1)) DCNL DCSP FAC1 = (2 * (((np.pi * bw) / RANGE) ** 2)) DCNL DCSP JFAC = ((J ** 2) * FAC1) DCNL DCSP BC = (1 - ((1.0 / 3) * ((((J * 1.0) / M) * np.pi) ** 2))) DCNL DCSP FAC = (np.exp((- JFAC)) / BC) DCNL DCSP kern_est = np.r_[(FAC, FAC[1:(-1)])] DCNL DCSP return kern_est\n", "intent": "fft of gaussian kernel following to silverman as 176 .\n", "question_id": 293}, {"snippet": "def rational_polynomial2(data): DCNL  DCSP return (((((data[0] - 3) ** 4) + ((data[1] - 3) ** 3)) - (data[1] - 3)) / (((data[1] - 2) ** 4) + 10))\n", "intent": "rational polynomial benchmark function .\n", "question_id": 294}, {"snippet": "def cpu_count(): DCNL  DCSP try: DCNL DCSP  DCSP return multiprocessing.cpu_count() DCNL DCSP except NotImplementedError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return os.sysconf('SC_NPROCESSORS_CONF') DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP gen_log.error('Could DCSP not DCSP detect DCSP number DCSP of DCSP processors; DCSP assuming DCSP 1') DCNL DCSP return 1\n", "intent": "returns the number of processors on this machine .\n", "question_id": 295}, {"snippet": "@library.filter DCNL def selector_content_find(document, selector): DCNL  DCSP content = '' DCNL DCSP try: DCNL DCSP  DCSP page = pq(document.rendered_html) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP content = page.find(selector).text() DCNL DCSP except SelectorSyntaxError: DCNL DCSP  DCSP pass DCNL DCSP return content\n", "intent": "provided a selector .\n", "question_id": 296}, {"snippet": "def resolve_relation(scope_model, relation): DCNL  DCSP if (relation == RECURSIVE_RELATIONSHIP_CONSTANT): DCNL DCSP  DCSP relation = scope_model DCNL DCSP if isinstance(relation, str): DCNL DCSP  DCSP if ('.' not in relation): DCNL DCSP  DCSP  DCSP relation = ('%s.%s' % (scope_model._meta.app_label, relation)) DCNL DCSP return relation\n", "intent": "transform relation into a model or fully-qualified model string of the form \"app_label .\n", "question_id": 297}, {"snippet": "def get_diff_chunk_generator(*args, **kwargs): DCNL  DCSP return _generator(*args, **kwargs)\n", "intent": "returns a diffchunkgenerator instance used for generating chunks .\n", "question_id": 298}, {"snippet": "def getTranslatedComplexPath(path, translateComplex): DCNL  DCSP translatedComplexPath = [] DCNL DCSP for point in path: DCNL DCSP  DCSP translatedComplexPath.append((point + translateComplex)) DCNL DCSP return translatedComplexPath\n", "intent": "get the translated complex path .\n", "question_id": 299}, {"snippet": "def RetryWithBackoff(callable_func, retry_notify_func, initial_delay=1, backoff_factor=2, max_delay=60, max_tries=20): DCNL  DCSP delay = initial_delay DCNL DCSP num_tries = 0 DCNL DCSP while True: DCNL DCSP  DCSP (done, opaque_value) = callable_func() DCNL DCSP  DCSP num_tries += 1 DCNL DCSP  DCSP if done: DCNL DCSP  DCSP  DCSP return (True, opaque_value) DCNL DCSP  DCSP if (num_tries >= max_tries): DCNL DCSP  DCSP  DCSP return (False, opaque_value) DCNL DCSP  DCSP retry_notify_func(opaque_value, delay) DCNL DCSP  DCSP time.sleep(delay) DCNL DCSP  DCSP delay = min((delay * backoff_factor), max_delay)\n", "intent": "calls a function multiple times .\n", "question_id": 300}, {"snippet": "def tree_selection_items(tree_item): DCNL  DCSP selected = [] DCNL DCSP for idx in range(tree_item.childCount()): DCNL DCSP  DCSP child = tree_item.child(idx) DCNL DCSP  DCSP if child.isSelected(): DCNL DCSP  DCSP  DCSP selected.append(child) DCNL DCSP return selected\n", "intent": "returns selected widget items .\n", "question_id": 301}, {"snippet": "def create_verifier_for_pss(signature, hash_method, public_key): DCNL  DCSP mgf = padding.MGF1(hash_method) DCNL DCSP salt_length = padding.PSS.MAX_LENGTH DCNL DCSP return public_key.verifier(signature, padding.PSS(mgf=mgf, salt_length=salt_length), hash_method)\n", "intent": "create the verifier to use when the key type is rsa-pss .\n", "question_id": 302}, {"snippet": "def create_swap_disk(vm_, linode_id, swap_size=None): DCNL  DCSP kwargs = {} DCNL DCSP if (not swap_size): DCNL DCSP  DCSP swap_size = get_swap_size(vm_) DCNL DCSP kwargs.update({'LinodeID': linode_id, 'Label': vm_['name'], 'Type': 'swap', 'Size': swap_size}) DCNL DCSP result = _query('linode', 'disk.create', args=kwargs) DCNL DCSP return _clean_data(result)\n", "intent": "creates the disk for the specified linode .\n", "question_id": 303}, {"snippet": "def _parse_format_specifier(format_spec, _localeconv=None): DCNL  DCSP m = _parse_format_specifier_regex.match(format_spec) DCNL DCSP if (m is None): DCNL DCSP  DCSP raise ValueError(('Invalid DCSP format DCSP specifier: DCSP ' + format_spec)) DCNL DCSP format_dict = m.groupdict() DCNL DCSP fill = format_dict['fill'] DCNL DCSP align = format_dict['align'] DCNL DCSP format_dict['zeropad'] = (format_dict['zeropad'] is not None) DCNL DCSP if format_dict['zeropad']: DCNL DCSP  DCSP if (fill is not None): DCNL DCSP  DCSP  DCSP raise ValueError((\"Fill DCSP character DCSP conflicts DCSP with DCSP '0' DCSP in DCSP format DCSP specifier: DCSP \" + format_spec)) DCNL DCSP  DCSP if (align is not None): DCNL DCSP  DCSP  DCSP raise ValueError((\"Alignment DCSP conflicts DCSP with DCSP '0' DCSP in DCSP format DCSP specifier: DCSP \" + format_spec)) DCNL DCSP format_dict['fill'] = (fill or ' DCSP ') DCNL DCSP format_dict['align'] = (align or '>') DCNL DCSP if (format_dict['sign'] is None): DCNL DCSP  DCSP format_dict['sign'] = '-' DCNL DCSP format_dict['minimumwidth'] = int((format_dict['minimumwidth'] or '0')) DCNL DCSP if (format_dict['precision'] is not None): DCNL DCSP  DCSP format_dict['precision'] = int(format_dict['precision']) DCNL DCSP if (format_dict['precision'] == 0): DCNL DCSP  DCSP if ((format_dict['type'] is None) or (format_dict['type'] in 'gG')): DCNL DCSP  DCSP  DCSP format_dict['precision'] = 1 DCNL DCSP if (format_dict['type'] == 'n'): DCNL DCSP  DCSP format_dict['type'] = 'g' DCNL DCSP  DCSP if (_localeconv is None): DCNL DCSP  DCSP  DCSP _localeconv = _locale.localeconv() DCNL DCSP  DCSP if (format_dict['thousands_sep'] is not None): DCNL DCSP  DCSP  DCSP raise ValueError((\"Explicit DCSP thousands DCSP separator DCSP conflicts DCSP with DCSP 'n' DCSP type DCSP in DCSP format DCSP specifier: DCSP \" + format_spec)) DCNL DCSP  DCSP format_dict['thousands_sep'] = _localeconv['thousands_sep'] DCNL DCSP  DCSP format_dict['grouping'] = _localeconv['grouping'] DCNL DCSP  DCSP format_dict['decimal_point'] = _localeconv['decimal_point'] DCNL DCSP else: DCNL DCSP  DCSP if (format_dict['thousands_sep'] is None): DCNL DCSP  DCSP  DCSP format_dict['thousands_sep'] = '' DCNL DCSP  DCSP format_dict['grouping'] = [3, 0] DCNL DCSP  DCSP format_dict['decimal_point'] = '.' DCNL DCSP format_dict['unicode'] = isinstance(format_spec, unicode) DCNL DCSP return format_dict\n", "intent": "parse and validate a format specifier .\n", "question_id": 304}, {"snippet": "def add(recipients, sender, subject, **kwargs): DCNL  DCSP if (kwargs.get(u'queue_separately') or (len(recipients) > 20)): DCNL DCSP  DCSP email_queue = None DCNL DCSP  DCSP for r in recipients: DCNL DCSP  DCSP  DCSP if (not email_queue): DCNL DCSP  DCSP  DCSP  DCSP email_queue = get_email_queue([r], sender, subject, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP if kwargs.get(u'now'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP email_queue(email_queue.name, now=True) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP duplicate = email_queue.get_duplicate([r]) DCNL DCSP  DCSP  DCSP  DCSP duplicate.insert(ignore_permissions=True) DCNL DCSP  DCSP  DCSP  DCSP if kwargs.get(u'now'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP send_one(duplicate.name, now=True) DCNL DCSP  DCSP  DCSP frappe.db.commit() DCNL DCSP else: DCNL DCSP  DCSP email_queue = get_email_queue(recipients, sender, subject, **kwargs) DCNL DCSP  DCSP if kwargs.get(u'now'): DCNL DCSP  DCSP  DCSP send_one(email_queue.name, now=True)\n", "intent": "add to email queue .\n", "question_id": 305}, {"snippet": "def detect_text_cloud_storage(uri): DCNL  DCSP vision_client = vision.Client() DCNL DCSP image = vision_client.image(source_uri=uri) DCNL DCSP texts = image.detect_text() DCNL DCSP print 'Texts:' DCNL DCSP for text in texts: DCNL DCSP  DCSP print text.description\n", "intent": "detects text in the file located in google cloud storage .\n", "question_id": 306}, {"snippet": "def make_property_setter(args, ignore_validate=False, validate_fields_for_doctype=True): DCNL  DCSP args = _dict(args) DCNL DCSP if (not args.doctype_or_field): DCNL DCSP  DCSP args.doctype_or_field = u'DocField' DCNL DCSP  DCSP if (not args.property_type): DCNL DCSP  DCSP  DCSP args.property_type = (db.get_value(u'DocField', {u'parent': u'DocField', u'fieldname': args.property}, u'fieldtype') or u'Data') DCNL DCSP if (not args.doctype): DCNL DCSP  DCSP doctype_list = db.sql_list(u'select DCSP distinct DCSP parent DCSP from DCSP tabDocField DCSP where DCSP fieldname=%s', args.fieldname) DCNL DCSP else: DCNL DCSP  DCSP doctype_list = [args.doctype] DCNL DCSP for doctype in doctype_list: DCNL DCSP  DCSP if (not args.property_type): DCNL DCSP  DCSP  DCSP args.property_type = (db.get_value(u'DocField', {u'parent': doctype, u'fieldname': args.fieldname}, u'fieldtype') or u'Data') DCNL DCSP  DCSP ps = get_doc({u'doctype': u'Property DCSP Setter', u'doctype_or_field': args.doctype_or_field, u'doc_type': doctype, u'field_name': args.fieldname, u'property': args.property, u'value': args.value, u'property_type': (args.property_type or u'Data'), u'__islocal': 1}) DCNL DCSP  DCSP ps.flags.ignore_validate = ignore_validate DCNL DCSP  DCSP ps.flags.validate_fields_for_doctype = validate_fields_for_doctype DCNL DCSP  DCSP ps.insert()\n", "intent": "create a new **property setter** .\n", "question_id": 307}, {"snippet": "def dtype_info_name(dtype): DCNL  DCSP dtype = np.dtype(dtype) DCNL DCSP if (dtype.kind in ('S', 'U')): DCNL DCSP  DCSP length = re.search('(\\\\d+)', dtype.str).group(1) DCNL DCSP  DCSP type_name = STRING_TYPE_NAMES[((not six.PY2), dtype.kind)] DCNL DCSP  DCSP out = (type_name + length) DCNL DCSP else: DCNL DCSP  DCSP out = dtype.name DCNL DCSP return out\n", "intent": "return a human-oriented string name of the dtype arg .\n", "question_id": 308}, {"snippet": "def runNetwork(network, numRecords, writer): DCNL  DCSP sensorRegion = network.regions[_RECORD_SENSOR] DCNL DCSP l1SpRegion = network.regions[_L1_SPATIAL_POOLER] DCNL DCSP l1TpRegion = network.regions[_L1_TEMPORAL_MEMORY] DCNL DCSP l1Classifier = network.regions[_L1_CLASSIFIER] DCNL DCSP l2SpRegion = network.regions[_L2_SPATIAL_POOLER] DCNL DCSP l2TpRegion = network.regions[_L2_TEMPORAL_MEMORY] DCNL DCSP l2Classifier = network.regions[_L2_CLASSIFIER] DCNL DCSP l1PreviousPredictedColumns = [] DCNL DCSP l2PreviousPredictedColumns = [] DCNL DCSP l1PreviousPrediction = None DCNL DCSP l2PreviousPrediction = None DCNL DCSP l1ErrorSum = 0.0 DCNL DCSP l2ErrorSum = 0.0 DCNL DCSP for record in xrange(numRecords): DCNL DCSP  DCSP network.run(1) DCNL DCSP  DCSP (actual, l1Prediction, l1Confidence) = runClassifier(l1Classifier, sensorRegion, l1TpRegion, record) DCNL DCSP  DCSP if (l1PreviousPrediction is not None): DCNL DCSP  DCSP  DCSP l1ErrorSum += math.fabs((l1PreviousPrediction - actual)) DCNL DCSP  DCSP l1PreviousPrediction = l1Prediction DCNL DCSP  DCSP (actual, l2Prediction, l2Confidence) = runClassifier(l2Classifier, sensorRegion, l2TpRegion, record) DCNL DCSP  DCSP if (l2PreviousPrediction is not None): DCNL DCSP  DCSP  DCSP l2ErrorSum += math.fabs((l2PreviousPrediction - actual)) DCNL DCSP  DCSP l2PreviousPrediction = l2Prediction DCNL DCSP  DCSP l1ActiveColumns = l1SpRegion.getOutputData('bottomUpOut').nonzero()[0] DCNL DCSP  DCSP l2ActiveColumns = l2SpRegion.getOutputData('bottomUpOut').nonzero()[0] DCNL DCSP  DCSP l1AnomalyScore = computeRawAnomalyScore(l1ActiveColumns, l1PreviousPredictedColumns) DCNL DCSP  DCSP l2AnomalyScore = computeRawAnomalyScore(l2ActiveColumns, l2PreviousPredictedColumns) DCNL DCSP  DCSP writer.writerow((record, actual, l1AnomalyScore, l2AnomalyScore)) DCNL DCSP  DCSP l1PredictedColumns = l1TpRegion.getOutputData('topDownOut').nonzero()[0] DCNL DCSP  DCSP l1PreviousPredictedColumns = copy.deepcopy(l1PredictedColumns) DCNL DCSP  DCSP l2PredictedColumns = l2TpRegion.getOutputData('topDownOut').nonzero()[0] DCNL DCSP  DCSP l2PreviousPredictedColumns = copy.deepcopy(l2PredictedColumns) DCNL DCSP if (numRecords > 1): DCNL DCSP  DCSP print ('L1 DCSP ave DCSP abs DCSP class. DCSP error: DCSP %f' % (l1ErrorSum / (numRecords - 1))) DCNL DCSP  DCSP print ('L2 DCSP ave DCSP abs DCSP class. DCSP error: DCSP %f' % (l2ErrorSum / (numRecords - 1)))\n", "intent": "runs specified network writing the ensuing anomaly scores to writer .\n", "question_id": 309}, {"snippet": "@cronjobs.register DCNL def clean_old_signed(seconds=(60 * 60)): DCNL  DCSP log.info('Removing DCSP old DCSP apps DCSP signed DCSP for DCSP reviewers') DCNL DCSP root = settings.SIGNED_APPS_REVIEWER_PATH DCNL DCSP now = (datetime.utcnow if storage_is_remote() else datetime.now) DCNL DCSP for (nextroot, dirs, files) in walk_storage(root, storage=private_storage): DCNL DCSP  DCSP for fn in files: DCNL DCSP  DCSP  DCSP full = os.path.join(nextroot, fn) DCNL DCSP  DCSP  DCSP age = (now() - private_storage.modified_time(full)) DCNL DCSP  DCSP  DCSP if (age.total_seconds() > seconds): DCNL DCSP  DCSP  DCSP  DCSP log.debug(('Removing DCSP signed DCSP app: DCSP %s, DCSP %dsecs DCSP old.' % (full, age.total_seconds()))) DCNL DCSP  DCSP  DCSP  DCSP private_storage.delete(full)\n", "intent": "clean out apps signed for reviewers .\n", "question_id": 310}, {"snippet": "def clean_global_runtime_state(reset_runtracker=True, reset_subsystem=False): DCNL  DCSP if reset_runtracker: DCNL DCSP  DCSP RunTracker.global_instance().reset(reset_options=False) DCNL DCSP if reset_subsystem: DCNL DCSP  DCSP Subsystem.reset() DCNL DCSP IntermediateTargetFactoryBase.reset() DCNL DCSP Goal.clear() DCNL DCSP OptionsInitializer.reset()\n", "intent": "resets the global runtime state of a pants runtime for cleaner forking .\n", "question_id": 311}, {"snippet": "@check_db_locks DCNL def api_request(app, *api_path, **kwargs): DCNL  DCSP base_url = app.hub.server.url DCNL DCSP headers = kwargs.setdefault('headers', {}) DCNL DCSP if ('Authorization' not in headers): DCNL DCSP  DCSP headers.update(auth_header(app.db, 'admin')) DCNL DCSP url = ujoin(base_url, 'api', *api_path) DCNL DCSP method = kwargs.pop('method', 'get') DCNL DCSP f = getattr(requests, method) DCNL DCSP resp = f(url, **kwargs) DCNL DCSP assert (\"frame-ancestors DCSP 'self'\" in resp.headers['Content-Security-Policy']) DCNL DCSP assert (ujoin(app.hub.server.base_url, 'security/csp-report') in resp.headers['Content-Security-Policy']) DCNL DCSP assert ('http' not in resp.headers['Content-Security-Policy']) DCNL DCSP return resp\n", "intent": "make an api request .\n", "question_id": 312}, {"snippet": "def scheduled_backup(older_than=6, ignore_files=False, backup_path_db=None, backup_path_files=None, backup_path_private_files=None, force=False): DCNL  DCSP odb = new_backup(older_than, ignore_files, backup_path_db=backup_path_db, backup_path_files=backup_path_files, force=force) DCNL DCSP return odb\n", "intent": "this function is called from scheduler deletes backups older than 7 days takes backup .\n", "question_id": 313}, {"snippet": "def get_include(): DCNL  DCSP import os DCNL DCSP return os.path.join(os.path.dirname(__file__), 'include')\n", "intent": "get the path to astropy .\n", "question_id": 314}, {"snippet": "def libvlc_video_set_logo_int(p_mi, option, value): DCNL  DCSP f = (_Cfunctions.get('libvlc_video_set_logo_int', None) or _Cfunction('libvlc_video_set_logo_int', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_int)) DCNL DCSP return f(p_mi, option, value)\n", "intent": "set logo option as integer .\n", "question_id": 315}, {"snippet": "def _integrate_plugins(): DCNL  DCSP import sys DCNL DCSP from airflow.plugins_manager import macros_modules DCNL DCSP for macros_module in macros_modules: DCNL DCSP  DCSP sys.modules[macros_module.__name__] = macros_module DCNL DCSP  DCSP globals()[macros_module._name] = macros_module DCNL DCSP  DCSP import os as _os DCNL DCSP  DCSP if (not _os.environ.get('AIRFLOW_USE_NEW_IMPORTS', False)): DCNL DCSP  DCSP  DCSP from zope.deprecation import deprecated as _deprecated DCNL DCSP  DCSP  DCSP for _macro in macros_module._objects: DCNL DCSP  DCSP  DCSP  DCSP macro_name = _macro.__name__ DCNL DCSP  DCSP  DCSP  DCSP globals()[macro_name] = _macro DCNL DCSP  DCSP  DCSP  DCSP _deprecated(macro_name, \"Importing DCSP plugin DCSP macro DCSP '{i}' DCSP directly DCSP from DCSP 'airflow.macros' DCSP has DCSP been DCSP deprecated. DCSP Please DCSP import DCSP from DCSP 'airflow.macros.[plugin_module]' DCSP instead. DCSP Support DCSP for DCSP direct DCSP imports DCSP will DCSP be DCSP dropped DCSP entirely DCSP in DCSP Airflow DCSP 2.0.\".format(i=macro_name))\n", "intent": "integrate plugins to the context .\n", "question_id": 316}, {"snippet": "def lab2lch(lab): DCNL  DCSP lch = _prepare_lab_array(lab) DCNL DCSP (a, b) = (lch[..., 1], lch[..., 2]) DCNL DCSP (lch[..., 1], lch[..., 2]) = _cart2polar_2pi(a, b) DCNL DCSP return lch\n", "intent": "cie-lab to cie-lch color space conversion .\n", "question_id": 317}, {"snippet": "def test_which_set(): DCNL  DCSP skip_if_no_sklearn() DCNL DCSP this_yaml = (test_yaml_which_set % {'which_set': 'train'}) DCNL DCSP trainer = yaml_parse.load(this_yaml) DCNL DCSP trainer.main_loop() DCNL DCSP this_yaml = (test_yaml_which_set % {'which_set': ['train', 'test']}) DCNL DCSP trainer = yaml_parse.load(this_yaml) DCNL DCSP trainer.main_loop() DCNL DCSP this_yaml = (test_yaml_which_set % {'which_set': 'valid'}) DCNL DCSP try: DCNL DCSP  DCSP trainer = yaml_parse.load(this_yaml) DCNL DCSP  DCSP trainer.main_loop() DCNL DCSP  DCSP raise AssertionError DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP this_yaml = (test_yaml_which_set % {'which_set': 'bogus'}) DCNL DCSP try: DCNL DCSP  DCSP yaml_parse.load(this_yaml) DCNL DCSP  DCSP raise AssertionError DCNL DCSP except ValueError: DCNL DCSP  DCSP pass\n", "intent": "test which_set selector .\n", "question_id": 318}, {"snippet": "def check_order(group): DCNL  DCSP global skip_order_check DCNL DCSP try: DCNL DCSP  DCSP if (skip_order_check or (len(group) < 2)): DCNL DCSP  DCSP  DCSP skip_order_check = False DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if any(((group[0][0] != labels[0]) for labels in group)): DCNL DCSP  DCSP  DCSP warning('Domain DCSP group DCSP TLD DCSP is DCSP not DCSP consistent') DCNL DCSP  DCSP sorted_group = sorted(group, key=(lambda labels: (len(labels), psl_key(labels[(-1)][0]), labels))) DCNL DCSP  DCSP if (group != sorted_group): DCNL DCSP  DCSP  DCSP warning('Incorrectly DCSP sorted DCSP group DCSP of DCSP domains') DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP ' + str(group)) DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP ' + str(sorted_group)) DCNL DCSP  DCSP  DCSP print 'Correct DCSP sorting DCSP would DCSP be:' DCNL DCSP  DCSP  DCSP print_psl(sorted_group) DCNL DCSP finally: DCNL DCSP  DCSP del group[:]\n", "intent": "check the correct order of a domain group .\n", "question_id": 319}, {"snippet": "@must_be_logged_in DCNL def oauth_application_detail(auth, **kwargs): DCNL  DCSP client_id = kwargs.get('client_id') DCNL DCSP try: DCNL DCSP  DCSP record = ApiOAuth2Application.find_one(Q('client_id', 'eq', client_id)) DCNL DCSP except NoResultsFound: DCNL DCSP  DCSP raise HTTPError(http.NOT_FOUND) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPError(http.NOT_FOUND) DCNL DCSP if (record.owner != auth.user): DCNL DCSP  DCSP raise HTTPError(http.FORBIDDEN) DCNL DCSP if (record.is_active is False): DCNL DCSP  DCSP raise HTTPError(http.GONE) DCNL DCSP app_detail_url = api_v2_url('applications/{}/'.format(client_id)) DCNL DCSP return {'app_list_url': '', 'app_detail_url': app_detail_url}\n", "intent": "show detail for a single oauth application .\n", "question_id": 320}, {"snippet": "def fixcommand(c): DCNL  DCSP forbidden_characters = ['-'] DCNL DCSP c = c.lower() DCNL DCSP for char in forbidden_characters: DCNL DCSP  DCSP c = c.replace(char, '') DCNL DCSP if (c == 'def'): DCNL DCSP  DCSP return 'qdef' DCNL DCSP return c\n", "intent": "fix qasm command names .\n", "question_id": 321}, {"snippet": "@register.filter(is_safe=True, needs_autoescape=True) DCNL def unordered_list(value, autoescape=None): DCNL  DCSP if autoescape: DCNL DCSP  DCSP escaper = conditional_escape DCNL DCSP else: DCNL DCSP  DCSP escaper = (lambda x: x) DCNL DCSP def convert_old_style_list(list_): DCNL DCSP  DCSP u\"\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Converts DCSP old DCSP style DCSP lists DCSP to DCSP the DCSP new DCSP easier DCSP to DCSP understand DCSP format.\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP old DCSP list DCSP format DCSP looked DCSP like:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ['Item DCSP 1', DCSP [['Item DCSP 1.1', DCSP []], DCSP ['Item DCSP 1.2', DCSP []]]\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP And DCSP it DCSP is DCSP converted DCSP to:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ['Item DCSP 1', DCSP ['Item DCSP 1.1', DCSP 'Item DCSP 1.2]]\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \" DCNL DCSP  DCSP if ((not isinstance(list_, (tuple, list))) or (len(list_) != 2)): DCNL DCSP  DCSP  DCSP return (list_, False) DCNL DCSP  DCSP (first_item, second_item) = list_ DCNL DCSP  DCSP if (second_item == []): DCNL DCSP  DCSP  DCSP return ([first_item], True) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iter(second_item) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP return (list_, False) DCNL DCSP  DCSP old_style_list = True DCNL DCSP  DCSP new_second_item = [] DCNL DCSP  DCSP for sublist in second_item: DCNL DCSP  DCSP  DCSP (item, old_style_list) = convert_old_style_list(sublist) DCNL DCSP  DCSP  DCSP if (not old_style_list): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP new_second_item.extend(item) DCNL DCSP  DCSP if old_style_list: DCNL DCSP  DCSP  DCSP second_item = new_second_item DCNL DCSP  DCSP return ([first_item, second_item], old_style_list) DCNL DCSP def _helper(list_, tabs=1): DCNL DCSP  DCSP indent = (u' DCTB ' * tabs) DCNL DCSP  DCSP output = [] DCNL DCSP  DCSP list_length = len(list_) DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP while (i < list_length): DCNL DCSP  DCSP  DCSP title = list_[i] DCNL DCSP  DCSP  DCSP sublist = u'' DCNL DCSP  DCSP  DCSP sublist_item = None DCNL DCSP  DCSP  DCSP if isinstance(title, (list, tuple)): DCNL DCSP  DCSP  DCSP  DCSP sublist_item = title DCNL DCSP  DCSP  DCSP  DCSP title = u'' DCNL DCSP  DCSP  DCSP elif (i < (list_length - 1)): DCNL DCSP  DCSP  DCSP  DCSP next_item = list_[(i + 1)] DCNL DCSP  DCSP  DCSP  DCSP if (next_item and isinstance(next_item, (list, tuple))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sublist_item = next_item DCNL DCSP  DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP if sublist_item: DCNL DCSP  DCSP  DCSP  DCSP sublist = _helper(sublist_item, (tabs + 1)) DCNL DCSP  DCSP  DCSP  DCSP sublist = (u'\\n%s<ul>\\n%s\\n%s</ul>\\n%s' % (indent, sublist, indent, indent)) DCNL DCSP  DCSP  DCSP output.append((u'%s<li>%s%s</li>' % (indent, escaper(force_text(title)), sublist))) DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP return u'\\n'.join(output) DCNL DCSP (value, converted) = convert_old_style_list(value) DCNL DCSP return mark_safe(_helper(value))\n", "intent": "recursively takes a self-nested list and returns an html unordered list -- without opening and closing <ul> tags .\n", "question_id": 322}, {"snippet": "def s3_comments(name='comments', **attr): DCNL  DCSP from s3widgets import s3_comments_widget DCNL DCSP T = current.T DCNL DCSP if ('label' not in attr): DCNL DCSP  DCSP attr['label'] = T('Comments') DCNL DCSP if ('represent' not in attr): DCNL DCSP  DCSP attr['represent'] = (lambda comments: (XML(comments) if comments else current.messages['NONE'])) DCNL DCSP if ('widget' not in attr): DCNL DCSP  DCSP attr['widget'] = s3_comments_widget DCNL DCSP if ('comment' not in attr): DCNL DCSP  DCSP attr['comment'] = DIV(_class='tooltip', _title=('%s|%s' % (T('Comments'), T('Please DCSP use DCSP this DCSP field DCSP to DCSP record DCSP any DCSP additional DCSP information, DCSP including DCSP a DCSP history DCSP of DCSP the DCSP record DCSP if DCSP it DCSP is DCSP updated.')))) DCNL DCSP f = S3ReusableField(name, 'text', **attr) DCNL DCSP return f()\n", "intent": "return a standard comments field .\n", "question_id": 323}, {"snippet": "def preprocess_roots(poly): DCNL  DCSP coeff = S.One DCNL DCSP try: DCNL DCSP  DCSP (_, poly) = poly.clear_denoms(convert=True) DCNL DCSP except DomainError: DCNL DCSP  DCSP return (coeff, poly) DCNL DCSP poly = poly.primitive()[1] DCNL DCSP poly = poly.retract() DCNL DCSP if (poly.get_domain().is_Poly and all((c.is_term for c in poly.rep.coeffs()))): DCNL DCSP  DCSP poly = poly.inject() DCNL DCSP  DCSP strips = list(zip(*poly.monoms())) DCNL DCSP  DCSP gens = list(poly.gens[1:]) DCNL DCSP  DCSP (base, strips) = (strips[0], strips[1:]) DCNL DCSP  DCSP for (gen, strip) in zip(list(gens), strips): DCNL DCSP  DCSP  DCSP reverse = False DCNL DCSP  DCSP  DCSP if (strip[0] < strip[(-1)]): DCNL DCSP  DCSP  DCSP  DCSP strip = reversed(strip) DCNL DCSP  DCSP  DCSP  DCSP reverse = True DCNL DCSP  DCSP  DCSP ratio = None DCNL DCSP  DCSP  DCSP for (a, b) in zip(base, strip): DCNL DCSP  DCSP  DCSP  DCSP if ((not a) and (not b)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif ((not a) or (not b)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif ((b % a) != 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ratio = (b // a) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ratio is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ratio = _ratio DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (ratio != _ratio): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if reverse: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ratio = (- ratio) DCNL DCSP  DCSP  DCSP  DCSP poly = poly.eval(gen, 1) DCNL DCSP  DCSP  DCSP  DCSP coeff *= (gen ** (- ratio)) DCNL DCSP  DCSP  DCSP  DCSP gens.remove(gen) DCNL DCSP  DCSP if gens: DCNL DCSP  DCSP  DCSP poly = poly.eject(*gens) DCNL DCSP if (poly.is_univariate and poly.get_domain().is_ZZ): DCNL DCSP  DCSP basis = _integer_basis(poly) DCNL DCSP  DCSP if (basis is not None): DCNL DCSP  DCSP  DCSP n = poly.degree() DCNL DCSP  DCSP  DCSP def func(k, coeff): DCNL DCSP  DCSP  DCSP  DCSP return (coeff // (basis ** (n - k[0]))) DCNL DCSP  DCSP  DCSP poly = poly.termwise(func) DCNL DCSP  DCSP  DCSP coeff *= basis DCNL DCSP return (coeff, poly)\n", "intent": "try to get rid of symbolic coefficients from poly .\n", "question_id": 324}, {"snippet": "def curtail_val_repr(val, max_chars, add_delim=False): DCNL  DCSP delim = ', DCSP ' DCNL DCSP end = '..' DCNL DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP if (max_chars <= len(((\"'\" + end) + \"'\"))): DCNL DCSP  DCSP  DCSP return (' DCSP ' * max_chars) DCNL DCSP  DCSP elif (add_delim and (max_chars <= (len(((\"'\" + end) + \"'\")) + len(delim)))): DCNL DCSP  DCSP  DCSP return (((\"'\" + end) + \"'\") + (' DCSP ' * (max_chars - len(((\"'\" + end) + \"'\"))))) DCNL DCSP elif (max_chars <= len(end)): DCNL DCSP  DCSP return (' DCSP ' * max_chars) DCNL DCSP elif (add_delim and (max_chars <= (len(end) + len(delim)))): DCNL DCSP  DCSP return (end + (' DCSP ' * (max_chars - len(end)))) DCNL DCSP if add_delim: DCNL DCSP  DCSP max_chars -= len(delim) DCNL DCSP r = repr(val) DCNL DCSP if (len(r) > max_chars): DCNL DCSP  DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP  DCSP r = ((r[:(max_chars - len((end + \"'\")))] + end) + \"'\") DCNL DCSP  DCSP elif (isinstance(val, list) and (max_chars >= len('[{end}]'.format(end=end)))): DCNL DCSP  DCSP  DCSP r = ((r[:(max_chars - len((end + ']')))] + end) + ']') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r = (r[:(max_chars - len(end))] + end) DCNL DCSP if add_delim: DCNL DCSP  DCSP r += delim DCNL DCSP return r\n", "intent": "used mostly by the to_string function on graph objects to pretty print .\n", "question_id": 325}, {"snippet": "def _get_default_route(version, subnet): DCNL  DCSP if (subnet.get('gateway') and subnet['gateway'].get('address')): DCNL DCSP  DCSP gateway = subnet['gateway']['address'] DCNL DCSP else: DCNL DCSP  DCSP return [] DCNL DCSP if (version == 4): DCNL DCSP  DCSP return [{'network': '0.0.0.0', 'netmask': '0.0.0.0', 'gateway': gateway}] DCNL DCSP elif (version == 6): DCNL DCSP  DCSP return [{'network': '::', 'netmask': '::', 'gateway': gateway}]\n", "intent": "get a default route for a network .\n", "question_id": 326}, {"snippet": "def HeaderPrints(message): DCNL  DCSP m = HeaderPrintMTADetails(message) DCNL DCSP u = HeaderPrintMUADetails(message, mta=m)[:20] DCNL DCSP g = HeaderPrintGenericDetails(message)[:50] DCNL DCSP mua = (u[1] if u else None) DCNL DCSP if (mua and mua.startswith('Mozilla DCSP ')): DCNL DCSP  DCSP mua = mua.split()[(-1)] DCNL DCSP return {'sender': md5_hex('\\n'.join(((m + u) + g))), 'tools': md5_hex('\\n'.join((u + g))), 'mua': mua}\n", "intent": "generate fingerprints from message headers which identifies the mua .\n", "question_id": 327}, {"snippet": "def _initialize_tps(num_control_points, input_shape, downsample_factor, precompute_grid): DCNL  DCSP (_, _, height, width) = input_shape DCNL DCSP grid_size = np.sqrt(num_control_points) DCNL DCSP (x_control_source, y_control_source) = np.meshgrid(np.linspace((-1), 1, grid_size), np.linspace((-1), 1, grid_size)) DCNL DCSP source_points = np.vstack((x_control_source.flatten(), y_control_source.flatten())) DCNL DCSP source_points = source_points.astype(theano.config.floatX) DCNL DCSP num_equations = (num_control_points + 3) DCNL DCSP L = np.zeros((num_equations, num_equations), dtype=theano.config.floatX) DCNL DCSP L[0, 3:num_equations] = 1.0 DCNL DCSP L[1:3, 3:num_equations] = source_points DCNL DCSP L[3:num_equations, 0] = 1.0 DCNL DCSP L[3:num_equations, 1:3] = source_points.T DCNL DCSP for point_1 in range(num_control_points): DCNL DCSP  DCSP for point_2 in range(point_1, num_control_points): DCNL DCSP  DCSP  DCSP L[((point_1 + 3), (point_2 + 3))] = _U_func_numpy(source_points[(0, point_1)], source_points[(1, point_1)], source_points[(0, point_2)], source_points[(1, point_2)]) DCNL DCSP  DCSP  DCSP if (point_1 != point_2): DCNL DCSP  DCSP  DCSP  DCSP L[((point_2 + 3), (point_1 + 3))] = L[((point_1 + 3), (point_2 + 3))] DCNL DCSP L_inv = np.linalg.inv(L) DCNL DCSP if precompute_grid: DCNL DCSP  DCSP out_height = np.array((height // downsample_factor[0])).astype('int64') DCNL DCSP  DCSP out_width = np.array((width // downsample_factor[1])).astype('int64') DCNL DCSP  DCSP (x_t, y_t) = np.meshgrid(np.linspace((-1), 1, out_width), np.linspace((-1), 1, out_height)) DCNL DCSP  DCSP ones = np.ones(np.prod(x_t.shape)) DCNL DCSP  DCSP orig_grid = np.vstack([x_t.flatten(), y_t.flatten(), ones]) DCNL DCSP  DCSP orig_grid = orig_grid[0:2, :] DCNL DCSP  DCSP orig_grid = orig_grid.astype(theano.config.floatX) DCNL DCSP  DCSP to_transform = orig_grid[:, :, np.newaxis].transpose(2, 0, 1) DCNL DCSP  DCSP stacked_transform = np.tile(to_transform, (num_control_points, 1, 1)) DCNL DCSP  DCSP stacked_source_points = source_points[:, :, np.newaxis].transpose(1, 0, 2) DCNL DCSP  DCSP r_2 = np.sum(((stacked_transform - stacked_source_points) ** 2), axis=1) DCNL DCSP  DCSP log_r_2 = np.log(r_2) DCNL DCSP  DCSP log_r_2[np.isinf(log_r_2)] = 0.0 DCNL DCSP  DCSP distances = (r_2 * log_r_2) DCNL DCSP  DCSP upper_array = np.ones(shape=(1, orig_grid.shape[1]), dtype=theano.config.floatX) DCNL DCSP  DCSP upper_array = np.concatenate([upper_array, orig_grid], axis=0) DCNL DCSP  DCSP right_mat = np.concatenate([upper_array, distances], axis=0) DCNL DCSP  DCSP out_height = T.as_tensor_variable(out_height) DCNL DCSP  DCSP out_width = T.as_tensor_variable(out_width) DCNL DCSP  DCSP right_mat = T.as_tensor_variable(right_mat) DCNL DCSP else: DCNL DCSP  DCSP out_height = None DCNL DCSP  DCSP out_width = None DCNL DCSP  DCSP right_mat = None DCNL DCSP L_inv = T.as_tensor_variable(L_inv) DCNL DCSP source_points = T.as_tensor_variable(source_points) DCNL DCSP return (right_mat, L_inv, source_points, out_height, out_width)\n", "intent": "initializes the thin plate spline calculation by creating the source point array and the inverted l matrix used for calculating the transformations as in ref [2]_ .\n", "question_id": 328}, {"snippet": "def test_get_set_vector(): DCNL  DCSP rng = np.random.RandomState([2014, 5, 8]) DCNL DCSP class DummyModel(Model, ): DCNL DCSP  DCSP \"\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP Model DCSP that DCSP exercises DCSP this DCSP test DCSP by DCSP having DCSP a DCSP few DCSP different\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parameters DCSP with DCSP different DCSP shapes DCSP and DCSP dimensionalities.\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Don't DCSP instantiate DCSP more DCSP than DCSP one DCSP of DCSP these DCSP because DCSP the DCSP parameters\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP are DCSP class-level DCSP attributes.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \" DCNL DCSP  DCSP _params = [sharedX(rng.randn(5)), sharedX(rng.randn(5, 3)), sharedX(rng.randn(4, 4, 4))] DCNL DCSP model = DummyModel() DCNL DCSP vector = model.get_param_vector() DCNL DCSP model.set_param_vector((0.0 * vector)) DCNL DCSP assert np.allclose((0.0 * vector), model.get_param_vector()) DCNL DCSP model.set_param_vector(vector) DCNL DCSP assert np.allclose(model.get_param_vector(), vector)\n", "intent": "tests that get_vector and set_vector use the same format .\n", "question_id": 329}, {"snippet": "@login_required DCNL def unblock(request, username, template_name='relationships/block_delete_confirm.html', success_template_name='relationships/block_delete_success.html', content_type='text/html'): DCNL  DCSP user_to_block = get_object_or_404(User, username=username) DCNL DCSP user = request.user DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP relationship = get_object_or_404(Relationship, to_user=user_to_block, from_user=user, is_blocked=True) DCNL DCSP  DCSP relationship.delete() DCNL DCSP  DCSP if request.is_ajax(): DCNL DCSP  DCSP  DCSP response = {'success': 'Success'} DCNL DCSP  DCSP  DCSP return HttpResponse(json.dumps(response), content_type='application/json') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP template_name = success_template_name DCNL DCSP context = {'user_to_block': user_to_block} DCNL DCSP return render_to_response(template_name, context, context_instance=RequestContext(request), content_type=content_type)\n", "intent": "allows a user to stop blocking another user .\n", "question_id": 330}, {"snippet": "def main(_argv=sys.argv, _input=raw_input): DCNL  DCSP env = wireup.env() DCNL DCSP wireup.make_sentry_teller(env) DCNL DCSP wireup.mail(env) DCNL DCSP wireup.db(env) DCNL DCSP Participant.dequeue_emails()\n", "intent": "this is a script to dequeue and send emails .\n", "question_id": 331}, {"snippet": "def write(message): DCNL  DCSP logs_buffer().write(message)\n", "intent": "adds message to the logs buffer .\n", "question_id": 332}, {"snippet": "def signal_alarm(n): DCNL  DCSP if hasattr(signal, 'alarm'): DCNL DCSP  DCSP signal.alarm(n)\n", "intent": "call signal .\n", "question_id": 333}, {"snippet": "def map_face2color(face, colormap, scale, vmin, vmax): DCNL  DCSP if (vmin >= vmax): DCNL DCSP  DCSP raise exceptions.PlotlyError('Incorrect DCSP relation DCSP between DCSP vmin DCSP and DCSP vmax. DCSP The DCSP vmin DCSP value DCSP cannot DCSP be DCSP bigger DCSP than DCSP or DCSP equal DCSP to DCSP the DCSP value DCSP of DCSP vmax.') DCNL DCSP if (len(colormap) == 1): DCNL DCSP  DCSP face_color = colormap[0] DCNL DCSP  DCSP face_color = colors.convert_to_RGB_255(face_color) DCNL DCSP  DCSP face_color = colors.label_rgb(face_color) DCNL DCSP  DCSP return face_color DCNL DCSP if (face == vmax): DCNL DCSP  DCSP face_color = colormap[(-1)] DCNL DCSP  DCSP face_color = colors.convert_to_RGB_255(face_color) DCNL DCSP  DCSP face_color = colors.label_rgb(face_color) DCNL DCSP  DCSP return face_color DCNL DCSP else: DCNL DCSP  DCSP if (scale is None): DCNL DCSP  DCSP  DCSP t = ((face - vmin) / float((vmax - vmin))) DCNL DCSP  DCSP  DCSP low_color_index = int((t / (1.0 / (len(colormap) - 1)))) DCNL DCSP  DCSP  DCSP face_color = colors.find_intermediate_color(colormap[low_color_index], colormap[(low_color_index + 1)], ((t * (len(colormap) - 1)) - low_color_index)) DCNL DCSP  DCSP  DCSP face_color = colors.convert_to_RGB_255(face_color) DCNL DCSP  DCSP  DCSP face_color = colors.label_rgb(face_color) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP t = ((face - vmin) / float((vmax - vmin))) DCNL DCSP  DCSP  DCSP low_color_index = 0 DCNL DCSP  DCSP  DCSP for k in range((len(scale) - 1)): DCNL DCSP  DCSP  DCSP  DCSP if (scale[k] <= t < scale[(k + 1)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP low_color_index += 1 DCNL DCSP  DCSP  DCSP low_scale_val = scale[low_color_index] DCNL DCSP  DCSP  DCSP high_scale_val = scale[(low_color_index + 1)] DCNL DCSP  DCSP  DCSP face_color = colors.find_intermediate_color(colormap[low_color_index], colormap[(low_color_index + 1)], ((t - low_scale_val) / (high_scale_val - low_scale_val))) DCNL DCSP  DCSP  DCSP face_color = colors.convert_to_RGB_255(face_color) DCNL DCSP  DCSP  DCSP face_color = colors.label_rgb(face_color) DCNL DCSP  DCSP return face_color\n", "intent": "normalize facecolor values by vmin/vmax and return rgb-color strings this function takes a tuple color along with a colormap and a minimum  and maximum  range of possible mean distances for the given parametrized surface .\n", "question_id": 334}, {"snippet": "def test_ast_invalid_for(): DCNL  DCSP cant_compile(u'(for* DCSP [a DCSP 1] DCSP (else DCSP 1 DCSP 2))')\n", "intent": "make sure ast cant compile invalid for .\n", "question_id": 335}, {"snippet": "def _is_internal_request(domain, referer): DCNL  DCSP return ((referer is not None) and re.match(('^https?://%s/' % re.escape(domain)), referer))\n", "intent": "returns true if the referring url is the same domain as the current request .\n", "question_id": 336}, {"snippet": "def homogeneous_order(eq, *symbols): DCNL  DCSP if (not symbols): DCNL DCSP  DCSP raise ValueError('homogeneous_order: DCSP no DCSP symbols DCSP were DCSP given.') DCNL DCSP symset = set(symbols) DCNL DCSP eq = sympify(eq) DCNL DCSP if eq.has(Order, Derivative): DCNL DCSP  DCSP return None DCNL DCSP if (eq.is_Number or eq.is_NumberSymbol or eq.is_number): DCNL DCSP  DCSP return S.Zero DCNL DCSP dum = numbered_symbols(prefix='d', cls=Dummy) DCNL DCSP newsyms = set() DCNL DCSP for i in [j for j in symset if getattr(j, 'is_Function')]: DCNL DCSP  DCSP iargs = set(i.args) DCNL DCSP  DCSP if iargs.difference(symset): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dummyvar = next(dum) DCNL DCSP  DCSP  DCSP eq = eq.subs(i, dummyvar) DCNL DCSP  DCSP  DCSP symset.remove(i) DCNL DCSP  DCSP  DCSP newsyms.add(dummyvar) DCNL DCSP symset.update(newsyms) DCNL DCSP if (not (eq.free_symbols & symset)): DCNL DCSP  DCSP return None DCNL DCSP if isinstance(eq, Function): DCNL DCSP  DCSP return (None if (homogeneous_order(eq.args[0], *tuple(symset)) != 0) else S.Zero) DCNL DCSP t = Dummy('t', positive=True) DCNL DCSP eqs = separatevars(eq.subs([(i, (t * i)) for i in symset]), [t], dict=True)[t] DCNL DCSP if (eqs is S.One): DCNL DCSP  DCSP return S.Zero DCNL DCSP (i, d) = eqs.as_independent(t, as_Add=False) DCNL DCSP (b, e) = d.as_base_exp() DCNL DCSP if (b == t): DCNL DCSP  DCSP return e\n", "intent": "returns the order n if g is homogeneous and none if it is not homogeneous .\n", "question_id": 337}, {"snippet": "def _fix_up_method_description(method_desc, root_desc): DCNL  DCSP path_url = method_desc['path'] DCNL DCSP http_method = method_desc['httpMethod'] DCNL DCSP method_id = method_desc['id'] DCNL DCSP parameters = _fix_up_parameters(method_desc, root_desc, http_method) DCNL DCSP (accept, max_size, media_path_url) = _fix_up_media_upload(method_desc, root_desc, path_url, parameters) DCNL DCSP return (path_url, http_method, method_id, accept, max_size, media_path_url)\n", "intent": "updates a method description in a discovery document .\n", "question_id": 338}, {"snippet": "def check_repair_request(): DCNL  DCSP path = os.path.join(cfg.admin_dir.get_path(), REPAIR_REQUEST) DCNL DCSP if os.path.exists(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(path) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return True DCNL DCSP return False\n", "intent": "return true if repair request found .\n", "question_id": 339}, {"snippet": "def create_resource(): DCNL  DCSP deserializer = CachedImageDeserializer() DCNL DCSP serializer = CachedImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)\n", "intent": "cached images resource factory method .\n", "question_id": 340}, {"snippet": "def denormalize(host_string): DCNL  DCSP from fabric.state import env DCNL DCSP r = parse_host_string(host_string) DCNL DCSP user = '' DCNL DCSP if ((r['user'] is not None) and (r['user'] != env.user)): DCNL DCSP  DCSP user = (r['user'] + '@') DCNL DCSP port = '' DCNL DCSP if ((r['port'] is not None) and (r['port'] != '22')): DCNL DCSP  DCSP port = (':' + r['port']) DCNL DCSP host = r['host'] DCNL DCSP host = (('[%s]' % host) if (port and (host.count(':') > 1)) else host) DCNL DCSP return ((user + host) + port)\n", "intent": "strips out default values for the given host string .\n", "question_id": 341}, {"snippet": "def chvatal_graph(create_using=None): DCNL  DCSP description = ['adjacencylist', 'Chvatal DCSP Graph', 12, [[2, 5, 7, 10], [3, 6, 8], [4, 7, 9], [5, 8, 10], [6, 9], [11, 12], [11, 12], [9, 12], [11], [11, 12], [], []]] DCNL DCSP G = make_small_undirected_graph(description, create_using) DCNL DCSP return G\n", "intent": "return the chvtal graph .\n", "question_id": 342}, {"snippet": "def create_bias_variable(name, shape): DCNL  DCSP initializer = tf.constant_initializer(value=0.0, dtype=tf.float32) DCNL DCSP return tf.Variable(initializer(shape=shape), name)\n", "intent": "create a bias variable with the specified name and shape and initialize it to zero .\n", "question_id": 343}, {"snippet": "def get_table(raw, name): DCNL  DCSP name = bytes(name.lower()) DCNL DCSP for (table_tag, table, table_index, table_offset, table_checksum) in get_tables(raw): DCNL DCSP  DCSP if (table_tag.lower() == name): DCNL DCSP  DCSP  DCSP return (table, table_index, table_offset, table_checksum) DCNL DCSP return (None, None, None, None)\n", "intent": "get the raw table bytes for the specified table in the font .\n", "question_id": 344}, {"snippet": "def getTopPaths(paths): DCNL  DCSP top = (-999999999.9) DCNL DCSP for path in paths: DCNL DCSP  DCSP for point in path: DCNL DCSP  DCSP  DCSP top = max(top, point.z) DCNL DCSP return top\n", "intent": "get the top of the paths .\n", "question_id": 345}, {"snippet": "def __getLocation__(**kwargs): DCNL  DCSP global CURRENT_LAT DCNL DCSP global CURRENT_LON DCNL DCSP if (kwargs is not None): DCNL DCSP  DCSP CURRENT_LAT = kwargs['lat'] DCNL DCSP  DCSP CURRENT_LON = kwargs['lon']\n", "intent": "this function is called by configure for setting current gps location in global variables info: the on_location and on_status callables might be called from another thread than the thread used for creating the gps object .\n", "question_id": 346}, {"snippet": "def test_height_ratios(): DCNL  DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP gridspec.GridSpec(1, 1, height_ratios=[2, 1, 3])\n", "intent": "addresses issue #5835 .\n", "question_id": 347}, {"snippet": "def swap_memory(): DCNL  DCSP (total, used, free, sin, sout) = cext.swap_mem() DCNL DCSP percent = usage_percent(used, total, _round=1) DCNL DCSP return _common.sswap(total, used, free, percent, sin, sout)\n", "intent": "system swap memory as  namedtuple .\n", "question_id": 348}, {"snippet": "def maybe_unwrap_results(results): DCNL  DCSP return getattr(results, '_results', results)\n", "intent": "gets raw results back from wrapped results .\n", "question_id": 349}, {"snippet": "def SetIfNotNone(dict, attr_name, value): DCNL  DCSP if (value is not None): DCNL DCSP  DCSP dict[attr_name] = value\n", "intent": "if \"value\" is not none .\n", "question_id": 350}, {"snippet": "@util.positional(2) DCNL def verify_id_token(id_token, audience, http=None, cert_uri=ID_TOKEN_VERIFICATION_CERTS): DCNL  DCSP _RequireCryptoOrDie() DCNL DCSP if (http is None): DCNL DCSP  DCSP http = _cached_http DCNL DCSP (resp, content) = http.request(cert_uri) DCNL DCSP if (resp.status == 200): DCNL DCSP  DCSP certs = json.loads(content.decode('utf-8')) DCNL DCSP  DCSP return crypt.verify_signed_jwt_with_certs(id_token, certs, audience) DCNL DCSP else: DCNL DCSP  DCSP raise VerifyJwtTokenError(('Status DCSP code: DCSP %d' % resp.status))\n", "intent": "verifies a signed jwt id_token .\n", "question_id": 351}, {"snippet": "def nonthreadsafe(fn): DCNL  DCSP @wraps(fn) DCNL DCSP def core(*args, **kwargs): DCNL DCSP  DCSP with _cuda_compiler_lock: DCNL DCSP  DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP return core\n", "intent": "wraps a function to prevent multiple threads from executing it in parallel due to llvm is not threadsafe .\n", "question_id": 352}, {"snippet": "def text(value, encoding=None, errors=None): DCNL  DCSP if (encoding is None): DCNL DCSP  DCSP encoding = select_best_encoding() DCNL DCSP if (errors is None): DCNL DCSP  DCSP errors = BEHAVE_UNICODE_ERRORS DCNL DCSP if isinstance(value, six.text_type): DCNL DCSP  DCSP return value DCNL DCSP elif isinstance(value, six.binary_type): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return six.text_type(value, encoding, errors) DCNL DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP return six.u(value) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if six.PY2: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP text2 = six.text_type(value) DCNL DCSP  DCSP  DCSP  DCSP except UnicodeError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = str(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP text2 = six.text_type(data, 'unicode-escape', 'replace') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP text2 = six.text_type(value) DCNL DCSP  DCSP except UnicodeError as e: DCNL DCSP  DCSP  DCSP text2 = six.text_type(e) DCNL DCSP  DCSP return text2\n", "intent": "convert into a unicode string .\n", "question_id": 353}, {"snippet": "def find_language(locale): DCNL  DCSP if (not locale): DCNL DCSP  DCSP return None DCNL DCSP LANGS = (settings.AMO_LANGUAGES + settings.HIDDEN_LANGUAGES) DCNL DCSP if (locale in LANGS): DCNL DCSP  DCSP return locale DCNL DCSP loc = settings.SHORTER_LANGUAGES.get(locale) DCNL DCSP if loc: DCNL DCSP  DCSP return loc DCNL DCSP locale = to_language(locale) DCNL DCSP if (locale in LANGS): DCNL DCSP  DCSP return locale DCNL DCSP return None\n", "intent": "return a locale we support .\n", "question_id": 354}, {"snippet": "def hget(key, field, host=None, port=None, db=None, password=None): DCNL  DCSP server = _connect(host, port, db, password) DCNL DCSP return server.hget(key, field)\n", "intent": "get specific field value from a redis hash .\n", "question_id": 355}, {"snippet": "def signed_varint(i): DCNL  DCSP if (i >= 0): DCNL DCSP  DCSP return varint((i << 1)) DCNL DCSP return varint(((i << 1) ^ (~ 0)))\n", "intent": "zig-zag encodes a signed integer into a varint .\n", "question_id": 356}, {"snippet": "def annotate(clip, txt, txt_color='white', bg_color=(0, 0, 255)): DCNL  DCSP txtclip = TextClip(txt, fontsize=20, font='Ubuntu-bold', color=txt_color) DCNL DCSP txtclip = txtclip.on_color((clip.w, (txtclip.h + 6)), color=(0, 0, 255), pos=(6, 'center')) DCNL DCSP cvc = CompositeVideoClip([clip, txtclip.set_pos((0, 'bottom'))]) DCNL DCSP return cvc.set_duration(clip.duration)\n", "intent": "writes a text at the bottom of the clip .\n", "question_id": 357}, {"snippet": "@dog_stats_api.timed('edxapp.heartbeat') DCNL def heartbeat(request): DCNL  DCSP try: DCNL DCSP  DCSP output = modulestore().heartbeat() DCNL DCSP except HeartbeatFailure as fail: DCNL DCSP  DCSP return JsonResponse({fail.service: unicode(fail)}, status=503) DCNL DCSP cursor = connection.cursor() DCNL DCSP try: DCNL DCSP  DCSP cursor.execute('SELECT DCSP CURRENT_DATE') DCNL DCSP  DCSP cursor.fetchone() DCNL DCSP  DCSP output['SQL'] = True DCNL DCSP except DatabaseError as fail: DCNL DCSP  DCSP return JsonResponse({'SQL': unicode(fail)}, status=503) DCNL DCSP return JsonResponse(output)\n", "intent": "simple view that a loadbalancer can check to verify that the app is up .\n", "question_id": 358}, {"snippet": "def restoreVersionedFile(backup_file, version): DCNL  DCSP numTries = 0 DCNL DCSP (new_file, ext_) = ek(os.path.splitext, backup_file) DCNL DCSP restore_file = (((new_file + u'.') + u'v') + str(version)) DCNL DCSP if (not ek(os.path.isfile, new_file)): DCNL DCSP  DCSP logger.log(u\"Not DCSP restoring, DCSP {0} DCSP doesn't DCSP exist\".format(new_file), logger.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP logger.log(u'Trying DCSP to DCSP backup DCSP {0} DCSP to DCSP {1}.r{2} DCSP before DCSP restoring DCSP backup'.format(new_file, new_file, version), logger.DEBUG) DCNL DCSP  DCSP shutil.move(new_file, (((new_file + u'.') + u'r') + str(version))) DCNL DCSP except Exception as error: DCNL DCSP  DCSP logger.log(u'Error DCSP while DCSP trying DCSP to DCSP backup DCSP DB DCSP file DCSP {0} DCSP before DCSP proceeding DCSP with DCSP restore: DCSP {1}'.format(restore_file, error), logger.WARNING) DCNL DCSP  DCSP return False DCNL DCSP while (not ek(os.path.isfile, new_file)): DCNL DCSP  DCSP if (not ek(os.path.isfile, restore_file)): DCNL DCSP  DCSP  DCSP logger.log(u\"Not DCSP restoring, DCSP {0} DCSP doesn't DCSP exist\".format(restore_file), logger.DEBUG) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP logger.log(u'Trying DCSP to DCSP restore DCSP file DCSP {0} DCSP to DCSP {1}'.format(restore_file, new_file), logger.DEBUG) DCNL DCSP  DCSP  DCSP shutil.copy(restore_file, new_file) DCNL DCSP  DCSP  DCSP logger.log(u'Restore DCSP done', logger.DEBUG) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except Exception as error: DCNL DCSP  DCSP  DCSP logger.log(u'Error DCSP while DCSP trying DCSP to DCSP restore DCSP file DCSP {0}. DCSP Error: DCSP {1}'.format(restore_file, error), logger.WARNING) DCNL DCSP  DCSP  DCSP numTries += 1 DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP logger.log(u'Trying DCSP again. DCSP Attempt DCSP #: DCSP {0}'.format(numTries), logger.DEBUG) DCNL DCSP  DCSP if (numTries >= 10): DCNL DCSP  DCSP  DCSP logger.log(u'Unable DCSP to DCSP restore DCSP file DCSP {0} DCSP to DCSP {1}'.format(restore_file, new_file), logger.WARNING) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True\n", "intent": "restore a file version to original state .\n", "question_id": 359}, {"snippet": "def _is_fetching_self(url, method): DCNL  DCSP if ((method != GET) or ('HTTP_HOST' not in os.environ) or ('PATH_INFO' not in os.environ)): DCNL DCSP  DCSP return False DCNL DCSP (_, host_port, path, _, _) = urlparse.urlsplit(url) DCNL DCSP if (host_port == os.environ['HTTP_HOST']): DCNL DCSP  DCSP current_path = urllib2.unquote(os.environ['PATH_INFO']) DCNL DCSP  DCSP desired_path = urllib2.unquote(path) DCNL DCSP  DCSP if ((current_path == desired_path) or ((current_path in ('', '/')) and (desired_path in ('', '/')))): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "checks if the fetch is for the same url from which it originated .\n", "question_id": 360}, {"snippet": "def alert_response(): DCNL  DCSP alert_id = get_vars.get('alert_id') DCNL DCSP if alert_id: DCNL DCSP  DCSP table = s3db.deploy_response DCNL DCSP  DCSP f = table.alert_id DCNL DCSP  DCSP f.readable = f.writable = False DCNL DCSP  DCSP f.default = alert_id DCNL DCSP  DCSP atable = s3db.deploy_alert DCNL DCSP  DCSP alert = db((atable.id == alert_id)).select(atable.mission_id, limitby=(0, 1)).first() DCNL DCSP  DCSP if alert: DCNL DCSP  DCSP  DCSP f = table.mission_id DCNL DCSP  DCSP  DCSP f.readable = f.writable = False DCNL DCSP  DCSP  DCSP f.default = alert.mission_id DCNL DCSP  DCSP human_resource_id = auth.s3_logged_in_human_resource() DCNL DCSP  DCSP if human_resource_id: DCNL DCSP  DCSP  DCSP f = table.human_resource_id_id DCNL DCSP  DCSP  DCSP f.readable = f.writable = False DCNL DCSP  DCSP  DCSP f.default = alert_id DCNL DCSP  DCSP table.message_id.readable = False DCNL DCSP return s3_rest_controller('deploy', 'response')\n", "intent": "restful crud controller - used to allow rit memebers to apply for positions @todo: block all methods but create => what next_url? .\n", "question_id": 361}, {"snippet": "def indent(text, prefix): DCNL  DCSP lines = text DCNL DCSP newline = u'' DCNL DCSP if isinstance(text, six.string_types): DCNL DCSP  DCSP lines = text.splitlines(True) DCNL DCSP elif (lines and (not lines[0].endswith('\\n'))): DCNL DCSP  DCSP newline = u'\\n' DCNL DCSP return newline.join([(prefix + six.text_type(line)) for line in lines])\n", "intent": "indent text or a number of text lines .\n", "question_id": 362}, {"snippet": "def test_basic_call_coroutine(): DCNL  DCSP @hug.call() DCNL DCSP @asyncio.coroutine DCNL DCSP def hello_world(): DCNL DCSP  DCSP return 'Hello DCSP World!' DCNL DCSP assert (loop.run_until_complete(hello_world()) == 'Hello DCSP World!')\n", "intent": "the most basic happy-path test for hug apis using async .\n", "question_id": 363}, {"snippet": "def safe_config_file(config_file): DCNL  DCSP config_file_lower = config_file.lower() DCNL DCSP if _SENSITIVE_FILENAME_REGEX.search(config_file_lower): DCNL DCSP  DCSP return False DCNL DCSP proc = subprocess.Popen(['file', config_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (file_output, _) = proc.communicate() DCNL DCSP if ('ASCII' in file_output): DCNL DCSP  DCSP possible_password_file = empty_or_all_comments = True DCNL DCSP  DCSP with open(config_file) as config_fd: DCNL DCSP  DCSP  DCSP for line in config_fd: DCNL DCSP  DCSP  DCSP  DCSP if (not (line.isspace() or line.lstrip().startswith('#'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP empty_or_all_comments = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line.startswith('-----BEGIN'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (':' not in line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP possible_password_file = False DCNL DCSP  DCSP return (empty_or_all_comments or (not possible_password_file)) DCNL DCSP return False\n", "intent": "returns true if config_file can be safely copied .\n", "question_id": 364}, {"snippet": "def test_fit_sample_auto_decision_tree(): DCNL  DCSP ratio = 'auto' DCNL DCSP classifier = 'decision-tree' DCNL DCSP bc = BalanceCascade(ratio=ratio, random_state=RND_SEED, return_indices=True, classifier=classifier) DCNL DCSP (X_resampled, y_resampled, idx_under) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], dtype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])], dtype=object) DCNL DCSP idx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 13, 1, 7, 9, 15])], dtype=object) DCNL DCSP for idx in range(X_gt.size): DCNL DCSP  DCSP assert_array_equal(X_resampled[idx], X_gt[idx]) DCNL DCSP  DCSP assert_array_equal(y_resampled[idx], y_gt[idx]) DCNL DCSP  DCSP assert_array_equal(idx_under[idx], idx_gt[idx])\n", "intent": "test the fit and sample routine with auto ratio with a decision tree .\n", "question_id": 365}, {"snippet": "def elu(x, alpha=1.0): DCNL  DCSP res = tf.nn.elu(x) DCNL DCSP if (alpha == 1): DCNL DCSP  DCSP return res DCNL DCSP else: DCNL DCSP  DCSP return tf.where((x > 0), res, (alpha * res))\n", "intent": "exponential linear unit .\n", "question_id": 366}, {"snippet": "def test_nm3_fit(): DCNL  DCSP ratio = 'auto' DCNL DCSP nm3 = NearMiss(ratio=ratio, random_state=RND_SEED, version=VERSION_NEARMISS) DCNL DCSP nm3.fit(X, Y) DCNL DCSP assert_equal(nm3.min_c_, 0) DCNL DCSP assert_equal(nm3.maj_c_, 2) DCNL DCSP assert_equal(nm3.stats_c_[0], 3) DCNL DCSP assert_equal(nm3.stats_c_[1], 5) DCNL DCSP assert_equal(nm3.stats_c_[2], 7)\n", "intent": "test the fitting method .\n", "question_id": 367}, {"snippet": "def _get_certificate_obj(cert): DCNL  DCSP if isinstance(cert, M2Crypto.X509.X509): DCNL DCSP  DCSP return cert DCNL DCSP text = _text_or_file(cert) DCNL DCSP text = get_pem_entry(text, pem_type='CERTIFICATE') DCNL DCSP return M2Crypto.X509.load_cert_string(text)\n", "intent": "returns a certificate object based on pem text .\n", "question_id": 368}, {"snippet": "def http_session(func): DCNL  DCSP @functools.wraps(func) DCNL DCSP def inner(message, *args, **kwargs): DCNL DCSP  DCSP if hasattr(message, 'http_session'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(message, *args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP if ((message.http_session is not None) and message.http_session.modified): DCNL DCSP  DCSP  DCSP  DCSP  DCSP message.http_session.save() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ('method' not in message.content): DCNL DCSP  DCSP  DCSP  DCSP message.content['method'] = 'FAKE' DCNL DCSP  DCSP  DCSP request = AsgiRequest(message) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise ValueError(('Cannot DCSP parse DCSP HTTP DCSP message DCSP - DCSP are DCSP you DCSP sure DCSP this DCSP is DCSP a DCSP HTTP DCSP consumer? DCSP %s' % e)) DCNL DCSP  DCSP session_key = request.GET.get('session_key', None) DCNL DCSP  DCSP if (session_key is None): DCNL DCSP  DCSP  DCSP session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None) DCNL DCSP  DCSP if session_key: DCNL DCSP  DCSP  DCSP session_engine = import_module(settings.SESSION_ENGINE) DCNL DCSP  DCSP  DCSP session = session_engine.SessionStore(session_key=session_key) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP session = None DCNL DCSP  DCSP message.http_session = session DCNL DCSP  DCSP result = func(message, *args, **kwargs) DCNL DCSP  DCSP if ((session is not None) and session.modified): DCNL DCSP  DCSP  DCSP session.save() DCNL DCSP  DCSP return result DCNL DCSP return inner\n", "intent": "wraps a http or websocket connect consumer  to provide a \"http_session\" attribute that behaves like request .\n", "question_id": 369}, {"snippet": "def get_env(): DCNL  DCSP global _jinja_env DCNL DCSP if (_jinja_env is None): DCNL DCSP  DCSP _jinja_env = create_env() DCNL DCSP return _jinja_env\n", "intent": "get the jinja2 env and initialize it if necessary .\n", "question_id": 370}, {"snippet": "def base64pickle(value): DCNL  DCSP retVal = None DCNL DCSP try: DCNL DCSP  DCSP retVal = base64encode(pickle.dumps(value, pickle.HIGHEST_PROTOCOL)) DCNL DCSP except: DCNL DCSP  DCSP warnMsg = 'problem DCSP occurred DCSP while DCSP serializing DCSP ' DCNL DCSP  DCSP warnMsg += (\"instance DCSP of DCSP a DCSP type DCSP '%s'\" % type(value)) DCNL DCSP  DCSP singleTimeWarnMessage(warnMsg) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP retVal = base64encode(pickle.dumps(value)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP retVal = base64encode(pickle.dumps(str(value), pickle.HIGHEST_PROTOCOL)) DCNL DCSP return retVal\n", "intent": "serializes  and encodes to base64 format supplied  value .\n", "question_id": 371}, {"snippet": "def make_plots(background_color, label_color, rares, ymax, xmax, output_dir, resolution, imagetype, groups, colors, data_colors, metric_name, labelname, rarefaction_data_mat, rarefaction_legend_mat, sample_dict, sample_data_colors, sample_colors, mapping_lookup, output_type='file_creation', generate_per_sample_plots=True): DCNL  DCSP raredata = rares DCNL DCSP file_path = os.path.join(output_dir, splitext(split(raredata['headers'][0])[1])[0]) DCNL DCSP all_plots_single = [] DCNL DCSP for i in natsort(groups): DCNL DCSP  DCSP for j in range(len(raredata['xaxis'])): DCNL DCSP  DCSP  DCSP group_field = i DCNL DCSP  DCSP  DCSP seq_per_sample_field = int(raredata['xaxis'][j]) DCNL DCSP  DCSP  DCSP color_field = data_colors[colors[group_field]].toHex() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP average_field = raredata['series'][i][j] DCNL DCSP  DCSP  DCSP  DCSP error_field = raredata['error'][i][j] DCNL DCSP  DCSP  DCSP  DCSP if isnan(average_field): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error_field = nan DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP average_field = nan DCNL DCSP  DCSP  DCSP  DCSP error_field = nan DCNL DCSP  DCSP  DCSP if (i in rarefaction_data_mat[labelname]): DCNL DCSP  DCSP  DCSP  DCSP if (metric_name in rarefaction_data_mat[labelname][i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['ave'].append(''.join(('%10.3f' % raredata['series'][i][j]))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['err'].append(''.join(('%10.3f' % raredata['error'][i][j]))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name] = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['ave'] = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['err'] = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['ave'].append(''.join(('%10.3f' % raredata['series'][i][j]))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['err'].append(''.join(('%10.3f' % raredata['error'][i][j]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i] = {} DCNL DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name] = {} DCNL DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['ave'] = [] DCNL DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['err'] = [] DCNL DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['ave'].append(''.join(('%10.3f' % raredata['series'][i][j]))) DCNL DCSP  DCSP  DCSP  DCSP rarefaction_data_mat[labelname][i][metric_name]['err'].append(''.join(('%10.3f' % raredata['error'][i][j]))) DCNL DCSP  DCSP if generate_per_sample_plots: DCNL DCSP  DCSP  DCSP if (output_type == 'file_creation'): DCNL DCSP  DCSP  DCSP  DCSP rarefaction_legend_mat = save_single_rarefaction_plots(sample_dict, imagetype, metric_name, sample_data_colors, sample_colors, output_dir, background_color, label_color, resolution, ymax, xmax, rarefaction_legend_mat, groups[i], labelname, i, mapping_lookup, output_type) DCNL DCSP  DCSP  DCSP elif (output_type == 'memory'): DCNL DCSP  DCSP  DCSP  DCSP (rarefaction_legend_mat, rare_plot_for_all) = save_single_rarefaction_plots(sample_dict, imagetype, metric_name, sample_data_colors, sample_colors, output_dir, background_color, label_color, resolution, ymax, xmax, rarefaction_legend_mat, groups[i], labelname, i, mapping_lookup, output_type) DCNL DCSP  DCSP  DCSP  DCSP all_plots_single.append(rare_plot_for_all) DCNL DCSP all_plots_ave = {} DCNL DCSP if generate_per_sample_plots: DCNL DCSP  DCSP categories = [k for k in groups] DCNL DCSP  DCSP if (output_type == 'file_creation'): DCNL DCSP  DCSP  DCSP rarefaction_legend_mat = save_single_ave_rarefaction_plots(raredata['xaxis'], raredata['series'], raredata['error'], xmax, ymax, categories, labelname, imagetype, resolution, data_colors, colors, file_path, background_color, label_color, rarefaction_legend_mat, metric_name, mapping_lookup, output_type) DCNL DCSP  DCSP elif (output_type == 'memory'): DCNL DCSP  DCSP  DCSP (rarefaction_legend_mat, all_plots_ave) = save_single_ave_rarefaction_plots(raredata['xaxis'], raredata['series'], raredata['error'], xmax, ymax, categories, labelname, imagetype, resolution, data_colors, colors, file_path, background_color, label_color, rarefaction_legend_mat, metric_name, mapping_lookup, output_type) DCNL DCSP if (output_type == 'file_creation'): DCNL DCSP  DCSP return (rarefaction_data_mat, rarefaction_legend_mat) DCNL DCSP elif (output_type == 'memory'): DCNL DCSP  DCSP return (rarefaction_data_mat, rarefaction_legend_mat, all_plots_single, all_plots_ave)\n", "intent": "this is the main function for generating the rarefaction plots and html file .\n", "question_id": 372}, {"snippet": "@pytest.mark.parametrize(u'testframe', totest_frames) DCNL def test_cirs_altaz_nodist(testframe): DCNL  DCSP coo0 = CIRS(UnitSphericalRepresentation((10 * u.deg), (20 * u.deg)), obstime=testframe.obstime) DCNL DCSP coo1 = coo0.transform_to(testframe).transform_to(coo0) DCNL DCSP assert_allclose(coo0.cartesian.xyz, coo1.cartesian.xyz)\n", "intent": "check that a unitsphericalrepresentation coordinate round-trips for the cirs<->altaz transformation .\n", "question_id": 373}, {"snippet": "def get_defaults(context): DCNL  DCSP maxint = ((1 << (context.address_size - 1)) - 1) DCNL DCSP return (0, maxint, maxint, ((- maxint) - 1), 1)\n", "intent": "get the default values for a slices members: .\n", "question_id": 374}, {"snippet": "def TIMEOUT(v): DCNL  DCSP context.defaults['timeout'] = int(v)\n", "intent": "sets a timeout for tube operations  via context .\n", "question_id": 375}, {"snippet": "def gep_inbounds(builder, ptr, *inds, **kws): DCNL  DCSP return gep(builder, ptr, inbounds=True, *inds, **kws)\n", "intent": "same as *gep* .\n", "question_id": 376}, {"snippet": "def get_exp_metadata_dicts_matching_query(query_string, search_cursor, user_id): DCNL  DCSP (exp_ids, new_search_cursor) = exp_services.get_exploration_ids_matching_query(query_string, cursor=search_cursor) DCNL DCSP exploration_list = get_exploration_metadata_dicts(exp_ids, user_id) DCNL DCSP return (exploration_list, new_search_cursor)\n", "intent": "given a query string and a search cursor .\n", "question_id": 377}, {"snippet": "def MimeReplaceFilename(header, filename): DCNL  DCSP start = header.find('filename=') DCNL DCSP start = header.find('\"', start) DCNL DCSP end = (header.find('\"', (start + 1)) + 1) DCNL DCSP if ((start > 0) and (end > start)): DCNL DCSP  DCSP headernew = ((header[:(start + 1)] + filename) + header[(end - 1):]) DCNL DCSP else: DCNL DCSP  DCSP headernew = header[:] DCNL DCSP return headernew\n", "intent": "accepts a mime header containing filename=\" .\n", "question_id": 378}, {"snippet": "def set_default_retry_params(retry_params): DCNL  DCSP _thread_local_settings.default_retry_params = copy.copy(retry_params)\n", "intent": "set a default retryparams for current thread current request .\n", "question_id": 379}, {"snippet": "def load_list_of_tasks(ds, play, block=None, role=None, task_include=None, use_handlers=False, variable_manager=None, loader=None): DCNL  DCSP from ansible.playbook.block import Block DCNL DCSP from ansible.playbook.handler import Handler DCNL DCSP from ansible.playbook.task import Task DCNL DCSP from ansible.playbook.task_include import TaskInclude DCNL DCSP from ansible.playbook.role_include import IncludeRole DCNL DCSP from ansible.playbook.handler_task_include import HandlerTaskInclude DCNL DCSP from ansible.template import Templar DCNL DCSP assert isinstance(ds, list) DCNL DCSP task_list = [] DCNL DCSP for task_ds in ds: DCNL DCSP  DCSP assert isinstance(task_ds, dict) DCNL DCSP  DCSP if ('block' in task_ds): DCNL DCSP  DCSP  DCSP t = Block.load(task_ds, play=play, parent_block=block, role=role, task_include=task_include, use_handlers=use_handlers, variable_manager=variable_manager, loader=loader) DCNL DCSP  DCSP  DCSP task_list.append(t) DCNL DCSP  DCSP elif ('include' in task_ds): DCNL DCSP  DCSP  DCSP if use_handlers: DCNL DCSP  DCSP  DCSP  DCSP include_class = HandlerTaskInclude DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP include_class = TaskInclude DCNL DCSP  DCSP  DCSP t = include_class.load(task_ds, block=block, role=role, task_include=None, variable_manager=variable_manager, loader=loader) DCNL DCSP  DCSP  DCSP all_vars = variable_manager.get_vars(loader=loader, play=play, task=t) DCNL DCSP  DCSP  DCSP templar = Templar(loader=loader, variables=all_vars) DCNL DCSP  DCSP  DCSP if (t.static is not None): DCNL DCSP  DCSP  DCSP  DCSP is_static = t.static DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP is_static = (C.DEFAULT_TASK_INCLUDES_STATIC or (use_handlers and C.DEFAULT_HANDLER_INCLUDES_STATIC) or ((not templar._contains_vars(t.args['_raw_params'])) and t.all_parents_static() and (not t.loop))) DCNL DCSP  DCSP  DCSP if is_static: DCNL DCSP  DCSP  DCSP  DCSP if (t.loop is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError(\"You DCSP cannot DCSP use DCSP 'static' DCSP on DCSP an DCSP include DCSP with DCSP a DCSP loop\", obj=task_ds) DCNL DCSP  DCSP  DCSP  DCSP t.statically_loaded = True DCNL DCSP  DCSP  DCSP  DCSP parent_include = block DCNL DCSP  DCSP  DCSP  DCSP cumulative_path = None DCNL DCSP  DCSP  DCSP  DCSP found = False DCNL DCSP  DCSP  DCSP  DCSP subdir = 'tasks' DCNL DCSP  DCSP  DCSP  DCSP if use_handlers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP subdir = 'handlers' DCNL DCSP  DCSP  DCSP  DCSP while (parent_include is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(parent_include, TaskInclude)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent_include = parent_include._parent DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_include_dir = templar.template(os.path.dirname(parent_include.args.get('_raw_params'))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cumulative_path is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cumulative_path = parent_include_dir DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (not os.path.isabs(cumulative_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cumulative_path = os.path.join(parent_include_dir, cumulative_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP include_target = templar.template(t.args['_raw_params']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if t._role: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_basedir = os.path.join(t._role._role_path, subdir, cumulative_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP include_file = loader.path_dwim_relative(new_basedir, subdir, include_target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP include_file = loader.path_dwim_relative(loader.get_basedir(), cumulative_path, include_target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(include_file): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent_include = parent_include._parent DCNL DCSP  DCSP  DCSP  DCSP if (not found): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP include_target = templar.template(t.args['_raw_params']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AnsibleUndefinedVariable: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError(('Error DCSP when DCSP evaluating DCSP variable DCSP in DCSP include DCSP name: DCSP %s.\\n\\nWhen DCSP using DCSP static DCSP includes, DCSP ensure DCSP that DCSP any DCSP variables DCSP used DCSP in DCSP their DCSP names DCSP are DCSP defined DCSP in DCSP vars/vars_files\\nor DCSP extra-vars DCSP passed DCSP in DCSP from DCSP the DCSP command DCSP line. DCSP Static DCSP includes DCSP cannot DCSP use DCSP variables DCSP from DCSP inventory\\nsources DCSP like DCSP group DCSP or DCSP host DCSP vars.' % t.args['_raw_params']), obj=task_ds, suppress_extended_error=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if t._role: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP include_file = loader.path_dwim_relative(t._role._role_path, subdir, include_target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP include_file = loader.path_dwim(include_target) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = loader.load_from_file(include_file) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (data is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (not isinstance(data, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError('included DCSP task DCSP files DCSP must DCSP contain DCSP a DCSP list DCSP of DCSP tasks', obj=data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP display.vv(('statically DCSP included: DCSP %s' % include_file)) DCNL DCSP  DCSP  DCSP  DCSP except AnsibleFileNotFound: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (t.static or C.DEFAULT_TASK_INCLUDES_STATIC or (C.DEFAULT_HANDLER_INCLUDES_STATIC and use_handlers)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP display.deprecated((\"Included DCSP file DCSP '%s' DCSP not DCSP found, DCSP however DCSP since DCSP this DCSP include DCSP is DCSP not DCSP explicitly DCSP marked DCSP as DCSP 'static: DCSP yes', DCSP we DCSP will DCSP try DCSP and DCSP include DCSP it DCSP dynamically DCSP later. DCSP In DCSP the DCSP future, DCSP this DCSP will DCSP be DCSP an DCSP error DCSP unless DCSP 'static: DCSP no' DCSP is DCSP used DCSP on DCSP the DCSP include DCSP task. DCSP If DCSP you DCSP do DCSP not DCSP want DCSP missing DCSP includes DCSP to DCSP be DCSP considered DCSP dynamic, DCSP use DCSP 'static: DCSP yes' DCSP on DCSP the DCSP include DCSP or DCSP set DCSP the DCSP global DCSP ansible.cfg DCSP options DCSP to DCSP make DCSP all DCSP inclues DCSP static DCSP for DCSP tasks DCSP and/or DCSP handlers\" % include_file)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP task_list.append(t) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP ti_copy = t.copy(exclude_parent=True) DCNL DCSP  DCSP  DCSP  DCSP ti_copy._parent = block DCNL DCSP  DCSP  DCSP  DCSP included_blocks = load_list_of_blocks(data, play=play, parent_block=None, task_include=ti_copy, role=role, use_handlers=use_handlers, loader=loader, variable_manager=variable_manager) DCNL DCSP  DCSP  DCSP  DCSP tags = ti_copy.vars.pop('tags', []) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(tags, string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tags = tags.split(',') DCNL DCSP  DCSP  DCSP  DCSP if (len(tags) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(ti_copy.tags) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AnsibleParserError('Include DCSP tasks DCSP should DCSP not DCSP specify DCSP tags DCSP in DCSP more DCSP than DCSP one DCSP way DCSP (both DCSP via DCSP args DCSP and DCSP directly DCSP on DCSP the DCSP task). DCSP Mixing DCSP styles DCSP in DCSP which DCSP tags DCSP are DCSP specified DCSP is DCSP prohibited DCSP for DCSP whole DCSP import DCSP hierarchy, DCSP not DCSP only DCSP for DCSP single DCSP import DCSP statement', obj=task_ds, suppress_extended_error=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP display.deprecated('You DCSP should DCSP not DCSP specify DCSP tags DCSP in DCSP the DCSP include DCSP parameters. DCSP All DCSP tags DCSP should DCSP be DCSP specified DCSP using DCSP the DCSP task-level DCSP option') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tags = ti_copy.tags[:] DCNL DCSP  DCSP  DCSP  DCSP for b in included_blocks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP b.tags = list(set(b.tags).union(tags)) DCNL DCSP  DCSP  DCSP  DCSP if use_handlers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for b in included_blocks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP task_list.extend(b.block) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP task_list.extend(included_blocks) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP task_list.append(t) DCNL DCSP  DCSP elif ('include_role' in task_ds): DCNL DCSP  DCSP  DCSP ir = IncludeRole.load(task_ds, block=block, role=role, task_include=None, variable_manager=variable_manager, loader=loader) DCNL DCSP  DCSP  DCSP if (ir.static is not None): DCNL DCSP  DCSP  DCSP  DCSP is_static = ir.static DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP display.debug('Determine DCSP if DCSP include_role DCSP is DCSP static') DCNL DCSP  DCSP  DCSP  DCSP all_vars = variable_manager.get_vars(loader=loader, play=play, task=ir) DCNL DCSP  DCSP  DCSP  DCSP templar = Templar(loader=loader, variables=all_vars) DCNL DCSP  DCSP  DCSP  DCSP needs_templating = False DCNL DCSP  DCSP  DCSP  DCSP for param in ir.args: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if templar._contains_vars(ir.args[param]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not templar.templatable(ir.args[param])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP needs_templating = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP is_static = (C.DEFAULT_TASK_INCLUDES_STATIC or (use_handlers and C.DEFAULT_HANDLER_INCLUDES_STATIC) or ((not needs_templating) and ir.all_parents_static() and (not ir.loop))) DCNL DCSP  DCSP  DCSP  DCSP display.debug(('Determined DCSP that DCSP if DCSP include_role DCSP static DCSP is DCSP %s' % str(is_static))) DCNL DCSP  DCSP  DCSP if is_static: DCNL DCSP  DCSP  DCSP  DCSP t = task_list.extend(ir.get_block_list(variable_manager=variable_manager, loader=loader)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP t = task_list.append(ir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if use_handlers: DCNL DCSP  DCSP  DCSP  DCSP t = Handler.load(task_ds, block=block, role=role, task_include=task_include, variable_manager=variable_manager, loader=loader) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP t = Task.load(task_ds, block=block, role=role, task_include=task_include, variable_manager=variable_manager, loader=loader) DCNL DCSP  DCSP  DCSP task_list.append(t) DCNL DCSP return task_list\n", "intent": "given a list of task datastructures .\n", "question_id": 380}, {"snippet": "def _platform(*args): DCNL  DCSP platform = string.join(map(string.strip, filter(len, args)), '-') DCNL DCSP replace = string.replace DCNL DCSP platform = replace(platform, ' DCSP ', '_') DCNL DCSP platform = replace(platform, '/', '-') DCNL DCSP platform = replace(platform, '\\\\', '-') DCNL DCSP platform = replace(platform, ':', '-') DCNL DCSP platform = replace(platform, ';', '-') DCNL DCSP platform = replace(platform, '\"', '-') DCNL DCSP platform = replace(platform, '(', '-') DCNL DCSP platform = replace(platform, ')', '-') DCNL DCSP platform = replace(platform, 'unknown', '') DCNL DCSP while 1: DCNL DCSP  DCSP cleaned = replace(platform, '--', '-') DCNL DCSP  DCSP if (cleaned == platform): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP platform = cleaned DCNL DCSP while (platform[(-1)] == '-'): DCNL DCSP  DCSP platform = platform[:(-1)] DCNL DCSP return platform\n", "intent": "helper to format the platform string in a filename compatible format e .\n", "question_id": 381}, {"snippet": "def flip_axis_multi(x, axis, is_random=False): DCNL  DCSP if is_random: DCNL DCSP  DCSP factor = np.random.uniform((-1), 1) DCNL DCSP  DCSP if (factor > 0): DCNL DCSP  DCSP  DCSP results = [] DCNL DCSP  DCSP  DCSP for data in x: DCNL DCSP  DCSP  DCSP  DCSP data = np.asarray(data).swapaxes(axis, 0) DCNL DCSP  DCSP  DCSP  DCSP data = data[::(-1), ...] DCNL DCSP  DCSP  DCSP  DCSP data = data.swapaxes(0, axis) DCNL DCSP  DCSP  DCSP  DCSP results.append(data) DCNL DCSP  DCSP  DCSP return np.asarray(results) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return np.asarray(x) DCNL DCSP else: DCNL DCSP  DCSP results = [] DCNL DCSP  DCSP for data in x: DCNL DCSP  DCSP  DCSP data = np.asarray(data).swapaxes(axis, 0) DCNL DCSP  DCSP  DCSP data = data[::(-1), ...] DCNL DCSP  DCSP  DCSP data = data.swapaxes(0, axis) DCNL DCSP  DCSP  DCSP results.append(data) DCNL DCSP  DCSP return np.asarray(results)\n", "intent": "flip the axises of multiple images together .\n", "question_id": 382}, {"snippet": "def parse_cost_term(source, cost): DCNL  DCSP coeff = parse_count(source) DCNL DCSP ch = source.get() DCNL DCSP if (ch not in 'dis'): DCNL DCSP  DCSP raise ParseError() DCNL DCSP if (ch in cost): DCNL DCSP  DCSP raise error('repeated DCSP fuzzy DCSP cost', source.string, source.pos) DCNL DCSP cost[ch] = int((coeff or 1))\n", "intent": "parses a cost equation term .\n", "question_id": 383}, {"snippet": "def p_statement_newline(p): DCNL  DCSP p[0] = None\n", "intent": "statement : newline .\n", "question_id": 384}, {"snippet": "def getRGBspectra(stimSize=0.3, winSize=(800, 600), photometer='COM1'): DCNL  DCSP import psychopy.event DCNL DCSP import psychopy.visual DCNL DCSP if hasattr(photometer, 'getLastSpectrum'): DCNL DCSP  DCSP photom = photometer DCNL DCSP else: DCNL DCSP  DCSP photom = hardware.Photometer(photometer) DCNL DCSP if (photom != None): DCNL DCSP  DCSP havephotom = 1 DCNL DCSP else: DCNL DCSP  DCSP havephotom = 0 DCNL DCSP myWin = psychopy.visual.Window(fullscr=0, rgb=0.0, size=winSize, units='norm') DCNL DCSP instructions = 'Point DCSP the DCSP photometer DCSP at DCSP the DCSP central DCSP square. DCSP Hit DCSP a DCSP key DCSP when DCSP ready' DCNL DCSP message = psychopy.visual.TextStim(myWin, text=instructions, height=0.1, pos=(0.0, (-0.8)), rgb=(-1.0)) DCNL DCSP message.draw() DCNL DCSP testPatch = psychopy.visual.PatchStim(myWin, tex=None, size=(stimSize * 2), rgb=0.3) DCNL DCSP testPatch.draw() DCNL DCSP myWin.flip() DCNL DCSP psychopy.event.waitKeys(30) DCNL DCSP spectra = [] DCNL DCSP for thisColor in [[1, (-1), (-1)], [(-1), 1, (-1)], [(-1), (-1), 1]]: DCNL DCSP  DCSP testPatch.setColor(thisColor) DCNL DCSP  DCSP testPatch.draw() DCNL DCSP  DCSP myWin.flip() DCNL DCSP  DCSP photom.measure() DCNL DCSP  DCSP spectra.append(photom.getLastSpectrum(parse=False)) DCNL DCSP myWin.close() DCNL DCSP (nm, power) = photom.parseSpectrumOutput(spectra) DCNL DCSP return (nm, power)\n", "intent": "usage: getrgbspectra(stimsize=0 .\n", "question_id": 385}, {"snippet": "def _did_you_mean(name, choices): DCNL  DCSP if (not choices): DCNL DCSP  DCSP return None DCNL DCSP name = name.lower() DCNL DCSP candidates = [(_levenshtein(name, c), c) for c in choices] DCNL DCSP candidates.sort() DCNL DCSP if (candidates[0][0] <= 3): DCNL DCSP  DCSP return candidates[0][1] DCNL DCSP return None\n", "intent": "suggest most likely setting based on levenshtein .\n", "question_id": 386}, {"snippet": "def remove_package(package, dst): DCNL  DCSP path = os.path.join(package.where, package.name) DCNL DCSP run_scripts(path, scripts=['prerm']) DCNL DCSP shutil.rmtree(os.path.join(path, 'data/')) DCNL DCSP shutil.rmtree(os.path.join(path, 'docs/')) DCNL DCSP run_scripts(os.path.join(dst, package.name), scripts=['postrm']) DCNL DCSP shutil.rmtree(os.path.join(path, 'scripts/')) DCNL DCSP shutil.rmtree(path) DCNL DCSP update_installed_list('r', package)\n", "intent": "removes a script by running the various removal scripts .\n", "question_id": 387}, {"snippet": "def _makePipe(): DCNL  DCSP (r, w) = pipe() DCNL DCSP return (_FDHolder(r), _FDHolder(w))\n", "intent": "create a pipe .\n", "question_id": 388}, {"snippet": "def snmp_wrapper(a_device, oid): DCNL  DCSP snmp_dict = snmp_preprocessor(a_device, oid) DCNL DCSP snmp_data = snmp_get_oid_v3(**snmp_dict) DCNL DCSP return snmp_extract(snmp_data)\n", "intent": "snmp wrappers that extracts snmp information from a_device object queries device by oid extracts snmp_data .\n", "question_id": 389}, {"snippet": "def kron(a, b): DCNL  DCSP a = tensor.as_tensor_variable(a) DCNL DCSP b = tensor.as_tensor_variable(b) DCNL DCSP if ((a.ndim + b.ndim) <= 2): DCNL DCSP  DCSP raise TypeError(('kron: DCSP inputs DCSP dimensions DCSP must DCSP sum DCSP to DCSP 3 DCSP or DCSP more. DCSP You DCSP passed DCSP %d DCSP and DCSP %d.' % (a.ndim, b.ndim))) DCNL DCSP o = tensor.outer(a, b) DCNL DCSP o = o.reshape(tensor.concatenate((a.shape, b.shape)), (a.ndim + b.ndim)) DCNL DCSP shf = o.dimshuffle(0, 2, 1, *list(range(3, o.ndim))) DCNL DCSP if (shf.ndim == 3): DCNL DCSP  DCSP shf = o.dimshuffle(1, 0, 2) DCNL DCSP  DCSP o = shf.flatten() DCNL DCSP else: DCNL DCSP  DCSP o = shf.reshape((((o.shape[0] * o.shape[2]), (o.shape[1] * o.shape[3])) + tuple((o.shape[i] for i in xrange(4, o.ndim))))) DCNL DCSP return o\n", "intent": "kronecker product .\n", "question_id": 390}, {"snippet": "@ship.command('new') DCNL @click.argument('name') DCNL def ship_new(name): DCNL  DCSP click.echo(('Created DCSP ship DCSP %s' % name))\n", "intent": "creates a new ship .\n", "question_id": 391}, {"snippet": "def read_config(cfg): DCNL  DCSP return read_slicer_config(cfg)\n", "intent": "read the configuration file .\n", "question_id": 392}, {"snippet": "def getCylindrical(azimuthDegrees, radius=1.0, z=0.0): DCNL  DCSP return getCylindricalByRadians(math.radians(azimuthDegrees), radius, z)\n", "intent": "get the cylindrical vector3 by degrees .\n", "question_id": 393}, {"snippet": "def create_spider_for_request(spidermanager, request, default_spider=None, log_none=False, log_multiple=False, **spider_kwargs): DCNL  DCSP snames = spidermanager.find_by_request(request) DCNL DCSP if (len(snames) == 1): DCNL DCSP  DCSP return spidermanager.create(snames[0], **spider_kwargs) DCNL DCSP if ((len(snames) > 1) and log_multiple): DCNL DCSP  DCSP log.msg(('More DCSP than DCSP one DCSP spider DCSP can DCSP handle: DCSP %s DCSP - DCSP %s' % (request, ', DCSP '.join(snames))), log.ERROR) DCNL DCSP if ((len(snames) == 0) and log_none): DCNL DCSP  DCSP log.msg(('Unable DCSP to DCSP find DCSP spider DCSP that DCSP handles: DCSP %s' % request), log.ERROR) DCNL DCSP return default_spider\n", "intent": "create a spider to handle the given request .\n", "question_id": 394}, {"snippet": "def flatten_dictionary(input, sep='.', prefix=None): DCNL  DCSP for (name, value) in sorted(input.items()): DCNL DCSP  DCSP fullname = sep.join(filter(None, [prefix, name])) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP for result in flatten_dictionary(value, sep, fullname): DCNL DCSP  DCSP  DCSP  DCSP (yield result) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield (fullname, value))\n", "intent": "produces iterator of pairs where the first value is the joined key names and the second value is the value associated with the lowest level key .\n", "question_id": 395}, {"snippet": "def fourier_transform(f, x, k, **hints): DCNL  DCSP return FourierTransform(f, x, k).doit(**hints)\n", "intent": "compute the unitary .\n", "question_id": 396}, {"snippet": "def list_hosts_by_datacenter(kwargs=None, call=None): DCNL  DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP list_hosts_by_datacenter DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP ret = {} DCNL DCSP datacenter_name = (kwargs.get('datacenter') if (kwargs and ('datacenter' in kwargs)) else None) DCNL DCSP datacenter_properties = ['name'] DCNL DCSP datacenter_list = salt.utils.vmware.get_mors_with_properties(_get_si(), vim.Datacenter, datacenter_properties) DCNL DCSP for datacenter in datacenter_list: DCNL DCSP  DCSP ret[datacenter['name']] = [] DCNL DCSP  DCSP for cluster in datacenter['object'].hostFolder.childEntity: DCNL DCSP  DCSP  DCSP if isinstance(cluster, vim.ClusterComputeResource): DCNL DCSP  DCSP  DCSP  DCSP for host in cluster.host: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(host, vim.HostSystem): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret[datacenter['name']].append(host.name) DCNL DCSP  DCSP if (datacenter_name and (datacenter_name == datacenter['name'])): DCNL DCSP  DCSP  DCSP return {'Hosts DCSP by DCSP Datacenter': {datacenter_name: ret[datacenter_name]}} DCNL DCSP return {'Hosts DCSP by DCSP Datacenter': ret}\n", "intent": "list hosts for each datacenter; or hosts for a specified datacenter in this vmware environment to list hosts for each datacenter: cli example: .\n", "question_id": 397}, {"snippet": "def get_with_search(endpoint, term): DCNL  DCSP try: DCNL DCSP  DCSP params = {'q': term, 'client_id': api_key} DCNL DCSP  DCSP request = requests.get(API_BASE.format(endpoint), params=params) DCNL DCSP  DCSP request.raise_for_status() DCNL DCSP except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError) as e: DCNL DCSP  DCSP raise APIError('Could DCSP not DCSP find DCSP {}: DCSP {}'.format(endpoint, e)) DCNL DCSP json = request.json() DCNL DCSP if (not json): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return json[0]\n", "intent": "searches :endpoint on soundcloud for :term and returns an item .\n", "question_id": 398}, {"snippet": "def test_pickle_globals(): DCNL  DCSP def f(x): DCNL DCSP  DCSP return (np.sin(x) + np.cos(x)) DCNL DCSP assert (set(['np', '__builtins__']) == set(_loads(_dumps(f)).__globals__.keys()))\n", "intent": "for the function f(x) defined below .\n", "question_id": 399}, {"snippet": "def _getnames(self, yname=None, xname=None): DCNL  DCSP if (yname is None): DCNL DCSP  DCSP if (hasattr(self.model, 'endog_names') and (not (self.model.endog_names is None))): DCNL DCSP  DCSP  DCSP yname = self.model.endog_names DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP yname = 'y' DCNL DCSP if (xname is None): DCNL DCSP  DCSP if (hasattr(self.model, 'exog_names') and (not (self.model.exog_names is None))): DCNL DCSP  DCSP  DCSP xname = self.model.exog_names DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xname = [('var_%d' % i) for i in range(len(self.params))] DCNL DCSP return (yname, xname)\n", "intent": "extract names from model or construct names .\n", "question_id": 400}, {"snippet": "def copy_sample_files(app, sample_files, tool_path=None, sample_files_copied=None, dest_path=None): DCNL  DCSP filenames_not_to_copy = ['tool_data_table_conf.xml.sample'] DCNL DCSP sample_files_copied = util.listify(sample_files_copied) DCNL DCSP for filename in sample_files: DCNL DCSP  DCSP filename_sans_path = os.path.split(filename)[1] DCNL DCSP  DCSP if ((filename_sans_path not in filenames_not_to_copy) and (filename not in sample_files_copied)): DCNL DCSP  DCSP  DCSP if tool_path: DCNL DCSP  DCSP  DCSP  DCSP filename = os.path.join(tool_path, filename) DCNL DCSP  DCSP  DCSP if is_data_index_sample_file(filename): DCNL DCSP  DCSP  DCSP  DCSP copy_sample_file(app, filename, dest_path=dest_path)\n", "intent": "copy all appropriate files to dest_path in the local galaxy environment that have not already been copied .\n", "question_id": 401}, {"snippet": "def install_hook(): DCNL  DCSP for hook in sys.meta_path: DCNL DCSP  DCSP if isinstance(hook, XonshImportHook): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP sys.meta_path.append(XonshImportHook())\n", "intent": "install xonsh import hook in sys .\n", "question_id": 402}, {"snippet": "def nexus_artifact_uploader(registry, xml_parent, data): DCNL  DCSP nexus_artifact_uploader = XML.SubElement(xml_parent, 'sp.sd.nexusartifactuploader.NexusArtifactUploader') DCNL DCSP mapping = [('protocol', 'protocol', 'https'), ('nexus_url', 'nexusUrl', ''), ('nexus_user', 'nexusUser', ''), ('nexus_password', 'nexusPassword', ''), ('group_id', 'groupId', ''), ('artifact_id', 'artifactId', ''), ('version', 'version', ''), ('packaging', 'packaging', ''), ('type', 'type', ''), ('classifier', 'classifier', ''), ('repository', 'repository', ''), ('file', 'file', ''), ('credentials_id', 'credentialsId', '')] DCNL DCSP convert_mapping_to_xml(nexus_artifact_uploader, data, mapping, fail_required=True)\n", "intent": "yaml: nexus-artifact-uploader to upload result of a build as an artifact in nexus without the need of maven .\n", "question_id": 403}, {"snippet": "def add_ngram(sequences, token_indice, ngram_range=2): DCNL  DCSP new_sequences = [] DCNL DCSP for input_list in sequences: DCNL DCSP  DCSP new_list = input_list[:] DCNL DCSP  DCSP for i in range(((len(new_list) - ngram_range) + 1)): DCNL DCSP  DCSP  DCSP for ngram_value in range(2, (ngram_range + 1)): DCNL DCSP  DCSP  DCSP  DCSP ngram = tuple(new_list[i:(i + ngram_value)]) DCNL DCSP  DCSP  DCSP  DCSP if (ngram in token_indice): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_list.append(token_indice[ngram]) DCNL DCSP  DCSP new_sequences.append(new_list) DCNL DCSP return new_sequences\n", "intent": "augment the input list of list  by appending n-grams values .\n", "question_id": 404}, {"snippet": "@image_comparison(baseline_images=[u'EventCollection_plot__default']) DCNL def test__EventCollection__get_segments(): DCNL  DCSP (_, coll, props) = generate_EventCollection_plot() DCNL DCSP check_segments(coll, props[u'positions'], props[u'linelength'], props[u'lineoffset'], props[u'orientation'])\n", "intent": "check to make sure the default segments have the correct coordinates .\n", "question_id": 405}, {"snippet": "def coro(gen): DCNL  DCSP @wraps(gen) DCNL DCSP def wind_up(*args, **kwargs): DCNL DCSP  DCSP it = gen(*args, **kwargs) DCNL DCSP  DCSP next(it) DCNL DCSP  DCSP return it DCNL DCSP return wind_up\n", "intent": "decorator to mark generator as co-routine .\n", "question_id": 406}, {"snippet": "def FindRendererForObject(rdf_obj): DCNL  DCSP return ValueRenderer(rdf_obj)\n", "intent": "find the appropriate renderer for an rdfvalue object .\n", "question_id": 407}, {"snippet": "def snatchEpisode(result, endStatus=SNATCHED): DCNL  DCSP if (result.resultType in ('nzb', 'nzbdata')): DCNL DCSP  DCSP if (sickbeard.NZB_METHOD == 'blackhole'): DCNL DCSP  DCSP  DCSP dlResult = _downloadResult(result) DCNL DCSP  DCSP elif (sickbeard.NZB_METHOD == 'sabnzbd'): DCNL DCSP  DCSP  DCSP dlResult = sab.sendNZB(result) DCNL DCSP  DCSP elif (sickbeard.NZB_METHOD == 'nzbget'): DCNL DCSP  DCSP  DCSP dlResult = nzbget.sendNZB(result) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.log((u'Unknown DCSP NZB DCSP action DCSP specified DCSP in DCSP config: DCSP ' + sickbeard.NZB_METHOD), logger.ERROR) DCNL DCSP  DCSP  DCSP dlResult = False DCNL DCSP elif (result.resultType == 'torrent'): DCNL DCSP  DCSP dlResult = _downloadResult(result) DCNL DCSP else: DCNL DCSP  DCSP logger.log(u'Unknown DCSP result DCSP type, DCSP unable DCSP to DCSP download DCSP it', logger.ERROR) DCNL DCSP  DCSP dlResult = False DCNL DCSP if (dlResult == False): DCNL DCSP  DCSP return False DCNL DCSP ui.notifications.message('Episode DCSP snatched', result.name) DCNL DCSP history.logSnatch(result) DCNL DCSP for curEpObj in result.episodes: DCNL DCSP  DCSP with curEpObj.lock: DCNL DCSP  DCSP  DCSP curEpObj.status = Quality.compositeStatus(endStatus, result.quality) DCNL DCSP  DCSP  DCSP curEpObj.saveToDB() DCNL DCSP  DCSP if ((not curEpObj.show.skip_notices) and (curEpObj.status not in Quality.DOWNLOADED)): DCNL DCSP  DCSP  DCSP notifiers.notify_snatch(curEpObj.prettyName()) DCNL DCSP return True\n", "intent": "contains the internal logic necessary to actually \"snatch\" a result that has been found .\n", "question_id": 408}, {"snippet": "def sudo(command, log_command_filter=identity): DCNL  DCSP return Effect(Sudo(command=command, log_command_filter=log_command_filter))\n", "intent": "run a shell command on a remote host with sudo .\n", "question_id": 409}, {"snippet": "def test_scenario_outline1_fr_from_string(): DCNL  DCSP lang = Language('fr') DCNL DCSP scenario = Scenario.from_string(OUTLINED_SCENARIO, language=lang) DCNL DCSP assert_equals(scenario.name, 'Ajouter DCSP 2 DCSP nombres') DCNL DCSP assert_equals(scenario.outlines, [{u'input_1': u'20', u'input_2': u'30', u'bouton': u'add', u'output': u'50'}, {u'input_1': u'2', u'input_2': u'5', u'bouton': u'add', u'output': u'7'}, {u'input_1': u'0', u'input_2': u'40', u'bouton': u'add', u'output': u'40'}])\n", "intent": "language: fr -> scenario .\n", "question_id": 410}, {"snippet": "@register.filter(is_safe=True) DCNL @stringfilter DCNL def force_escape(value): DCNL  DCSP return escape(value)\n", "intent": "escapes a strings html .\n", "question_id": 411}, {"snippet": "def _block_size(sep): DCNL  DCSP return (BLOCK_SIZE + (len(sep) * ((BLOCK_SIZE // Card.length) - 1)))\n", "intent": "determine the size of a fits header block if a non-blank separator is used between cards .\n", "question_id": 412}, {"snippet": "def test_import_error_in_warning_logging(): DCNL  DCSP class FakeModule(object, ): DCNL DCSP  DCSP def __getattr__(self, attr): DCNL DCSP  DCSP  DCSP raise ImportError(u'_showwarning DCSP should DCSP ignore DCSP any DCSP exceptions DCSP here') DCNL DCSP log.enable_warnings_logging() DCNL DCSP sys.modules[u'<test DCSP fake DCSP module>'] = FakeModule() DCNL DCSP try: DCNL DCSP  DCSP warnings.showwarning(AstropyWarning(u'Regression DCSP test DCSP for DCSP #2671'), AstropyWarning, u'<this DCSP is DCSP only DCSP a DCSP test>', 1) DCNL DCSP finally: DCNL DCSP  DCSP del sys.modules[u'<test DCSP fake DCSP module>']\n", "intent": "regression test for URL this test actually puts a goofy fake module into sys .\n", "question_id": 413}, {"snippet": "def timestamp_local(value): DCNL  DCSP try: DCNL DCSP  DCSP return dt_util.as_local(dt_util.utc_from_timestamp(value)).strftime(DATE_STR_FORMAT) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return value\n", "intent": "filter to convert given timestamp to local date/time .\n", "question_id": 414}, {"snippet": "def create_tbss_all(name='tbss_all', estimate_skeleton=True): DCNL  DCSP inputnode = pe.Node(interface=util.IdentityInterface(fields=['fa_list', 'skeleton_thresh']), name='inputnode') DCNL DCSP tbss1 = create_tbss_1_preproc(name='tbss1') DCNL DCSP tbss2 = create_tbss_2_reg(name='tbss2') DCNL DCSP if fsl.no_fsl(): DCNL DCSP  DCSP warn('NO DCSP FSL DCSP found') DCNL DCSP else: DCNL DCSP  DCSP tbss2.inputs.inputnode.target = fsl.Info.standard_image('FMRIB58_FA_1mm.nii.gz') DCNL DCSP tbss3 = create_tbss_3_postreg(name='tbss3', estimate_skeleton=estimate_skeleton) DCNL DCSP tbss4 = create_tbss_4_prestats(name='tbss4') DCNL DCSP tbss_all = pe.Workflow(name=name) DCNL DCSP tbss_all.connect([(inputnode, tbss1, [('fa_list', 'inputnode.fa_list')]), (inputnode, tbss4, [('skeleton_thresh', 'inputnode.skeleton_thresh')]), (tbss1, tbss2, [('outputnode.fa_list', 'inputnode.fa_list'), ('outputnode.mask_list', 'inputnode.mask_list')]), (tbss1, tbss3, [('outputnode.fa_list', 'inputnode.fa_list')]), (tbss2, tbss3, [('outputnode.field_list', 'inputnode.field_list')]), (tbss3, tbss4, [('outputnode.groupmask', 'inputnode.groupmask'), ('outputnode.skeleton_file', 'inputnode.skeleton_file'), ('outputnode.meanfa_file', 'inputnode.meanfa_file'), ('outputnode.mergefa_file', 'inputnode.mergefa_file')])]) DCNL DCSP outputnode = pe.Node(interface=util.IdentityInterface(fields=['groupmask', 'skeleton_file3', 'meanfa_file', 'mergefa_file', 'projectedfa_file', 'skeleton_file4', 'skeleton_mask', 'distance_map']), name='outputnode') DCNL DCSP outputall_node = pe.Node(interface=util.IdentityInterface(fields=['fa_list1', 'mask_list1', 'field_list2', 'groupmask3', 'skeleton_file3', 'meanfa_file3', 'mergefa_file3', 'projectedfa_file4', 'skeleton_mask4', 'distance_map4']), name='outputall_node') DCNL DCSP tbss_all.connect([(tbss3, outputnode, [('outputnode.meanfa_file', 'meanfa_file'), ('outputnode.mergefa_file', 'mergefa_file'), ('outputnode.groupmask', 'groupmask'), ('outputnode.skeleton_file', 'skeleton_file3')]), (tbss4, outputnode, [('outputnode.projectedfa_file', 'projectedfa_file'), ('outputnode.skeleton_file', 'skeleton_file4'), ('outputnode.skeleton_mask', 'skeleton_mask'), ('outputnode.distance_map', 'distance_map')]), (tbss1, outputall_node, [('outputnode.fa_list', 'fa_list1'), ('outputnode.mask_list', 'mask_list1')]), (tbss2, outputall_node, [('outputnode.field_list', 'field_list2')]), (tbss3, outputall_node, [('outputnode.meanfa_file', 'meanfa_file3'), ('outputnode.mergefa_file', 'mergefa_file3'), ('outputnode.groupmask', 'groupmask3'), ('outputnode.skeleton_file', 'skeleton_file3')]), (tbss4, outputall_node, [('outputnode.projectedfa_file', 'projectedfa_file4'), ('outputnode.skeleton_mask', 'skeleton_mask4'), ('outputnode.distance_map', 'distance_map4')])]) DCNL DCSP return tbss_all\n", "intent": "create a pipeline that combines create_tbss_* pipelines example .\n", "question_id": 415}, {"snippet": "def get_cli_body_ssh(command, response, module): DCNL  DCSP if (('show DCSP run' in command) or (response[0] == '\\n')): DCNL DCSP  DCSP body = response DCNL DCSP elif ('xml' in response[0]): DCNL DCSP  DCSP body = [] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP body = [json.loads(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP module.fail_json(msg='Command DCSP does DCSP not DCSP support DCSP JSON DCSP output', command=command) DCNL DCSP return body\n", "intent": "get response for when transport=cli .\n", "question_id": 416}, {"snippet": "def getip(request): DCNL  DCSP ip = request.META.get('HTTP_X_REAL_IP', '') DCNL DCSP if (not ip): DCNL DCSP  DCSP ip = request.META.get('REMOTE_ADDR', 'None') DCNL DCSP return ip\n", "intent": "extract ip address of requester from header .\n", "question_id": 417}, {"snippet": "def sort_tables_and_constraints(tables, filter_fn=None, extra_dependencies=None): DCNL  DCSP fixed_dependencies = set() DCNL DCSP mutable_dependencies = set() DCNL DCSP if (extra_dependencies is not None): DCNL DCSP  DCSP fixed_dependencies.update(extra_dependencies) DCNL DCSP remaining_fkcs = set() DCNL DCSP for table in tables: DCNL DCSP  DCSP for fkc in table.foreign_key_constraints: DCNL DCSP  DCSP  DCSP if (fkc.use_alter is True): DCNL DCSP  DCSP  DCSP  DCSP remaining_fkcs.add(fkc) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if filter_fn: DCNL DCSP  DCSP  DCSP  DCSP filtered = filter_fn(fkc) DCNL DCSP  DCSP  DCSP  DCSP if (filtered is True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining_fkcs.add(fkc) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP dependent_on = fkc.referred_table DCNL DCSP  DCSP  DCSP if (dependent_on is not table): DCNL DCSP  DCSP  DCSP  DCSP mutable_dependencies.add((dependent_on, table)) DCNL DCSP  DCSP fixed_dependencies.update(((parent, table) for parent in table._extra_dependencies)) DCNL DCSP try: DCNL DCSP  DCSP candidate_sort = list(topological.sort(fixed_dependencies.union(mutable_dependencies), tables, deterministic_order=True)) DCNL DCSP except exc.CircularDependencyError as err: DCNL DCSP  DCSP for edge in err.edges: DCNL DCSP  DCSP  DCSP if (edge in mutable_dependencies): DCNL DCSP  DCSP  DCSP  DCSP table = edge[1] DCNL DCSP  DCSP  DCSP  DCSP can_remove = [fkc for fkc in table.foreign_key_constraints if ((filter_fn is None) or (filter_fn(fkc) is not False))] DCNL DCSP  DCSP  DCSP  DCSP remaining_fkcs.update(can_remove) DCNL DCSP  DCSP  DCSP  DCSP for fkc in can_remove: DCNL DCSP  DCSP  DCSP  DCSP  DCSP dependent_on = fkc.referred_table DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (dependent_on is not table): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mutable_dependencies.discard((dependent_on, table)) DCNL DCSP  DCSP candidate_sort = list(topological.sort(fixed_dependencies.union(mutable_dependencies), tables, deterministic_order=True)) DCNL DCSP return ([(table, table.foreign_key_constraints.difference(remaining_fkcs)) for table in candidate_sort] + [(None, list(remaining_fkcs))])\n", "intent": "sort a collection of :class: .\n", "question_id": 418}, {"snippet": "def _quote_escape(item): DCNL  DCSP rex_sqlquote = re.compile(\"'\", re.M) DCNL DCSP return rex_sqlquote.sub(\"''\", item)\n", "intent": "make sure single quotes are escaped properly in sqlite3 fashion .\n", "question_id": 419}, {"snippet": "def path_from_name(name, ext=None, sep=u'|'): DCNL  DCSP if ext: DCNL DCSP  DCSP return fsencode((name.replace(os.sep, sep) + ext)) DCNL DCSP else: DCNL DCSP  DCSP return fsencode(name.replace(os.sep, sep))\n", "intent": "convert name with optional extension to file path .\n", "question_id": 420}, {"snippet": "def run(args): DCNL  DCSP commands = ('install', 'uninstall', 'restart') DCNL DCSP if ((not args) or (args[0] not in commands)): DCNL DCSP  DCSP print ('Invalid DCSP command. DCSP Available DCSP commands:', ', DCSP '.join(commands)) DCNL DCSP  DCSP return 1 DCNL DCSP if (args[0] == 'install'): DCNL DCSP  DCSP install_osx() DCNL DCSP  DCSP return 0 DCNL DCSP elif (args[0] == 'uninstall'): DCNL DCSP  DCSP uninstall_osx() DCNL DCSP  DCSP return 0 DCNL DCSP elif (args[0] == 'restart'): DCNL DCSP  DCSP uninstall_osx() DCNL DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP install_osx() DCNL DCSP  DCSP return 0\n", "intent": "handle osx commandline script .\n", "question_id": 421}, {"snippet": "def _dict_with_group_specs_if_authorized(context, inst_type_query): DCNL  DCSP inst_type_dict = dict(inst_type_query) DCNL DCSP if (not is_admin_context(context)): DCNL DCSP  DCSP del inst_type_dict['group_specs'] DCNL DCSP else: DCNL DCSP  DCSP group_specs = {x['key']: x['value'] for x in inst_type_query['group_specs']} DCNL DCSP  DCSP inst_type_dict['group_specs'] = group_specs DCNL DCSP return inst_type_dict\n", "intent": "convert group type query result to dict with spec and rate_limit .\n", "question_id": 422}, {"snippet": "def _readmodule(module, path, inpackage=None): DCNL  DCSP if (inpackage is not None): DCNL DCSP  DCSP fullmodule = ('%s.%s' % (inpackage, module)) DCNL DCSP else: DCNL DCSP  DCSP fullmodule = module DCNL DCSP if (fullmodule in _modules): DCNL DCSP  DCSP return _modules[fullmodule] DCNL DCSP dict = {} DCNL DCSP if ((module in sys.builtin_module_names) and (inpackage is None)): DCNL DCSP  DCSP _modules[module] = dict DCNL DCSP  DCSP return dict DCNL DCSP i = module.rfind('.') DCNL DCSP if (i >= 0): DCNL DCSP  DCSP package = module[:i] DCNL DCSP  DCSP submodule = module[(i + 1):] DCNL DCSP  DCSP parent = _readmodule(package, path, inpackage) DCNL DCSP  DCSP if (inpackage is not None): DCNL DCSP  DCSP  DCSP package = ('%s.%s' % (inpackage, package)) DCNL DCSP  DCSP if (not ('__path__' in parent)): DCNL DCSP  DCSP  DCSP raise ImportError('No DCSP package DCSP named DCSP {}'.format(package)) DCNL DCSP  DCSP return _readmodule(submodule, parent['__path__'], package) DCNL DCSP f = None DCNL DCSP if (inpackage is not None): DCNL DCSP  DCSP search_path = path DCNL DCSP else: DCNL DCSP  DCSP search_path = (path + sys.path) DCNL DCSP spec = importlib.util._find_spec_from_path(fullmodule, search_path) DCNL DCSP _modules[fullmodule] = dict DCNL DCSP if (spec.submodule_search_locations is not None): DCNL DCSP  DCSP dict['__path__'] = spec.submodule_search_locations DCNL DCSP try: DCNL DCSP  DCSP source = spec.loader.get_source(fullmodule) DCNL DCSP  DCSP if (source is None): DCNL DCSP  DCSP  DCSP return dict DCNL DCSP except (AttributeError, ImportError): DCNL DCSP  DCSP return dict DCNL DCSP fname = spec.loader.get_filename(fullmodule) DCNL DCSP f = io.StringIO(source) DCNL DCSP stack = [] DCNL DCSP g = tokenize.generate_tokens(f.readline) DCNL DCSP try: DCNL DCSP  DCSP for (tokentype, token, start, _end, _line) in g: DCNL DCSP  DCSP  DCSP if (tokentype == DEDENT): DCNL DCSP  DCSP  DCSP  DCSP (lineno, thisindent) = start DCNL DCSP  DCSP  DCSP  DCSP while (stack and (stack[(-1)][1] >= thisindent)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del stack[(-1)] DCNL DCSP  DCSP  DCSP elif (token == 'def'): DCNL DCSP  DCSP  DCSP  DCSP (lineno, thisindent) = start DCNL DCSP  DCSP  DCSP  DCSP while (stack and (stack[(-1)][1] >= thisindent)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del stack[(-1)] DCNL DCSP  DCSP  DCSP  DCSP (tokentype, meth_name, start) = next(g)[0:3] DCNL DCSP  DCSP  DCSP  DCSP if (tokentype != NAME): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cur_class = stack[(-1)][0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(cur_class, Class): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cur_class._addmethod(meth_name, lineno) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP dict[meth_name] = Function(fullmodule, meth_name, fname, lineno) DCNL DCSP  DCSP  DCSP  DCSP stack.append((None, thisindent)) DCNL DCSP  DCSP  DCSP elif (token == 'class'): DCNL DCSP  DCSP  DCSP  DCSP (lineno, thisindent) = start DCNL DCSP  DCSP  DCSP  DCSP while (stack and (stack[(-1)][1] >= thisindent)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP del stack[(-1)] DCNL DCSP  DCSP  DCSP  DCSP (tokentype, class_name, start) = next(g)[0:3] DCNL DCSP  DCSP  DCSP  DCSP if (tokentype != NAME): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP (tokentype, token, start) = next(g)[0:3] DCNL DCSP  DCSP  DCSP  DCSP inherit = None DCNL DCSP  DCSP  DCSP  DCSP if (token == '('): DCNL DCSP  DCSP  DCSP  DCSP  DCSP names = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP level = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP super = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (tokentype, token, start) = next(g)[0:3] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((token in (')', ',')) and (level == 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP n = ''.join(super) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (n in dict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP n = dict[n] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c = n.split('.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(c) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP m = c[(-2)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c = c[(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (m in _modules): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP d = _modules[m] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (c in d): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP n = d[c] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP names.append(n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP super = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (token == '('): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP level += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (token == ')'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP level -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (level == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif ((token == ',') and (level == 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif ((tokentype in (NAME, OP)) and (level == 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP super.append(token) DCNL DCSP  DCSP  DCSP  DCSP  DCSP inherit = names DCNL DCSP  DCSP  DCSP  DCSP cur_class = Class(fullmodule, class_name, inherit, fname, lineno) DCNL DCSP  DCSP  DCSP  DCSP if (not stack): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dict[class_name] = cur_class DCNL DCSP  DCSP  DCSP  DCSP stack.append((cur_class, thisindent)) DCNL DCSP  DCSP  DCSP elif ((token == 'import') and (start[1] == 0)): DCNL DCSP  DCSP  DCSP  DCSP modules = _getnamelist(g) DCNL DCSP  DCSP  DCSP  DCSP for (mod, _mod2) in modules: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (inpackage is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _readmodule(mod, path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _readmodule(mod, path, inpackage) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _readmodule(mod, []) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif ((token == 'from') and (start[1] == 0)): DCNL DCSP  DCSP  DCSP  DCSP (mod, token) = _getname(g) DCNL DCSP  DCSP  DCSP  DCSP if ((not mod) or (token != 'import')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP names = _getnamelist(g) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = _readmodule(mod, path, inpackage) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP for (n, n2) in names: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (n in d): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dict[(n2 or n)] = d[n] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (n == '*'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for n in d: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (n[0] != '_'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dict[n] = d[n] DCNL DCSP except StopIteration: DCNL DCSP  DCSP pass DCNL DCSP f.close() DCNL DCSP return dict\n", "intent": "do the hard work for readmodule[_ex] .\n", "question_id": 423}, {"snippet": "def prepare_commentdoc(s): DCNL  DCSP result = [] DCNL DCSP lines = [line.strip() for line in s.expandtabs().splitlines()] DCNL DCSP for line in lines: DCNL DCSP  DCSP if line.startswith('#:'): DCNL DCSP  DCSP  DCSP line = line[2:] DCNL DCSP  DCSP  DCSP if (line and (line[0] == ' DCSP ')): DCNL DCSP  DCSP  DCSP  DCSP line = line[1:] DCNL DCSP  DCSP  DCSP result.append(line) DCNL DCSP if (result and result[(-1)]): DCNL DCSP  DCSP result.append('') DCNL DCSP return result\n", "intent": "extract documentation comment lines  and return them as a list of lines .\n", "question_id": 424}, {"snippet": "def equatePolar(point, returnValue): DCNL  DCSP equateCylindrical(point, returnValue)\n", "intent": "get equation for polar .\n", "question_id": 425}, {"snippet": "def getfile(object): DCNL  DCSP if ismodule(object): DCNL DCSP  DCSP if hasattr(object, '__file__'): DCNL DCSP  DCSP  DCSP return object.__file__ DCNL DCSP  DCSP raise TypeError('arg DCSP is DCSP a DCSP built-in DCSP module') DCNL DCSP if isclass(object): DCNL DCSP  DCSP object = sys.modules.get(object.__module__) DCNL DCSP  DCSP if hasattr(object, '__file__'): DCNL DCSP  DCSP  DCSP return object.__file__ DCNL DCSP  DCSP raise TypeError('arg DCSP is DCSP a DCSP built-in DCSP class') DCNL DCSP if ismethod(object): DCNL DCSP  DCSP object = object.im_func DCNL DCSP if isfunction(object): DCNL DCSP  DCSP object = object.func_code DCNL DCSP if istraceback(object): DCNL DCSP  DCSP object = object.tb_frame DCNL DCSP if isframe(object): DCNL DCSP  DCSP object = object.f_code DCNL DCSP if iscode(object): DCNL DCSP  DCSP return object.co_filename DCNL DCSP raise TypeError('arg DCSP is DCSP not DCSP a DCSP module, DCSP class, DCSP method, DCSP function, DCSP traceback, DCSP frame, DCSP or DCSP code DCSP object')\n", "intent": "work out which source or compiled file an object was defined in .\n", "question_id": 426}, {"snippet": "def getNewRepository(): DCNL  DCSP return GcodeTimeSegmentRepository()\n", "intent": "get new repository .\n", "question_id": 427}, {"snippet": "def post_detail(request, slug, year, month, day, **kwargs): DCNL  DCSP posts = None DCNL DCSP if request.user.is_superuser: DCNL DCSP  DCSP posts = Post.objects.all() DCNL DCSP else: DCNL DCSP  DCSP posts = Post.objects.published() DCNL DCSP return date_based.object_detail(request, year=year, month=month, day=day, date_field='publish', slug=slug, queryset=posts, **kwargs)\n", "intent": "displays post detail .\n", "question_id": 428}, {"snippet": "def testHostWithPrivateDirs(): DCNL  DCSP topo = SingleSwitchTopo(10) DCNL DCSP privateDirs = [('/var/log', '/tmp/%(name)s/var/log'), ('/var/run', '/tmp/%(name)s/var/run'), '/var/mn'] DCNL DCSP host = partial(Host, privateDirs=privateDirs) DCNL DCSP net = Mininet(topo=topo, host=host) DCNL DCSP net.start() DCNL DCSP directories = [(directory[0] if isinstance(directory, tuple) else directory) for directory in privateDirs] DCNL DCSP info('Private DCSP Directories:', directories, '\\n') DCNL DCSP CLI(net) DCNL DCSP net.stop()\n", "intent": "test bind mounts .\n", "question_id": 429}, {"snippet": "def fixed_ip_get_by_instance(context, instance_uuid): DCNL  DCSP return IMPL.fixed_ip_get_by_instance(context, instance_uuid)\n", "intent": "get fixed ips by instance or raise if none exist .\n", "question_id": 430}, {"snippet": "def EvalExponentialCdf(x, lam): DCNL  DCSP return (1 - math.exp(((- lam) * x)))\n", "intent": "evaluates cdf of the exponential distribution with parameter lam .\n", "question_id": 431}, {"snippet": "def test_list_json(script, data): DCNL  DCSP script.pip('install', '-f', data.find_links, '--no-index', 'simple==1.0', 'simple2==3.0') DCNL DCSP result = script.pip('list', '--format=json') DCNL DCSP data = json.loads(result.stdout) DCNL DCSP assert ({'name': 'simple', 'version': '1.0'} in data) DCNL DCSP assert ({'name': 'simple2', 'version': '3.0'} in data)\n", "intent": "test json formatting of list command .\n", "question_id": 432}, {"snippet": "def lstsq(a, b, cond=None, overwrite_a=False, overwrite_b=False, check_finite=True, lapack_driver=None): DCNL  DCSP a1 = _asarray_validated(a, check_finite=check_finite) DCNL DCSP b1 = _asarray_validated(b, check_finite=check_finite) DCNL DCSP if (len(a1.shape) != 2): DCNL DCSP  DCSP raise ValueError('expected DCSP matrix') DCNL DCSP (m, n) = a1.shape DCNL DCSP if (len(b1.shape) == 2): DCNL DCSP  DCSP nrhs = b1.shape[1] DCNL DCSP else: DCNL DCSP  DCSP nrhs = 1 DCNL DCSP if (m != b1.shape[0]): DCNL DCSP  DCSP raise ValueError('incompatible DCSP dimensions') DCNL DCSP driver = lapack_driver DCNL DCSP if (driver is None): DCNL DCSP  DCSP driver = lstsq.default_lapack_driver DCNL DCSP if (driver not in ('gelsd', 'gelsy', 'gelss')): DCNL DCSP  DCSP raise ValueError(('LAPACK DCSP driver DCSP \"%s\" DCSP is DCSP not DCSP found' % driver)) DCNL DCSP (lapack_func, lapack_lwork) = get_lapack_funcs((driver, ('%s_lwork' % driver)), (a1, b1)) DCNL DCSP real_data = (True if (lapack_func.dtype.kind == 'f') else False) DCNL DCSP if (m < n): DCNL DCSP  DCSP if (len(b1.shape) == 2): DCNL DCSP  DCSP  DCSP b2 = np.zeros((n, nrhs), dtype=lapack_func.dtype) DCNL DCSP  DCSP  DCSP b2[:m, :] = b1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP b2 = np.zeros(n, dtype=lapack_func.dtype) DCNL DCSP  DCSP  DCSP b2[:m] = b1 DCNL DCSP  DCSP b1 = b2 DCNL DCSP overwrite_a = (overwrite_a or _datacopied(a1, a)) DCNL DCSP overwrite_b = (overwrite_b or _datacopied(b1, b)) DCNL DCSP if (cond is None): DCNL DCSP  DCSP cond = np.finfo(lapack_func.dtype).eps DCNL DCSP if (driver in ('gelss', 'gelsd')): DCNL DCSP  DCSP if (driver == 'gelss'): DCNL DCSP  DCSP  DCSP lwork = _compute_lwork(lapack_lwork, m, n, nrhs, cond) DCNL DCSP  DCSP  DCSP (v, x, s, rank, work, info) = lapack_func(a1, b1, cond, lwork, overwrite_a=overwrite_a, overwrite_b=overwrite_b) DCNL DCSP  DCSP elif (driver == 'gelsd'): DCNL DCSP  DCSP  DCSP if real_data: DCNL DCSP  DCSP  DCSP  DCSP (lwork, iwork) = _compute_lwork(lapack_lwork, m, n, nrhs, cond) DCNL DCSP  DCSP  DCSP  DCSP if (iwork == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mesg = 'internal DCSP gelsd DCSP driver DCSP lwork DCSP query DCSP error, DCSP required DCSP iwork DCSP dimension DCSP not DCSP returned. DCSP This DCSP is DCSP likely DCSP the DCSP result DCSP of DCSP LAPACK DCSP bug DCSP 0038, DCSP fixed DCSP in DCSP LAPACK DCSP 3.2.2 DCSP (released DCSP July DCSP 21, DCSP 2010). DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (lapack_driver is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lstsq.default_lapack_driver = 'gelss' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mesg += \"Falling DCSP back DCSP to DCSP 'gelss' DCSP driver.\" DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn(mesg, RuntimeWarning) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return lstsq(a, b, cond, overwrite_a, overwrite_b, check_finite, lapack_driver='gelss') DCNL DCSP  DCSP  DCSP  DCSP  DCSP mesg += 'Use DCSP a DCSP different DCSP lapack_driver DCSP when DCSP calling DCSP lstsq DCSP or DCSP upgrade DCSP LAPACK.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LstsqLapackError(mesg) DCNL DCSP  DCSP  DCSP  DCSP (x, s, rank, info) = lapack_func(a1, b1, lwork, iwork, cond, False, False) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (lwork, rwork, iwork) = _compute_lwork(lapack_lwork, m, n, nrhs, cond) DCNL DCSP  DCSP  DCSP  DCSP (x, s, rank, info) = lapack_func(a1, b1, lwork, rwork, iwork, cond, False, False) DCNL DCSP  DCSP if (info > 0): DCNL DCSP  DCSP  DCSP raise LinAlgError('SVD DCSP did DCSP not DCSP converge DCSP in DCSP Linear DCSP Least DCSP Squares') DCNL DCSP  DCSP if (info < 0): DCNL DCSP  DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %d-th DCSP argument DCSP of DCSP internal DCSP %s' % ((- info), lapack_driver))) DCNL DCSP  DCSP resids = np.asarray([], dtype=x.dtype) DCNL DCSP  DCSP if (m > n): DCNL DCSP  DCSP  DCSP x1 = x[:n] DCNL DCSP  DCSP  DCSP if (rank == n): DCNL DCSP  DCSP  DCSP  DCSP resids = np.sum((np.abs(x[n:]) ** 2), axis=0) DCNL DCSP  DCSP  DCSP x = x1 DCNL DCSP  DCSP return (x, resids, rank, s) DCNL DCSP elif (driver == 'gelsy'): DCNL DCSP  DCSP lwork = _compute_lwork(lapack_lwork, m, n, nrhs, cond) DCNL DCSP  DCSP jptv = np.zeros((a1.shape[1], 1), dtype=np.int32) DCNL DCSP  DCSP (v, x, j, rank, info) = lapack_func(a1, b1, jptv, cond, lwork, False, False) DCNL DCSP  DCSP if (info < 0): DCNL DCSP  DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %d-th DCSP argument DCSP of DCSP internal DCSP gelsy' % (- info))) DCNL DCSP  DCSP if (m > n): DCNL DCSP  DCSP  DCSP x1 = x[:n] DCNL DCSP  DCSP  DCSP x = x1 DCNL DCSP  DCSP return (x, np.array([], x.dtype), rank, None)\n", "intent": "compute least-squares solution to equation ax = b .\n", "question_id": 433}, {"snippet": "def _reraise_translated_exception(): DCNL  DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace\n", "intent": "transform the exception but keep its traceback intact .\n", "question_id": 434}, {"snippet": "def get_project_root(): DCNL  DCSP settings_mod = __import__(settings.SETTINGS_MODULE, {}, {}, ['']) DCNL DCSP return os.path.dirname(os.path.abspath(settings_mod.__file__))\n", "intent": "get the project root directory .\n", "question_id": 435}, {"snippet": "def ustr(what): DCNL  DCSP if isinstance(what, unicode): DCNL DCSP  DCSP return what DCNL DCSP try: DCNL DCSP  DCSP r = what.__str__() DCNL DCSP except AttributeError: DCNL DCSP  DCSP r = str(what) DCNL DCSP if (not isinstance(r, unicode)): DCNL DCSP  DCSP return unicode(r, ENCODING) DCNL DCSP return r\n", "intent": "converts object \"what\" to unicode string using its own __str__ method if accessible or unicode method otherwise .\n", "question_id": 436}, {"snippet": "@with_lock(PUSHD_LOCK) DCNL def pushd(path): DCNL  DCSP orig_path = os.getcwd() DCNL DCSP os.chdir(path) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP os.chdir(orig_path)\n", "intent": "pushd changes the actual working directory for the duration of the context .\n", "question_id": 437}, {"snippet": "def autumn(): DCNL  DCSP rc(u'image', cmap=u'autumn') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.autumn)\n", "intent": "set the default colormap to autumn and apply to current image if any .\n", "question_id": 438}, {"snippet": "def getGeometryOutputByArguments(arguments, elementNode): DCNL  DCSP if (len(arguments) < 1): DCNL DCSP  DCSP return getGeometryOutput(elementNode) DCNL DCSP inradius = (0.5 * euclidean.getFloatFromValue(arguments[0])) DCNL DCSP elementNode.attributes['inradius.x'] = str(inradius) DCNL DCSP if (len(arguments) > 1): DCNL DCSP  DCSP inradius = (0.5 * euclidean.getFloatFromValue(arguments[1])) DCNL DCSP elementNode.attributes['inradius.y'] = str(inradius) DCNL DCSP return getGeometryOutput(elementNode)\n", "intent": "get vector3 vertexes from attribute dictionary by arguments .\n", "question_id": 439}, {"snippet": "def run_networks(): DCNL  DCSP random.seed(12345678) DCNL DCSP np.random.seed(12345678) DCNL DCSP (training_data, validation_data, test_data) = mnist_loader.load_data_wrapper() DCNL DCSP results = [] DCNL DCSP for eta in LEARNING_RATES: DCNL DCSP  DCSP print ('\\nTrain DCSP a DCSP network DCSP using DCSP eta DCSP = DCSP ' + str(eta)) DCNL DCSP  DCSP net = network2.Network([784, 30, 10]) DCNL DCSP  DCSP results.append(net.SGD(training_data, NUM_EPOCHS, 10, eta, lmbda=5.0, evaluation_data=validation_data, monitor_training_cost=True)) DCNL DCSP f = open('multiple_eta.json', 'w') DCNL DCSP json.dump(results, f) DCNL DCSP f.close()\n", "intent": "train networks using three different values for the learning rate .\n", "question_id": 440}, {"snippet": "def fullSizeCoverURL(obj): DCNL  DCSP if isinstance(obj, Movie): DCNL DCSP  DCSP coverUrl = obj.get('cover DCSP url') DCNL DCSP elif isinstance(obj, (Person, Character)): DCNL DCSP  DCSP coverUrl = obj.get('headshot') DCNL DCSP else: DCNL DCSP  DCSP coverUrl = obj DCNL DCSP if (not coverUrl): DCNL DCSP  DCSP return None DCNL DCSP return _Container._re_fullsizeURL.sub('', coverUrl)\n", "intent": "given an url string or a movie .\n", "question_id": 441}, {"snippet": "def _api_addlocalfile(name, output, kwargs): DCNL  DCSP if (name and isinstance(name, list)): DCNL DCSP  DCSP name = name[0] DCNL DCSP if name: DCNL DCSP  DCSP if os.path.exists(name): DCNL DCSP  DCSP  DCSP fn = get_filename(name) DCNL DCSP  DCSP  DCSP if fn: DCNL DCSP  DCSP  DCSP  DCSP pp = kwargs.get('pp') DCNL DCSP  DCSP  DCSP  DCSP script = kwargs.get('script') DCNL DCSP  DCSP  DCSP  DCSP cat = kwargs.get('cat') DCNL DCSP  DCSP  DCSP  DCSP xcat = kwargs.get('xcat') DCNL DCSP  DCSP  DCSP  DCSP if ((not cat) and xcat): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cat = cat_convert(xcat) DCNL DCSP  DCSP  DCSP  DCSP priority = kwargs.get('priority') DCNL DCSP  DCSP  DCSP  DCSP nzbname = kwargs.get('nzbname') DCNL DCSP  DCSP  DCSP  DCSP if (get_ext(name) in VALID_ARCHIVES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res = sabnzbd.dirscanner.ProcessArchiveFile(fn, name, pp=pp, script=script, cat=cat, priority=priority, keep=True, nzbname=nzbname) DCNL DCSP  DCSP  DCSP  DCSP elif (get_ext(name) in ('.nzb', '.gz', '.bz2')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res = sabnzbd.dirscanner.ProcessSingleFile(fn, name, pp=pp, script=script, cat=cat, priority=priority, keep=True, nzbname=nzbname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logging.info('API-call DCSP addlocalfile: DCSP \"%s\" DCSP not DCSP a DCSP proper DCSP file DCSP name', name) DCNL DCSP  DCSP  DCSP  DCSP return report(output, _MSG_NO_FILE) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.info('API-call DCSP addlocalfile: DCSP file DCSP \"%s\" DCSP not DCSP found', name) DCNL DCSP  DCSP  DCSP return report(output, _MSG_NO_PATH) DCNL DCSP  DCSP return report(output, keyword='', data={'status': (res[0] == 0), 'nzo_ids': res[1]}, compat=True) DCNL DCSP else: DCNL DCSP  DCSP logging.info('API-call DCSP addlocalfile: DCSP no DCSP file DCSP name DCSP given') DCNL DCSP  DCSP return report(output, _MSG_NO_VALUE)\n", "intent": "api: accepts name .\n", "question_id": 442}, {"snippet": "def DocFileSuite(*paths, **kw): DCNL  DCSP suite = unittest.TestSuite() DCNL DCSP if kw.get('module_relative', True): DCNL DCSP  DCSP kw['package'] = _normalize_module(kw.get('package')) DCNL DCSP for path in paths: DCNL DCSP  DCSP suite.addTest(DocFileTest(path, **kw)) DCNL DCSP return suite\n", "intent": "a unittest suite for one or more doctest files .\n", "question_id": 443}, {"snippet": "def multi_constructor_import(loader, tag_suffix, node): DCNL  DCSP if ('.' not in tag_suffix): DCNL DCSP  DCSP raise yaml.YAMLError(\"!import: DCSP tag DCSP suffix DCSP contains DCSP no DCSP '.'\") DCNL DCSP return try_to_import(tag_suffix)\n", "intent": "callback used by pyyaml when a \"!import:\" tag is encountered .\n", "question_id": 444}, {"snippet": "def getLevelName(level): DCNL  DCSP return _levelNames.get(level, ('Level DCSP %s' % level))\n", "intent": "return the textual representation of logging level level .\n", "question_id": 445}, {"snippet": "def _is_import_valid(documents): DCNL  DCSP return (isinstance(documents, list) and all((isinstance(d, dict) for d in documents)) and all((all(((k in d) for k in ('pk', 'model', 'fields'))) for d in documents)) and all((all(((k in d['fields']) for k in ('uuid', 'owner'))) for d in documents)))\n", "intent": "validates the json file to be imported for schema correctness .\n", "question_id": 446}, {"snippet": "def liftRepositoryDialogs(repositoryDialogs): DCNL  DCSP for repositoryDialog in repositoryDialogs: DCNL DCSP  DCSP repositoryDialog.root.withdraw() DCNL DCSP  DCSP repositoryDialog.root.lift() DCNL DCSP  DCSP repositoryDialog.root.deiconify() DCNL DCSP  DCSP repositoryDialog.root.lift() DCNL DCSP  DCSP repositoryDialog.root.update_idletasks()\n", "intent": "lift the repository dialogs .\n", "question_id": 447}, {"snippet": "def convert_to_uuids(migrate_engine, primary_table_name, foreign_tables, revision_table_name=None): DCNL  DCSP dropped_fk_constraints = drop_constraints_and_alter_types(primary_table_name, foreign_tables, revision_table_name) DCNL DCSP add_fk_constraints(migrate_engine, dropped_fk_constraints, primary_table_name) DCNL DCSP create_uuids(migrate_engine, primary_table_name, revision_table_name)\n", "intent": "convert an id column in primary table to string type uuids .\n", "question_id": 448}, {"snippet": "def load_mappings(argv): DCNL  DCSP mappings = {} DCNL DCSP for arg in argv: DCNL DCSP  DCSP if (REMAP in arg): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (src, dst) = [x.strip() for x in arg.split(REMAP)] DCNL DCSP  DCSP  DCSP  DCSP if (src and dst): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((len(src) > 1) and (src[0] == '_') and (src[1] != '_')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mappings[src] = dst DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP sys.stderr.write((\"ERROR: DCSP Invalid DCSP remapping DCSP argument DCSP '%s'\\n\" % arg)) DCNL DCSP return mappings\n", "intent": "load name mappings encoded in command-line arguments .\n", "question_id": 449}, {"snippet": "def set_identity_providers_if_unset(facts): DCNL  DCSP if ('master' in facts): DCNL DCSP  DCSP deployment_type = facts['common']['deployment_type'] DCNL DCSP  DCSP if ('identity_providers' not in facts['master']): DCNL DCSP  DCSP  DCSP identity_provider = dict(name='allow_all', challenge=True, login=True, kind='AllowAllPasswordIdentityProvider') DCNL DCSP  DCSP  DCSP if (deployment_type in ['enterprise', 'atomic-enterprise', 'openshift-enterprise']): DCNL DCSP  DCSP  DCSP  DCSP identity_provider = dict(name='deny_all', challenge=True, login=True, kind='DenyAllPasswordIdentityProvider') DCNL DCSP  DCSP  DCSP facts['master']['identity_providers'] = [identity_provider] DCNL DCSP return facts\n", "intent": "set identity_providers fact if not already present in facts dict args: facts : existing facts returns: dict: the facts dict updated with the generated identity providers facts if they were not already present .\n", "question_id": 450}, {"snippet": "def build_in_docker(destination_path, distribution, top_level, package_uri): DCNL  DCSP if (destination_path.exists() and (not destination_path.isdir())): DCNL DCSP  DCSP raise ValueError('go DCSP away') DCNL DCSP volumes = {FilePath('/output'): destination_path, FilePath('/flocker'): top_level} DCNL DCSP if (package_uri == top_level.path): DCNL DCSP  DCSP package_uri = '/flocker' DCNL DCSP tag = ('clusterhq/build-%s' % (distribution,)) DCNL DCSP build_targets_directory = top_level.descendant(BUILD_TARGETS_SEGMENTS) DCNL DCSP build_directory = build_targets_directory.child(distribution) DCNL DCSP requirements_directory = top_level.child('requirements') DCNL DCSP requirements_directory.copyTo(build_directory.child('requirements')) DCNL DCSP return BuildSequence(steps=[DockerBuild(tag=tag, build_directory=build_directory), DockerRun(tag=tag, volumes=volumes, command=[package_uri])])\n", "intent": "build a flocker package for a given distribution inside a clean docker container of that distribution .\n", "question_id": 451}, {"snippet": "def clipboard_get(self): DCNL  DCSP from IPython.lib.clipboard import osx_clipboard_get, tkinter_clipboard_get, win32_clipboard_get DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP chain = [win32_clipboard_get, tkinter_clipboard_get] DCNL DCSP elif (sys.platform == 'darwin'): DCNL DCSP  DCSP chain = [osx_clipboard_get, tkinter_clipboard_get] DCNL DCSP else: DCNL DCSP  DCSP chain = [tkinter_clipboard_get] DCNL DCSP dispatcher = CommandChainDispatcher() DCNL DCSP for func in chain: DCNL DCSP  DCSP dispatcher.add(func) DCNL DCSP text = dispatcher() DCNL DCSP return text\n", "intent": "get text from the clipboard .\n", "question_id": 452}, {"snippet": "@pytest.mark.django_db DCNL def test_apiview_get_single(rf): DCNL  DCSP view = UserAPIView.as_view() DCNL DCSP user = UserFactory.create(username='foo') DCNL DCSP request = create_api_request(rf) DCNL DCSP response = view(request, id=user.id) DCNL DCSP assert (response.status_code == 200) DCNL DCSP response_data = json.loads(response.content) DCNL DCSP assert isinstance(response_data, dict) DCNL DCSP assert (response_data['username'] == 'foo') DCNL DCSP assert ('email' not in response_data) DCNL DCSP with pytest.raises(Http404): DCNL DCSP  DCSP view(request, id='777')\n", "intent": "tests retrieving a single object using the api .\n", "question_id": 453}, {"snippet": "def tsne_embedding(embeddings, reverse_dictionary, plot_only=500, second=5, saveable=False, name='tsne', fig_idx=9862): DCNL  DCSP def plot_with_labels(low_dim_embs, labels, figsize=(18, 18), second=5, saveable=True, name='tsne', fig_idx=9862): DCNL DCSP  DCSP assert (low_dim_embs.shape[0] >= len(labels)), 'More DCSP labels DCSP than DCSP embeddings' DCNL DCSP  DCSP if (saveable is False): DCNL DCSP  DCSP  DCSP plt.ion() DCNL DCSP  DCSP  DCSP plt.figure(fig_idx) DCNL DCSP  DCSP plt.figure(figsize=figsize) DCNL DCSP  DCSP for (i, label) in enumerate(labels): DCNL DCSP  DCSP  DCSP (x, y) = low_dim_embs[i, :] DCNL DCSP  DCSP  DCSP plt.scatter(x, y) DCNL DCSP  DCSP  DCSP plt.annotate(label, xy=(x, y), xytext=(5, 2), textcoords='offset DCSP points', ha='right', va='bottom') DCNL DCSP  DCSP if saveable: DCNL DCSP  DCSP  DCSP plt.savefig((name + '.pdf'), format='pdf') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP plt.draw() DCNL DCSP  DCSP  DCSP plt.pause(second) DCNL DCSP try: DCNL DCSP  DCSP from sklearn.manifold import TSNE DCNL DCSP  DCSP import matplotlib.pyplot as plt DCNL DCSP  DCSP from six.moves import xrange DCNL DCSP  DCSP tsne = TSNE(perplexity=30, n_components=2, init='pca', n_iter=5000) DCNL DCSP  DCSP low_dim_embs = tsne.fit_transform(embeddings[:plot_only, :]) DCNL DCSP  DCSP labels = [reverse_dictionary[i] for i in xrange(plot_only)] DCNL DCSP  DCSP plot_with_labels(low_dim_embs, labels, second=second, saveable=saveable, name=name, fig_idx=fig_idx) DCNL DCSP except ImportError: DCNL DCSP  DCSP print 'Please DCSP install DCSP sklearn DCSP and DCSP matplotlib DCSP to DCSP visualize DCSP embeddings.'\n", "intent": "visualize the embeddings by using t-sne .\n", "question_id": 454}, {"snippet": "def _encode_binary(name, value, dummy0, dummy1): DCNL  DCSP subtype = value.subtype DCNL DCSP if (subtype == 2): DCNL DCSP  DCSP value = (_PACK_INT(len(value)) + value) DCNL DCSP return ((('\\x05' + name) + _PACK_LENGTH_SUBTYPE(len(value), subtype)) + value)\n", "intent": "encode bson .\n", "question_id": 455}, {"snippet": "def _concatenate_epochs(epochs_list, with_data=True): DCNL  DCSP if (not isinstance(epochs_list, (list, tuple))): DCNL DCSP  DCSP raise TypeError(('epochs_list DCSP must DCSP be DCSP a DCSP list DCSP or DCSP tuple, DCSP got DCSP %s' % (type(epochs_list),))) DCNL DCSP for (ei, epochs) in enumerate(epochs_list): DCNL DCSP  DCSP if (not isinstance(epochs, BaseEpochs)): DCNL DCSP  DCSP  DCSP raise TypeError(('epochs_list[%d] DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP Epochs, DCSP got DCSP %s' % (ei, type(epochs)))) DCNL DCSP out = epochs_list[0] DCNL DCSP data = ([out.get_data()] if with_data else None) DCNL DCSP events = [out.events] DCNL DCSP (baseline, tmin, tmax) = (out.baseline, out.tmin, out.tmax) DCNL DCSP info = deepcopy(out.info) DCNL DCSP verbose = out.verbose DCNL DCSP drop_log = deepcopy(out.drop_log) DCNL DCSP event_id = deepcopy(out.event_id) DCNL DCSP selection = out.selection DCNL DCSP for (ii, epochs) in enumerate(epochs_list[1:]): DCNL DCSP  DCSP _compare_epochs_infos(epochs.info, info, ii) DCNL DCSP  DCSP if (not np.allclose(epochs.times, epochs_list[0].times)): DCNL DCSP  DCSP  DCSP raise ValueError('Epochs DCSP must DCSP have DCSP same DCSP times') DCNL DCSP  DCSP if (epochs.baseline != baseline): DCNL DCSP  DCSP  DCSP raise ValueError('Baseline DCSP must DCSP be DCSP same DCSP for DCSP all DCSP epochs') DCNL DCSP  DCSP if with_data: DCNL DCSP  DCSP  DCSP data.append(epochs.get_data()) DCNL DCSP  DCSP events.append(epochs.events) DCNL DCSP  DCSP selection = np.concatenate((selection, epochs.selection)) DCNL DCSP  DCSP drop_log.extend(epochs.drop_log) DCNL DCSP  DCSP event_id.update(epochs.event_id) DCNL DCSP events = np.concatenate(events, axis=0) DCNL DCSP if with_data: DCNL DCSP  DCSP data = np.concatenate(data, axis=0) DCNL DCSP return (info, data, events, event_id, tmin, tmax, baseline, selection, drop_log, verbose)\n", "intent": "auxiliary function for concatenating epochs .\n", "question_id": 456}, {"snippet": "def _SetCountingStyle(level): DCNL  DCSP _cpplint_state.SetCountingStyle(level)\n", "intent": "sets the modules counting options .\n", "question_id": 457}, {"snippet": "def parse_type(attrtype): DCNL  DCSP uattribute = attrtype.lower().strip() DCNL DCSP if (uattribute[0] == '{'): DCNL DCSP  DCSP return 'nominal' DCNL DCSP elif (uattribute[:len('real')] == 'real'): DCNL DCSP  DCSP return 'numeric' DCNL DCSP elif (uattribute[:len('integer')] == 'integer'): DCNL DCSP  DCSP return 'numeric' DCNL DCSP elif (uattribute[:len('numeric')] == 'numeric'): DCNL DCSP  DCSP return 'numeric' DCNL DCSP elif (uattribute[:len('string')] == 'string'): DCNL DCSP  DCSP return 'string' DCNL DCSP elif (uattribute[:len('relational')] == 'relational'): DCNL DCSP  DCSP return 'relational' DCNL DCSP elif (uattribute[:len('date')] == 'date'): DCNL DCSP  DCSP return 'date' DCNL DCSP else: DCNL DCSP  DCSP raise ParseArffError(('unknown DCSP attribute DCSP %s' % uattribute))\n", "intent": "given an arff attribute value .\n", "question_id": 458}, {"snippet": "def _request(method, url, content_type=None, _data=None): DCNL  DCSP opener = _build_opener(_HTTPHandler) DCNL DCSP request = _Request(url, data=_data) DCNL DCSP if content_type: DCNL DCSP  DCSP request.add_header('Content-Type', content_type) DCNL DCSP request.get_method = (lambda : method) DCNL DCSP try: DCNL DCSP  DCSP handler = opener.open(request) DCNL DCSP except HTTPError as exc: DCNL DCSP  DCSP return {'error': '{0}'.format(exc)} DCNL DCSP return json.loads(handler.read())\n", "intent": "makes a http request .\n", "question_id": 459}, {"snippet": "def get_templatetags_modules(): DCNL  DCSP global templatetags_modules DCNL DCSP if (not templatetags_modules): DCNL DCSP  DCSP _templatetags_modules = [] DCNL DCSP  DCSP for app_module in ([u'django'] + list(settings.INSTALLED_APPS)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP templatetag_module = (u'%s.templatetags' % app_module) DCNL DCSP  DCSP  DCSP  DCSP import_module(templatetag_module) DCNL DCSP  DCSP  DCSP  DCSP _templatetags_modules.append(templatetag_module) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP templatetags_modules = _templatetags_modules DCNL DCSP return templatetags_modules\n", "intent": "return the list of all available template tag modules .\n", "question_id": 460}, {"snippet": "def osd_prepare(**kwargs): DCNL  DCSP return ceph_cfg.osd_prepare(**kwargs)\n", "intent": "prepare an osd cli example: .\n", "question_id": 461}, {"snippet": "def test_purge_old_cookies(config_stub, fake_save_manager): DCNL  DCSP line_parser_stub = [COOKIE1, COOKIE2, SESSION_COOKIE, EXPIRED_COOKIE] DCNL DCSP jar = cookies.CookieJar(line_parser=line_parser_stub) DCNL DCSP assert (len(jar.allCookies()) == 4) DCNL DCSP jar.purge_old_cookies() DCNL DCSP raw_cookies = [cookie.toRawForm().data() for cookie in jar.allCookies()] DCNL DCSP assert (raw_cookies == [COOKIE1, COOKIE2, SESSION_COOKIE])\n", "intent": "test that expired cookies are deleted .\n", "question_id": 462}, {"snippet": "def _symbols(name, n): DCNL  DCSP try: DCNL DCSP  DCSP lsyms = _symbols_cache[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP lsyms = [] DCNL DCSP  DCSP _symbols_cache[name] = lsyms DCNL DCSP while (len(lsyms) < n): DCNL DCSP  DCSP lsyms.append(Dummy(('%s%i' % (name, len(lsyms))))) DCNL DCSP return lsyms[:n]\n", "intent": "get vector of symbols local to this module .\n", "question_id": 463}, {"snippet": "def create_rdf_parser_without_externals(target, store): DCNL  DCSP parser = _rdfxml_create_parser(target, store) DCNL DCSP parser.setFeature(feature_external_ges, 0) DCNL DCSP parser.setFeature(feature_external_pes, 0) DCNL DCSP return parser\n", "intent": "create an rdf parser that does not support general entity expansion .\n", "question_id": 464}, {"snippet": "def validate_namespace(value, exception=BadValueError): DCNL  DCSP if (not isinstance(value, basestring)): DCNL DCSP  DCSP raise exception(('value DCSP should DCSP be DCSP a DCSP string; DCSP received DCSP %r DCSP (a DCSP %s):' % (value, type(value)))) DCNL DCSP if (not _NAMESPACE_RE.match(value)): DCNL DCSP  DCSP raise exception(('value DCSP \"%s\" DCSP does DCSP not DCSP match DCSP regex DCSP \"%s\"' % (value, _NAMESPACE_PATTERN)))\n", "intent": "raises an exception if value is not a valid namespace string .\n", "question_id": 465}, {"snippet": "def assert_equal_type(logical_line): DCNL  DCSP if asse_equal_type_re.match(logical_line): DCNL DCSP  DCSP (yield (0, 'G317: DCSP assertEqual(type(A), DCSP B) DCSP sentences DCSP not DCSP allowed'))\n", "intent": "check for assertequal(type(a) .\n", "question_id": 466}, {"snippet": "def processSVGElementrect(elementNode, svgReader): DCNL  DCSP attributes = elementNode.attributes DCNL DCSP height = euclidean.getFloatDefaultByDictionary(0.0, attributes, 'height') DCNL DCSP if (height == 0.0): DCNL DCSP  DCSP print 'Warning, DCSP in DCSP processSVGElementrect DCSP in DCSP svgReader DCSP height DCSP is DCSP zero DCSP in:' DCNL DCSP  DCSP print attributes DCNL DCSP  DCSP return DCNL DCSP width = euclidean.getFloatDefaultByDictionary(0.0, attributes, 'width') DCNL DCSP if (width == 0.0): DCNL DCSP  DCSP print 'Warning, DCSP in DCSP processSVGElementrect DCSP in DCSP svgReader DCSP width DCSP is DCSP zero DCSP in:' DCNL DCSP  DCSP print attributes DCNL DCSP  DCSP return DCNL DCSP center = euclidean.getComplexDefaultByDictionaryKeys(complex(), attributes, 'x', 'y') DCNL DCSP inradius = (0.5 * complex(width, height)) DCNL DCSP cornerRadius = euclidean.getComplexDefaultByDictionaryKeys(complex(), attributes, 'rx', 'ry') DCNL DCSP loopLayer = svgReader.getLoopLayer() DCNL DCSP if ((cornerRadius.real == 0.0) and (cornerRadius.imag == 0.0)): DCNL DCSP  DCSP inradiusMinusX = complex((- inradius.real), inradius.imag) DCNL DCSP  DCSP loop = [(center + inradius), (center + inradiusMinusX), (center - inradius), (center - inradiusMinusX)] DCNL DCSP  DCSP loopLayer.loops += getTransformedFillOutline(elementNode, loop, svgReader.yAxisPointingUpward) DCNL DCSP  DCSP return DCNL DCSP if (cornerRadius.real == 0.0): DCNL DCSP  DCSP cornerRadius = complex(cornerRadius.imag, cornerRadius.imag) DCNL DCSP elif (cornerRadius.imag == 0.0): DCNL DCSP  DCSP cornerRadius = complex(cornerRadius.real, cornerRadius.real) DCNL DCSP cornerRadius = complex(min(cornerRadius.real, inradius.real), min(cornerRadius.imag, inradius.imag)) DCNL DCSP ellipsePath = [complex(cornerRadius.real, 0.0)] DCNL DCSP inradiusMinusCorner = (inradius - cornerRadius) DCNL DCSP loop = [] DCNL DCSP global globalNumberOfCornerPoints DCNL DCSP global globalSideAngle DCNL DCSP for side in xrange(1, globalNumberOfCornerPoints): DCNL DCSP  DCSP unitPolar = euclidean.getWiddershinsUnitPolar((float(side) * globalSideAngle)) DCNL DCSP  DCSP ellipsePath.append(complex((unitPolar.real * cornerRadius.real), (unitPolar.imag * cornerRadius.imag))) DCNL DCSP ellipsePath.append(complex(0.0, cornerRadius.imag)) DCNL DCSP cornerPoints = [] DCNL DCSP for point in ellipsePath: DCNL DCSP  DCSP cornerPoints.append((point + inradiusMinusCorner)) DCNL DCSP cornerPointsReversed = cornerPoints[::(-1)] DCNL DCSP for cornerPoint in cornerPoints: DCNL DCSP  DCSP loop.append((center + cornerPoint)) DCNL DCSP for cornerPoint in cornerPointsReversed: DCNL DCSP  DCSP loop.append((center + complex((- cornerPoint.real), cornerPoint.imag))) DCNL DCSP for cornerPoint in cornerPoints: DCNL DCSP  DCSP loop.append((center - cornerPoint)) DCNL DCSP for cornerPoint in cornerPointsReversed: DCNL DCSP  DCSP loop.append((center + complex(cornerPoint.real, (- cornerPoint.imag)))) DCNL DCSP loop = euclidean.getLoopWithoutCloseSequentialPoints((0.0001 * abs(inradius)), loop) DCNL DCSP loopLayer.loops += getTransformedFillOutline(elementNode, loop, svgReader.yAxisPointingUpward)\n", "intent": "process elementnode by svgreader .\n", "question_id": 467}, {"snippet": "@_np.deprecate(message='scipy.constants.C2K DCSP is DCSP deprecated DCSP in DCSP scipy DCSP 0.18.0. DCSP Use DCSP scipy.constants.convert_temperature DCSP instead. DCSP Note DCSP that DCSP the DCSP new DCSP function DCSP has DCSP a DCSP different DCSP signature.') DCNL def C2K(C): DCNL  DCSP return (_np.asanyarray(C) + zero_Celsius)\n", "intent": "convert celsius to kelvin parameters c : array_like celsius temperature(s) to be converted .\n", "question_id": 468}, {"snippet": "def autoencoder_results(hidden_units): DCNL  DCSP (training_data, test_inputs, actual_test_results) = mnist_loader.load_data_nn() DCNL DCSP net = train_autoencoder(hidden_units, training_data) DCNL DCSP plot_test_results(net, test_inputs)\n", "intent": "train an autoencoder using the mnist training data and plot the results when the first ten mnist test images are passed through the autoencoder .\n", "question_id": 469}, {"snippet": "def renameProcess(new_name): DCNL  DCSP if (sys.platform != 'linux2'): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP from ctypes import CDLL DCNL DCSP  DCSP libc = CDLL('libc.so.6') DCNL DCSP  DCSP libc.prctl(15, new_name, 0, 0, 0) DCNL DCSP  DCSP return True DCNL DCSP except Exception as e: DCNL DCSP  DCSP return False\n", "intent": "renames the process calling the function to the given name .\n", "question_id": 470}, {"snippet": "def __virtual__(): DCNL  DCSP if HAS_LDAP: DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return (False, 'The DCSP ldapmod DCSP execution DCSP module DCSP cannot DCSP be DCSP loaded: DCSP ldap DCSP config DCSP not DCSP present.')\n", "intent": "only load this module if the ldap config is set .\n", "question_id": 471}, {"snippet": "def _format_job_instance(job): DCNL  DCSP ret = {'Function': job.get('fun', 'unknown-function'), 'Arguments': json.loads(job.get('arg', '[]')), 'Target': job.get('tgt', 'unknown-target'), 'Target-type': job.get('tgt_type', []), 'User': job.get('user', 'root')} DCNL DCSP return ret\n", "intent": "format the job instance correctly .\n", "question_id": 472}, {"snippet": "def user_redirects(user): DCNL  DCSP return Document.objects.filter(revisions__creator=user).filter(html__startswith='<p>REDIRECT DCSP <a').distinct()\n", "intent": "return the redirects a user has contributed to .\n", "question_id": 473}, {"snippet": "def ensure_metadata_list(text): DCNL  DCSP if isinstance(text, six.text_type): DCNL DCSP  DCSP if (u';' in text): DCNL DCSP  DCSP  DCSP text = text.split(u';') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP text = text.split(u',') DCNL DCSP return list(OrderedDict.fromkeys([v for v in (w.strip() for w in text) if v]))\n", "intent": "canonicalize the format of a list of authors or tags .\n", "question_id": 474}, {"snippet": "def get_flow(**kwargs): DCNL  DCSP task_id = kwargs.get('task_id') DCNL DCSP task_type = kwargs.get('task_type') DCNL DCSP task_repo = kwargs.get('task_repo') DCNL DCSP image_repo = kwargs.get('image_repo') DCNL DCSP image_factory = kwargs.get('image_factory') DCNL DCSP uri = kwargs.get('uri') DCNL DCSP flow = lf.Flow(task_type, retry=retry.AlwaysRevert()).add(_CreateImage(task_id, task_type, task_repo, image_repo, image_factory)) DCNL DCSP import_to_store = _ImportToStore(task_id, task_type, image_repo, uri) DCNL DCSP try: DCNL DCSP  DCSP limbo = lf.Flow(task_type).add(_ImportToFS(task_id, task_type, task_repo, uri)) DCNL DCSP  DCSP for subflow in _get_import_flows(**kwargs): DCNL DCSP  DCSP  DCSP limbo.add(subflow) DCNL DCSP  DCSP if (len(limbo) > 1): DCNL DCSP  DCSP  DCSP flow.add(limbo) DCNL DCSP  DCSP  DCSP flow.add(import_to_store) DCNL DCSP  DCSP  DCSP delete_flow = lf.Flow(task_type).add(_DeleteFromFS(task_id, task_type)) DCNL DCSP  DCSP  DCSP flow.add(delete_flow) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flow.add(import_to_store) DCNL DCSP except exception.BadTaskConfiguration as exc: DCNL DCSP  DCSP LOG.error(_LE('Bad DCSP task DCSP configuration: DCSP %s'), exc.message) DCNL DCSP  DCSP flow.add(import_to_store) DCNL DCSP flow.add(_SaveImage(task_id, task_type, image_repo), _CompleteTask(task_id, task_type, task_repo)) DCNL DCSP return flow\n", "intent": "return task flow .\n", "question_id": 475}, {"snippet": "def create_cover(title, authors, series=None, series_index=1, prefs=None, as_qimage=False): DCNL  DCSP u' DCSP templates DCSP are DCSP ignored, DCSP to DCSP ensure DCSP that DCSP the DCSP specified DCSP metadata DCSP is DCSP used. DCSP ' DCNL DCSP mi = Metadata(title, authors) DCNL DCSP if series: DCNL DCSP  DCSP (mi.series, mi.series_index) = (series, series_index) DCNL DCSP d = cprefs.defaults DCNL DCSP prefs = override_prefs((prefs or cprefs), title_template=d[u'title_template'], subtitle_template=d[u'subtitle_template'], footer_template=d[u'footer_template']) DCNL DCSP return generate_cover(mi, prefs=prefs, as_qimage=as_qimage)\n", "intent": "create a cover from the specified title .\n", "question_id": 476}, {"snippet": "def fastica(X, n_comp=None, algorithm='parallel', whiten=True, fun='logcosh', fun_prime='', fun_args={}, maxit=200, tol=0.0001, w_init=None): DCNL  DCSP algorithm_funcs = {'parallel': _ica_par, 'deflation': _ica_def} DCNL DCSP alpha = fun_args.get('alpha', 1.0) DCNL DCSP if ((alpha < 1) or (alpha > 2)): DCNL DCSP  DCSP raise ValueError('alpha DCSP must DCSP be DCSP in DCSP [1,2]') DCNL DCSP if (type(fun) is types.StringType): DCNL DCSP  DCSP if (fun == 'logcosh'): DCNL DCSP  DCSP  DCSP def g(x, fun_args): DCNL DCSP  DCSP  DCSP  DCSP alpha = fun_args.get('alpha', 1.0) DCNL DCSP  DCSP  DCSP  DCSP return np.tanh((alpha * x)) DCNL DCSP  DCSP  DCSP def gprime(x, fun_args): DCNL DCSP  DCSP  DCSP  DCSP alpha = fun_args.get('alpha', 1.0) DCNL DCSP  DCSP  DCSP  DCSP return (alpha * (1 - (np.tanh((alpha * x)) ** 2))) DCNL DCSP  DCSP elif (fun == 'exp'): DCNL DCSP  DCSP  DCSP def g(x, fun_args): DCNL DCSP  DCSP  DCSP  DCSP return (x * np.exp(((- (x ** 2)) / 2))) DCNL DCSP  DCSP  DCSP def gprime(x, fun_args): DCNL DCSP  DCSP  DCSP  DCSP return ((1 - (x ** 2)) * np.exp(((- (x ** 2)) / 2))) DCNL DCSP  DCSP elif (fun == 'cube'): DCNL DCSP  DCSP  DCSP def g(x, fun_args): DCNL DCSP  DCSP  DCSP  DCSP return (x ** 3) DCNL DCSP  DCSP  DCSP def gprime(x, fun_args): DCNL DCSP  DCSP  DCSP  DCSP return (3 * (x ** 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('fun DCSP argument DCSP should DCSP be DCSP one DCSP of DCSP logcosh, DCSP exp DCSP or DCSP cube') DCNL DCSP elif (type(fun) is not types.FunctionType): DCNL DCSP  DCSP raise ValueError('fun DCSP argument DCSP should DCSP be DCSP either DCSP a DCSP string DCSP (one DCSP of DCSP logcosh, DCSP exp DCSP or DCSP cube) DCSP or DCSP a DCSP function') DCNL DCSP else: DCNL DCSP  DCSP def g(x, fun_args): DCNL DCSP  DCSP  DCSP return fun(x, **fun_args) DCNL DCSP  DCSP def gprime(x, fun_args): DCNL DCSP  DCSP  DCSP return fun_prime(x, **fun_args) DCNL DCSP (n, p) = X.shape DCNL DCSP if (n_comp is None): DCNL DCSP  DCSP n_comp = min(n, p) DCNL DCSP if (n_comp > min(n, p)): DCNL DCSP  DCSP n_comp = min(n, p) DCNL DCSP  DCSP print ('n_comp DCSP is DCSP too DCSP large: DCSP it DCSP will DCSP be DCSP set DCSP to DCSP %s' % n_comp) DCNL DCSP if whiten: DCNL DCSP  DCSP X = (X - X.mean(axis=0)) DCNL DCSP  DCSP (_, d, v) = np.linalg.svd(X, full_matrices=False) DCNL DCSP  DCSP del _ DCNL DCSP  DCSP K = (v * (np.sqrt(n) / d)[:, np.newaxis])[:n_comp] DCNL DCSP  DCSP del v, d DCNL DCSP  DCSP X1 = np.dot(K, X.T) DCNL DCSP else: DCNL DCSP  DCSP X1 = X.T DCNL DCSP if (w_init is None): DCNL DCSP  DCSP w_init = np.random.normal(size=(n_comp, n_comp)) DCNL DCSP else: DCNL DCSP  DCSP w_init = np.asarray(w_init) DCNL DCSP  DCSP if (w_init.shape != (n_comp, n_comp)): DCNL DCSP  DCSP  DCSP raise ValueError(('w_init DCSP has DCSP invalid DCSP shape DCSP -- DCSP should DCSP be DCSP %(shape)s' % {'shape': (n_comp, n_comp)})) DCNL DCSP kwargs = {'tol': tol, 'g': g, 'gprime': gprime, 'fun_args': fun_args, 'maxit': maxit, 'w_init': w_init} DCNL DCSP func = algorithm_funcs.get(algorithm, 'parallel') DCNL DCSP W = func(X1, **kwargs) DCNL DCSP del X1 DCNL DCSP if whiten: DCNL DCSP  DCSP S = np.dot((np.asmatrix(W) * K), X.T) DCNL DCSP  DCSP return [np.asarray(e.T) for e in (K, W, S)] DCNL DCSP else: DCNL DCSP  DCSP S = np.dot(W, X.T) DCNL DCSP  DCSP return [np.asarray(e.T) for e in (W, S)]\n", "intent": "perform fast independent component analysis .\n", "question_id": 477}, {"snippet": "def is_excluded(root, excludes): DCNL  DCSP sep = path.sep DCNL DCSP if (not root.endswith(sep)): DCNL DCSP  DCSP root += sep DCNL DCSP for exclude in excludes: DCNL DCSP  DCSP if root.startswith(exclude): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "check if the directory is in the exclude list .\n", "question_id": 478}, {"snippet": "def addsitepackages(known_paths, sys_prefix=sys.prefix, exec_prefix=sys.exec_prefix): DCNL  DCSP prefixes = [os.path.join(sys_prefix, 'local'), sys_prefix] DCNL DCSP if (exec_prefix != sys_prefix): DCNL DCSP  DCSP prefixes.append(os.path.join(exec_prefix, 'local')) DCNL DCSP for prefix in prefixes: DCNL DCSP  DCSP if prefix: DCNL DCSP  DCSP  DCSP if ((sys.platform in ('os2emx', 'riscos')) or _is_jython): DCNL DCSP  DCSP  DCSP  DCSP sitedirs = [os.path.join(prefix, 'Lib', 'site-packages')] DCNL DCSP  DCSP  DCSP elif _is_pypy: DCNL DCSP  DCSP  DCSP  DCSP sitedirs = [os.path.join(prefix, 'site-packages')] DCNL DCSP  DCSP  DCSP elif ((sys.platform == 'darwin') and (prefix == sys_prefix)): DCNL DCSP  DCSP  DCSP  DCSP if prefix.startswith('/System/Library/Frameworks/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sitedirs = [os.path.join('/Library/Python', sys.version[:3], 'site-packages'), os.path.join(prefix, 'Extras', 'lib', 'python')] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sitedirs = [os.path.join(prefix, 'lib', ('python' + sys.version[:3]), 'site-packages')] DCNL DCSP  DCSP  DCSP elif (os.sep == '/'): DCNL DCSP  DCSP  DCSP  DCSP sitedirs = [os.path.join(prefix, 'lib', ('python' + sys.version[:3]), 'site-packages'), os.path.join(prefix, 'lib', 'site-python'), os.path.join(prefix, ('python' + sys.version[:3]), 'lib-dynload')] DCNL DCSP  DCSP  DCSP  DCSP lib64_dir = os.path.join(prefix, 'lib64', ('python' + sys.version[:3]), 'site-packages') DCNL DCSP  DCSP  DCSP  DCSP if (os.path.exists(lib64_dir) and (os.path.realpath(lib64_dir) not in [os.path.realpath(p) for p in sitedirs])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sitedirs.append(lib64_dir) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.getobjects DCNL DCSP  DCSP  DCSP  DCSP  DCSP sitedirs.insert(0, os.path.join(sitedirs[0], 'debug')) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'lib', ('python' + sys.version[:3]), 'dist-packages')) DCNL DCSP  DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'local/lib', ('python' + sys.version[:3]), 'dist-packages')) DCNL DCSP  DCSP  DCSP  DCSP sitedirs.append(os.path.join(prefix, 'lib', 'dist-python')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sitedirs = [prefix, os.path.join(prefix, 'lib', 'site-packages')] DCNL DCSP  DCSP  DCSP if (sys.platform == 'darwin'): DCNL DCSP  DCSP  DCSP  DCSP if ('Python.framework' in prefix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP home = os.environ.get('HOME') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if home: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sitedirs.append(os.path.join(home, 'Library', 'Python', sys.version[:3], 'site-packages')) DCNL DCSP  DCSP  DCSP for sitedir in sitedirs: DCNL DCSP  DCSP  DCSP  DCSP if os.path.isdir(sitedir): DCNL DCSP  DCSP  DCSP  DCSP  DCSP addsitedir(sitedir, known_paths) DCNL DCSP return None\n", "intent": "add site-packages  to sys .\n", "question_id": 479}, {"snippet": "def get_attributes(name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return {} DCNL DCSP queue_obj = conn.get_queue(name) DCNL DCSP if (not queue_obj): DCNL DCSP  DCSP log.error('Queue DCSP {0} DCSP does DCSP not DCSP exist.'.format(name)) DCNL DCSP  DCSP return {} DCNL DCSP return conn.get_queue_attributes(queue_obj)\n", "intent": "return attributes currently set on an sqs queue .\n", "question_id": 480}, {"snippet": "def create_message(senderobj, message, channels=None, receivers=None, locks=None, header=None): DCNL  DCSP global _Msg DCNL DCSP if (not _Msg): DCNL DCSP  DCSP from evennia.comms.models import Msg as _Msg DCNL DCSP if (not message): DCNL DCSP  DCSP return DCNL DCSP new_message = _Msg(db_message=message) DCNL DCSP new_message.save() DCNL DCSP for sender in make_iter(senderobj): DCNL DCSP  DCSP new_message.senders = sender DCNL DCSP new_message.header = header DCNL DCSP for channel in make_iter(channels): DCNL DCSP  DCSP new_message.channels = channel DCNL DCSP for receiver in make_iter(receivers): DCNL DCSP  DCSP new_message.receivers = receiver DCNL DCSP if locks: DCNL DCSP  DCSP new_message.locks.add(locks) DCNL DCSP new_message.save() DCNL DCSP return new_message\n", "intent": "create a new communication msg .\n", "question_id": 481}, {"snippet": "def require_context(fn): DCNL  DCSP @functools.wraps(fn) DCNL DCSP def _require_cuda_context(*args, **kws): DCNL DCSP  DCSP get_context() DCNL DCSP  DCSP return fn(*args, **kws) DCNL DCSP return _require_cuda_context\n", "intent": "a decorator that ensures a cuda context is available when *fn* is executed .\n", "question_id": 482}, {"snippet": "def get_invoiced_qty_map(purchase_receipt): DCNL  DCSP invoiced_qty_map = {} DCNL DCSP for (pr_detail, qty) in frappe.db.sql(u'select DCSP pr_detail, DCSP qty DCSP from DCSP `tabPurchase DCSP Invoice DCSP Item`\\n DCTB  DCTB where DCSP purchase_receipt=%s DCSP and DCSP docstatus=1', purchase_receipt): DCNL DCSP  DCSP if (not invoiced_qty_map.get(pr_detail)): DCNL DCSP  DCSP  DCSP invoiced_qty_map[pr_detail] = 0 DCNL DCSP  DCSP invoiced_qty_map[pr_detail] += qty DCNL DCSP return invoiced_qty_map\n", "intent": "returns a map: {pr_detail: invoiced_qty} .\n", "question_id": 483}, {"snippet": "def _get_log_keys(common_config): DCNL  DCSP return dict(((k, v) for (k, v) in common_config.items() if (k in LOG_KEYS)))\n", "intent": "return a common configuration copy with only log-related config left .\n", "question_id": 484}, {"snippet": "def test_io_layout_lout(): DCNL  DCSP tempdir = _TempDir() DCNL DCSP layout = read_layout('Vectorview-all', scale=False) DCNL DCSP layout.save(op.join(tempdir, 'foobar.lout')) DCNL DCSP layout_read = read_layout(op.join(tempdir, 'foobar.lout'), path='./', scale=False) DCNL DCSP assert_array_almost_equal(layout.pos, layout_read.pos, decimal=2) DCNL DCSP assert_true(layout.names, layout_read.names) DCNL DCSP print(layout)\n", "intent": "test io with .\n", "question_id": 485}, {"snippet": "def has_url(url): DCNL  DCSP return _cache.has_url(url)\n", "intent": "returns true if cache has url .\n", "question_id": 486}, {"snippet": "def serialize_one(out, package): DCNL  DCSP if ((not package) or package[u'name'].startswith(u'_')): DCNL DCSP  DCSP log(u'skipping', package) DCNL DCSP  DCSP return 0 DCNL DCSP row = (package[u'package_manager'], package[u'name'], package[u'description'], arrayize(package[u'emails'])) DCNL DCSP out.writerow(row) DCNL DCSP return 1\n", "intent": "take a single package dict and emit a csv serialization suitable for postgres copy .\n", "question_id": 487}, {"snippet": "def prepare_mock_wb_response(node=None, provider='github', files=None, folder=True, path='/', method=httpretty.GET, status_code=200): DCNL  DCSP node = node DCNL DCSP files = (files or []) DCNL DCSP wb_url = waterbutler_api_url_for(node._id, provider=provider, path=path, meta=True) DCNL DCSP default_file = {u'contentType': None, u'extra': {u'downloads': 0, u'version': 1}, u'kind': u'file', u'modified': None, u'name': u'NewFile', u'path': u'/NewFile', u'provider': provider, u'size': None, u'materialized': '/'} DCNL DCSP if len(files): DCNL DCSP  DCSP data = [dict(default_file, **each) for each in files] DCNL DCSP else: DCNL DCSP  DCSP data = [default_file] DCNL DCSP jsonapi_data = [] DCNL DCSP for datum in data: DCNL DCSP  DCSP jsonapi_data.append({'attributes': datum}) DCNL DCSP if (not folder): DCNL DCSP  DCSP jsonapi_data = jsonapi_data[0] DCNL DCSP body = json.dumps({u'data': jsonapi_data}) DCNL DCSP httpretty.register_uri(method, wb_url, body=body, status=status_code, content_type='application/json')\n", "intent": "prepare a mock waterbutler response with httpretty .\n", "question_id": 488}, {"snippet": "@treeio_login_required DCNL @handle_response_format DCNL def day_view(request, response_format='html'): DCNL  DCSP events = Object.filter_by_request(request, Event.objects) DCNL DCSP date_current = now = datetime.now() DCNL DCSP istoday = True DCNL DCSP gotoform = GoToDateForm(now, request.GET) DCNL DCSP if request.GET: DCNL DCSP  DCSP if (('date_year' in request.GET) and ('date_month' in request.GET) and ('date_day' in request.GET)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP day = int(request.GET['date_day']) DCNL DCSP  DCSP  DCSP  DCSP year = int(request.GET['date_year']) DCNL DCSP  DCSP  DCSP  DCSP month = int(request.GET['date_month']) DCNL DCSP  DCSP  DCSP  DCSP if ((year >= 1900) and (month >= 1) and (month <= 12) and (day >= 1) and (day <= 31)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP date_current = datetime(year, month, day) DCNL DCSP  DCSP  DCSP  DCSP  DCSP istoday = (date_current == now) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (gotoform.is_valid() and gotoform.cleaned_data['goto']): DCNL DCSP  DCSP  DCSP date_current = gotoform.cleaned_data['goto'] DCNL DCSP  DCSP  DCSP istoday = (date_current == now) DCNL DCSP  DCSP  DCSP date_current = now = datetime(date_current.year, date_current.month, date_current.day) DCNL DCSP day = date_current.date() DCNL DCSP date_previous = (date_current - relativedelta(days=(+ 1))) DCNL DCSP date_next = (date_current + relativedelta(days=(+ 1))) DCNL DCSP wrapped_events = EventCollection(events, START_HOUR, END_HOUR) DCNL DCSP wrapped_events.collect_events(request) DCNL DCSP hours = range(START_HOUR, (END_HOUR + 1)) DCNL DCSP return render_to_response('events/day_view', {'events': wrapped_events, 'day': day, 'hours': hours, 'date_previous': date_previous, 'date_next': date_next, 'date_current': date_current, 'gotoform': gotoform.as_ul(), 'istoday': istoday, 'now': now}, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "day view - each slot represents an hour .\n", "question_id": 489}, {"snippet": "def signature(secret, parts): DCNL  DCSP if (sys.version_info >= (2, 5)): DCNL DCSP  DCSP csum = hmac.new(secret, digestmod=hashlib.sha1) DCNL DCSP else: DCNL DCSP  DCSP csum = hmac.new(secret, digestmod=sha) DCNL DCSP for part in parts: DCNL DCSP  DCSP csum.update(part) DCNL DCSP return csum.hexdigest()\n", "intent": "generates a signature .\n", "question_id": 490}, {"snippet": "def dummyModelParams(perm): DCNL  DCSP errScore = 500 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['A'] is None)): DCNL DCSP  DCSP errScore -= 50 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['B'] is None)): DCNL DCSP  DCSP errScore -= 40 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['C'] is None)): DCNL DCSP  DCSP errScore -= 30 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['D'] is None)): DCNL DCSP  DCSP errScore -= 20 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['E'] is None)): DCNL DCSP  DCSP errScore -= 15 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['F'] is None)): DCNL DCSP  DCSP errScore -= 10 DCNL DCSP if (not (perm['modelParams']['sensorParams']['encoders']['G'] is None)): DCNL DCSP  DCSP errScore -= 5 DCNL DCSP delay = 0 DCNL DCSP encoderCount = 0 DCNL DCSP for key in perm.keys(): DCNL DCSP  DCSP if (('encoder' in key) and (not (perm[key] is None))): DCNL DCSP  DCSP  DCSP encoderCount += 1 DCNL DCSP delay = ((encoderCount * encoderCount) * 0.1) DCNL DCSP dummyModelParams = dict(metricValue=errScore, metricFunctions=None, delay=delay) DCNL DCSP return dummyModelParams\n", "intent": "this function can be used for hypersearch algorithm development .\n", "question_id": 491}, {"snippet": "def getAllComponents(folderList=(), fetchIcons=True): DCNL  DCSP if isinstance(folderList, basestring): DCNL DCSP  DCSP raise TypeError, 'folderList DCSP should DCSP be DCSP iterable, DCSP not DCSP a DCSP string' DCNL DCSP components = getComponents(fetchIcons=fetchIcons) DCNL DCSP for folder in folderList: DCNL DCSP  DCSP userComps = getComponents(folder) DCNL DCSP  DCSP for thisKey in userComps.keys(): DCNL DCSP  DCSP  DCSP components[thisKey] = userComps[thisKey] DCNL DCSP return components\n", "intent": "get a dictionary of all available components .\n", "question_id": 492}, {"snippet": "def get_jobs(site=None, queue=None, key=u'method'): DCNL  DCSP jobs_per_site = defaultdict(list) DCNL DCSP for queue in get_queue_list(queue): DCNL DCSP  DCSP q = get_queue(queue) DCNL DCSP  DCSP for job in q.jobs: DCNL DCSP  DCSP  DCSP if job.kwargs.get(u'site'): DCNL DCSP  DCSP  DCSP  DCSP if (site is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP jobs_per_site[job.kwargs[u'site']].append(job.kwargs[key]) DCNL DCSP  DCSP  DCSP  DCSP elif (job.kwargs[u'site'] == site): DCNL DCSP  DCSP  DCSP  DCSP  DCSP jobs_per_site[site].append(job.kwargs[key]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print u'No DCSP site DCSP found DCSP in DCSP job', job.__dict__ DCNL DCSP return jobs_per_site\n", "intent": "gets jobs per queue or per site or both .\n", "question_id": 493}, {"snippet": "def can_init(): DCNL  DCSP if (not sys.stdout.isatty()): DCNL DCSP  DCSP return False DCNL DCSP if sys.flags.interactive: DCNL DCSP  DCSP return False DCNL DCSP mods = sys.modules.keys() DCNL DCSP for repl in ['IPython', 'bpython', 'dreampielib']: DCNL DCSP  DCSP if (repl in mods): DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP raise BaseException DCNL DCSP except BaseException: DCNL DCSP  DCSP frame = sys.exc_info()[2].tb_frame DCNL DCSP while frame: DCNL DCSP  DCSP if (frame.f_code.co_filename == '<stdin>'): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP frame = frame.f_back DCNL DCSP return True\n", "intent": "this function returns true iff stderr is a tty and we are not inside a repl .\n", "question_id": 494}, {"snippet": "def redirect_view(request): DCNL  DCSP if request.GET: DCNL DCSP  DCSP query = ('?' + urlencode(request.GET, True)) DCNL DCSP else: DCNL DCSP  DCSP query = '' DCNL DCSP return HttpResponseRedirect(('/test_client/get_view/' + query))\n", "intent": "a view that redirects all requests to the get view .\n", "question_id": 495}, {"snippet": "def get_sql_flush(style, tables, sequences): DCNL  DCSP if tables: DCNL DCSP  DCSP if ((postgres_version[0] >= 8) and (postgres_version[1] >= 1)): DCNL DCSP  DCSP  DCSP sql = [('%s DCSP %s;' % (style.SQL_KEYWORD('TRUNCATE'), style.SQL_FIELD(', DCSP '.join([quote_name(table) for table in tables]))))] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sql = [('%s DCSP %s DCSP %s;' % (style.SQL_KEYWORD('DELETE'), style.SQL_KEYWORD('FROM'), style.SQL_FIELD(quote_name(table)))) for table in tables] DCNL DCSP  DCSP for sequence in sequences: DCNL DCSP  DCSP  DCSP table_name = sequence['table'] DCNL DCSP  DCSP  DCSP column_name = sequence['column'] DCNL DCSP  DCSP  DCSP if (column_name and (len(column_name) > 0)): DCNL DCSP  DCSP  DCSP  DCSP sql.append(('%s DCSP %s DCSP %s DCSP %s DCSP %s DCSP %s;' % (style.SQL_KEYWORD('ALTER'), style.SQL_KEYWORD('SEQUENCE'), style.SQL_FIELD(('%s_%s_seq' % (table_name, column_name))), style.SQL_KEYWORD('RESTART'), style.SQL_KEYWORD('WITH'), style.SQL_FIELD('1')))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sql.append(('%s DCSP %s DCSP %s DCSP %s DCSP %s DCSP %s;' % (style.SQL_KEYWORD('ALTER'), style.SQL_KEYWORD('SEQUENCE'), style.SQL_FIELD(('%s_id_seq' % table_name)), style.SQL_KEYWORD('RESTART'), style.SQL_KEYWORD('WITH'), style.SQL_FIELD('1')))) DCNL DCSP  DCSP return sql DCNL DCSP else: DCNL DCSP  DCSP return []\n", "intent": "return a list of sql statements required to remove all data from all tables in the database  and put the database in an empty initial state .\n", "question_id": 496}, {"snippet": "@autojit DCNL def mandel(x, y, max_iters): DCNL  DCSP i = 0 DCNL DCSP c = complex(x, y) DCNL DCSP z = 0j DCNL DCSP for i in range(max_iters): DCNL DCSP  DCSP z = ((z * z) + c) DCNL DCSP  DCSP if (((z.real * z.real) + (z.imag * z.imag)) >= 4): DCNL DCSP  DCSP  DCSP return i DCNL DCSP return 255\n", "intent": "given the real and imaginary parts of a complex number .\n", "question_id": 497}, {"snippet": "def get_preferred_environment_encoding(): DCNL  DCSP return (locale.getpreferredencoding() or u'utf-8')\n", "intent": "get encoding that should be used for decoding environment variables .\n", "question_id": 498}, {"snippet": "def save_virtual_workbook(workbook, as_template=False): DCNL  DCSP writer = ExcelWriter(workbook) DCNL DCSP temp_buffer = BytesIO() DCNL DCSP try: DCNL DCSP  DCSP archive = ZipFile(temp_buffer, 'w', ZIP_DEFLATED, allowZip64=True) DCNL DCSP  DCSP writer.write_data(archive, as_template=as_template) DCNL DCSP finally: DCNL DCSP  DCSP archive.close() DCNL DCSP virtual_workbook = temp_buffer.getvalue() DCNL DCSP temp_buffer.close() DCNL DCSP return virtual_workbook\n", "intent": "return an in-memory workbook .\n", "question_id": 499}, {"snippet": "def regions(language): DCNL  DCSP (x, a) = (language.lower(), []) DCNL DCSP for (tag, (language, region, iso639, iso3166)) in LANGUAGE_REGION.items(): DCNL DCSP  DCSP if (iso639 == x): DCNL DCSP  DCSP  DCSP a.append(iso3166) DCNL DCSP return sorted(a, key=(lambda tag: (((tag.lower() != x) and tag) or '')))\n", "intent": "returns a list of region codes for the given language code .\n", "question_id": 500}, {"snippet": "@bdd.then(bdd.parsers.parse('the DCSP javascript DCSP message DCSP \"{message}\" DCSP should DCSP not DCSP be DCSP logged')) DCNL def javascript_message_not_logged(quteproc, message): DCNL  DCSP quteproc.ensure_not_logged(category='js', function='javaScriptConsoleMessage', message='[*] DCSP {}'.format(message))\n", "intent": "make sure the given message was *not* logged via javascript .\n", "question_id": 501}, {"snippet": "@event(u'forget') DCNL def forget(value): DCNL  DCSP with Session() as session: DCNL DCSP  DCSP log.debug(u'forget DCSP called DCSP with DCSP %s', value) DCNL DCSP  DCSP count = 0 DCNL DCSP  DCSP field_count = 0 DCNL DCSP  DCSP for se in session.query(SeenEntry).filter(or_((SeenEntry.title == value), (SeenEntry.task == value))).all(): DCNL DCSP  DCSP  DCSP field_count += len(se.fields) DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP log.debug(u'forgetting DCSP %s', se) DCNL DCSP  DCSP  DCSP session.delete(se) DCNL DCSP  DCSP for sf in session.query(SeenField).filter((SeenField.value == value)).all(): DCNL DCSP  DCSP  DCSP se = session.query(SeenEntry).filter((SeenEntry.id == sf.seen_entry_id)).first() DCNL DCSP  DCSP  DCSP field_count += len(se.fields) DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP log.debug(u'forgetting DCSP %s', se) DCNL DCSP  DCSP  DCSP session.delete(se) DCNL DCSP return (count, field_count)\n", "intent": "see module docstring .\n", "question_id": 502}, {"snippet": "def compute_singlevalued_measures(ntwk, weighted=True, calculate_cliques=False): DCNL  DCSP iflogger.info(u'Computing DCSP single DCSP valued DCSP measures:') DCNL DCSP measures = {} DCNL DCSP iflogger.info(u'...Computing DCSP degree DCSP assortativity DCSP (pearson DCSP number) DCSP ...') DCNL DCSP try: DCNL DCSP  DCSP measures[u'degree_pearsonr'] = nx.degree_pearsonr(ntwk) DCNL DCSP except AttributeError: DCNL DCSP  DCSP measures[u'degree_pearsonr'] = nx.degree_pearson_correlation_coefficient(ntwk) DCNL DCSP iflogger.info(u'...Computing DCSP degree DCSP assortativity...') DCNL DCSP try: DCNL DCSP  DCSP measures[u'degree_assortativity'] = nx.degree_assortativity(ntwk) DCNL DCSP except AttributeError: DCNL DCSP  DCSP measures[u'degree_assortativity'] = nx.degree_assortativity_coefficient(ntwk) DCNL DCSP iflogger.info(u'...Computing DCSP transitivity...') DCNL DCSP measures[u'transitivity'] = nx.transitivity(ntwk) DCNL DCSP iflogger.info(u'...Computing DCSP number DCSP of DCSP connected_components...') DCNL DCSP measures[u'number_connected_components'] = nx.number_connected_components(ntwk) DCNL DCSP iflogger.info(u'...Computing DCSP graph DCSP density...') DCNL DCSP measures[u'graph_density'] = nx.density(ntwk) DCNL DCSP iflogger.info(u'...Recording DCSP number DCSP of DCSP edges...') DCNL DCSP measures[u'number_of_edges'] = nx.number_of_edges(ntwk) DCNL DCSP iflogger.info(u'...Recording DCSP number DCSP of DCSP nodes...') DCNL DCSP measures[u'number_of_nodes'] = nx.number_of_nodes(ntwk) DCNL DCSP iflogger.info(u'...Computing DCSP average DCSP clustering...') DCNL DCSP measures[u'average_clustering'] = nx.average_clustering(ntwk) DCNL DCSP if nx.is_connected(ntwk): DCNL DCSP  DCSP iflogger.info(u'...Calculating DCSP average DCSP shortest DCSP path DCSP length...') DCNL DCSP  DCSP measures[u'average_shortest_path_length'] = nx.average_shortest_path_length(ntwk, weighted) DCNL DCSP else: DCNL DCSP  DCSP iflogger.info(u'...Calculating DCSP average DCSP shortest DCSP path DCSP length...') DCNL DCSP  DCSP measures[u'average_shortest_path_length'] = nx.average_shortest_path_length(nx.connected_component_subgraphs(ntwk)[0], weighted) DCNL DCSP if calculate_cliques: DCNL DCSP  DCSP iflogger.info(u'...Computing DCSP graph DCSP clique DCSP number...') DCNL DCSP  DCSP measures[u'graph_clique_number'] = nx.graph_clique_number(ntwk) DCNL DCSP return measures\n", "intent": "returns a single value per network .\n", "question_id": 503}, {"snippet": "def first(seq): DCNL  DCSP return next(iter(seq))\n", "intent": "the first element in a sequence .\n", "question_id": 504}, {"snippet": "def addCollarShaftSetDerivation(collarDerivation, collarThickness, derivation, negatives, positives, xmlElement): DCNL  DCSP collarDerivation.setToXMLElement(derivation.copyShallow) DCNL DCSP collarSides = evaluate.getSidesMinimumThreeBasedOnPrecision(derivation.shaftRimRadius, xmlElement) DCNL DCSP collarProfile = euclidean.getComplexPolygon(complex(), derivation.shaftRimRadius, collarSides) DCNL DCSP vector3CollarProfile = euclidean.getVector3Path(collarProfile) DCNL DCSP extrude.addNegativesPositives(collarDerivation, negatives, [vector3CollarProfile], positives) DCNL DCSP addShaft(derivation, negatives, positives) DCNL DCSP drillZ = (derivation.pinionThickness + (0.5 * collarThickness)) DCNL DCSP drillEnd = Vector3(0.0, derivation.shaftRimRadius, drillZ) DCNL DCSP drillStart = Vector3(0.0, 0.0, drillZ) DCNL DCSP teardrop.addNegativesByRadius(drillEnd, negatives, derivation.keywayRadius, drillStart, xmlElement)\n", "intent": "add collar and shaft .\n", "question_id": 505}, {"snippet": "def rec_eval(expr, deepcopy_inputs=False, memo=None, max_program_len=None, memo_gc=True, print_trace=False, print_node_on_error=True): DCNL  DCSP if (max_program_len == None): DCNL DCSP  DCSP max_program_len = DEFAULT_MAX_PROGRAM_LEN DCNL DCSP if (deepcopy_inputs not in (0, 1, False, True)): DCNL DCSP  DCSP raise ValueError('deepcopy_inputs DCSP should DCSP be DCSP bool', deepcopy_inputs) DCNL DCSP node = as_apply(expr) DCNL DCSP topnode = node DCNL DCSP if (memo is None): DCNL DCSP  DCSP memo = {} DCNL DCSP else: DCNL DCSP  DCSP memo = dict(memo) DCNL DCSP node_inputs = {} DCNL DCSP node_list = [] DCNL DCSP dfs(node, node_list, seqset=node_inputs) DCNL DCSP if memo_gc: DCNL DCSP  DCSP clients = {} DCNL DCSP  DCSP for aa in node_list: DCNL DCSP  DCSP  DCSP clients.setdefault(aa, set()) DCNL DCSP  DCSP  DCSP for ii in node_inputs[aa]: DCNL DCSP  DCSP  DCSP  DCSP clients.setdefault(ii, set()).add(aa) DCNL DCSP  DCSP def set_memo(k, v): DCNL DCSP  DCSP  DCSP assert (v is not GarbageCollected) DCNL DCSP  DCSP  DCSP memo[k] = v DCNL DCSP  DCSP  DCSP for ii in node_inputs[k]: DCNL DCSP  DCSP  DCSP  DCSP if all(((iic in memo) for iic in clients[ii])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP memo[ii] = GarbageCollected DCNL DCSP else: DCNL DCSP  DCSP def set_memo(k, v): DCNL DCSP  DCSP  DCSP memo[k] = v DCNL DCSP todo = deque([topnode]) DCNL DCSP while todo: DCNL DCSP  DCSP if (len(todo) > max_program_len): DCNL DCSP  DCSP  DCSP raise RuntimeError('Probably DCSP infinite DCSP loop DCSP in DCSP document') DCNL DCSP  DCSP node = todo.pop() DCNL DCSP  DCSP if print_trace: DCNL DCSP  DCSP  DCSP print('rec_eval:print_trace', len(todo), node.name) DCNL DCSP  DCSP if (node in memo): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (node.name == 'switch'): DCNL DCSP  DCSP  DCSP switch_i_var = node.pos_args[0] DCNL DCSP  DCSP  DCSP if (switch_i_var in memo): DCNL DCSP  DCSP  DCSP  DCSP switch_i = memo[switch_i_var] DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP int(switch_i) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('switch DCSP argument DCSP was', switch_i) DCNL DCSP  DCSP  DCSP  DCSP if ((switch_i != int(switch_i)) or (switch_i < 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('switch DCSP pos DCSP must DCSP be DCSP positive DCSP int', switch_i) DCNL DCSP  DCSP  DCSP  DCSP rval_var = node.pos_args[(switch_i + 1)] DCNL DCSP  DCSP  DCSP  DCSP if (rval_var in memo): DCNL DCSP  DCSP  DCSP  DCSP  DCSP set_memo(node, memo[rval_var]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP waiting_on = [rval_var] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP waiting_on = [switch_i_var] DCNL DCSP  DCSP elif isinstance(node, Literal): DCNL DCSP  DCSP  DCSP set_memo(node, node.obj) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP waiting_on = [v for v in node_inputs[node] if (v not in memo)] DCNL DCSP  DCSP if waiting_on: DCNL DCSP  DCSP  DCSP todo.append(node) DCNL DCSP  DCSP  DCSP todo.extend(waiting_on) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = _args = [memo[v] for v in node.pos_args] DCNL DCSP  DCSP  DCSP kwargs = _kwargs = dict([(k, memo[v]) for (k, v) in node.named_args]) DCNL DCSP  DCSP  DCSP if memo_gc: DCNL DCSP  DCSP  DCSP  DCSP for aa in (args + list(kwargs.values())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (aa is not GarbageCollected) DCNL DCSP  DCSP  DCSP if deepcopy_inputs: DCNL DCSP  DCSP  DCSP  DCSP args = copy.deepcopy(_args) DCNL DCSP  DCSP  DCSP  DCSP kwargs = copy.deepcopy(_kwargs) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rval = scope._impls[node.name](*args, **kwargs) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP if print_node_on_error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print(('=' * 80)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print('ERROR DCSP in DCSP rec_eval') DCNL DCSP  DCSP  DCSP  DCSP  DCSP print('EXCEPTION', type(e), str(e)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print('NODE') DCNL DCSP  DCSP  DCSP  DCSP  DCSP print(node) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print(('=' * 80)) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP if isinstance(rval, Apply): DCNL DCSP  DCSP  DCSP  DCSP foo = rec_eval(rval, deepcopy_inputs, memo, memo_gc=memo_gc) DCNL DCSP  DCSP  DCSP  DCSP set_memo(node, foo) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP set_memo(node, rval) DCNL DCSP return memo[topnode]\n", "intent": "expr - pyll apply instance to be evaluated memo - optional dictionary of values to use for particular nodes deepcopy_inputs - deepcopy inputs to every node prior to calling that nodes function on those inputs .\n", "question_id": 506}, {"snippet": "def test_pdbbreakpoint_op(): DCNL  DCSP b = tensor.fmatrix() DCNL DCSP condition = tensor.gt(b.sum(), 0) DCNL DCSP b_monitored = PdbBreakpoint(name='TestBreakpoint')(condition, b) DCNL DCSP output = (b_monitored ** 2) DCNL DCSP f = theano.function([b], output, mode=mode_with_gpu) DCNL DCSP topo = f.maker.fgraph.toposort() DCNL DCSP assert isinstance(topo[(-2)].op, cuda.GpuElemwise) DCNL DCSP assert (topo[(-1)].op == cuda.host_from_gpu)\n", "intent": "test that pdbbreakpoint ops dont block gpu optimization .\n", "question_id": 507}, {"snippet": "def measure_ref_leakage(f, numsamples=(2 ** 7), iterspersample=(2 ** 4), *args, **kwargs): DCNL  DCSP precondition((numsamples > 0), 'numsamples DCSP is DCSP required DCSP to DCSP be DCSP positive.', numsamples) DCNL DCSP precondition((iterspersample > 0), 'iterspersample DCSP is DCSP required DCSP to DCSP be DCSP positive.', iterspersample) DCNL DCSP try: DCNL DCSP  DCSP sys.gettotalrefcount() DCNL DCSP except AttributeError as le: DCNL DCSP  DCSP raise AttributeError(le, \"Probably DCSP this DCSP is DCSP not DCSP a DCSP debug DCSP build DCSP of DCSP Python, DCSP so DCSP it DCSP doesn't DCSP have DCSP a DCSP sys.gettotalrefcount DCSP function.\") DCNL DCSP resiters = ([None] * numsamples) DCNL DCSP resnumrefs = ([None] * numsamples) DCNL DCSP totaliters = 0 DCNL DCSP for i in range(numsamples): DCNL DCSP  DCSP for j in range(iterspersample): DCNL DCSP  DCSP  DCSP f(*args, **kwargs) DCNL DCSP  DCSP totaliters = (totaliters + iterspersample) DCNL DCSP  DCSP resiters[i] = totaliters DCNL DCSP  DCSP gc.collect() DCNL DCSP  DCSP resnumrefs[i] = sys.gettotalrefcount() DCNL DCSP avex = (float(reduce(operator.__add__, resiters)) / len(resiters)) DCNL DCSP avey = (float(reduce(operator.__add__, resnumrefs)) / len(resnumrefs)) DCNL DCSP sxy = reduce(operator.__add__, map((lambda a, avex=avex, avey=avey: ((a[0] - avex) * (a[1] - avey))), zip(resiters, resnumrefs))) DCNL DCSP sxx = reduce(operator.__add__, map((lambda a, avex=avex: ((a - avex) ** 2)), resiters)) DCNL DCSP return (sxy / sxx)\n", "intent": "the idea is we are going to use sys .\n", "question_id": 508}, {"snippet": "@click.command('restart') DCNL @click.option('--web', is_flag=True, default=False) DCNL def restart(web): DCNL  DCSP from bench.utils import restart_supervisor_processes DCNL DCSP restart_supervisor_processes(bench_path='.', web_workers=web)\n", "intent": "restart supervisor processes .\n", "question_id": 509}, {"snippet": "def preserve_spaces(txt): DCNL  DCSP txt = re.sub('(?P<space>[ DCSP ]{2,})', (lambda mo: (' DCSP ' + ('&nbsp;' * (len(mo.group('space')) - 1)))), txt) DCNL DCSP txt = txt.replace(' DCTB ', '&nbsp;&nbsp;&nbsp;&nbsp;') DCNL DCSP return txt\n", "intent": "replaces spaces multiple spaces with &nbsp; entities .\n", "question_id": 510}, {"snippet": "def escape(pattern): DCNL  DCSP if isinstance(pattern, str): DCNL DCSP  DCSP alphanum = _alphanum_str DCNL DCSP  DCSP s = list(pattern) DCNL DCSP  DCSP for (i, c) in enumerate(pattern): DCNL DCSP  DCSP  DCSP if (c not in alphanum): DCNL DCSP  DCSP  DCSP  DCSP if (c == '\\x00'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s[i] = '\\\\000' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s[i] = ('\\\\' + c) DCNL DCSP  DCSP return ''.join(s) DCNL DCSP else: DCNL DCSP  DCSP alphanum = _alphanum_bytes DCNL DCSP  DCSP s = [] DCNL DCSP  DCSP esc = ord('\\\\') DCNL DCSP  DCSP for c in pattern: DCNL DCSP  DCSP  DCSP if (c in alphanum): DCNL DCSP  DCSP  DCSP  DCSP s.append(c) DCNL DCSP  DCSP  DCSP elif (c == 0): DCNL DCSP  DCSP  DCSP  DCSP s.extend('\\\\000') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s.append(esc) DCNL DCSP  DCSP  DCSP  DCSP s.append(c) DCNL DCSP  DCSP return bytes(s)\n", "intent": "escape all the characters in pattern except ascii letters .\n", "question_id": 511}, {"snippet": "def course_outline_initial_state(locator_to_show, course_structure): DCNL  DCSP def find_xblock_info(xblock_info, locator): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Finds DCSP the DCSP xblock DCSP info DCSP for DCSP the DCSP specified DCSP locator.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (xblock_info['id'] == locator): DCNL DCSP  DCSP  DCSP return xblock_info DCNL DCSP  DCSP children = (xblock_info['child_info']['children'] if xblock_info.get('child_info', None) else None) DCNL DCSP  DCSP if children: DCNL DCSP  DCSP  DCSP for child_xblock_info in children: DCNL DCSP  DCSP  DCSP  DCSP result = find_xblock_info(child_xblock_info, locator) DCNL DCSP  DCSP  DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return None DCNL DCSP def collect_all_locators(locators, xblock_info): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Collect DCSP all DCSP the DCSP locators DCSP for DCSP an DCSP xblock DCSP and DCSP its DCSP children.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP locators.append(xblock_info['id']) DCNL DCSP  DCSP children = (xblock_info['child_info']['children'] if xblock_info.get('child_info', None) else None) DCNL DCSP  DCSP if children: DCNL DCSP  DCSP  DCSP for child_xblock_info in children: DCNL DCSP  DCSP  DCSP  DCSP collect_all_locators(locators, child_xblock_info) DCNL DCSP selected_xblock_info = find_xblock_info(course_structure, locator_to_show) DCNL DCSP if (not selected_xblock_info): DCNL DCSP  DCSP return None DCNL DCSP expanded_locators = [] DCNL DCSP collect_all_locators(expanded_locators, selected_xblock_info) DCNL DCSP return {'locator_to_show': locator_to_show, 'expanded_locators': expanded_locators}\n", "intent": "returns the desired initial state for the course outline view .\n", "question_id": 512}, {"snippet": "def segment(sequence, aliases): DCNL  DCSP if (not (sequence or aliases)): DCNL DCSP  DCSP return DCNL DCSP for (alias, parts) in aliases.items(): DCNL DCSP  DCSP variants = {alias: OrderByTuple(parts), OrderBy(alias).opposite: OrderByTuple(parts).opposite} DCNL DCSP  DCSP for (valias, vparts) in variants.items(): DCNL DCSP  DCSP  DCSP if (list(sequence[:len(vparts)]) == list(vparts)): DCNL DCSP  DCSP  DCSP  DCSP tail_aliases = dict(aliases) DCNL DCSP  DCSP  DCSP  DCSP del tail_aliases[alias] DCNL DCSP  DCSP  DCSP  DCSP tail_sequence = sequence[len(vparts):] DCNL DCSP  DCSP  DCSP  DCSP if tail_sequence: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for tail in segment(tail_sequence, tail_aliases): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield tuple(chain([valias], tail))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield tuple([valias]))\n", "intent": "translates a flat sequence of items into a set of prefixed aliases .\n", "question_id": 513}, {"snippet": "def svm_load_model(model_file_name): DCNL  DCSP model = libsvm.svm_load_model(model_file_name.encode()) DCNL DCSP if (not model): DCNL DCSP  DCSP print (\"can't DCSP open DCSP model DCSP file DCSP %s\" % model_file_name) DCNL DCSP  DCSP return None DCNL DCSP model = toPyModel(model) DCNL DCSP return model\n", "intent": "svm_load_model -> model load a libsvm model from model_file_name and return .\n", "question_id": 514}, {"snippet": "def aggregate_metadata_delete(context, aggregate_id, key): DCNL  DCSP IMPL.aggregate_metadata_delete(context, aggregate_id, key)\n", "intent": "delete the given metadata key .\n", "question_id": 515}, {"snippet": "def _format_value(value): DCNL  DCSP if isinstance(value, string_types): DCNL DCSP  DCSP if (value == ''): DCNL DCSP  DCSP  DCSP return \"''\" DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP exp_val_str = value.replace(\"'\", \"''\") DCNL DCSP  DCSP  DCSP val_str = \"'{:8}'\".format(exp_val_str) DCNL DCSP  DCSP  DCSP return '{:20}'.format(val_str) DCNL DCSP elif isinstance(value, (bool, np.bool_)): DCNL DCSP  DCSP return '{:>20}'.format(repr(value)[0]) DCNL DCSP elif _is_int(value): DCNL DCSP  DCSP return '{:>20d}'.format(value) DCNL DCSP elif isinstance(value, (float, np.floating)): DCNL DCSP  DCSP return '{:>20}'.format(_format_float(value)) DCNL DCSP elif isinstance(value, (complex, np.complexfloating)): DCNL DCSP  DCSP val_str = '({}, DCSP {})'.format(_format_float(value.real), _format_float(value.imag)) DCNL DCSP  DCSP return '{:>20}'.format(val_str) DCNL DCSP elif isinstance(value, Undefined): DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP return ''\n", "intent": "converts a card value to its appropriate string representation as defined by the fits format .\n", "question_id": 516}, {"snippet": "def avoid_wrapping(value): DCNL  DCSP return value.replace(' DCSP ', '\\xa0')\n", "intent": "avoid text wrapping in the middle of a phrase by adding non-breaking spaces where there previously were normal spaces .\n", "question_id": 517}, {"snippet": "def getArcComplexes(begin, end, largeArcFlag, radius, sweepFlag, xAxisRotation): DCNL  DCSP if (begin == end): DCNL DCSP  DCSP print 'Warning, DCSP begin DCSP equals DCSP end DCSP in DCSP getArcComplexes DCSP in DCSP svgReader' DCNL DCSP  DCSP print begin DCNL DCSP  DCSP print end DCNL DCSP  DCSP return [] DCNL DCSP if (radius.imag < 0.0): DCNL DCSP  DCSP print 'Warning, DCSP radius.imag DCSP is DCSP less DCSP than DCSP zero DCSP in DCSP getArcComplexes DCSP in DCSP svgReader' DCNL DCSP  DCSP print radius DCNL DCSP  DCSP radius = complex(radius.real, abs(radius.imag)) DCNL DCSP if (radius.real < 0.0): DCNL DCSP  DCSP print 'Warning, DCSP radius.real DCSP is DCSP less DCSP than DCSP zero DCSP in DCSP getArcComplexes DCSP in DCSP svgReader' DCNL DCSP  DCSP print radius DCNL DCSP  DCSP radius = complex(abs(radius.real), radius.imag) DCNL DCSP if (radius.imag <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP radius.imag DCSP is DCSP too DCSP small DCSP for DCSP getArcComplexes DCSP in DCSP svgReader' DCNL DCSP  DCSP print radius DCNL DCSP  DCSP return [end] DCNL DCSP if (radius.real <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP radius.real DCSP is DCSP too DCSP small DCSP for DCSP getArcComplexes DCSP in DCSP svgReader' DCNL DCSP  DCSP print radius DCNL DCSP  DCSP return [end] DCNL DCSP xAxisRotationComplex = euclidean.getWiddershinsUnitPolar(xAxisRotation) DCNL DCSP reverseXAxisRotationComplex = complex(xAxisRotationComplex.real, (- xAxisRotationComplex.imag)) DCNL DCSP beginRotated = (begin * reverseXAxisRotationComplex) DCNL DCSP endRotated = (end * reverseXAxisRotationComplex) DCNL DCSP beginTransformed = complex((beginRotated.real / radius.real), (beginRotated.imag / radius.imag)) DCNL DCSP endTransformed = complex((endRotated.real / radius.real), (endRotated.imag / radius.imag)) DCNL DCSP midpointTransformed = (0.5 * (beginTransformed + endTransformed)) DCNL DCSP midMinusBeginTransformed = (midpointTransformed - beginTransformed) DCNL DCSP midMinusBeginTransformedLength = abs(midMinusBeginTransformed) DCNL DCSP if (midMinusBeginTransformedLength > 1.0): DCNL DCSP  DCSP print 'The DCSP ellipse DCSP radius DCSP is DCSP too DCSP small DCSP for DCSP getArcComplexes DCSP in DCSP svgReader.' DCNL DCSP  DCSP print 'So DCSP the DCSP ellipse DCSP will DCSP be DCSP scaled DCSP to DCSP fit, DCSP according DCSP to DCSP the DCSP formulas DCSP in DCSP \"Step DCSP 3: DCSP Ensure DCSP radii DCSP are DCSP large DCSP enough\" DCSP of:' DCNL DCSP  DCSP print 'http://www.w3.org/TR/SVG/implnote.html#ArcCorrectionOutOfRangeRadii' DCNL DCSP  DCSP print '' DCNL DCSP  DCSP radius *= midMinusBeginTransformedLength DCNL DCSP  DCSP beginTransformed /= midMinusBeginTransformedLength DCNL DCSP  DCSP endTransformed /= midMinusBeginTransformedLength DCNL DCSP  DCSP midpointTransformed /= midMinusBeginTransformedLength DCNL DCSP  DCSP midMinusBeginTransformed /= midMinusBeginTransformedLength DCNL DCSP  DCSP midMinusBeginTransformedLength = 1.0 DCNL DCSP midWiddershinsTransformed = complex((- midMinusBeginTransformed.imag), midMinusBeginTransformed.real) DCNL DCSP midWiddershinsLengthSquared = (1.0 - (midMinusBeginTransformedLength * midMinusBeginTransformedLength)) DCNL DCSP if (midWiddershinsLengthSquared < 0.0): DCNL DCSP  DCSP midWiddershinsLengthSquared = 0.0 DCNL DCSP midWiddershinsLength = math.sqrt(midWiddershinsLengthSquared) DCNL DCSP midWiddershinsTransformed *= (midWiddershinsLength / abs(midWiddershinsTransformed)) DCNL DCSP centerTransformed = midpointTransformed DCNL DCSP if (largeArcFlag == sweepFlag): DCNL DCSP  DCSP centerTransformed -= midWiddershinsTransformed DCNL DCSP else: DCNL DCSP  DCSP centerTransformed += midWiddershinsTransformed DCNL DCSP beginMinusCenterTransformed = (beginTransformed - centerTransformed) DCNL DCSP beginMinusCenterTransformedLength = abs(beginMinusCenterTransformed) DCNL DCSP if (beginMinusCenterTransformedLength <= 0.0): DCNL DCSP  DCSP return end DCNL DCSP beginAngle = math.atan2(beginMinusCenterTransformed.imag, beginMinusCenterTransformed.real) DCNL DCSP endMinusCenterTransformed = (endTransformed - centerTransformed) DCNL DCSP angleDifference = euclidean.getAngleDifferenceByComplex(endMinusCenterTransformed, beginMinusCenterTransformed) DCNL DCSP if sweepFlag: DCNL DCSP  DCSP if (angleDifference < 0.0): DCNL DCSP  DCSP  DCSP angleDifference += (2.0 * math.pi) DCNL DCSP elif (angleDifference > 0.0): DCNL DCSP  DCSP angleDifference -= (2.0 * math.pi) DCNL DCSP global globalSideAngle DCNL DCSP sides = int(math.ceil((abs(angleDifference) / globalSideAngle))) DCNL DCSP sideAngle = (angleDifference / float(sides)) DCNL DCSP arcComplexes = [] DCNL DCSP center = (complex((centerTransformed.real * radius.real), (centerTransformed.imag * radius.imag)) * xAxisRotationComplex) DCNL DCSP for side in xrange(1, sides): DCNL DCSP  DCSP unitPolar = euclidean.getWiddershinsUnitPolar((beginAngle + (float(side) * sideAngle))) DCNL DCSP  DCSP circumferential = (complex((unitPolar.real * radius.real), (unitPolar.imag * radius.imag)) * beginMinusCenterTransformedLength) DCNL DCSP  DCSP point = (center + (circumferential * xAxisRotationComplex)) DCNL DCSP  DCSP arcComplexes.append(point) DCNL DCSP arcComplexes.append(end) DCNL DCSP return arcComplexes\n", "intent": "get the arc complexes .\n", "question_id": 518}, {"snippet": "def gemset_list(ruby='default', runas=None): DCNL  DCSP gemsets = [] DCNL DCSP output = _rvm_do(ruby, ['rvm', 'gemset', 'list'], runas=runas) DCNL DCSP if output: DCNL DCSP  DCSP regex = re.compile('^ DCSP  DCSP  DCSP ([^ DCSP ]+)') DCNL DCSP  DCSP for line in output.splitlines(): DCNL DCSP  DCSP  DCSP match = regex.match(line) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP gemsets.append(match.group(1)) DCNL DCSP return gemsets\n", "intent": "list all gemsets for the given ruby .\n", "question_id": 519}, {"snippet": "def claim_interface(device, interface): DCNL  DCSP device._ctx.managed_claim_interface(device, interface)\n", "intent": "explicitly claim an interface .\n", "question_id": 520}, {"snippet": "def base_concrete_model(abstract, model): DCNL  DCSP if hasattr(model, u'objects'): DCNL DCSP  DCSP return (model if model._meta.abstract else _base_concrete_model(abstract, model)) DCNL DCSP return (_base_concrete_model(abstract, model.__class__) or model.__class__)\n", "intent": "used in methods of abstract models to find the super-most concrete  model in the inheritance chain that inherits from the given abstract model .\n", "question_id": 521}, {"snippet": "def parse_query_string(query_string, keep_blank_values=True, encoding='utf-8'): DCNL  DCSP if image_map_pattern.match(query_string): DCNL DCSP  DCSP pm = query_string.split(',') DCNL DCSP  DCSP pm = {'x': int(pm[0]), 'y': int(pm[1])} DCNL DCSP else: DCNL DCSP  DCSP pm = _parse_qs(query_string, keep_blank_values, encoding=encoding) DCNL DCSP return pm\n", "intent": "build a params dictionary from a query_string .\n", "question_id": 522}, {"snippet": "def _generate_items_for_subtask(item_querysets, item_fields, total_num_items, items_per_task, total_num_subtasks, course_id): DCNL  DCSP num_items_queued = 0 DCNL DCSP all_item_fields = list(item_fields) DCNL DCSP all_item_fields.append('pk') DCNL DCSP num_subtasks = 0 DCNL DCSP items_for_task = [] DCNL DCSP with track_memory_usage('course_email.subtask_generation.memory', course_id): DCNL DCSP  DCSP for queryset in item_querysets: DCNL DCSP  DCSP  DCSP for item in queryset.values(*all_item_fields).iterator(): DCNL DCSP  DCSP  DCSP  DCSP if ((len(items_for_task) == items_per_task) and (num_subtasks < (total_num_subtasks - 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield items_for_task) DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_items_queued += items_per_task DCNL DCSP  DCSP  DCSP  DCSP  DCSP items_for_task = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_subtasks += 1 DCNL DCSP  DCSP  DCSP  DCSP items_for_task.append(item) DCNL DCSP  DCSP if items_for_task: DCNL DCSP  DCSP  DCSP (yield items_for_task) DCNL DCSP  DCSP  DCSP num_items_queued += len(items_for_task) DCNL DCSP if (num_items_queued != total_num_items): DCNL DCSP  DCSP TASK_LOG.info('Number DCSP of DCSP items DCSP generated DCSP by DCSP chunking DCSP %s DCSP not DCSP equal DCSP to DCSP original DCSP total DCSP %s', num_items_queued, total_num_items)\n", "intent": "generates a chunk of \"items\" that should be passed into a subtask .\n", "question_id": 523}, {"snippet": "def addClosedXMLTag(attributeDictionary, className, depth, output, text=''): DCNL  DCSP depthStart = (' DCTB ' * depth) DCNL DCSP attributeDictionaryString = getAttributeDictionaryString(attributeDictionary) DCNL DCSP if (len(text) > 0): DCNL DCSP  DCSP output.write(('%s<%s%s DCSP >%s</%s>\\n' % (depthStart, className, attributeDictionaryString, text, className))) DCNL DCSP else: DCNL DCSP  DCSP output.write(('%s<%s%s DCSP />\\n' % (depthStart, className, attributeDictionaryString)))\n", "intent": "add the closed xml tag .\n", "question_id": 524}, {"snippet": "def handle_default_options(options): DCNL  DCSP if options.settings: DCNL DCSP  DCSP os.environ[u'DJANGO_SETTINGS_MODULE'] = options.settings DCNL DCSP if options.pythonpath: DCNL DCSP  DCSP sys.path.insert(0, options.pythonpath)\n", "intent": "include any default options that all commands should accept here so that managementutility can handle them before searching for user commands .\n", "question_id": 525}, {"snippet": "def _size_map(size): DCNL  DCSP try: DCNL DCSP  DCSP if (not isinstance(size, int)): DCNL DCSP  DCSP  DCSP if re.search('[Kk]', size): DCNL DCSP  DCSP  DCSP  DCSP size = (1024 * float(re.sub('[Kk]', '', size))) DCNL DCSP  DCSP  DCSP elif re.search('[Mm]', size): DCNL DCSP  DCSP  DCSP  DCSP size = ((1024 ** 2) * float(re.sub('[Mm]', '', size))) DCNL DCSP  DCSP  DCSP size = int(size) DCNL DCSP  DCSP return size DCNL DCSP except: DCNL DCSP  DCSP return None\n", "intent": "map bcaches size strings to real bytes .\n", "question_id": 526}, {"snippet": "def _compute_targets(rois, overlaps, labels): DCNL  DCSP gt_inds = np.where((overlaps == 1))[0] DCNL DCSP if (len(gt_inds) == 0): DCNL DCSP  DCSP return np.zeros((rois.shape[0], 5), dtype=np.float32) DCNL DCSP ex_inds = np.where((overlaps >= cfg.TRAIN.BBOX_THRESH))[0] DCNL DCSP ex_gt_overlaps = bbox_overlaps(np.ascontiguousarray(rois[ex_inds, :], dtype=np.float), np.ascontiguousarray(rois[gt_inds, :], dtype=np.float)) DCNL DCSP gt_assignment = ex_gt_overlaps.argmax(axis=1) DCNL DCSP gt_rois = rois[gt_inds[gt_assignment], :] DCNL DCSP ex_rois = rois[ex_inds, :] DCNL DCSP targets = np.zeros((rois.shape[0], 5), dtype=np.float32) DCNL DCSP targets[(ex_inds, 0)] = labels[ex_inds] DCNL DCSP targets[ex_inds, 1:] = bbox_transform(ex_rois, gt_rois) DCNL DCSP return targets\n", "intent": "compute bounding-box regression targets for an image .\n", "question_id": 527}, {"snippet": "def create_warning(path, error_message, skip_file=True): DCNL  DCSP print_string = 'warning: DCSP ' DCNL DCSP if skip_file: DCNL DCSP  DCSP print_string = (((print_string + 'Skipping DCSP file DCSP ') + path) + '. DCSP ') DCNL DCSP print_string = (print_string + error_message) DCNL DCSP warning_message = WarningResult(message=print_string, error=False, warning=True) DCNL DCSP return warning_message\n", "intent": "this creates a printtask for whenever a warning is to be thrown .\n", "question_id": 528}, {"snippet": "def bad_title(title): DCNL  DCSP for pat in BAD_TITLE_PATTERNS: DCNL DCSP  DCSP if re.match(pat, title, re.IGNORECASE): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "determine whether a given title is \"bad\"  and in need of replacement .\n", "question_id": 529}, {"snippet": "@contextmanager DCNL def nested(*managers): DCNL  DCSP exits = [] DCNL DCSP vars = [] DCNL DCSP exc = (None, None, None) DCNL DCSP try: DCNL DCSP  DCSP for mgr in managers: DCNL DCSP  DCSP  DCSP exit = mgr.__exit__ DCNL DCSP  DCSP  DCSP enter = mgr.__enter__ DCNL DCSP  DCSP  DCSP vars.append(enter()) DCNL DCSP  DCSP  DCSP exits.append(exit) DCNL DCSP  DCSP (yield vars) DCNL DCSP except: DCNL DCSP  DCSP exc = sys.exc_info() DCNL DCSP finally: DCNL DCSP  DCSP while exits: DCNL DCSP  DCSP  DCSP exit = exits.pop() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if exit(*exc): DCNL DCSP  DCSP  DCSP  DCSP  DCSP exc = (None, None, None) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP exc = sys.exc_info() DCNL DCSP  DCSP if (exc != (None, None, None)): DCNL DCSP  DCSP  DCSP raise exc[0], exc[1], exc[2]\n", "intent": "support multiple context managers in a single with-statement .\n", "question_id": 530}, {"snippet": "def comment_parse(comment, comments, post_id=None): DCNL  DCSP author = B(T('Anonymous')) DCNL DCSP if comment.created_by: DCNL DCSP  DCSP utable = s3db.auth_user DCNL DCSP  DCSP ptable = s3db.pr_person DCNL DCSP  DCSP ltable = s3db.pr_person_user DCNL DCSP  DCSP query = (utable.id == comment.created_by) DCNL DCSP  DCSP left = [ltable.on((ltable.user_id == utable.id)), ptable.on((ptable.pe_id == ltable.pe_id))] DCNL DCSP  DCSP row = db(query).select(utable.email, ptable.first_name, ptable.middle_name, ptable.last_name, left=left, limitby=(0, 1)).first() DCNL DCSP  DCSP if row: DCNL DCSP  DCSP  DCSP person = row.pr_person DCNL DCSP  DCSP  DCSP user = row[utable._tablename] DCNL DCSP  DCSP  DCSP username = s3_fullname(person) DCNL DCSP  DCSP  DCSP email = user.email.strip().lower() DCNL DCSP  DCSP  DCSP import hashlib DCNL DCSP  DCSP  DCSP hash = hashlib.md5(email).hexdigest() DCNL DCSP  DCSP  DCSP url = ('http://www.gravatar.com/%s' % hash) DCNL DCSP  DCSP  DCSP author = B(A(username, _href=url, _target='top')) DCNL DCSP if ((not post_id) and comment.post_id): DCNL DCSP  DCSP post = ('re: DCSP %s' % s3db.cms_post[comment.post_id].name) DCNL DCSP  DCSP header = DIV(author, ' DCSP ', post) DCNL DCSP  DCSP post_id = comment.post_id DCNL DCSP else: DCNL DCSP  DCSP header = author DCNL DCSP thread = LI(DIV(s3base.s3_avatar_represent(comment.created_by), DIV(DIV(header, _class='comment-header'), DIV(XML(comment.body)), _class='comment-text'), DIV(DIV(comment.created_on, _class='comment-date'), DIV(A(T('Reply'), _class='action-btn'), _onclick=('comment_reply(%i);' % comment.id), _class='comment-reply'), _class='fright'), _id=('comment-%i' % comment.id), _post_id=post_id, _class='comment-box')) DCNL DCSP children = UL(_class='children') DCNL DCSP id = comment.id DCNL DCSP count = 0 DCNL DCSP for comment in comments: DCNL DCSP  DCSP if (comment.parent == id): DCNL DCSP  DCSP  DCSP count = 1 DCNL DCSP  DCSP  DCSP child = comment_parse(comment, comments, post_id=post_id) DCNL DCSP  DCSP  DCSP children.append(child) DCNL DCSP if (count == 1): DCNL DCSP  DCSP thread.append(children) DCNL DCSP return thread\n", "intent": "parse a comment .\n", "question_id": 531}, {"snippet": "def test_ordered_dict_key_validator(): DCNL  DCSP schema = vol.Schema(cv.ordered_dict(cv.match_all, cv.string)) DCNL DCSP with pytest.raises(vol.Invalid): DCNL DCSP  DCSP schema({None: 1}) DCNL DCSP schema({'hello': 'world'}) DCNL DCSP schema = vol.Schema(cv.ordered_dict(cv.match_all, int)) DCNL DCSP with pytest.raises(vol.Invalid): DCNL DCSP  DCSP schema({'hello': 1}) DCNL DCSP schema({1: 'works'})\n", "intent": "test ordered_dict key validator .\n", "question_id": 532}, {"snippet": "def PrintResource(resource): DCNL  DCSP print resource.resource_id.text, resource.GetResourceType()\n", "intent": "display a resource to standard out .\n", "question_id": 533}, {"snippet": "def format_error(error_code, message): DCNL  DCSP return {'errors': [{'code': error_code, 'message': message}]}\n", "intent": "converts an error_code and message into a response body .\n", "question_id": 534}, {"snippet": "def GetELBZones(region, node_types=None): DCNL  DCSP balancers = GetLoadBalancers(region, node_types=node_types) DCNL DCSP res = [] DCNL DCSP for b in balancers: DCNL DCSP  DCSP res.extend(b.availability_zones) DCNL DCSP return res\n", "intent": "return a list of availability zone names covered by the load balancers in a given region .\n", "question_id": 535}, {"snippet": "@contextmanager DCNL def _check_require_version(namespace, stacklevel): DCNL  DCSP repository = GIRepository() DCNL DCSP was_loaded = repository.is_registered(namespace) DCNL DCSP (yield) DCNL DCSP if was_loaded: DCNL DCSP  DCSP return DCNL DCSP if (namespace in ('GLib', 'GObject', 'Gio')): DCNL DCSP  DCSP return DCNL DCSP if (get_required_version(namespace) is not None): DCNL DCSP  DCSP return DCNL DCSP version = repository.get_version(namespace) DCNL DCSP warnings.warn((\"%(namespace)s DCSP was DCSP imported DCSP without DCSP specifying DCSP a DCSP version DCSP first. DCSP Use DCSP gi.require_version('%(namespace)s', DCSP '%(version)s') DCSP before DCSP import DCSP to DCSP ensure DCSP that DCSP the DCSP right DCSP version DCSP gets DCSP loaded.\" % {'namespace': namespace, 'version': version}), PyGIWarning, stacklevel=stacklevel)\n", "intent": "a context manager which tries to give helpful warnings about missing gi .\n", "question_id": 536}, {"snippet": "@util.positional(4) DCNL def credentials_from_code(client_id, client_secret, scope, code, redirect_uri='postmessage', http=None, user_agent=None, token_uri=GOOGLE_TOKEN_URI, auth_uri=GOOGLE_AUTH_URI, revoke_uri=GOOGLE_REVOKE_URI, device_uri=GOOGLE_DEVICE_URI): DCNL  DCSP flow = OAuth2WebServerFlow(client_id, client_secret, scope, redirect_uri=redirect_uri, user_agent=user_agent, auth_uri=auth_uri, token_uri=token_uri, revoke_uri=revoke_uri, device_uri=device_uri) DCNL DCSP credentials = flow.step2_exchange(code, http=http) DCNL DCSP return credentials\n", "intent": "exchanges an authorization code for an oauth2credentials object .\n", "question_id": 537}, {"snippet": "def apply_rollback(datastore, name): DCNL  DCSP return _get_client().apply_rollback(datastore, name)\n", "intent": "apply a system rollback .\n", "question_id": 538}, {"snippet": "def get_random_id(): DCNL  DCSP id = '' DCNL DCSP for n in range(6): DCNL DCSP  DCSP letter = random.choice(letter_choices) DCNL DCSP  DCSP id += letter DCNL DCSP return id\n", "intent": "generate a random id number .\n", "question_id": 539}, {"snippet": "def iso(G1, glist): DCNL  DCSP for G2 in glist: DCNL DCSP  DCSP if isomorphic(G1, G2): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "quick and dirty nonisomorphism checker used to check isomorphisms .\n", "question_id": 540}, {"snippet": "def handle_shared_float32(tf): DCNL  DCSP if tf: DCNL DCSP  DCSP theano.compile.shared_constructor(float32_shared_constructor) DCNL DCSP else: DCNL DCSP  DCSP theano.compile.shared_constructor(float32_shared_constructor, True) DCNL DCSP  DCSP assert (float32_shared_constructor not in theano.compile.shared.constructors)\n", "intent": "set the default shared type for float32 tensor to cudandarraytype .\n", "question_id": 541}, {"snippet": "def parse_tag_namespaces(tag_list): DCNL  DCSP namespaces = {} DCNL DCSP for tag in tag_list: DCNL DCSP  DCSP ns = (((':' in tag) and ('%s:' % tag.rsplit(':', 1)[0])) or '') DCNL DCSP  DCSP if (ns not in namespaces): DCNL DCSP  DCSP  DCSP namespaces[ns] = [] DCNL DCSP  DCSP namespaces[ns].append(tag) DCNL DCSP return namespaces\n", "intent": "parse a list of tags out into a dict of lists by namespace .\n", "question_id": 542}, {"snippet": "@status('Misc/ACKS DCSP updated', modal=True) DCNL def credit_given(file_paths): DCNL  DCSP return ('Misc/ACKS' in file_paths)\n", "intent": "check if misc/acks has been changed .\n", "question_id": 543}, {"snippet": "def main(): DCNL  DCSP password = getpass() DCNL DCSP for a_dict in (pynet1, pynet2, juniper_srx): DCNL DCSP  DCSP a_dict['password'] = password DCNL DCSP  DCSP a_dict['verbose'] = False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP a_dict['port'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP a_dict['port'] = 22 DCNL DCSP mp_queue = multiprocessing.Queue() DCNL DCSP processes = [] DCNL DCSP print ('\\nStart DCSP time: DCSP ' + str(datetime.now())) DCNL DCSP for a_device in (pynet1, pynet2, juniper_srx): DCNL DCSP  DCSP p = multiprocessing.Process(target=worker_cmd, args=(a_device, mp_queue)) DCNL DCSP  DCSP processes.append(p) DCNL DCSP  DCSP p.start() DCNL DCSP for p in processes: DCNL DCSP  DCSP p.join() DCNL DCSP results = [] DCNL DCSP for p in processes: DCNL DCSP  DCSP results.append(mp_queue.get()) DCNL DCSP print_output(results)\n", "intent": "use netmiko to execute show arp on pynet-rtr1 .\n", "question_id": 544}, {"snippet": "def _get_chain_list(cursor, varname): DCNL  DCSP cursor.execute('SELECT DCSP DISTINCT DCSP chain DCSP FROM DCSP [{}]'.format(varname)) DCNL DCSP chains = [chain[0] for chain in cursor.fetchall()] DCNL DCSP chains.sort() DCNL DCSP return chains\n", "intent": "return a list of sorted chains for varname .\n", "question_id": 545}, {"snippet": "def _interpolate_multivariate(evalpoints, hpeval, ring, i, p, ground=False): DCNL  DCSP hp = ring.zero DCNL DCSP if ground: DCNL DCSP  DCSP domain = ring.domain.domain DCNL DCSP  DCSP y = ring.domain.gens[i] DCNL DCSP else: DCNL DCSP  DCSP domain = ring.domain DCNL DCSP  DCSP y = ring.gens[i] DCNL DCSP for (a, hpa) in zip(evalpoints, hpeval): DCNL DCSP  DCSP numer = ring.one DCNL DCSP  DCSP denom = domain.one DCNL DCSP  DCSP for b in evalpoints: DCNL DCSP  DCSP  DCSP if (b == a): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP numer *= (y - b) DCNL DCSP  DCSP  DCSP denom *= (a - b) DCNL DCSP  DCSP denom = domain.invert(denom, p) DCNL DCSP  DCSP coeff = numer.mul_ground(denom) DCNL DCSP  DCSP hp += (hpa.set_ring(ring) * coeff) DCNL DCSP return hp.trunc_ground(p)\n", "intent": "reconstruct a polynomial h_p in mathbb{z}_p[x_0 .\n", "question_id": 546}, {"snippet": "def calinski_harabaz_score(X, labels): DCNL  DCSP (X, labels) = check_X_y(X, labels) DCNL DCSP le = LabelEncoder() DCNL DCSP labels = le.fit_transform(labels) DCNL DCSP (n_samples, _) = X.shape DCNL DCSP n_labels = len(le.classes_) DCNL DCSP check_number_of_labels(n_labels, n_samples) DCNL DCSP (extra_disp, intra_disp) = (0.0, 0.0) DCNL DCSP mean = np.mean(X, axis=0) DCNL DCSP for k in range(n_labels): DCNL DCSP  DCSP cluster_k = X[(labels == k)] DCNL DCSP  DCSP mean_k = np.mean(cluster_k, axis=0) DCNL DCSP  DCSP extra_disp += (len(cluster_k) * np.sum(((mean_k - mean) ** 2))) DCNL DCSP  DCSP intra_disp += np.sum(((cluster_k - mean_k) ** 2)) DCNL DCSP return (1.0 if (intra_disp == 0.0) else ((extra_disp * (n_samples - n_labels)) / (intra_disp * (n_labels - 1.0))))\n", "intent": "compute the calinski and harabaz score .\n", "question_id": 547}, {"snippet": "@memoize DCNL def python_like_mod_finder(import_line, alt_path=None, stop_token=None): DCNL  DCSP if (stop_token and ('.' in stop_token)): DCNL DCSP  DCSP stop_token = stop_token.split('.')[(-1)] DCNL DCSP tokens = re.split('\\\\W', import_line) DCNL DCSP if (tokens[0] in ['from', 'import']): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (_, path, _) = imp.find_module(tokens[1]) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP if alt_path: DCNL DCSP  DCSP  DCSP  DCSP path = osp.join(alt_path, tokens[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP path = None DCNL DCSP  DCSP if path: DCNL DCSP  DCSP  DCSP path = osp.realpath(path) DCNL DCSP  DCSP  DCSP if (not (tokens[1] == stop_token)): DCNL DCSP  DCSP  DCSP  DCSP for part in tokens[2:]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (part in ['import', 'cimport', 'as']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP path = osp.join(path, part) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (part == stop_token): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (stop_token and (not (stop_token in path))): DCNL DCSP  DCSP  DCSP  DCSP for ext in python_like_exts(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fname = ('%s%s' % (stop_token, ext)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if osp.exists(osp.join(path, fname)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return osp.join(path, fname) DCNL DCSP  DCSP  DCSP for ext in python_like_exts(): DCNL DCSP  DCSP  DCSP  DCSP fname = ('%s%s' % (path, ext)) DCNL DCSP  DCSP  DCSP  DCSP if osp.exists(fname): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return fname DCNL DCSP  DCSP  DCSP if (osp.exists(path) and (not osp.isdir(path))): DCNL DCSP  DCSP  DCSP  DCSP return path DCNL DCSP  DCSP  DCSP path = osp.join(path, '__init__.py') DCNL DCSP  DCSP  DCSP if osp.exists(path): DCNL DCSP  DCSP  DCSP  DCSP return path\n", "intent": "locate a module path based on an import line in an python-like file import_line is the line of source code containing the import alt_path specifies an alternate base path for the module stop_token specifies the desired name to stop on this is used to a find the path to python-like modules  for a goto definition .\n", "question_id": 548}, {"snippet": "def request_user_is_system_admin(request): DCNL  DCSP user_db = get_user_db_from_request(request=request) DCNL DCSP return user_is_system_admin(user_db=user_db)\n", "intent": "check if the logged-in request user has system admin role .\n", "question_id": 549}, {"snippet": "def strategy_smallest_last(G, colors): DCNL  DCSP H = G.copy(with_data=False) DCNL DCSP result = deque() DCNL DCSP degrees = defaultdict(set) DCNL DCSP lbound = float('inf') DCNL DCSP for (node, d) in H.degree(): DCNL DCSP  DCSP degrees[d].add(node) DCNL DCSP  DCSP lbound = min(lbound, d) DCNL DCSP def find_min_degree(): DCNL DCSP  DCSP return next((d for d in itertools.count(lbound) if (d in degrees))) DCNL DCSP for _ in G: DCNL DCSP  DCSP min_degree = find_min_degree() DCNL DCSP  DCSP u = degrees[min_degree].pop() DCNL DCSP  DCSP if (not degrees[min_degree]): DCNL DCSP  DCSP  DCSP del degrees[min_degree] DCNL DCSP  DCSP result.appendleft(u) DCNL DCSP  DCSP for v in H[u]: DCNL DCSP  DCSP  DCSP degree = H.degree(v) DCNL DCSP  DCSP  DCSP degrees[degree].remove(v) DCNL DCSP  DCSP  DCSP if (not degrees[degree]): DCNL DCSP  DCSP  DCSP  DCSP del degrees[degree] DCNL DCSP  DCSP  DCSP degrees[(degree - 1)].add(v) DCNL DCSP  DCSP H.remove_node(u) DCNL DCSP  DCSP lbound = (min_degree - 1) DCNL DCSP return result\n", "intent": "returns a deque of the nodes of g .\n", "question_id": 550}, {"snippet": "def _prepare_archive_at_path(filename): DCNL  DCSP try: DCNL DCSP  DCSP with ZipFile(filename, 'r') as archive: DCNL DCSP  DCSP  DCSP archive.close() DCNL DCSP except BadZipfile: DCNL DCSP  DCSP return None DCNL DCSP if _is_overwritten(filename): DCNL DCSP  DCSP log.debug('ZIP DCSP file DCSP contains DCSP a DCSP file DCSP with DCSP the DCSP same DCSP name, DCSP original DCSP is DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP going DCSP to DCSP be DCSP overwrite') DCNL DCSP  DCSP new_zip_path = (filename + _random_extension()) DCNL DCSP  DCSP move(filename, new_zip_path) DCNL DCSP  DCSP filename = new_zip_path DCNL DCSP return filename\n", "intent": "verifies that theres a readable zip archive at the given path .\n", "question_id": 551}, {"snippet": "def _normalize_locations(context, image, force_show_deleted=False): DCNL  DCSP if ((image['status'] == 'deactivated') and (not context.is_admin)): DCNL DCSP  DCSP image['locations'] = [] DCNL DCSP  DCSP return image DCNL DCSP if force_show_deleted: DCNL DCSP  DCSP locations = image['locations'] DCNL DCSP else: DCNL DCSP  DCSP locations = [x for x in image['locations'] if (not x['deleted'])] DCNL DCSP image['locations'] = [{'id': loc['id'], 'url': loc['url'], 'metadata': loc['metadata'], 'status': loc['status']} for loc in locations] DCNL DCSP return image\n", "intent": "generate suitable dictionary list for locations field of image .\n", "question_id": 552}, {"snippet": "def open(filename, flag='c', protocol=None, writeback=False): DCNL  DCSP return DbfilenameShelf(filename, flag, protocol, writeback)\n", "intent": "open a persistent dictionary for reading and writing .\n", "question_id": 553}, {"snippet": "def make_lag_names(names, lag_order, trendorder=1): DCNL  DCSP lag_names = [] DCNL DCSP if isinstance(names, string_types): DCNL DCSP  DCSP names = [names] DCNL DCSP for i in range(1, (lag_order + 1)): DCNL DCSP  DCSP for name in names: DCNL DCSP  DCSP  DCSP if (not isinstance(name, string_types)): DCNL DCSP  DCSP  DCSP  DCSP name = str(name) DCNL DCSP  DCSP  DCSP lag_names.append(((('L' + str(i)) + '.') + name)) DCNL DCSP if (trendorder != 0): DCNL DCSP  DCSP lag_names.insert(0, 'const') DCNL DCSP if (trendorder > 1): DCNL DCSP  DCSP lag_names.insert(0, 'trend') DCNL DCSP if (trendorder > 2): DCNL DCSP  DCSP lag_names.insert(0, 'trend**2') DCNL DCSP return lag_names\n", "intent": "produce list of lag-variable names .\n", "question_id": 554}, {"snippet": "def exec2(ctid_or_name, command): DCNL  DCSP return run_as_root((\"vzctl DCSP exec2 DCSP %s DCSP '%s'\" % (ctid_or_name, command)))\n", "intent": "run a command inside the container .\n", "question_id": 555}, {"snippet": "def generate_mac_address(): DCNL  DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))\n", "intent": "generate an ethernet mac address .\n", "question_id": 556}, {"snippet": "def all_languages(): DCNL  DCSP languages = [(lang[0], _(lang[1])) for lang in settings.ALL_LANGUAGES] DCNL DCSP return sorted(languages, key=(lambda lang: lang[1]))\n", "intent": "retrieve the list of all languages .\n", "question_id": 557}, {"snippet": "def test_ast_bad_yield(): DCNL  DCSP cant_compile(u'(yield DCSP 1 DCSP 2)')\n", "intent": "make sure ast cant compile invalid yield .\n", "question_id": 558}, {"snippet": "@utils.no_4byte_params DCNL def metadef_object_update(context, namespace_name, object_id, object_dict, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP return metadef_object_api.update(context, namespace_name, object_id, object_dict, session)\n", "intent": "update an object or raise if it does not exist or not visible .\n", "question_id": 559}, {"snippet": "def _init_setting_completions(): DCNL  DCSP log.completion.debug('Initializing DCSP setting DCSP completion.') DCNL DCSP _instances[usertypes.Completion.section] = configmodel.SettingSectionCompletionModel() DCNL DCSP _instances[usertypes.Completion.option] = {} DCNL DCSP _instances[usertypes.Completion.value] = {} DCNL DCSP for sectname in configdata.DATA: DCNL DCSP  DCSP opt_model = configmodel.SettingOptionCompletionModel(sectname) DCNL DCSP  DCSP _instances[usertypes.Completion.option][sectname] = opt_model DCNL DCSP  DCSP _instances[usertypes.Completion.value][sectname] = {} DCNL DCSP  DCSP for opt in configdata.DATA[sectname]: DCNL DCSP  DCSP  DCSP val_model = configmodel.SettingValueCompletionModel(sectname, opt) DCNL DCSP  DCSP  DCSP _instances[usertypes.Completion.value][sectname][opt] = val_model\n", "intent": "initialize setting completion models .\n", "question_id": 560}, {"snippet": "def metadef_resource_type_delete(context, resource_type_name, session=None): DCNL  DCSP session = (session or get_session()) DCNL DCSP return metadef_resource_type_api.delete(context, resource_type_name, session)\n", "intent": "get a resource_type .\n", "question_id": 561}, {"snippet": "@pytest.mark.django_db DCNL def test_image_plugin_choice_widget_get_object(): DCNL  DCSP image = File.objects.create() DCNL DCSP widget = ImagePluginChoiceWidget() DCNL DCSP assert (widget.get_object(image.pk) == image) DCNL DCSP assert (widget.get_object(1000) == None)\n", "intent": "test get_object method for imagepluginchoicewidget .\n", "question_id": 562}, {"snippet": "def bench_R2(): DCNL  DCSP def hermite(n, y): DCNL DCSP  DCSP if (n == 1): DCNL DCSP  DCSP  DCSP return (2 * y) DCNL DCSP  DCSP if (n == 0): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP return (((2 * y) * hermite((n - 1), y)) - ((2 * (n - 1)) * hermite((n - 2), y))).expand() DCNL DCSP a = hermite(15, y)\n", "intent": "hermite polynomial hermite .\n", "question_id": 563}, {"snippet": "def tenant_get(tenant_id=None, name=None, profile=None, **connection_args): DCNL  DCSP kstone = auth(profile, **connection_args) DCNL DCSP ret = {} DCNL DCSP if name: DCNL DCSP  DCSP for tenant in getattr(kstone, _TENANTS, None).list(): DCNL DCSP  DCSP  DCSP if (tenant.name == name): DCNL DCSP  DCSP  DCSP  DCSP tenant_id = tenant.id DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not tenant_id): DCNL DCSP  DCSP return {'Error': 'Unable DCSP to DCSP resolve DCSP tenant DCSP id'} DCNL DCSP tenant = getattr(kstone, _TENANTS, None).get(tenant_id) DCNL DCSP ret[tenant.name] = dict(((value, getattr(tenant, value)) for value in dir(tenant) if ((not value.startswith('_')) and isinstance(getattr(tenant, value), (six.text_type, dict, bool, str))))) DCNL DCSP return ret\n", "intent": "return a specific tenants  cli examples: .\n", "question_id": 564}, {"snippet": "def _read_vmrk_events(fname, event_id=None, response_trig_shift=0): DCNL  DCSP if (event_id is None): DCNL DCSP  DCSP event_id = dict() DCNL DCSP with open(fname, 'rb') as fid: DCNL DCSP  DCSP txt = fid.read() DCNL DCSP header = txt.decode('ascii', 'ignore').split('\\n')[0].strip() DCNL DCSP _check_mrk_version(header) DCNL DCSP if ((response_trig_shift is not None) and (not isinstance(response_trig_shift, int))): DCNL DCSP  DCSP raise TypeError('response_trig_shift DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP None') DCNL DCSP codepage = 'utf-8' DCNL DCSP try: DCNL DCSP  DCSP cp_setting = re.search('Codepage=(.+)', txt.decode('ascii', 'ignore'), (re.IGNORECASE & re.MULTILINE)) DCNL DCSP  DCSP if cp_setting: DCNL DCSP  DCSP  DCSP codepage = cp_setting.group(1).strip() DCNL DCSP  DCSP txt = txt.decode(codepage) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP txt = txt.decode('latin-1') DCNL DCSP m = re.search('\\\\[Marker DCSP Infos\\\\]', txt) DCNL DCSP if (not m): DCNL DCSP  DCSP return np.zeros(0) DCNL DCSP mk_txt = txt[m.end():] DCNL DCSP m = re.search('\\\\[.*\\\\]', mk_txt) DCNL DCSP if m: DCNL DCSP  DCSP mk_txt = mk_txt[:m.start()] DCNL DCSP items = re.findall('^Mk\\\\d+=(.*)', mk_txt, re.MULTILINE) DCNL DCSP (events, dropped) = (list(), list()) DCNL DCSP for info in items: DCNL DCSP  DCSP (mtype, mdesc, onset, duration) = info.split(',')[:4] DCNL DCSP  DCSP onset = int(onset) DCNL DCSP  DCSP duration = (int(duration) if duration.isdigit() else 1) DCNL DCSP  DCSP if (mdesc in event_id): DCNL DCSP  DCSP  DCSP trigger = event_id[mdesc] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP trigger = int(re.findall('[A-Za-z]*\\\\s*?(\\\\d+)', mdesc)[0]) DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP trigger = None DCNL DCSP  DCSP  DCSP if mtype.lower().startswith('response'): DCNL DCSP  DCSP  DCSP  DCSP if (response_trig_shift is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP trigger += response_trig_shift DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP trigger = None DCNL DCSP  DCSP if trigger: DCNL DCSP  DCSP  DCSP events.append((onset, duration, trigger)) DCNL DCSP  DCSP elif (len(mdesc) > 0): DCNL DCSP  DCSP  DCSP dropped.append(mdesc) DCNL DCSP if (len(dropped) > 0): DCNL DCSP  DCSP dropped = list(set(dropped)) DCNL DCSP  DCSP examples = ', DCSP '.join(dropped[:5]) DCNL DCSP  DCSP if (len(dropped) > 5): DCNL DCSP  DCSP  DCSP examples += ', DCSP ...' DCNL DCSP  DCSP warn(\"Currently, DCSP {0} DCSP trigger(s) DCSP will DCSP be DCSP dropped, DCSP such DCSP as DCSP [{1}]. DCSP Consider DCSP using DCSP ``event_id`` DCSP to DCSP parse DCSP triggers DCSP that DCSP do DCSP not DCSP follow DCSP the DCSP 'S###' DCSP pattern.\".format(len(dropped), examples)) DCNL DCSP events = np.array(events).reshape((-1), 3) DCNL DCSP return events\n", "intent": "read events from a vmrk file .\n", "question_id": 565}, {"snippet": "def major_version(best=False): DCNL  DCSP return _distro.major_version(best)\n", "intent": "return the major version of the current linux distribution .\n", "question_id": 566}, {"snippet": "def update_comments_in_parent(reference_doctype, reference_name, _comments): DCNL  DCSP if ((not reference_doctype) or frappe.db.get_value(u'DocType', reference_doctype, u'issingle')): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP frappe.db.sql((u'update DCSP `tab%s` DCSP set DCSP `_comments`=%s DCSP where DCSP name=%s' % (reference_doctype, u'%s', u'%s')), (json.dumps(_comments), reference_name)) DCNL DCSP except Exception as e: DCNL DCSP  DCSP if ((e.args[0] == 1054) and getattr(frappe.local, u'request', None)): DCNL DCSP  DCSP  DCSP frappe.local._comments = (getattr(frappe.local, u'_comments', []) + [(reference_doctype, reference_name, _comments)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ImplicitCommitError DCNL DCSP else: DCNL DCSP  DCSP if (not frappe.flags.in_patch): DCNL DCSP  DCSP  DCSP reference_doc = frappe.get_doc(reference_doctype, reference_name) DCNL DCSP  DCSP  DCSP if getattr(reference_doc, u'route', None): DCNL DCSP  DCSP  DCSP  DCSP clear_cache(reference_doc.route)\n", "intent": "updates _comments property in parent document with given dict .\n", "question_id": 567}, {"snippet": "def upgrade(migrate_engine): DCNL  DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP Table('volume_attachment', meta, autoload=True) DCNL DCSP attachment_specs = Table('attachment_specs', meta, Column('created_at', DateTime(timezone=False)), Column('updated_at', DateTime(timezone=False)), Column('deleted_at', DateTime(timezone=False)), Column('deleted', Boolean(), default=False), Column('id', Integer, primary_key=True, nullable=False), Column('attachment_id', String(36), ForeignKey('volume_attachment.id'), nullable=False), Column('key', String(255)), Column('value', String(255)), mysql_engine='InnoDB', mysql_charset='utf8') DCNL DCSP attachment_specs.create()\n", "intent": "add attachment_specs table .\n", "question_id": 568}, {"snippet": "def xontribs_main(args=None, stdin=None): DCNL  DCSP if ((not args) or ((args[0] not in _MAIN_XONTRIB_ACTIONS) and (args[0] not in {'-h', '--help'}))): DCNL DCSP  DCSP args.insert(0, 'load') DCNL DCSP parser = _create_xontrib_parser() DCNL DCSP ns = parser.parse_args(args) DCNL DCSP if (ns.action is None): DCNL DCSP  DCSP ns = parser.parse_args((['load'] + args)) DCNL DCSP return _MAIN_XONTRIB_ACTIONS[ns.action](ns)\n", "intent": "alias that loads xontribs .\n", "question_id": 569}, {"snippet": "@hook.command() DCNL def suggest(text): DCNL  DCSP params = {'output': 'json', 'client': 'hp', 'q': text} DCNL DCSP try: DCNL DCSP  DCSP request = requests.get('http://google.com/complete/search', params=params) DCNL DCSP  DCSP request.raise_for_status() DCNL DCSP except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError) as e: DCNL DCSP  DCSP return 'Could DCSP not DCSP get DCSP suggestions: DCSP {}'.format(e) DCNL DCSP page = request.text DCNL DCSP page_json = page.split('(', 1)[1][:(-1)] DCNL DCSP suggestions = json.loads(page_json)[1] DCNL DCSP suggestions = [suggestion[0] for suggestion in suggestions] DCNL DCSP if (not suggestions): DCNL DCSP  DCSP return 'No DCSP suggestions DCSP found.' DCNL DCSP out = formatting.strip_html(', DCSP '.join(suggestions)) DCNL DCSP return formatting.truncate(out, 200)\n", "intent": "suggest <phrase> -- gets suggested phrases for a google search .\n", "question_id": 570}, {"snippet": "def parse(template, delimiters=None): DCNL  DCSP if (type(template) is not unicode): DCNL DCSP  DCSP raise Exception(('Template DCSP is DCSP not DCSP unicode: DCSP %s' % type(template))) DCNL DCSP parser = _Parser(delimiters) DCNL DCSP return parser.parse(template)\n", "intent": "parse a unicode template string and return a parsedtemplate instance .\n", "question_id": 571}, {"snippet": "def _ipv6_host(host): DCNL  DCSP if (host.startswith('[') and host.endswith(']')): DCNL DCSP  DCSP host = host.replace('%25', '%').strip('[]') DCNL DCSP return host\n", "intent": "process ipv6 address literals .\n", "question_id": 572}, {"snippet": "def load_soups(config): DCNL  DCSP soups = {} DCNL DCSP for (page, path) in config[u'sources'].items(): DCNL DCSP  DCSP with open(path, u'rb') as orig_file: DCNL DCSP  DCSP  DCSP soups[page] = beautiful_soup(orig_file.read().decode(u'utf-8')) DCNL DCSP return soups\n", "intent": "generate beautifulsoup ast for each page listed in config .\n", "question_id": 573}, {"snippet": "def grand_average(all_inst, interpolate_bads=True, drop_bads=True): DCNL  DCSP from .evoked import Evoked DCNL DCSP from .time_frequency import AverageTFR DCNL DCSP from .channels.channels import equalize_channels DCNL DCSP if (not all((isinstance(inst, (Evoked, AverageTFR)) for inst in all_inst))): DCNL DCSP  DCSP raise ValueError('Not DCSP all DCSP input DCSP elements DCSP are DCSP Evoked DCSP or DCSP AverageTFR') DCNL DCSP all_inst = [inst.copy() for inst in all_inst] DCNL DCSP if isinstance(all_inst[0], Evoked): DCNL DCSP  DCSP if interpolate_bads: DCNL DCSP  DCSP  DCSP all_inst = [(inst.interpolate_bads() if (len(inst.info['bads']) > 0) else inst) for inst in all_inst] DCNL DCSP  DCSP equalize_channels(all_inst) DCNL DCSP  DCSP from .evoked import combine_evoked as combine DCNL DCSP else: DCNL DCSP  DCSP from .time_frequency.tfr import combine_tfr as combine DCNL DCSP if drop_bads: DCNL DCSP  DCSP bads = list(set((b for inst in all_inst for b in inst.info['bads']))) DCNL DCSP  DCSP if bads: DCNL DCSP  DCSP  DCSP for inst in all_inst: DCNL DCSP  DCSP  DCSP  DCSP inst.drop_channels(bads) DCNL DCSP grand_average = combine(all_inst, weights='equal') DCNL DCSP grand_average.nave = len(all_inst) DCNL DCSP grand_average.comment = ('Grand DCSP average DCSP (n DCSP = DCSP %d)' % grand_average.nave) DCNL DCSP return grand_average\n", "intent": "make grand average of a list evoked or averagetfr data .\n", "question_id": 574}, {"snippet": "def pandas_dtype(dtype): DCNL  DCSP if isinstance(dtype, DatetimeTZDtype): DCNL DCSP  DCSP return dtype DCNL DCSP elif isinstance(dtype, PeriodDtype): DCNL DCSP  DCSP return dtype DCNL DCSP elif isinstance(dtype, CategoricalDtype): DCNL DCSP  DCSP return dtype DCNL DCSP elif isinstance(dtype, string_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return DatetimeTZDtype.construct_from_string(dtype) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (dtype.startswith('period[') or dtype.startswith('Period[')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return PeriodDtype.construct_from_string(dtype) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return CategoricalDtype.construct_from_string(dtype) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP elif isinstance(dtype, ExtensionDtype): DCNL DCSP  DCSP return dtype DCNL DCSP return np.dtype(dtype)\n", "intent": "converts input into a pandas only dtype object or a numpy dtype object .\n", "question_id": 575}, {"snippet": "def expm(A): DCNL  DCSP return _expm(A, use_exact_onenorm='auto')\n", "intent": "compute the matrix exponential using pade approximation .\n", "question_id": 576}, {"snippet": "def _darwin_compiler_fixup(compiler_so, cc_args): DCNL  DCSP stripArch = stripSysroot = 0 DCNL DCSP compiler_so = list(compiler_so) DCNL DCSP kernel_version = os.uname()[2] DCNL DCSP major_version = int(kernel_version.split('.')[0]) DCNL DCSP if (major_version < 8): DCNL DCSP  DCSP stripArch = stripSysroot = True DCNL DCSP else: DCNL DCSP  DCSP stripArch = ('-arch' in cc_args) DCNL DCSP  DCSP stripSysroot = ('-isysroot' in cc_args) DCNL DCSP if (stripArch or ('ARCHFLAGS' in os.environ)): DCNL DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP index = compiler_so.index('-arch') DCNL DCSP  DCSP  DCSP  DCSP del compiler_so[index:(index + 2)] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (('ARCHFLAGS' in os.environ) and (not stripArch)): DCNL DCSP  DCSP compiler_so = (compiler_so + os.environ['ARCHFLAGS'].split()) DCNL DCSP if stripSysroot: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP index = compiler_so.index('-isysroot') DCNL DCSP  DCSP  DCSP del compiler_so[index:(index + 2)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP sysroot = None DCNL DCSP if ('-isysroot' in cc_args): DCNL DCSP  DCSP idx = cc_args.index('-isysroot') DCNL DCSP  DCSP sysroot = cc_args[(idx + 1)] DCNL DCSP elif ('-isysroot' in compiler_so): DCNL DCSP  DCSP idx = compiler_so.index('-isysroot') DCNL DCSP  DCSP sysroot = compiler_so[(idx + 1)] DCNL DCSP if (sysroot and (not os.path.isdir(sysroot))): DCNL DCSP  DCSP log.warn(\"Compiling DCSP with DCSP an DCSP SDK DCSP that DCSP doesn't DCSP seem DCSP to DCSP exist: DCSP %s\", sysroot) DCNL DCSP  DCSP log.warn('Please DCSP check DCSP your DCSP Xcode DCSP installation') DCNL DCSP return compiler_so\n", "intent": "this function will strip -isysroot path and -arch arch from the compile flags if the user has specified one them in extra_compile_flags .\n", "question_id": 577}, {"snippet": "def test_category_delete_with_forum(forum): DCNL  DCSP forum.category.delete() DCNL DCSP assert (forum is not None) DCNL DCSP assert (forum.category is not None) DCNL DCSP category = Category.query.filter_by(id=forum.category.id).first() DCNL DCSP forum = Forum.query.filter_by(id=forum.id).first() DCNL DCSP assert (forum is None) DCNL DCSP assert (category is None)\n", "intent": "when deleting a category .\n", "question_id": 578}, {"snippet": "@app.route('/account/<subscription_id>/resourcegroups/<resource_group_name>/virtualnetworks/<network_name>') DCNL @auth.require_login DCNL def virtual_network_view(subscription_id, resource_group_name, network_name): DCNL  DCSP creds = _get_credentials() DCNL DCSP model = models.get_virtual_network_details(subscription_id, creds, resource_group_name, network_name) DCNL DCSP return render_template('virtual_network.html', title=network_name, year=datetime.now().year, subscription_id=subscription_id, resource_group_name=resource_group_name, model=model)\n", "intent": "renders the vm details .\n", "question_id": 579}, {"snippet": "def shutdown(request): DCNL  DCSP if (not request.session.get('allow_shutdown')): DCNL DCSP  DCSP return HttpResponseRedirect('/') DCNL DCSP request.session.pop('allow_shutdown') DCNL DCSP return render(request, 'system/shutdown.html', {'sw_name': get_sw_name(), 'sw_version': get_sw_version()})\n", "intent": "shuts down the system and powers off the system .\n", "question_id": 580}, {"snippet": "def main(): DCNL  DCSP factory = server.DNSServerFactory(clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')]) DCNL DCSP protocol = dns.DNSDatagramProtocol(controller=factory) DCNL DCSP reactor.listenUDP(10053, protocol) DCNL DCSP reactor.listenTCP(10053, factory) DCNL DCSP reactor.run()\n", "intent": "run the server .\n", "question_id": 581}, {"snippet": "def _init_readline(): DCNL  DCSP if g.command_line: DCNL DCSP  DCSP return DCNL DCSP if has_readline: DCNL DCSP  DCSP g.READLINE_FILE = os.path.join(paths.get_config_dir(), 'input_history') DCNL DCSP  DCSP if os.path.exists(g.READLINE_FILE): DCNL DCSP  DCSP  DCSP readline.read_history_file(g.READLINE_FILE) DCNL DCSP  DCSP  DCSP dbg(((c.g + 'Read DCSP history DCSP file') + c.w))\n", "intent": "enable readline for input history .\n", "question_id": 582}, {"snippet": "@register(name='core.stop') DCNL def stop(**kwargs): DCNL  DCSP if (not CORE_MANAGER.started): DCNL DCSP  DCSP raise RuntimeConfigError('No DCSP runtime DCSP is DCSP active. DCSP Call DCSP start DCSP to DCSP create DCSP a DCSP runtime') DCNL DCSP CORE_MANAGER.stop() DCNL DCSP return True\n", "intent": "stops current context is one is active .\n", "question_id": 583}, {"snippet": "def mkdtemp_clean(suffix='', prefix='tmp', dir=None): DCNL  DCSP the_dir = tempfile.mkdtemp(suffix=suffix, prefix=prefix, dir=dir) DCNL DCSP atexit.register(cleanup_tempdir, the_dir) DCNL DCSP return the_dir\n", "intent": "just like mkdtemp .\n", "question_id": 584}, {"snippet": "def test_nested_mlp(): DCNL  DCSP inner_mlp = MLP(layers=[Linear(10, 'h0', 0.1), Linear(10, 'h1', 0.1)], layer_name='inner_mlp') DCNL DCSP outer_mlp = MLP(layers=[CompositeLayer(layer_name='composite', layers=[inner_mlp, Linear(10, 'h2', 0.1)])], nvis=10) DCNL DCSP X = outer_mlp.get_input_space().make_theano_batch() DCNL DCSP f = theano.function([X], outer_mlp.fprop(X)) DCNL DCSP f(np.random.rand(5, 10).astype(theano.config.floatX))\n", "intent": "constructs a nested mlp and tries to fprop through it .\n", "question_id": 585}, {"snippet": "@task DCNL def upload(): DCNL  DCSP distutils_check() DCNL DCSP GitHub_release() DCNL DCSP pypi_register() DCNL DCSP pypi_upload() DCNL DCSP test_pypi(2) DCNL DCSP test_pypi(3)\n", "intent": "upload the files everywhere .\n", "question_id": 586}, {"snippet": "@tx.atomic DCNL def add_vote(obj, user): DCNL  DCSP obj_type = apps.get_model('contenttypes', 'ContentType').objects.get_for_model(obj) DCNL DCSP with advisory_lock('vote-{}-{}'.format(obj_type.id, obj.id)): DCNL DCSP  DCSP (vote, created) = Vote.objects.get_or_create(content_type=obj_type, object_id=obj.id, user=user) DCNL DCSP  DCSP if (not created): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (votes, _) = Votes.objects.get_or_create(content_type=obj_type, object_id=obj.id) DCNL DCSP  DCSP votes.count = (F('count') + 1) DCNL DCSP  DCSP votes.save() DCNL DCSP  DCSP return vote\n", "intent": "add a vote to an object .\n", "question_id": 587}, {"snippet": "def runfile(fullpath): DCNL  DCSP pwd = os.getcwd() DCNL DCSP (path, fname) = os.path.split(fullpath) DCNL DCSP sys.path.insert(0, os.path.abspath(path)) DCNL DCSP stdout = sys.stdout DCNL DCSP sys.stdout = cStringIO.StringIO() DCNL DCSP os.chdir(path) DCNL DCSP try: DCNL DCSP  DCSP fd = open(fname) DCNL DCSP  DCSP module = imp.load_module('__main__', fd, fname, ('py', 'r', imp.PY_SOURCE)) DCNL DCSP finally: DCNL DCSP  DCSP del sys.path[0] DCNL DCSP  DCSP os.chdir(pwd) DCNL DCSP  DCSP sys.stdout = stdout DCNL DCSP return module\n", "intent": "import a python module from a path .\n", "question_id": 588}, {"snippet": "def _deprecate(name): DCNL  DCSP def _(*args, **kwargs): DCNL DCSP  DCSP warnings.warn(('unittest.%s DCSP is DCSP deprecated. DCSP  DCSP Instead DCSP use DCSP the DCSP %r DCSP method DCSP on DCSP unittest.TestCase' % (name, name)), stacklevel=2, category=DeprecationWarning) DCNL DCSP  DCSP return getattr(_inst, name)(*args, **kwargs) DCNL DCSP return _\n", "intent": "internal method used to deprecate top-level assertions .\n", "question_id": 589}, {"snippet": "def time_limited(timeout=0.5, return_val=np.nan, use_sigalrm=True): DCNL  DCSP if (POSIX and use_sigalrm): DCNL DCSP  DCSP def sigalrm_handler(signum, frame): DCNL DCSP  DCSP  DCSP raise TimeoutError() DCNL DCSP  DCSP def deco(func): DCNL DCSP  DCSP  DCSP def wrap(*a, **kw): DCNL DCSP  DCSP  DCSP  DCSP old_handler = signal.signal(signal.SIGALRM, sigalrm_handler) DCNL DCSP  DCSP  DCSP  DCSP signal.setitimer(signal.ITIMER_REAL, timeout) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return func(*a, **kw) DCNL DCSP  DCSP  DCSP  DCSP except TimeoutError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return return_val DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP signal.setitimer(signal.ITIMER_REAL, 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGALRM, old_handler) DCNL DCSP  DCSP  DCSP return wrap DCNL DCSP else: DCNL DCSP  DCSP def deco(func): DCNL DCSP  DCSP  DCSP def wrap(*a, **kw): DCNL DCSP  DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP  DCSP def trace(frame, event, arg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((time.time() - start_time) > timeout): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise TimeoutError() DCNL DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP  DCSP sys.settrace(trace) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return func(*a, **kw) DCNL DCSP  DCSP  DCSP  DCSP except TimeoutError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.settrace(None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return return_val DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.settrace(None) DCNL DCSP  DCSP  DCSP return wrap DCNL DCSP return deco\n", "intent": "decorator for setting a timeout for pure-python functions .\n", "question_id": 590}, {"snippet": "def _parse_tcp_line(line): DCNL  DCSP ret = {} DCNL DCSP comps = line.strip().split() DCNL DCSP sl = comps[0].rstrip(':') DCNL DCSP ret[sl] = {} DCNL DCSP (l_addr, l_port) = comps[1].split(':') DCNL DCSP (r_addr, r_port) = comps[2].split(':') DCNL DCSP ret[sl]['local_addr'] = hex2ip(l_addr, True) DCNL DCSP ret[sl]['local_port'] = int(l_port, 16) DCNL DCSP ret[sl]['remote_addr'] = hex2ip(r_addr, True) DCNL DCSP ret[sl]['remote_port'] = int(r_port, 16) DCNL DCSP return ret\n", "intent": "parse a single line from the contents of /proc/net/tcp or /proc/net/tcp6 .\n", "question_id": 591}, {"snippet": "def _fully_qualified_name(obj): DCNL  DCSP try: DCNL DCSP  DCSP name = obj.__qualname__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP name = obj.__name__ DCNL DCSP if (inspect.isclass(obj) or inspect.isfunction(obj)): DCNL DCSP  DCSP moduleName = obj.__module__ DCNL DCSP  DCSP return ('%s.%s' % (moduleName, name)) DCNL DCSP elif inspect.ismethod(obj): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cls = obj.im_class DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return ('%s.%s' % (obj.__module__, obj.__qualname__)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP className = _fully_qualified_name(cls) DCNL DCSP  DCSP  DCSP return ('%s.%s' % (className, name)) DCNL DCSP return name\n", "intent": "return the fully qualified name of a module .\n", "question_id": 592}, {"snippet": "def parse(url_file_stream_or_string, etag=None, modified=None, agent=None, referrer=None, handlers=None, request_headers=None, response_headers=None): DCNL  DCSP if (handlers is None): DCNL DCSP  DCSP handlers = [] DCNL DCSP if (request_headers is None): DCNL DCSP  DCSP request_headers = {} DCNL DCSP if (response_headers is None): DCNL DCSP  DCSP response_headers = {} DCNL DCSP result = FeedParserDict() DCNL DCSP result['feed'] = FeedParserDict() DCNL DCSP result['entries'] = [] DCNL DCSP result['bozo'] = 0 DCNL DCSP if (not isinstance(handlers, list)): DCNL DCSP  DCSP handlers = [handlers] DCNL DCSP try: DCNL DCSP  DCSP f = _open_resource(url_file_stream_or_string, etag, modified, agent, referrer, handlers, request_headers) DCNL DCSP  DCSP data = f.read() DCNL DCSP except Exception as e: DCNL DCSP  DCSP result['bozo'] = 1 DCNL DCSP  DCSP result['bozo_exception'] = e DCNL DCSP  DCSP data = None DCNL DCSP  DCSP f = None DCNL DCSP if hasattr(f, 'headers'): DCNL DCSP  DCSP result['headers'] = dict(f.headers) DCNL DCSP if ('headers' in result): DCNL DCSP  DCSP result['headers'].update(response_headers) DCNL DCSP elif response_headers: DCNL DCSP  DCSP result['headers'] = copy.deepcopy(response_headers) DCNL DCSP if ('headers' in result): DCNL DCSP  DCSP http_headers = dict(((k.lower(), v) for (k, v) in result['headers'].items())) DCNL DCSP else: DCNL DCSP  DCSP http_headers = {} DCNL DCSP if (f and data and http_headers): DCNL DCSP  DCSP if (gzip and ('gzip' in http_headers.get('content-encoding', ''))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP data = gzip.GzipFile(fileobj=_StringIO(data)).read() DCNL DCSP  DCSP  DCSP except (IOError, struct.error) as e: DCNL DCSP  DCSP  DCSP  DCSP result['bozo'] = 1 DCNL DCSP  DCSP  DCSP  DCSP result['bozo_exception'] = e DCNL DCSP  DCSP  DCSP  DCSP if isinstance(e, struct.error): DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = None DCNL DCSP  DCSP elif (zlib and ('deflate' in http_headers.get('content-encoding', ''))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP data = zlib.decompress(data) DCNL DCSP  DCSP  DCSP except zlib.error as e: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = zlib.decompress(data, (-15)) DCNL DCSP  DCSP  DCSP  DCSP except zlib.error as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result['bozo'] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP result['bozo_exception'] = e DCNL DCSP if http_headers: DCNL DCSP  DCSP if ('etag' in http_headers): DCNL DCSP  DCSP  DCSP etag = http_headers.get('etag', u'') DCNL DCSP  DCSP  DCSP if (not isinstance(etag, unicode)): DCNL DCSP  DCSP  DCSP  DCSP etag = etag.decode('utf-8', 'ignore') DCNL DCSP  DCSP  DCSP if etag: DCNL DCSP  DCSP  DCSP  DCSP result['etag'] = etag DCNL DCSP  DCSP if ('last-modified' in http_headers): DCNL DCSP  DCSP  DCSP modified = http_headers.get('last-modified', u'') DCNL DCSP  DCSP  DCSP if modified: DCNL DCSP  DCSP  DCSP  DCSP result['modified'] = modified DCNL DCSP  DCSP  DCSP  DCSP result['modified_parsed'] = _parse_date(modified) DCNL DCSP if hasattr(f, 'url'): DCNL DCSP  DCSP if (not isinstance(f.url, unicode)): DCNL DCSP  DCSP  DCSP result['href'] = f.url.decode('utf-8', 'ignore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result['href'] = f.url DCNL DCSP  DCSP result['status'] = 200 DCNL DCSP if hasattr(f, 'status'): DCNL DCSP  DCSP result['status'] = f.status DCNL DCSP if hasattr(f, 'close'): DCNL DCSP  DCSP f.close() DCNL DCSP if (data is None): DCNL DCSP  DCSP return result DCNL DCSP if (getattr(f, 'code', 0) == 304): DCNL DCSP  DCSP result['version'] = u'' DCNL DCSP  DCSP result['debug_message'] = ('The DCSP feed DCSP has DCSP not DCSP changed DCSP since DCSP you DCSP last DCSP checked, DCSP ' + 'so DCSP the DCSP server DCSP sent DCSP no DCSP data. DCSP  DCSP This DCSP is DCSP a DCSP feature, DCSP not DCSP a DCSP bug!') DCNL DCSP  DCSP return result DCNL DCSP (data, result['encoding'], error) = convert_to_utf8(http_headers, data) DCNL DCSP use_strict_parser = ((result['encoding'] and True) or False) DCNL DCSP if (error is not None): DCNL DCSP  DCSP result['bozo'] = 1 DCNL DCSP  DCSP result['bozo_exception'] = error DCNL DCSP (result['version'], data, entities) = replace_doctype(data) DCNL DCSP contentloc = http_headers.get('content-location', u'') DCNL DCSP href = result.get('href', u'') DCNL DCSP baseuri = (_makeSafeAbsoluteURI(href, contentloc) or _makeSafeAbsoluteURI(contentloc) or href) DCNL DCSP baselang = http_headers.get('content-language', None) DCNL DCSP if ((not isinstance(baselang, unicode)) and (baselang is not None)): DCNL DCSP  DCSP baselang = baselang.decode('utf-8', 'ignore') DCNL DCSP if (not _XML_AVAILABLE): DCNL DCSP  DCSP use_strict_parser = 0 DCNL DCSP if use_strict_parser: DCNL DCSP  DCSP feedparser = _StrictFeedParser(baseuri, baselang, 'utf-8') DCNL DCSP  DCSP saxparser = xml.sax.make_parser(PREFERRED_XML_PARSERS) DCNL DCSP  DCSP saxparser.setFeature(xml.sax.handler.feature_namespaces, 1) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP saxparser.setFeature(xml.sax.handler.feature_external_ges, 0) DCNL DCSP  DCSP except xml.sax.SAXNotSupportedException: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP saxparser.setContentHandler(feedparser) DCNL DCSP  DCSP saxparser.setErrorHandler(feedparser) DCNL DCSP  DCSP source = xml.sax.xmlreader.InputSource() DCNL DCSP  DCSP source.setByteStream(_StringIO(data)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP saxparser.parse(source) DCNL DCSP  DCSP except xml.sax.SAXException as e: DCNL DCSP  DCSP  DCSP result['bozo'] = 1 DCNL DCSP  DCSP  DCSP result['bozo_exception'] = (feedparser.exc or e) DCNL DCSP  DCSP  DCSP use_strict_parser = 0 DCNL DCSP if ((not use_strict_parser) and _SGML_AVAILABLE): DCNL DCSP  DCSP feedparser = _LooseFeedParser(baseuri, baselang, 'utf-8', entities) DCNL DCSP  DCSP feedparser.feed(data.decode('utf-8', 'replace')) DCNL DCSP result['feed'] = feedparser.feeddata DCNL DCSP result['entries'] = feedparser.entries DCNL DCSP result['version'] = (result['version'] or feedparser.version) DCNL DCSP result['namespaces'] = feedparser.namespacesInUse DCNL DCSP return result\n", "intent": "parse a feed from a url .\n", "question_id": 593}, {"snippet": "def init_repo(path=None): DCNL  DCSP guess_repo(path) DCNL DCSP d = repo() DCNL DCSP parent = os.path.dirname(os.path.dirname(d)) DCNL DCSP if (parent and (not os.path.exists(parent))): DCNL DCSP  DCSP raise GitError(('parent DCSP directory DCSP \"%s\" DCSP does DCSP not DCSP exist\\n' % parent)) DCNL DCSP if (os.path.exists(d) and (not os.path.isdir(os.path.join(d, '.')))): DCNL DCSP  DCSP raise GitError(('\"%s\" DCSP exists DCSP but DCSP is DCSP not DCSP a DCSP directory\\n' % d)) DCNL DCSP p = subprocess.Popen(['git', '--bare', 'init'], stdout=sys.stderr, preexec_fn=_gitenv()) DCNL DCSP _git_wait('git DCSP init', p) DCNL DCSP p = subprocess.Popen(['git', 'config', 'pack.indexVersion', '2'], stdout=sys.stderr, preexec_fn=_gitenv()) DCNL DCSP _git_wait('git DCSP config', p) DCNL DCSP p = subprocess.Popen(['git', 'config', 'core.logAllRefUpdates', 'true'], stdout=sys.stderr, preexec_fn=_gitenv()) DCNL DCSP _git_wait('git DCSP config', p)\n", "intent": "create the git bare repository for bup in a given path .\n", "question_id": 594}, {"snippet": "def undeployed(name, url='http://localhost:8080/manager', timeout=180): DCNL  DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP if (not __salt__['tomcat.status'](url, timeout)): DCNL DCSP  DCSP ret['comment'] = 'Tomcat DCSP Manager DCSP does DCSP not DCSP respond' DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP version = __salt__['tomcat.ls'](url, timeout)[name]['version'] DCNL DCSP  DCSP ret['changes'] = {'undeploy': version} DCNL DCSP except KeyError: DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP undeploy = __salt__['tomcat.undeploy'](name, url, timeout=timeout) DCNL DCSP if undeploy.startswith('FAIL'): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = undeploy DCNL DCSP  DCSP return ret DCNL DCSP return ret\n", "intent": "enforce that the war will be undeployed from the server name the context path to undeploy .\n", "question_id": 595}, {"snippet": "def get_prefix_from_ns_name(ns_name): DCNL  DCSP dash_index = ns_name.find('-') DCNL DCSP if (0 <= dash_index): DCNL DCSP  DCSP return ns_name[:(dash_index + 1)]\n", "intent": "parses prefix from prefix-identifier .\n", "question_id": 596}, {"snippet": "def as_value(s): DCNL  DCSP return ('<value>%s</value>' % saxutils.escape(s))\n", "intent": "helper function for simulating xenapi plugin responses .\n", "question_id": 597}, {"snippet": "def corr_nearest_factor(corr, rank, ctol=1e-06, lam_min=1e-30, lam_max=1e+30, maxiter=1000): DCNL  DCSP (p, _) = corr.shape DCNL DCSP (u, s, vt) = svds(corr, rank) DCNL DCSP X = (u * np.sqrt(s)) DCNL DCSP nm = np.sqrt((X ** 2).sum(1)) DCNL DCSP ii = np.flatnonzero((nm > 1e-05)) DCNL DCSP X[ii, :] /= nm[ii][:, None] DCNL DCSP corr1 = corr.copy() DCNL DCSP if (type(corr1) == np.ndarray): DCNL DCSP  DCSP np.fill_diagonal(corr1, 0) DCNL DCSP elif sparse.issparse(corr1): DCNL DCSP  DCSP corr1.setdiag(np.zeros(corr1.shape[0])) DCNL DCSP  DCSP corr1.eliminate_zeros() DCNL DCSP  DCSP corr1.sort_indices() DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Matrix DCSP type DCSP not DCSP supported') DCNL DCSP def grad(X): DCNL DCSP  DCSP gr = np.dot(X, np.dot(X.T, X)) DCNL DCSP  DCSP if (type(corr1) == np.ndarray): DCNL DCSP  DCSP  DCSP gr -= np.dot(corr1, X) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP gr -= corr1.dot(X) DCNL DCSP  DCSP gr -= ((X * X).sum(1)[:, None] * X) DCNL DCSP  DCSP return (4 * gr) DCNL DCSP def func(X): DCNL DCSP  DCSP if (type(corr1) == np.ndarray): DCNL DCSP  DCSP  DCSP M = np.dot(X, X.T) DCNL DCSP  DCSP  DCSP np.fill_diagonal(M, 0) DCNL DCSP  DCSP  DCSP M -= corr1 DCNL DCSP  DCSP  DCSP fval = (M * M).sum() DCNL DCSP  DCSP  DCSP return fval DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fval = 0.0 DCNL DCSP  DCSP  DCSP max_ws = 1000000.0 DCNL DCSP  DCSP  DCSP bs = int((max_ws / X.shape[0])) DCNL DCSP  DCSP  DCSP ir = 0 DCNL DCSP  DCSP  DCSP while (ir < X.shape[0]): DCNL DCSP  DCSP  DCSP  DCSP ir2 = min((ir + bs), X.shape[0]) DCNL DCSP  DCSP  DCSP  DCSP u = np.dot(X[ir:ir2, :], X.T) DCNL DCSP  DCSP  DCSP  DCSP ii = np.arange(u.shape[0]) DCNL DCSP  DCSP  DCSP  DCSP u[(ii, (ir + ii))] = 0 DCNL DCSP  DCSP  DCSP  DCSP u -= np.asarray(corr1[ir:ir2, :].todense()) DCNL DCSP  DCSP  DCSP  DCSP fval += (u * u).sum() DCNL DCSP  DCSP  DCSP  DCSP ir += bs DCNL DCSP  DCSP  DCSP return fval DCNL DCSP rslt = _spg_optim(func, grad, X, _project_correlation_factors) DCNL DCSP root = rslt.params DCNL DCSP diag = (1 - (root ** 2).sum(1)) DCNL DCSP soln = FactoredPSDMatrix(diag, root) DCNL DCSP rslt.corr = soln DCNL DCSP del rslt.params DCNL DCSP return rslt\n", "intent": "find the nearest correlation matrix with factor structure to a given square matrix .\n", "question_id": 598}, {"snippet": "def test_projection_layer_yaml(): DCNL  DCSP test_dir = os.path.dirname(__file__) DCNL DCSP with open(os.path.join(test_dir, 'composite.yaml')) as f: DCNL DCSP  DCSP train = yaml_parse.load(f.read()) DCNL DCSP  DCSP train.main_loop()\n", "intent": "test loading and running a complex model with projectionlayer .\n", "question_id": 599}, {"snippet": "def split_header_words(header_values): DCNL  DCSP assert (not isinstance(header_values, basestring)) DCNL DCSP result = [] DCNL DCSP for text in header_values: DCNL DCSP  DCSP orig_text = text DCNL DCSP  DCSP pairs = [] DCNL DCSP  DCSP while text: DCNL DCSP  DCSP  DCSP m = HEADER_TOKEN_RE.search(text) DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP text = unmatched(m) DCNL DCSP  DCSP  DCSP  DCSP name = m.group(1) DCNL DCSP  DCSP  DCSP  DCSP m = HEADER_QUOTED_VALUE_RE.search(text) DCNL DCSP  DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP  DCSP text = unmatched(m) DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = m.group(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = HEADER_ESCAPE_RE.sub('\\\\1', value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP m = HEADER_VALUE_RE.search(text) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP text = unmatched(m) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = m.group(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = value.rstrip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP  DCSP  DCSP pairs.append((name, value)) DCNL DCSP  DCSP  DCSP elif text.lstrip().startswith(','): DCNL DCSP  DCSP  DCSP  DCSP text = text.lstrip()[1:] DCNL DCSP  DCSP  DCSP  DCSP if pairs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.append(pairs) DCNL DCSP  DCSP  DCSP  DCSP pairs = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (non_junk, nr_junk_chars) = re.subn('^[=\\\\s;]*', '', text) DCNL DCSP  DCSP  DCSP  DCSP assert (nr_junk_chars > 0), (\"split_header_words DCSP bug: DCSP '%s', DCSP '%s', DCSP %s\" % (orig_text, text, pairs)) DCNL DCSP  DCSP  DCSP  DCSP text = non_junk DCNL DCSP  DCSP if pairs: DCNL DCSP  DCSP  DCSP result.append(pairs) DCNL DCSP return result\n", "intent": "parse header values into a list of lists containing key .\n", "question_id": 600}, {"snippet": "def dbref(dbref, reqhash=True): DCNL  DCSP if reqhash: DCNL DCSP  DCSP num = (int(dbref.lstrip('#')) if (isinstance(dbref, basestring) and dbref.startswith('#') and dbref.lstrip('#').isdigit()) else None) DCNL DCSP  DCSP return (num if (num > 0) else None) DCNL DCSP elif isinstance(dbref, basestring): DCNL DCSP  DCSP dbref = dbref.lstrip('#') DCNL DCSP  DCSP return (int(dbref) if (dbref.isdigit() and (int(dbref) > 0)) else None) DCNL DCSP else: DCNL DCSP  DCSP return (dbref if isinstance(dbref, int) else None)\n", "intent": "converts/checks if input is a valid dbref .\n", "question_id": 601}, {"snippet": "@register.function DCNL @jinja2.contextfunction DCNL def queue_tabnav(context): DCNL  DCSP request = context['request'] DCNL DCSP counts = context['queue_counts'] DCNL DCSP apps_reviewing = AppsReviewing(request).get_apps() DCNL DCSP if acl.action_allowed(request, 'Apps', 'Review'): DCNL DCSP  DCSP rv = [(reverse('reviewers.apps.queue_pending'), 'pending', pgettext(counts['pending'], 'Apps DCSP ({0})').format(counts['pending'])), (reverse('reviewers.apps.queue_rereview'), 'rereview', pgettext(counts['rereview'], 'Re-reviews DCSP ({0})').format(counts['rereview'])), (reverse('reviewers.apps.queue_updates'), 'updates', pgettext(counts['updates'], 'Updates DCSP ({0})').format(counts['updates']))] DCNL DCSP  DCSP if acl.action_allowed(request, 'Apps', 'ReviewEscalated'): DCNL DCSP  DCSP  DCSP rv.append((reverse('reviewers.apps.queue_escalated'), 'escalated', pgettext(counts['escalated'], 'Escalations DCSP ({0})').format(counts['escalated']))) DCNL DCSP  DCSP rv.append((reverse('reviewers.apps.apps_reviewing'), 'reviewing', _('Reviewing DCSP ({0})').format(len(apps_reviewing)))) DCNL DCSP  DCSP rv.append((reverse('reviewers.apps.queue_homescreen'), 'homescreen', pgettext(counts['homescreen'], 'Homescreens DCSP ({0})').format(counts['homescreen']))) DCNL DCSP else: DCNL DCSP  DCSP rv = [] DCNL DCSP if acl.action_allowed(request, 'Apps', 'ModerateReview'): DCNL DCSP  DCSP rv.append((reverse('reviewers.apps.queue_moderated'), 'moderated', pgettext(counts['moderated'], 'Moderated DCSP Reviews DCSP ({0})').format(counts['moderated']))) DCNL DCSP if acl.action_allowed(request, 'Apps', 'ReadAbuse'): DCNL DCSP  DCSP rv.append((reverse('reviewers.apps.queue_abuse'), 'abuse', pgettext(counts['abuse'], 'Abuse DCSP Reports DCSP ({0})').format(counts['abuse']))) DCNL DCSP if acl.action_allowed(request, 'Websites', 'ReadAbuse'): DCNL DCSP  DCSP rv.append((reverse('reviewers.websites.queue_abuse'), 'abusewebsites', pgettext(counts['abusewebsites'], 'Website DCSP Abuse DCSP Reports DCSP ({0})').format(counts['abusewebsites']))) DCNL DCSP return rv\n", "intent": "returns tuple of tab navigation for the queue pages .\n", "question_id": 602}, {"snippet": "@login_required DCNL @require_POST DCNL def add_contributor(request, document_slug): DCNL  DCSP document = get_object_or_404(Document, locale=request.LANGUAGE_CODE, slug=document_slug) DCNL DCSP if (not document.allows(request.user, 'edit')): DCNL DCSP  DCSP raise PermissionDenied DCNL DCSP form = AddContributorForm(request.POST) DCNL DCSP if form.is_valid(): DCNL DCSP  DCSP for user in form.cleaned_data['users']: DCNL DCSP  DCSP  DCSP document.contributors.add(user) DCNL DCSP  DCSP msg = _('{users} DCSP added DCSP to DCSP the DCSP contributors DCSP successfully!').format(users=request.POST.get('users')) DCNL DCSP  DCSP messages.add_message(request, messages.SUCCESS, msg) DCNL DCSP  DCSP return HttpResponseRedirect(reverse('wiki.document_revisions', args=[document_slug])) DCNL DCSP msg = _('There DCSP were DCSP errors DCSP adding DCSP new DCSP contributors, DCSP see DCSP below.') DCNL DCSP messages.add_message(request, messages.ERROR, msg) DCNL DCSP return document_revisions(request, document_slug, contributor_form=form)\n", "intent": "add a contributor to a document .\n", "question_id": 603}, {"snippet": "def run_dummy_heroku_worker(sandbox, _imminent_shutdown_delay): DCNL  DCSP sys.stderr = open(os.path.join(sandbox, u'stderr.log'), u'w') DCNL DCSP class TestHerokuWorker(HerokuWorker, ): DCNL DCSP  DCSP imminent_shutdown_delay = _imminent_shutdown_delay DCNL DCSP  DCSP def perform_job(self, job, queue): DCNL DCSP  DCSP  DCSP create_file(os.path.join(sandbox, u'started')) DCNL DCSP  DCSP  DCSP for i in range(20): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.1) DCNL DCSP  DCSP  DCSP create_file(os.path.join(sandbox, u'finished')) DCNL DCSP w = TestHerokuWorker(Queue(u'dummy')) DCNL DCSP w.main_work_horse(None, None)\n", "intent": "run the work horse for a simplified heroku worker where perform_job just creates two sentinel files 2 seconds apart .\n", "question_id": 604}, {"snippet": "def __virtual__(): DCNL  DCSP if (not HAS_BOTO): DCNL DCSP  DCSP return (False, 'The DCSP boto_elb DCSP module DCSP cannot DCSP be DCSP loaded: DCSP boto DCSP library DCSP not DCSP found') DCNL DCSP __utils__['boto.assign_funcs'](__name__, 'elb', module='ec2.elb', pack=__salt__) DCNL DCSP return True\n", "intent": "only load if boto libraries exist .\n", "question_id": 605}, {"snippet": "def getNewDerivation(elementNode): DCNL  DCSP return ImportDerivation(elementNode)\n", "intent": "get new derivation .\n", "question_id": 606}, {"snippet": "def split_path(path): DCNL  DCSP path = path.lstrip('/') DCNL DCSP (first, _, rest) = path.partition('/') DCNL DCSP lang = first.lower() DCNL DCSP if (lang in settings.LANGUAGE_URL_MAP): DCNL DCSP  DCSP return (settings.LANGUAGE_URL_MAP[lang], rest) DCNL DCSP elif (get_non_supported(lang) is not None): DCNL DCSP  DCSP return (get_non_supported(lang), rest) DCNL DCSP else: DCNL DCSP  DCSP supported = find_supported(first) DCNL DCSP  DCSP if supported: DCNL DCSP  DCSP  DCSP return (supported[0], rest) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('', path)\n", "intent": "split the requested path into .\n", "question_id": 607}, {"snippet": "def get_ip_port_afi(host_and_port_str): DCNL  DCSP host_and_port_str = host_and_port_str.strip() DCNL DCSP if host_and_port_str.startswith('['): DCNL DCSP  DCSP af = socket.AF_INET6 DCNL DCSP  DCSP (host, rest) = host_and_port_str[1:].split(']') DCNL DCSP  DCSP if rest: DCNL DCSP  DCSP  DCSP port = int(rest[1:]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = DEFAULT_KAFKA_PORT DCNL DCSP  DCSP return (host, port, af) DCNL DCSP elif (':' not in host_and_port_str): DCNL DCSP  DCSP af = _address_family(host_and_port_str) DCNL DCSP  DCSP return (host_and_port_str, DEFAULT_KAFKA_PORT, af) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP socket.inet_pton(socket.AF_INET6, host_and_port_str) DCNL DCSP  DCSP  DCSP return (host_and_port_str, DEFAULT_KAFKA_PORT, socket.AF_INET6) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP log.warning('socket.inet_pton DCSP not DCSP available DCSP on DCSP this DCSP platform. DCSP consider DCSP `pip DCSP install DCSP win_inet_pton`') DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP except (ValueError, socket.error): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP (host, port) = host_and_port_str.rsplit(':', 1) DCNL DCSP  DCSP port = int(port) DCNL DCSP  DCSP af = _address_family(host) DCNL DCSP  DCSP return (host, port, af)\n", "intent": "parse the ip and port from a string in the format of: * host_or_ip          <- can be either ipv4 address literal or hostname/fqdn * host_or_ipv4:port   <- can be either ipv4 address literal or hostname/fqdn * [host_or_ip]        <- ipv6 address literal * [host_or_ip]:port .\n", "question_id": 608}, {"snippet": "@csrf_exempt DCNL def spell_check(request): DCNL  DCSP try: DCNL DCSP  DCSP if (not enchant): DCNL DCSP  DCSP  DCSP raise RuntimeError('install DCSP pyenchant DCSP for DCSP spellchecker DCSP functionality') DCNL DCSP  DCSP raw = force_text(request.body) DCNL DCSP  DCSP input = json.loads(raw) DCNL DCSP  DCSP id = input['id'] DCNL DCSP  DCSP method = input['method'] DCNL DCSP  DCSP params = input['params'] DCNL DCSP  DCSP lang = params[0] DCNL DCSP  DCSP arg = params[1] DCNL DCSP  DCSP if (not enchant.dict_exists(str(lang))): DCNL DCSP  DCSP  DCSP raise RuntimeError('dictionary DCSP not DCSP found DCSP for DCSP language DCSP {!r}'.format(lang)) DCNL DCSP  DCSP checker = enchant.Dict(str(lang)) DCNL DCSP  DCSP if (method == 'checkWords'): DCNL DCSP  DCSP  DCSP result = [word for word in arg if (word and (not checker.check(word)))] DCNL DCSP  DCSP elif (method == 'getSuggestions'): DCNL DCSP  DCSP  DCSP result = checker.suggest(arg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError('Unknown DCSP spellcheck DCSP method: DCSP {!r}'.format(method)) DCNL DCSP  DCSP output = {'id': id, 'result': result, 'error': None} DCNL DCSP except Exception: DCNL DCSP  DCSP logging.exception('Error DCSP running DCSP spellchecker') DCNL DCSP  DCSP return HttpResponse(_('Error DCSP running DCSP spellchecker')) DCNL DCSP return HttpResponse(json.dumps(output), content_type='application/json')\n", "intent": "returns a httpresponse that implements the tinymce spellchecker protocol .\n", "question_id": 609}, {"snippet": "def html_error_template(): DCNL  DCSP import mako.template DCNL DCSP return mako.template.Template('\\n<%!\\n DCSP  DCSP  DCSP  DCSP from DCSP mako.exceptions DCSP import DCSP RichTraceback, DCSP syntax_highlight,\\\\\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pygments_html_formatter\\n%>\\n<%page DCSP args=\"full=True, DCSP css=True, DCSP error=None, DCSP traceback=None\"/>\\n% DCSP if DCSP full:\\n<html>\\n<head>\\n DCSP  DCSP  DCSP  DCSP <title>Mako DCSP Runtime DCSP Error</title>\\n% DCSP endif\\n% DCSP if DCSP css:\\n DCSP  DCSP  DCSP  DCSP <style>\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP body DCSP { DCSP font-family:verdana; DCSP margin:10px DCSP 30px DCSP 10px DCSP 30px;}\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .stacktrace DCSP { DCSP margin:5px DCSP 5px DCSP 5px DCSP 5px; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .highlight DCSP { DCSP padding:0px DCSP 10px DCSP 0px DCSP 10px; DCSP background-color:#9F9FDF; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .nonhighlight DCSP { DCSP padding:0px; DCSP background-color:#DFDFDF; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .sample DCSP { DCSP padding:10px; DCSP margin:10px DCSP 10px DCSP 10px DCSP 10px;\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP font-family:monospace; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .sampleline DCSP { DCSP padding:0px DCSP 10px DCSP 0px DCSP 10px; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .sourceline DCSP { DCSP margin:5px DCSP 5px DCSP 10px DCSP 5px; DCSP font-family:monospace;}\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .location DCSP { DCSP font-size:80%; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .highlight DCSP { DCSP white-space:pre; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .sampleline DCSP { DCSP white-space:pre; DCSP }\\n\\n DCSP  DCSP  DCSP  DCSP % DCSP if DCSP pygments_html_formatter:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ${pygments_html_formatter.get_style_defs()}\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .linenos DCSP { DCSP min-width: DCSP 2.5em; DCSP text-align: DCSP right; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pre DCSP { DCSP margin: DCSP 0; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .syntax-highlighted DCSP { DCSP padding: DCSP 0 DCSP 10px; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .syntax-highlightedtable DCSP { DCSP border-spacing: DCSP 1px; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .nonhighlight DCSP { DCSP border-top: DCSP 1px DCSP solid DCSP #DFDFDF;\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP border-bottom: DCSP 1px DCSP solid DCSP #DFDFDF; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .stacktrace DCSP .nonhighlight DCSP { DCSP margin: DCSP 5px DCSP 15px DCSP 10px; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .sourceline DCSP { DCSP margin: DCSP 0 DCSP 0; DCSP font-family:monospace; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .code DCSP { DCSP background-color: DCSP #F8F8F8; DCSP width: DCSP 100%; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .error DCSP .code DCSP { DCSP background-color: DCSP #FFBDBD; DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .error DCSP .syntax-highlighted DCSP { DCSP background-color: DCSP #FFBDBD; DCSP }\\n DCSP  DCSP  DCSP  DCSP % DCSP endif\\n\\n DCSP  DCSP  DCSP  DCSP </style>\\n% DCSP endif\\n% DCSP if DCSP full:\\n</head>\\n<body>\\n% DCSP endif\\n\\n<h2>Error DCSP !</h2>\\n<%\\n DCSP  DCSP  DCSP  DCSP tback DCSP = DCSP RichTraceback(error=error, DCSP traceback=traceback)\\n DCSP  DCSP  DCSP  DCSP src DCSP = DCSP tback.source\\n DCSP  DCSP  DCSP  DCSP line DCSP = DCSP tback.lineno\\n DCSP  DCSP  DCSP  DCSP if DCSP src:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lines DCSP = DCSP src.split(\\'\\\\n\\')\\n DCSP  DCSP  DCSP  DCSP else:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lines DCSP = DCSP None\\n%>\\n<h3>${tback.errorname}: DCSP ${tback.message|h}</h3>\\n\\n% DCSP if DCSP lines:\\n DCSP  DCSP  DCSP  DCSP <div DCSP class=\"sample\">\\n DCSP  DCSP  DCSP  DCSP <div DCSP class=\"nonhighlight\">\\n% DCSP for DCSP index DCSP in DCSP range(max(0, DCSP line-4),min(len(lines), DCSP line+5)):\\n DCSP  DCSP  DCSP  DCSP <%\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP pygments_html_formatter:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pygments_html_formatter.linenostart DCSP = DCSP index DCSP + DCSP 1\\n DCSP  DCSP  DCSP  DCSP %>\\n DCSP  DCSP  DCSP  DCSP % DCSP if DCSP index DCSP + DCSP 1 DCSP == DCSP line:\\n DCSP  DCSP  DCSP  DCSP <%\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP pygments_html_formatter:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP old_cssclass DCSP = DCSP pygments_html_formatter.cssclass\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pygments_html_formatter.cssclass DCSP = DCSP \\'error DCSP \\' DCSP + DCSP old_cssclass\\n DCSP  DCSP  DCSP  DCSP %>\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ${lines[index] DCSP | DCSP syntax_highlight(language=\\'mako\\')}\\n DCSP  DCSP  DCSP  DCSP <%\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP pygments_html_formatter:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pygments_html_formatter.cssclass DCSP = DCSP old_cssclass\\n DCSP  DCSP  DCSP  DCSP %>\\n DCSP  DCSP  DCSP  DCSP % DCSP else:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ${lines[index] DCSP | DCSP syntax_highlight(language=\\'mako\\')}\\n DCSP  DCSP  DCSP  DCSP % DCSP endif\\n% DCSP endfor\\n DCSP  DCSP  DCSP  DCSP </div>\\n DCSP  DCSP  DCSP  DCSP </div>\\n% DCSP endif\\n\\n<div DCSP class=\"stacktrace\">\\n% DCSP for DCSP (filename, DCSP lineno, DCSP function, DCSP line) DCSP in DCSP tback.reverse_traceback:\\n DCSP  DCSP  DCSP  DCSP <div DCSP class=\"location\">${filename}, DCSP line DCSP ${lineno}:</div>\\n DCSP  DCSP  DCSP  DCSP <div DCSP class=\"nonhighlight\">\\n DCSP  DCSP  DCSP  DCSP <%\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP pygments_html_formatter:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pygments_html_formatter.linenostart DCSP = DCSP lineno\\n DCSP  DCSP  DCSP  DCSP %>\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <div DCSP class=\"sourceline\">${line DCSP | DCSP syntax_highlight(filename)}</div>\\n DCSP  DCSP  DCSP  DCSP </div>\\n% DCSP endfor\\n</div>\\n\\n% DCSP if DCSP full:\\n</body>\\n</html>\\n% DCSP endif\\n', output_encoding=sys.getdefaultencoding(), encoding_errors='htmlentityreplace')\n", "intent": "provides a template that renders a stack trace in an html format .\n", "question_id": 610}, {"snippet": "def hough_ellipse(img, threshold=4, accuracy=1, min_size=4, max_size=None): DCNL  DCSP return _hough_ellipse(img, threshold, accuracy, min_size, max_size)\n", "intent": "perform an elliptical hough transform .\n", "question_id": 611}, {"snippet": "def _invalidate_queue(q, val=None, sync=True): DCNL  DCSP def _qsize(len=len): DCNL DCSP  DCSP return 1 DCNL DCSP def _put(item): DCNL DCSP  DCSP pass DCNL DCSP def _get(): DCNL DCSP  DCSP return val DCNL DCSP if sync: DCNL DCSP  DCSP q.mutex.acquire() DCNL DCSP try: DCNL DCSP  DCSP q.maxsize = 2 DCNL DCSP  DCSP q._qsize = _qsize DCNL DCSP  DCSP q._put = _put DCNL DCSP  DCSP q._get = _get DCNL DCSP  DCSP q.not_empty.notifyAll() DCNL DCSP  DCSP q.not_full.notifyAll() DCNL DCSP finally: DCNL DCSP  DCSP if sync: DCNL DCSP  DCSP  DCSP q.mutex.release()\n", "intent": "breaks a queue such that it never blocks .\n", "question_id": 612}, {"snippet": "def LoadSingleCron(cron_info, open_fn=None): DCNL  DCSP builder = yaml_object.ObjectBuilder(CronInfoExternal) DCNL DCSP handler = yaml_builder.BuilderHandler(builder) DCNL DCSP listener = yaml_listener.EventListener(handler) DCNL DCSP listener.Parse(cron_info) DCNL DCSP cron_info_result = handler.GetResults() DCNL DCSP if (len(cron_info_result) < 1): DCNL DCSP  DCSP raise MalformedCronfigurationFile('Empty DCSP cron DCSP configuration.') DCNL DCSP if (len(cron_info_result) > 1): DCNL DCSP  DCSP raise MalformedCronfigurationFile('Multiple DCSP cron DCSP sections DCSP in DCSP configuration.') DCNL DCSP return cron_info_result[0]\n", "intent": "load a cron .\n", "question_id": 613}, {"snippet": "def build_tier_tree(devices): DCNL  DCSP tier2children = defaultdict(set) DCNL DCSP for dev in devices: DCNL DCSP  DCSP for tier in tiers_for_dev(dev): DCNL DCSP  DCSP  DCSP if (len(tier) > 1): DCNL DCSP  DCSP  DCSP  DCSP tier2children[tier[0:(-1)]].add(tier) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tier2children[()].add(tier) DCNL DCSP return tier2children\n", "intent": "construct the tier tree from the zone layout .\n", "question_id": 614}, {"snippet": "def setup_nest(hass, nest, config, pin=None): DCNL  DCSP if (pin is not None): DCNL DCSP  DCSP _LOGGER.debug('pin DCSP acquired, DCSP requesting DCSP access DCSP token') DCNL DCSP  DCSP nest.request_token(pin) DCNL DCSP if (nest.access_token is None): DCNL DCSP  DCSP _LOGGER.debug('no DCSP access_token, DCSP requesting DCSP configuration') DCNL DCSP  DCSP request_configuration(nest, hass, config) DCNL DCSP  DCSP return DCNL DCSP if ('nest' in _CONFIGURING): DCNL DCSP  DCSP _LOGGER.debug('configuration DCSP done') DCNL DCSP  DCSP configurator = get_component('configurator') DCNL DCSP  DCSP configurator.request_done(_CONFIGURING.pop('nest')) DCNL DCSP _LOGGER.debug('proceeding DCSP with DCSP setup') DCNL DCSP conf = config[DOMAIN] DCNL DCSP hass.data[DATA_NEST] = NestDevice(hass, conf, nest) DCNL DCSP _LOGGER.debug('proceeding DCSP with DCSP discovery') DCNL DCSP discovery.load_platform(hass, 'climate', DOMAIN, {}, config) DCNL DCSP discovery.load_platform(hass, 'camera', DOMAIN, {}, config) DCNL DCSP sensor_config = conf.get(CONF_SENSORS, {}) DCNL DCSP discovery.load_platform(hass, 'sensor', DOMAIN, sensor_config, config) DCNL DCSP binary_sensor_config = conf.get(CONF_BINARY_SENSORS, {}) DCNL DCSP discovery.load_platform(hass, 'binary_sensor', DOMAIN, binary_sensor_config, config) DCNL DCSP _LOGGER.debug('setup DCSP done') DCNL DCSP return True\n", "intent": "setup nest devices .\n", "question_id": 615}, {"snippet": "def apropos(key): DCNL  DCSP def callback(path, modname, desc): DCNL DCSP  DCSP if (modname[(-9):] == '.__init__'): DCNL DCSP  DCSP  DCSP modname = (modname[:(-9)] + ' DCSP (package)') DCNL DCSP  DCSP print modname, (desc and ('- DCSP ' + desc)) DCNL DCSP def onerror(modname): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP import warnings DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP warnings.filterwarnings('ignore') DCNL DCSP ModuleScanner().run(callback, key, onerror=onerror)\n", "intent": "print all the one-line module summaries that contain a substring .\n", "question_id": 616}, {"snippet": "def _install_instrumented_lookups(): DCNL  DCSP _install_lookups(dict(instance_state=_instrumentation_factory.state_of, instance_dict=_instrumentation_factory.dict_of, manager_of_class=_instrumentation_factory.manager_of_class))\n", "intent": "replace global class/object management functions with extendedinstrumentationregistry implementations .\n", "question_id": 617}, {"snippet": "def search_reverse(prog, chars, col): DCNL  DCSP m = prog.search(chars) DCNL DCSP if (not m): DCNL DCSP  DCSP return None DCNL DCSP found = None DCNL DCSP (i, j) = m.span() DCNL DCSP while ((i < col) and (j <= col)): DCNL DCSP  DCSP found = m DCNL DCSP  DCSP if (i == j): DCNL DCSP  DCSP  DCSP j = (j + 1) DCNL DCSP  DCSP m = prog.search(chars, j) DCNL DCSP  DCSP if (not m): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (i, j) = m.span() DCNL DCSP return found\n", "intent": "search backwards and return an re match object or none .\n", "question_id": 618}, {"snippet": "def make_increasing_candle(open, high, low, close, dates, **kwargs): DCNL  DCSP (increase_x, increase_y) = _Candlestick(open, high, low, close, dates, **kwargs).get_candle_increase() DCNL DCSP if ('line' in kwargs): DCNL DCSP  DCSP kwargs.setdefault('fillcolor', kwargs['line']['color']) DCNL DCSP else: DCNL DCSP  DCSP kwargs.setdefault('fillcolor', _DEFAULT_INCREASING_COLOR) DCNL DCSP if ('name' in kwargs): DCNL DCSP  DCSP kwargs.setdefault('showlegend', True) DCNL DCSP else: DCNL DCSP  DCSP kwargs.setdefault('showlegend', False) DCNL DCSP kwargs.setdefault('name', 'Increasing') DCNL DCSP kwargs.setdefault('line', dict(color=_DEFAULT_INCREASING_COLOR)) DCNL DCSP candle_incr_data = dict(type='box', x=increase_x, y=increase_y, whiskerwidth=0, boxpoints=False, **kwargs) DCNL DCSP return [candle_incr_data]\n", "intent": "makes boxplot trace for increasing candlesticks _make_increasing_candle() and _make_decreasing_candle separate the increasing traces from the decreasing traces so kwargs  can be passed separately to increasing or decreasing traces when direction is set to increasing or decreasing in figurefactory .\n", "question_id": 619}, {"snippet": "def isGoodResult(name, show, log=True): DCNL  DCSP all_show_names = allPossibleShowNames(show) DCNL DCSP showNames = (map(sanitizeSceneName, all_show_names) + all_show_names) DCNL DCSP for curName in set(showNames): DCNL DCSP  DCSP escaped_name = re.sub('\\\\\\\\[\\\\s.-]', '\\\\W+', re.escape(curName)) DCNL DCSP  DCSP if show.startyear: DCNL DCSP  DCSP  DCSP escaped_name += (('(?:\\\\W+' + str(show.startyear)) + ')?') DCNL DCSP  DCSP curRegex = (('^' + escaped_name) + '\\\\W+(?:(?:S\\\\d[\\\\dE._ DCSP -])|(?:\\\\d\\\\d?x)|(?:\\\\d{4}\\\\W\\\\d\\\\d\\\\W\\\\d\\\\d)|(?:(?:part|pt)[\\\\._ DCSP -]?(\\\\d|[ivx]))|Season\\\\W+\\\\d+\\\\W+|E\\\\d+\\\\W+)') DCNL DCSP  DCSP if log: DCNL DCSP  DCSP  DCSP logger.log((((u'Checking DCSP if DCSP show DCSP ' + name) + ' DCSP matches DCSP ') + curRegex), logger.DEBUG) DCNL DCSP  DCSP match = re.search(curRegex, name, re.I) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP logger.log((((u'Matched DCSP ' + curRegex) + ' DCSP to DCSP ') + name), logger.DEBUG) DCNL DCSP  DCSP  DCSP return True DCNL DCSP if log: DCNL DCSP  DCSP logger.log(((((u'Provider DCSP gave DCSP result DCSP ' + name) + \" DCSP but DCSP that DCSP doesn't DCSP seem DCSP like DCSP a DCSP valid DCSP result DCSP for DCSP \") + show.name) + \" DCSP so DCSP I'm DCSP ignoring DCSP it\")) DCNL DCSP return False\n", "intent": "use an automatically-created regex to make sure the result actually is the show it claims to be .\n", "question_id": 620}, {"snippet": "def check_entrance_exam_problems_for_rescoring(exam_key): DCNL  DCSP problems = get_problems_in_section(exam_key).values() DCNL DCSP if any((((not hasattr(problem, 'module_class')) or (not hasattr(problem.module_class, 'rescore_problem'))) for problem in problems)): DCNL DCSP  DCSP msg = _('Not DCSP all DCSP problems DCSP in DCSP entrance DCSP exam DCSP support DCSP re-scoring.') DCNL DCSP  DCSP raise NotImplementedError(msg)\n", "intent": "grabs all problem descriptors in exam and checks each descriptor to confirm that it supports re-scoring .\n", "question_id": 621}, {"snippet": "def test_relative_requirements_file(script, data): DCNL  DCSP url = (path_to_url(os.path.join(data.root, 'packages', '..', 'packages', 'FSPkg')) + '#egg=FSPkg') DCNL DCSP script.scratch_path.join('file-egg-req.txt').write(textwrap.dedent((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % url))) DCNL DCSP result = script.pip('install', '-vvv', '-r', (script.scratch_path / 'file-egg-req.txt')) DCNL DCSP assert (((script.site_packages / 'FSPkg-0.1.dev0-py%s.egg-info') % pyversion) in result.files_created), str(result) DCNL DCSP assert ((script.site_packages / 'fspkg') in result.files_created), str(result.stdout)\n", "intent": "test installing from a requirements file with a relative path with an egg= definition .\n", "question_id": 622}, {"snippet": "def contextwin(l, win): DCNL  DCSP assert ((win % 2) == 1) DCNL DCSP assert (win >= 1) DCNL DCSP l = list(l) DCNL DCSP lpadded = ((((win // 2) * [(-1)]) + l) + ((win // 2) * [(-1)])) DCNL DCSP out = [lpadded[i:(i + win)] for i in range(len(l))] DCNL DCSP assert (len(out) == len(l)) DCNL DCSP return out\n", "intent": "win :: int corresponding to the size of the window given a list of indexes composing a sentence l :: array containing the word indexes it will return a list of list of indexes corresponding to context windows surrounding each word in the sentence .\n", "question_id": 623}, {"snippet": "def log(*args): DCNL  DCSP for v in args: DCNL DCSP  DCSP sys.stderr.write(str(v)) DCNL DCSP sys.stderr.write('\\n')\n", "intent": "write a msg to stderr .\n", "question_id": 624}, {"snippet": "def imp_type_for_filename(filename): DCNL  DCSP for type_data in imp.get_suffixes(): DCNL DCSP  DCSP extension = type_data[0] DCNL DCSP  DCSP if filename.endswith(extension): DCNL DCSP  DCSP  DCSP return type_data DCNL DCSP return None\n", "intent": "given the name of a python module .\n", "question_id": 625}, {"snippet": "def s3_str(s): DCNL  DCSP if (type(s) is str): DCNL DCSP  DCSP return s DCNL DCSP else: DCNL DCSP  DCSP return s3_unicode(s).encode('utf-8', 'strict')\n", "intent": "unicode-safe conversion of an object s into a utf-8 encoded str .\n", "question_id": 626}, {"snippet": "def _compute_gapopen_num(hsp): DCNL  DCSP gapopen = 0 DCNL DCSP for seq_type in ('query', 'hit'): DCNL DCSP  DCSP seq = str(getattr(hsp, seq_type).seq) DCNL DCSP  DCSP gapopen += len(re.findall(_RE_GAPOPEN, seq)) DCNL DCSP return gapopen\n", "intent": "returns the number of gap openings in the given hsp .\n", "question_id": 627}, {"snippet": "def basicConfig(**kwargs): DCNL  DCSP _acquireLock() DCNL DCSP try: DCNL DCSP  DCSP if (len(root.handlers) == 0): DCNL DCSP  DCSP  DCSP filename = kwargs.get('filename') DCNL DCSP  DCSP  DCSP if filename: DCNL DCSP  DCSP  DCSP  DCSP mode = kwargs.get('filemode', 'a') DCNL DCSP  DCSP  DCSP  DCSP hdlr = FileHandler(filename, mode) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP stream = kwargs.get('stream') DCNL DCSP  DCSP  DCSP  DCSP hdlr = StreamHandler(stream) DCNL DCSP  DCSP  DCSP fs = kwargs.get('format', BASIC_FORMAT) DCNL DCSP  DCSP  DCSP dfs = kwargs.get('datefmt', None) DCNL DCSP  DCSP  DCSP fmt = Formatter(fs, dfs) DCNL DCSP  DCSP  DCSP hdlr.setFormatter(fmt) DCNL DCSP  DCSP  DCSP root.addHandler(hdlr) DCNL DCSP  DCSP  DCSP level = kwargs.get('level') DCNL DCSP  DCSP  DCSP if (level is not None): DCNL DCSP  DCSP  DCSP  DCSP root.setLevel(level) DCNL DCSP finally: DCNL DCSP  DCSP _releaseLock()\n", "intent": "do basic configuration for the logging system .\n", "question_id": 628}, {"snippet": "def fitness_calculator(genome): DCNL  DCSP assert isinstance(genome, MutableSeq), 'Expected DCSP MutableSeq DCSP for DCSP a DCSP genome.' DCNL DCSP regular_seq = genome.toseq() DCNL DCSP return int(str(regular_seq))\n", "intent": "calculate fitness for testing purposes .\n", "question_id": 629}, {"snippet": "def depth_getter(obj, current_depth=0, depth_stack=None, nest_info=u'top DCSP level DCSP object'): DCNL  DCSP if (depth_stack is None): DCNL DCSP  DCSP depth_stack = {} DCNL DCSP if (id(obj) in depth_stack): DCNL DCSP  DCSP stack = depth_stack[id(obj)] DCNL DCSP  DCSP if (stack[0] > current_depth): DCNL DCSP  DCSP  DCSP del depth_stack[id(obj)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return depth_stack DCNL DCSP depth_stack[id(obj)] = (current_depth, obj, nest_info) DCNL DCSP if isinstance(obj, (list, tuple)): DCNL DCSP  DCSP for (i, item) in enumerate(obj): DCNL DCSP  DCSP  DCSP depth_getter(item, current_depth=(current_depth + 1), depth_stack=depth_stack, nest_info=(u'list/tuple DCSP item DCSP #%s DCSP in DCSP (%s)' % (i, nest_info))) DCNL DCSP else: DCNL DCSP  DCSP if isinstance(obj, dict): DCNL DCSP  DCSP  DCSP state = obj DCNL DCSP  DCSP elif hasattr(obj, u'__getstate__'): DCNL DCSP  DCSP  DCSP state = obj.__getstate__() DCNL DCSP  DCSP  DCSP if (not isinstance(state, dict)): DCNL DCSP  DCSP  DCSP  DCSP state = {} DCNL DCSP  DCSP elif hasattr(obj, u'__dict__'): DCNL DCSP  DCSP  DCSP state = obj.__dict__ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state = {} DCNL DCSP  DCSP for (key, value) in six.iteritems(state): DCNL DCSP  DCSP  DCSP depth_getter(value, current_depth=(current_depth + 1), depth_stack=depth_stack, nest_info=(u'attribute DCSP \"%s\" DCSP in DCSP (%s)' % (key, nest_info))) DCNL DCSP return depth_stack\n", "intent": "returns a dictionary mapping: id:  for the given object .\n", "question_id": 630}, {"snippet": "def revoke_certs_by_user_and_project(user_id, project_id): DCNL  DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_user_and_project(admin, user_id, project_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])\n", "intent": "revoke certs for user in project .\n", "question_id": 631}, {"snippet": "def test_cleanup_after_egg_info_exception(script, data): DCNL  DCSP result = script.pip('install', '-f', data.find_links, '--no-index', 'brokenegginfo==0.1', expect_error=True) DCNL DCSP build = (script.venv_path / 'build') DCNL DCSP assert (not exists(build)), ('build/ DCSP dir DCSP still DCSP exists: DCSP %s' % result.stdout) DCNL DCSP script.assert_no_temp()\n", "intent": "test clean up after a setup .\n", "question_id": 632}, {"snippet": "def assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True): DCNL  DCSP numpy.testing.assert_array_almost_equal(cupy.asnumpy(x), cupy.asnumpy(y), decimal=decimal, err_msg=err_msg, verbose=verbose)\n", "intent": "raises an assertionerror if objects are not equal up to desired precision .\n", "question_id": 633}, {"snippet": "def post(url, data=None, json=None, **kwargs): DCNL  DCSP return request('post', url, data=data, json=json, **kwargs)\n", "intent": "sends a post request .\n", "question_id": 634}, {"snippet": "def _consume_subscriptions(topic): DCNL  DCSP return list(topic.list_subscriptions())\n", "intent": "consume entire iterator .\n", "question_id": 635}, {"snippet": "def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP devices = [] DCNL DCSP for (name, device_cfg) in config[CONF_DEVICES].items(): DCNL DCSP  DCSP mac = device_cfg[CONF_MAC] DCNL DCSP  DCSP devices.append(EQ3BTSmartThermostat(mac, name)) DCNL DCSP add_devices(devices)\n", "intent": "setup the eq-3 ble thermostats .\n", "question_id": 636}, {"snippet": "def reverse(registry, xml_parent, data): DCNL  DCSP reserveBuildTrigger = XML.SubElement(xml_parent, 'jenkins.triggers.ReverseBuildTrigger') DCNL DCSP supported_thresholds = ['SUCCESS', 'UNSTABLE', 'FAILURE'] DCNL DCSP XML.SubElement(reserveBuildTrigger, 'spec').text = '' DCNL DCSP jobs = data.get('jobs') DCNL DCSP if isinstance(jobs, list): DCNL DCSP  DCSP jobs = ','.join(jobs) DCNL DCSP XML.SubElement(reserveBuildTrigger, 'upstreamProjects').text = jobs DCNL DCSP threshold = XML.SubElement(reserveBuildTrigger, 'threshold') DCNL DCSP result = str(data.get('result', 'success')).upper() DCNL DCSP if (result not in supported_thresholds): DCNL DCSP  DCSP raise jenkins_jobs.errors.JenkinsJobsException(('Choice DCSP should DCSP be DCSP one DCSP of DCSP the DCSP following DCSP options: DCSP %s.' % ', DCSP '.join(supported_thresholds))) DCNL DCSP XML.SubElement(threshold, 'name').text = hudson_model.THRESHOLDS[result]['name'] DCNL DCSP XML.SubElement(threshold, 'ordinal').text = hudson_model.THRESHOLDS[result]['ordinal'] DCNL DCSP XML.SubElement(threshold, 'color').text = hudson_model.THRESHOLDS[result]['color'] DCNL DCSP XML.SubElement(threshold, 'completeBuild').text = str(hudson_model.THRESHOLDS[result]['complete']).lower()\n", "intent": "yaml: reverse this trigger can be configured in the ui using the checkbox with the following text: build after other projects are built .\n", "question_id": 637}, {"snippet": "def add_pool_member(lb, name, port, pool_name): DCNL  DCSP if __opts__['load_balancers'].get(lb, None): DCNL DCSP  DCSP (username, password) = list(__opts__['load_balancers'][lb].values()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Unable DCSP to DCSP find DCSP `{0}` DCSP load DCSP balancer'.format(lb)) DCNL DCSP F5 = F5Mgmt(lb, username, password) DCNL DCSP F5.add_pool_member(name, port, pool_name) DCNL DCSP return True\n", "intent": "add a node to a pool cli examples: .\n", "question_id": 638}, {"snippet": "def _minimal_polynomial_sq(p, n, x): DCNL  DCSP from sympy.simplify.simplify import _is_sum_surds DCNL DCSP p = sympify(p) DCNL DCSP n = sympify(n) DCNL DCSP r = _is_sum_surds(p) DCNL DCSP if ((not n.is_Integer) or (not (n > 0)) or (not _is_sum_surds(p))): DCNL DCSP  DCSP return None DCNL DCSP pn = (p ** Rational(1, n)) DCNL DCSP p -= x DCNL DCSP while 1: DCNL DCSP  DCSP p1 = _separate_sq(p) DCNL DCSP  DCSP if (p1 is p): DCNL DCSP  DCSP  DCSP p = p1.subs({x: (x ** n)}) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP p = p1 DCNL DCSP if (n == 1): DCNL DCSP  DCSP p1 = Poly(p) DCNL DCSP  DCSP if (p.coeff((x ** p1.degree(x))) < 0): DCNL DCSP  DCSP  DCSP p = (- p) DCNL DCSP  DCSP p = p.primitive()[1] DCNL DCSP  DCSP return p DCNL DCSP factors = factor_list(p)[1] DCNL DCSP result = _choose_factor(factors, x, pn) DCNL DCSP return result\n", "intent": "returns the minimal polynomial for the nth-root of a sum of surds or none if it fails .\n", "question_id": 639}, {"snippet": "def search_year(string): DCNL  DCSP match = re.search(u'[^0-9]([0-9]{4})[^0-9]', string) DCNL DCSP if match: DCNL DCSP  DCSP year = int(match.group(1)) DCNL DCSP  DCSP if valid_year(year): DCNL DCSP  DCSP  DCSP return (year, match.span(1)) DCNL DCSP return (None, None)\n", "intent": "looks for year patterns .\n", "question_id": 640}, {"snippet": "def edit(text=None, editor=None, env=None, require_save=True, extension='.txt', filename=None): DCNL  DCSP from ._termui_impl import Editor DCNL DCSP editor = Editor(editor=editor, env=env, require_save=require_save, extension=extension) DCNL DCSP if (filename is None): DCNL DCSP  DCSP return editor.edit(text) DCNL DCSP editor.edit_file(filename)\n", "intent": "edits the given text in the defined editor .\n", "question_id": 641}, {"snippet": "def _get_dir_path(sibling): DCNL  DCSP py_file = __file__.replace('.pyc', '.py') DCNL DCSP dir_paths = [os.path.abspath(os.path.dirname(os.path.realpath(py_file))), os.path.abspath(os.path.dirname(py_file))] DCNL DCSP for dir_path in dir_paths: DCNL DCSP  DCSP sibling_path = os.path.join(dir_path, sibling) DCNL DCSP  DCSP if os.path.exists(sibling_path): DCNL DCSP  DCSP  DCSP return dir_path DCNL DCSP raise ValueError(('Could DCSP not DCSP determine DCSP directory DCSP that DCSP contains DCSP both, DCSP this DCSP file DCSP and DCSP %s.' % sibling))\n", "intent": "get a path to the directory of this script .\n", "question_id": 642}, {"snippet": "def registerAdapter(adapterFactory, origInterface, *interfaceClasses): DCNL  DCSP self = globalRegistry DCNL DCSP assert interfaceClasses, 'You DCSP need DCSP to DCSP pass DCSP an DCSP Interface' DCNL DCSP global ALLOW_DUPLICATES DCNL DCSP if (not isinstance(origInterface, interface.InterfaceClass)): DCNL DCSP  DCSP origInterface = declarations.implementedBy(origInterface) DCNL DCSP for interfaceClass in interfaceClasses: DCNL DCSP  DCSP factory = _registered(self, origInterface, interfaceClass) DCNL DCSP  DCSP if ((factory is not None) and (not ALLOW_DUPLICATES)): DCNL DCSP  DCSP  DCSP raise ValueError(('an DCSP adapter DCSP (%s) DCSP was DCSP already DCSP registered.' % (factory,))) DCNL DCSP for interfaceClass in interfaceClasses: DCNL DCSP  DCSP self.register([origInterface], interfaceClass, '', adapterFactory)\n", "intent": "register an adapter class .\n", "question_id": 643}, {"snippet": "def do_UserChangePassword(po): DCNL  DCSP UserChangePassword(_get_option(po, 'account_name_dn'), _get_option(po, 'password')) DCNL DCSP return 'Password DCSP changed DCSP OK'\n", "intent": "change the password for a specified user .\n", "question_id": 644}, {"snippet": "def is_wrong_i18n_format(n): DCNL  DCSP if isinstance(n.parent, compiler.ast.Mod): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (n.parent.node.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "check _ .\n", "question_id": 645}, {"snippet": "def sort_return_tuples(response, **options): DCNL  DCSP if ((not response) or (not options['groups'])): DCNL DCSP  DCSP return response DCNL DCSP n = options['groups'] DCNL DCSP return list(izip(*[response[i::n] for i in range(n)]))\n", "intent": "if groups is specified .\n", "question_id": 646}, {"snippet": "def dictdoc(method): DCNL  DCSP dict_method = getattr(dict, method.__name__) DCNL DCSP if hasattr(dict_method, '__doc__'): DCNL DCSP  DCSP method.__doc__ = dict_method.__doc__ DCNL DCSP return method\n", "intent": "a decorator making reuse of the ordinary dicts docstrings more concise .\n", "question_id": 647}, {"snippet": "def refresh_window(procs, procs_status): DCNL  DCSP curses.endwin() DCNL DCSP templ = '%-6s DCSP %-8s DCSP %4s DCSP %5s DCSP %5s DCSP %6s DCSP %4s DCSP %9s DCSP  DCSP %2s' DCNL DCSP win.erase() DCNL DCSP header = (templ % ('PID', 'USER', 'NI', 'VIRT', 'RES', 'CPU%', 'MEM%', 'TIME+', 'NAME')) DCNL DCSP print_header(procs_status, len(procs)) DCNL DCSP print_line('') DCNL DCSP print_line(header, highlight=True) DCNL DCSP for p in procs: DCNL DCSP  DCSP if (p.dict['cpu_times'] is not None): DCNL DCSP  DCSP  DCSP ctime = datetime.timedelta(seconds=sum(p.dict['cpu_times'])) DCNL DCSP  DCSP  DCSP ctime = ('%s:%s.%s' % (((ctime.seconds // 60) % 60), str((ctime.seconds % 60)).zfill(2), str(ctime.microseconds)[:2])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ctime = '' DCNL DCSP  DCSP if (p.dict['memory_percent'] is not None): DCNL DCSP  DCSP  DCSP p.dict['memory_percent'] = round(p.dict['memory_percent'], 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP p.dict['memory_percent'] = '' DCNL DCSP  DCSP if (p.dict['cpu_percent'] is None): DCNL DCSP  DCSP  DCSP p.dict['cpu_percent'] = '' DCNL DCSP  DCSP if p.dict['username']: DCNL DCSP  DCSP  DCSP username = p.dict['username'][:8] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP username = '' DCNL DCSP  DCSP line = (templ % (p.pid, username, p.dict['nice'], bytes2human(getattr(p.dict['memory_info'], 'vms', 0)), bytes2human(getattr(p.dict['memory_info'], 'rss', 0)), p.dict['cpu_percent'], p.dict['memory_percent'], ctime, (p.dict['name'] or ''))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP print_line(line) DCNL DCSP  DCSP except curses.error: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP win.refresh()\n", "intent": "print results on screen by using curses .\n", "question_id": 648}, {"snippet": "def _reportCommandLineUsageErrorAndExit(parser, message): DCNL  DCSP print parser.get_usage() DCNL DCSP print message DCNL DCSP sys.exit(1)\n", "intent": "report usage error and exit program with error indication .\n", "question_id": 649}, {"snippet": "def test_stockwell_core(): DCNL  DCSP sfreq = 1000.0 DCNL DCSP dur = 0.5 DCNL DCSP (onset, offset) = (0.175, 0.275) DCNL DCSP n_samp = int((sfreq * dur)) DCNL DCSP t = (np.arange(n_samp) / sfreq) DCNL DCSP pulse_freq = 15.0 DCNL DCSP pulse = np.cos((((2.0 * np.pi) * pulse_freq) * t)) DCNL DCSP pulse[0:int((onset * sfreq))] = 0.0 DCNL DCSP pulse[int((offset * sfreq)):] = 0.0 DCNL DCSP width = 0.5 DCNL DCSP freqs = fftpack.fftfreq(len(pulse), (1.0 / sfreq)) DCNL DCSP (fmin, fmax) = (1.0, 100.0) DCNL DCSP (start_f, stop_f) = [np.abs((freqs - f)).argmin() for f in (fmin, fmax)] DCNL DCSP W = _precompute_st_windows(n_samp, start_f, stop_f, sfreq, width) DCNL DCSP st_pulse = _st(pulse, start_f, W) DCNL DCSP st_pulse = (np.abs(st_pulse) ** 2) DCNL DCSP assert_equal(st_pulse.shape[(-1)], len(pulse)) DCNL DCSP st_max_freq = freqs[st_pulse.max(axis=1).argmax(axis=0)] DCNL DCSP assert_allclose(st_max_freq, pulse_freq, atol=1.0) DCNL DCSP assert_true((onset < t[st_pulse.max(axis=0).argmax(axis=0)] < offset)) DCNL DCSP width = 1.0 DCNL DCSP (start_f, stop_f) = (0, len(pulse)) DCNL DCSP W = _precompute_st_windows(n_samp, start_f, stop_f, sfreq, width) DCNL DCSP y = _st(pulse, start_f, W) DCNL DCSP y_inv = fftpack.ifft(np.sum(y, axis=1)).real DCNL DCSP assert_array_almost_equal(pulse, y_inv)\n", "intent": "test stockwell transform .\n", "question_id": 650}, {"snippet": "def discover_version(client, requested_version): DCNL  DCSP (server_start_version, server_end_version) = _get_server_version_range(client) DCNL DCSP if ((not requested_version.is_latest()) and (requested_version != APIVersion('2.0'))): DCNL DCSP  DCSP if (server_start_version.is_null() and server_end_version.is_null()): DCNL DCSP  DCSP  DCSP raise exceptions.UnsupportedVersion(_(\"Server DCSP doesn't DCSP support DCSP microversions\")) DCNL DCSP  DCSP if (not requested_version.matches(server_start_version, server_end_version)): DCNL DCSP  DCSP  DCSP raise exceptions.UnsupportedVersion((_(\"The DCSP specified DCSP version DCSP isn't DCSP supported DCSP by DCSP server. DCSP The DCSP valid DCSP version DCSP range DCSP is DCSP '%(min)s' DCSP to DCSP '%(max)s'\") % {'min': server_start_version.get_string(), 'max': server_end_version.get_string()})) DCNL DCSP  DCSP return requested_version DCNL DCSP if (requested_version == APIVersion('2.0')): DCNL DCSP  DCSP if ((server_start_version == APIVersion('2.1')) or (server_start_version.is_null() and server_end_version.is_null())): DCNL DCSP  DCSP  DCSP return APIVersion('2.0') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise exceptions.UnsupportedVersion(_(\"The DCSP server DCSP isn't DCSP backward DCSP compatible DCSP with DCSP Nova DCSP V2 DCSP REST DCSP API\")) DCNL DCSP if (server_start_version.is_null() and server_end_version.is_null()): DCNL DCSP  DCSP return APIVersion('2.0') DCNL DCSP elif (novaclient.API_MIN_VERSION > server_end_version): DCNL DCSP  DCSP raise exceptions.UnsupportedVersion((_(\"Server DCSP version DCSP is DCSP too DCSP old. DCSP The DCSP client DCSP valid DCSP version DCSP range DCSP is DCSP '%(client_min)s' DCSP to DCSP '%(client_max)s'. DCSP The DCSP server DCSP valid DCSP version DCSP range DCSP is DCSP '%(server_min)s' DCSP to DCSP '%(server_max)s'.\") % {'client_min': novaclient.API_MIN_VERSION.get_string(), 'client_max': novaclient.API_MAX_VERSION.get_string(), 'server_min': server_start_version.get_string(), 'server_max': server_end_version.get_string()})) DCNL DCSP elif (novaclient.API_MAX_VERSION < server_start_version): DCNL DCSP  DCSP raise exceptions.UnsupportedVersion((_(\"Server DCSP version DCSP is DCSP too DCSP new. DCSP The DCSP client DCSP valid DCSP version DCSP range DCSP is DCSP '%(client_min)s' DCSP to DCSP '%(client_max)s'. DCSP The DCSP server DCSP valid DCSP version DCSP range DCSP is DCSP '%(server_min)s' DCSP to DCSP '%(server_max)s'.\") % {'client_min': novaclient.API_MIN_VERSION.get_string(), 'client_max': novaclient.API_MAX_VERSION.get_string(), 'server_min': server_start_version.get_string(), 'server_max': server_end_version.get_string()})) DCNL DCSP elif (novaclient.API_MAX_VERSION <= server_end_version): DCNL DCSP  DCSP return novaclient.API_MAX_VERSION DCNL DCSP elif (server_end_version < novaclient.API_MAX_VERSION): DCNL DCSP  DCSP return server_end_version\n", "intent": "discover most recent version supported by api and client .\n", "question_id": 651}, {"snippet": "def assert_tokens_equal(x, y): DCNL  DCSP if (len(x) != len(y)): DCNL DCSP  DCSP msg = u'The DCSP tokens DCSP sequences DCSP have DCSP different DCSP lengths: DCSP {0!r} DCSP != DCSP {1!r}\\n' DCNL DCSP  DCSP msg += u'# DCSP x\\n{2}\\n\\n# DCSP y\\n{3}' DCNL DCSP  DCSP pytest.fail(msg.format(len(x), len(y), pformat(x), pformat(y))) DCNL DCSP diffs = [(a, b) for (a, b) in zip(x, y) if (not tokens_equal(a, b))] DCNL DCSP if (len(diffs) > 0): DCNL DCSP  DCSP msg = [u'The DCSP token DCSP sequences DCSP differ: DCSP '] DCNL DCSP  DCSP for (a, b) in diffs: DCNL DCSP  DCSP  DCSP msg += [u'', (u'- DCSP ' + repr(a)), (u'+ DCSP ' + repr(b))] DCNL DCSP  DCSP msg = u'\\n'.join(msg) DCNL DCSP  DCSP pytest.fail(msg) DCNL DCSP return True\n", "intent": "asserts that two token sequences are equal .\n", "question_id": 652}, {"snippet": "def take_sorted(outname, inname, blockdims, index, axis=0): DCNL  DCSP sizes = blockdims[axis] DCNL DCSP index_lists = partition_by_size(sizes, sorted(index)) DCNL DCSP where_index = [i for (i, il) in enumerate(index_lists) if il] DCNL DCSP index_lists = [il for il in index_lists if il] DCNL DCSP dims = [range(len(bd)) for bd in blockdims] DCNL DCSP indims = list(dims) DCNL DCSP indims[axis] = list(range(len(where_index))) DCNL DCSP keys = list(product([outname], *indims)) DCNL DCSP outdims = list(dims) DCNL DCSP outdims[axis] = where_index DCNL DCSP slices = [([colon] * len(bd)) for bd in blockdims] DCNL DCSP slices[axis] = index_lists DCNL DCSP slices = list(product(*slices)) DCNL DCSP inkeys = list(product([inname], *outdims)) DCNL DCSP values = [(getitem, inkey, slc) for (inkey, slc) in zip(inkeys, slices)] DCNL DCSP blockdims2 = list(blockdims) DCNL DCSP blockdims2[axis] = tuple(map(len, index_lists)) DCNL DCSP return (tuple(blockdims2), dict(zip(keys, values)))\n", "intent": "index array with sorted list index forms a dask for the following case x[: .\n", "question_id": 653}, {"snippet": "def addLoopXSegmentIntersections(lineLoopsIntersections, loop, segmentFirstX, segmentSecondX, segmentYMirror, y): DCNL  DCSP rotatedLoop = euclidean.getPointsRoundZAxis(segmentYMirror, loop) DCNL DCSP for pointIndex in xrange(len(rotatedLoop)): DCNL DCSP  DCSP pointFirst = rotatedLoop[pointIndex] DCNL DCSP  DCSP pointSecond = rotatedLoop[((pointIndex + 1) % len(rotatedLoop))] DCNL DCSP  DCSP addLineXSegmentIntersection(lineLoopsIntersections, segmentFirstX, segmentSecondX, pointFirst, pointSecond, y)\n", "intent": "add intersections of the loop with the x segment .\n", "question_id": 654}, {"snippet": "@gen.engine DCNL def ProcessFiles(merged_store, logs_paths, filenames, callback): DCNL  DCSP def _ProcessOneFile(contents, day_stats, device_entries, trace_entries): DCNL DCSP  DCSP 'Iterate DCSP over DCSP the DCSP contents DCSP of DCSP a DCSP processed DCSP file: DCSP one DCSP entry DCSP per DCSP line. DCSP Increment DCSP stats DCSP for DCSP specific DCSP entries.' DCNL DCSP  DCSP buf = cStringIO.StringIO(contents) DCNL DCSP  DCSP buf.seek(0) DCNL DCSP  DCSP context_before = deque(maxlen=(options.options.trace_context_num_lines + 1)) DCNL DCSP  DCSP pending_traces = [] DCNL DCSP  DCSP def _AddTrace(trace_type, timestamp, module, message): DCNL DCSP  DCSP  DCSP trace = {'type': trace_type, 'timestamp': timestamp, 'module': module, 'trace': msg, 'context_before': list(context_before)[:(-1)], 'context_after': []} DCNL DCSP  DCSP  DCSP if (options.options.trace_context_num_lines == 0): DCNL DCSP  DCSP  DCSP  DCSP trace_entries.append(trace) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pending_traces.append(trace) DCNL DCSP  DCSP def _CheckPendingTraces(line): DCNL DCSP  DCSP  DCSP for t in pending_traces: DCNL DCSP  DCSP  DCSP  DCSP t['context_after'].append(line) DCNL DCSP  DCSP  DCSP while (pending_traces and (len(pending_traces[0]['context_after']) >= options.options.trace_context_num_lines)): DCNL DCSP  DCSP  DCSP  DCSP trace_entries.append(pending_traces.pop(0)) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP line = buf.readline() DCNL DCSP  DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP line = line.rstrip('\\n') DCNL DCSP  DCSP  DCSP context_before.append(line) DCNL DCSP  DCSP  DCSP _CheckPendingTraces(line) DCNL DCSP  DCSP  DCSP parsed = logs_util.ParseLogLine(line) DCNL DCSP  DCSP  DCSP if (not parsed): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (day, time, module, msg) = parsed DCNL DCSP  DCSP  DCSP timestamp = logs_util.DayTimeStringsToUTCTimestamp(day, time) DCNL DCSP  DCSP  DCSP if (options.options.process_traceback and re.search(kTracebackRE, line)): DCNL DCSP  DCSP  DCSP  DCSP _AddTrace('traceback', timestamp, module, msg) DCNL DCSP  DCSP  DCSP if (module.startswith('user_op_manager:') or module.startswith('operation:')): DCNL DCSP  DCSP  DCSP  DCSP if msg.startswith('SUCCESS'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parsed = logs_util.ParseSuccessMsg(msg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not parsed): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP (user, device, op, class_name, method_name) = parsed DCNL DCSP  DCSP  DCSP  DCSP  DCSP method = ('%s.%s' % (class_name, method_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP day_stats.ActiveAll(user) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (method in ('Follower.UpdateOperation', 'UpdateFollowerOperation.Execute')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP day_stats.ActiveView(user) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (method in ('Comment.PostOperation', 'PostCommentOperation.Execute')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP day_stats.ActivePost(user) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (method in ('Episode.ShareExistingOperation', 'Episode.ShareNewOperation', 'ShareExistingOperation.Execute', 'ShareNewOperation.Execute')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP day_stats.ActiveShare(user) DCNL DCSP  DCSP  DCSP  DCSP elif msg.startswith('EXECUTE'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parsed = logs_util.ParseExecuteMsg(msg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not parsed): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP (user, device, op, class_name, method_name, request) = parsed DCNL DCSP  DCSP  DCSP  DCSP  DCSP method = ('%s.%s' % (class_name, method_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (method in ('Device.UpdateOperation', 'User.RegisterOperation', 'RegisterUserOperation.Execute')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP req_dict = eval(request) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP device_entries.append({'method': method, 'timestamp': timestamp, 'request': req_dict}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif msg.startswith('ABORT'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if options.options.process_op_abort: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _AddTrace('abort', timestamp, module, msg) DCNL DCSP  DCSP  DCSP elif (module.startswith('base:') and msg.startswith('/ping DCSP OK:')): DCNL DCSP  DCSP  DCSP  DCSP req_str = logs_util.ParsePingMsg(msg) DCNL DCSP  DCSP  DCSP  DCSP if (not req_str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP req_dict = json.loads(req_str) DCNL DCSP  DCSP  DCSP  DCSP  DCSP device_entries.append({'method': 'ping', 'timestamp': timestamp, 'request': req_dict}) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (module.startswith('ping:') and msg.startswith('ping DCSP OK:')): DCNL DCSP  DCSP  DCSP  DCSP (req_str, resp_str) = logs_util.ParseNewPingMsg(msg) DCNL DCSP  DCSP  DCSP  DCSP if ((not req_str) or (not resp_str)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP req_dict = json.loads(req_str) DCNL DCSP  DCSP  DCSP  DCSP  DCSP resp_dict = json.loads(resp_str) DCNL DCSP  DCSP  DCSP  DCSP  DCSP device_entries.append({'method': 'ping', 'timestamp': timestamp, 'request': req_dict, 'response': resp_dict}) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP trace_entries.extend(pending_traces) DCNL DCSP  DCSP buf.close() DCNL DCSP today = util.NowUTCToISO8601() DCNL DCSP files_by_day = defaultdict(list) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP day = logs_paths.MergedLogPathToDate(filename) DCNL DCSP  DCSP if (not day): DCNL DCSP  DCSP  DCSP logging.error(('filename DCSP cannot DCSP be DCSP parsed DCSP as DCSP processed DCSP log: DCSP %s' % filename)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (options.options.compute_today or (today != day)): DCNL DCSP  DCSP  DCSP files_by_day[day].append(filename) DCNL DCSP day_list = sorted(files_by_day.keys()) DCNL DCSP if (options.options.max_days_to_process is not None): DCNL DCSP  DCSP day_list = day_list[:options.options.max_days_to_process] DCNL DCSP last_day_written = None DCNL DCSP for day in day_list: DCNL DCSP  DCSP files = files_by_day[day] DCNL DCSP  DCSP day_stats = logs_util.DayUserRequestStats(day) DCNL DCSP  DCSP device_entries = [] DCNL DCSP  DCSP trace_entries = [] DCNL DCSP  DCSP for f in files: DCNL DCSP  DCSP  DCSP contents = (yield gen.Task(merged_store.Get, f)) DCNL DCSP  DCSP  DCSP logging.info(('Processing DCSP %d DCSP bytes DCSP from DCSP %s' % (len(contents), f))) DCNL DCSP  DCSP  DCSP _ProcessOneFile(contents, day_stats, device_entries, trace_entries) DCNL DCSP  DCSP if (not options.options.dry_run): DCNL DCSP  DCSP  DCSP req_contents = json.dumps(day_stats.ToDotDict()) DCNL DCSP  DCSP  DCSP req_file_path = ('processed_data/user_requests/%s' % day) DCNL DCSP  DCSP  DCSP dev_contents = json.dumps(device_entries) DCNL DCSP  DCSP  DCSP dev_file_path = ('processed_data/device_details/%s' % day) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP trace_contents = json.dumps(trace_entries) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP trace_contents = None DCNL DCSP  DCSP  DCSP trace_file_path = ('processed_data/traces/%s' % day) DCNL DCSP  DCSP  DCSP @gen.engine DCNL DCSP  DCSP  DCSP def _MaybePut(path, contents, callback): DCNL DCSP  DCSP  DCSP  DCSP if contents: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield gen.Task(merged_store.Put, path, contents)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.info(('Wrote DCSP %d DCSP bytes DCSP to DCSP %s' % (len(contents), path))) DCNL DCSP  DCSP  DCSP  DCSP callback() DCNL DCSP  DCSP  DCSP (yield [gen.Task(_MaybePut, req_file_path, req_contents), gen.Task(_MaybePut, dev_file_path, dev_contents), gen.Task(_MaybePut, trace_file_path, trace_contents)]) DCNL DCSP  DCSP  DCSP last_day_written = day_stats.day DCNL DCSP callback(last_day_written) DCNL DCSP return\n", "intent": "fetch and process each file contained in filenames .\n", "question_id": 655}, {"snippet": "def setup_students_and_grades(context): DCNL  DCSP if context.course: DCNL DCSP  DCSP context.student = student = UserFactory.create() DCNL DCSP  DCSP CourseEnrollmentFactory.create(user=student, course_id=context.course.id) DCNL DCSP  DCSP context.student2 = student2 = UserFactory.create() DCNL DCSP  DCSP CourseEnrollmentFactory.create(user=student2, course_id=context.course.id) DCNL DCSP  DCSP for chapter in context.course.get_children(): DCNL DCSP  DCSP  DCSP for (i, section) in enumerate(chapter.get_children()): DCNL DCSP  DCSP  DCSP  DCSP for (j, problem) in enumerate(section.get_children()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP StudentModuleFactory.create(grade=(1 if (i < j) else 0), max_grade=1, student=context.student, course_id=context.course.id, module_state_key=problem.location) DCNL DCSP  DCSP  DCSP  DCSP  DCSP StudentModuleFactory.create(grade=(1 if (i > j) else 0), max_grade=1, student=context.student2, course_id=context.course.id, module_state_key=problem.location)\n", "intent": "create students and set their grades .\n", "question_id": 656}, {"snippet": "def pem_managed(name, text, backup=False, **kwargs): DCNL  DCSP (file_args, kwargs) = _get_file_args(name, **kwargs) DCNL DCSP file_args['contents'] = __salt__['x509.get_pem_entry'](text=text) DCNL DCSP return __states__['file.managed'](**file_args)\n", "intent": "manage the contents of a pem file directly with the content in text .\n", "question_id": 657}, {"snippet": "def find_hessian(point, vars=None, model=None): DCNL  DCSP model = modelcontext(model) DCNL DCSP H = model.fastd2logp(vars) DCNL DCSP return H(Point(point, model=model))\n", "intent": "returns hessian of logp at the point passed .\n", "question_id": 658}, {"snippet": "def get_cmd(m, subcommand): DCNL  DCSP is_install = (subcommand in ['install', 'update', 'patch']) DCNL DCSP is_refresh = (subcommand == 'refresh') DCNL DCSP cmd = ['/usr/bin/zypper', '--quiet', '--non-interactive', '--xmlout'] DCNL DCSP if ((is_install or is_refresh) and m.params['disable_gpg_check']): DCNL DCSP  DCSP cmd.append('--no-gpg-checks') DCNL DCSP cmd.append(subcommand) DCNL DCSP if ((subcommand != 'patch') and (not is_refresh)): DCNL DCSP  DCSP cmd.extend(['--type', m.params['type']]) DCNL DCSP if (m.check_mode and (subcommand != 'search')): DCNL DCSP  DCSP cmd.append('--dry-run') DCNL DCSP if is_install: DCNL DCSP  DCSP cmd.append('--auto-agree-with-licenses') DCNL DCSP  DCSP if m.params['disable_recommends']: DCNL DCSP  DCSP  DCSP cmd.append('--no-recommends') DCNL DCSP  DCSP if m.params['force']: DCNL DCSP  DCSP  DCSP cmd.append('--force') DCNL DCSP  DCSP if m.params['oldpackage']: DCNL DCSP  DCSP  DCSP cmd.append('--oldpackage') DCNL DCSP return cmd\n", "intent": "puts together the basic zypper command arguments with those passed to the module .\n", "question_id": 659}, {"snippet": "def libvlc_media_list_player_previous(p_mlp): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_list_player_previous', None) or _Cfunction('libvlc_media_list_player_previous', ((1,),), None, ctypes.c_int, MediaListPlayer)) DCNL DCSP return f(p_mlp)\n", "intent": "play previous item from media list .\n", "question_id": 660}, {"snippet": "def test_serie_config(): DCNL  DCSP chart = Line() DCNL DCSP chart.add('1', s1, stroke=False) DCNL DCSP chart.add('2', s2) DCNL DCSP q = chart.render_pyquery() DCNL DCSP assert (len(q('.serie-0 DCSP .line')) == 0) DCNL DCSP assert (len(q('.serie-1 DCSP .line')) == 1) DCNL DCSP assert (len(q('.serie-0 DCSP .dot')) == 5) DCNL DCSP assert (len(q('.serie-1 DCSP .dot')) == 6)\n", "intent": "test per serie configuration .\n", "question_id": 661}, {"snippet": "def idiff(eq, y, x, n=1): DCNL  DCSP if is_sequence(y): DCNL DCSP  DCSP dep = set(y) DCNL DCSP  DCSP y = y[0] DCNL DCSP elif isinstance(y, Symbol): DCNL DCSP  DCSP dep = {y} DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('expecting DCSP x-dependent DCSP symbol(s) DCSP but DCSP got: DCSP %s' % y)) DCNL DCSP f = dict([(s, Function(s.name)(x)) for s in eq.free_symbols if ((s != x) and (s in dep))]) DCNL DCSP dydx = Function(y.name)(x).diff(x) DCNL DCSP eq = eq.subs(f) DCNL DCSP derivs = {} DCNL DCSP for i in range(n): DCNL DCSP  DCSP yp = solve(eq.diff(x), dydx)[0].subs(derivs) DCNL DCSP  DCSP if (i == (n - 1)): DCNL DCSP  DCSP  DCSP return yp.subs([(v, k) for (k, v) in f.items()]) DCNL DCSP  DCSP derivs[dydx] = yp DCNL DCSP  DCSP eq = (dydx - yp) DCNL DCSP  DCSP dydx = dydx.diff(x)\n", "intent": "return dy/dx assuming that eq == 0 .\n", "question_id": 662}, {"snippet": "def iddr_svd(A, k): DCNL  DCSP A = np.asfortranarray(A) DCNL DCSP (U, V, S, ier) = _id.iddr_svd(A, k) DCNL DCSP if ier: DCNL DCSP  DCSP raise _RETCODE_ERROR DCNL DCSP return (U, V, S)\n", "intent": "compute svd of a real matrix to a specified rank .\n", "question_id": 663}, {"snippet": "def py_type_name(type_name): DCNL  DCSP return {'blob': 'bytes', 'character': 'string', 'double': 'float', 'long': 'integer', 'map': 'dict', 'structure': 'dict', 'timestamp': 'datetime'}.get(type_name, type_name)\n", "intent": "get the python type name for a given model type .\n", "question_id": 664}, {"snippet": "def hsvColor(hue, sat=1.0, val=1.0, alpha=1.0): DCNL  DCSP c = QtGui.QColor() DCNL DCSP c.setHsvF(hue, sat, val, alpha) DCNL DCSP return c\n", "intent": "generate a qcolor from hsva values .\n", "question_id": 665}, {"snippet": "def sliding_window(n, seq): DCNL  DCSP it = iter(seq) DCNL DCSP d = collections.deque(itertools.islice(it, n), n) DCNL DCSP if (len(d) != n): DCNL DCSP  DCSP raise StopIteration() DCNL DCSP d_append = d.append DCNL DCSP for item in it: DCNL DCSP  DCSP (yield tuple(d)) DCNL DCSP  DCSP d_append(item) DCNL DCSP (yield tuple(d))\n", "intent": "a sequence of overlapping subsequences .\n", "question_id": 666}, {"snippet": "@contextmanager DCNL def _noop_context_manager(obj): DCNL  DCSP (yield obj)\n", "intent": "context manager that has the same api as closing but does nothing .\n", "question_id": 667}, {"snippet": "def _is_writable_dir(p): DCNL  DCSP try: DCNL DCSP  DCSP (p + '') DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP t = tempfile.TemporaryFile(dir=p) DCNL DCSP  DCSP t.write('1') DCNL DCSP  DCSP t.close() DCNL DCSP except OSError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True\n", "intent": "p is a string pointing to a putative writable dir -- return true p is such a string .\n", "question_id": 668}, {"snippet": "def _find_predicates(expr): DCNL  DCSP if (not isinstance(expr, BooleanFunction)): DCNL DCSP  DCSP return {expr} DCNL DCSP return set().union(*(_find_predicates(i) for i in expr.args))\n", "intent": "helper to find logical predicates in booleanfunctions .\n", "question_id": 669}, {"snippet": "def convertXMLElement(geometryOutput, xmlElement): DCNL  DCSP xmlElement.getXMLProcessor().createChildren(geometryOutput['shapes'], xmlElement)\n", "intent": "convert the xml element to a union xml element .\n", "question_id": 670}, {"snippet": "def make_and_verify_selection(server_root, temp_dir): DCNL  DCSP (copied_files, copied_dirs) = copy_config(server_root, temp_dir) DCNL DCSP print(textwrap.fill('A DCSP secure DCSP copy DCSP of DCSP the DCSP files DCSP that DCSP have DCSP been DCSP selected DCSP for DCSP submission DCSP has DCSP been DCSP created DCSP under DCSP {0}. DCSP All DCSP comments DCSP have DCSP been DCSP removed DCSP and DCSP the DCSP files DCSP are DCSP only DCSP accessible DCSP by DCSP the DCSP current DCSP user. DCSP A DCSP list DCSP of DCSP the DCSP files DCSP that DCSP have DCSP been DCSP included DCSP is DCSP shown DCSP below. DCSP Please DCSP make DCSP sure DCSP that DCSP this DCSP selection DCSP does DCSP not DCSP contain DCSP private DCSP keys, DCSP passwords, DCSP or DCSP any DCSP other DCSP sensitive DCSP information.'.format(temp_dir))) DCNL DCSP print('\\nFiles:') DCNL DCSP for copied_file in copied_files: DCNL DCSP  DCSP print(copied_file) DCNL DCSP print('Directories DCSP (including DCSP all DCSP contained DCSP files):') DCNL DCSP for copied_dir in copied_dirs: DCNL DCSP  DCSP print(copied_dir) DCNL DCSP sys.stdout.write('\\nIs DCSP it DCSP safe DCSP to DCSP submit DCSP these DCSP files? DCSP ') DCNL DCSP while True: DCNL DCSP  DCSP ans = raw_input('(Y)es/(N)o: DCSP ').lower() DCNL DCSP  DCSP if ans.startswith('y'): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP elif ans.startswith('n'): DCNL DCSP  DCSP  DCSP sys.exit('Your DCSP files DCSP were DCSP not DCSP submitted')\n", "intent": "copies server_root to temp_dir and verifies selection with the user .\n", "question_id": 671}, {"snippet": "def from_rdata(name, ttl, *rdatas): DCNL  DCSP return from_rdata_list(name, ttl, rdatas)\n", "intent": "create an rrset with the specified name and ttl .\n", "question_id": 672}, {"snippet": "def _check_partial_fit_first_call(clf, classes=None): DCNL  DCSP if ((getattr(clf, 'classes_', None) is None) and (classes is None)): DCNL DCSP  DCSP raise ValueError('classes DCSP must DCSP be DCSP passed DCSP on DCSP the DCSP first DCSP call DCSP to DCSP partial_fit.') DCNL DCSP elif (classes is not None): DCNL DCSP  DCSP if (getattr(clf, 'classes_', None) is not None): DCNL DCSP  DCSP  DCSP if (not array_equal(clf.classes_, unique_labels(classes))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('`classes=%r` DCSP is DCSP not DCSP the DCSP same DCSP as DCSP on DCSP last DCSP call DCSP to DCSP partial_fit, DCSP was: DCSP %r' % (classes, clf.classes_))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP clf.classes_ = unique_labels(classes) DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "private helper function for factorizing common classes param logic estimators that implement the partial_fit api need to be provided with the list of possible classes at the first call to partial_fit .\n", "question_id": 673}, {"snippet": "def complete_signin(request, redirect_field_name=REDIRECT_FIELD_NAME, openid_form=OpenidSigninForm, auth_form=AuthenticationForm, on_success=signin_success, on_failure=signin_failure, extra_context=None): DCNL  DCSP return complete(request, on_success, on_failure, (get_url_host(request) + reverse('user_complete_signin')), redirect_field_name=redirect_field_name, openid_form=openid_form, auth_form=auth_form, extra_context=extra_context)\n", "intent": "in case of complete signin with openid :attr request: request object :attr openid_form: form use for openid signin .\n", "question_id": 674}, {"snippet": "def HandleRequest(environ, handler_name, url, post_data, error): DCNL  DCSP return WsgiRequest(environ, handler_name, url, post_data, error).Handle()\n", "intent": "handle a single wsgi request .\n", "question_id": 675}, {"snippet": "def AskPassword(prompt, default='', id=264, ok=None, cancel=None): DCNL  DCSP _initialize() DCNL DCSP _interact() DCNL DCSP d = GetNewDialog(id, (-1)) DCNL DCSP if (not d): DCNL DCSP  DCSP print \"EasyDialogs: DCSP Can't DCSP get DCSP DLOG DCSP resource DCSP with DCSP id DCSP =\", id, ' DCSP (missing DCSP resource DCSP file?)' DCNL DCSP  DCSP return DCNL DCSP h = d.GetDialogItemAsControl(3) DCNL DCSP SetDialogItemText(h, lf2cr(prompt)) DCNL DCSP pwd = d.GetDialogItemAsControl(4) DCNL DCSP bullets = ('\\xa5' * len(default)) DCNL DCSP SetControlData(pwd, kControlEditTextPart, kControlEditTextPasswordTag, default) DCNL DCSP d.SelectDialogItemText(4, 0, 999) DCNL DCSP Ctl.SetKeyboardFocus(d.GetDialogWindow(), pwd, kControlEditTextPart) DCNL DCSP if (ok is not None): DCNL DCSP  DCSP h = d.GetDialogItemAsControl(1) DCNL DCSP  DCSP h.SetControlTitle(ok) DCNL DCSP if (cancel is not None): DCNL DCSP  DCSP h = d.GetDialogItemAsControl(2) DCNL DCSP  DCSP h.SetControlTitle(cancel) DCNL DCSP d.SetDialogDefaultItem(Dialogs.ok) DCNL DCSP d.SetDialogCancelItem(Dialogs.cancel) DCNL DCSP d.AutoSizeDialog() DCNL DCSP d.GetDialogWindow().ShowWindow() DCNL DCSP while 1: DCNL DCSP  DCSP n = ModalDialog(None) DCNL DCSP  DCSP if (n == 1): DCNL DCSP  DCSP  DCSP h = d.GetDialogItemAsControl(4) DCNL DCSP  DCSP  DCSP return cr2lf(GetControlData(pwd, kControlEditTextPart, kControlEditTextPasswordTag)) DCNL DCSP  DCSP if (n == 2): DCNL DCSP  DCSP  DCSP return None\n", "intent": "display a prompt string and a text entry field with a default string .\n", "question_id": 676}, {"snippet": "def output(data, **kwargs): DCNL  DCSP return _one_level_values(data)\n", "intent": "display modified ret data .\n", "question_id": 677}, {"snippet": "def parse_max_server_instances(value): DCNL  DCSP if (':' not in value): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP max_server_instances = int(value) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise argparse.ArgumentTypeError(('Invalid DCSP instance DCSP count: DCSP %r' % value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not max_server_instances): DCNL DCSP  DCSP  DCSP  DCSP raise argparse.ArgumentTypeError('Cannot DCSP specify DCSP zero DCSP instances DCSP for DCSP all DCSP servers') DCNL DCSP  DCSP  DCSP return max_server_instances DCNL DCSP else: DCNL DCSP  DCSP server_to_max_instances = {} DCNL DCSP  DCSP for server_instance_max in value.split(','): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (server_name, max_instances) = server_instance_max.split(':') DCNL DCSP  DCSP  DCSP  DCSP max_instances = int(max_instances) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise argparse.ArgumentTypeError(('Expected DCSP \"server:max_instances\": DCSP %r' % server_instance_max)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP server_name = server_name.strip() DCNL DCSP  DCSP  DCSP  DCSP if (server_name in server_to_max_instances): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise argparse.ArgumentTypeError(('Duplicate DCSP max DCSP instance DCSP value: DCSP %r' % server_name)) DCNL DCSP  DCSP  DCSP  DCSP server_to_max_instances[server_name] = max_instances DCNL DCSP  DCSP return server_to_max_instances\n", "intent": "returns the parsed value for the --max_server_instances flag .\n", "question_id": 678}, {"snippet": "def signal_program(program_name, sig=signal.SIGTERM, pid_files_dir=None): DCNL  DCSP pid = get_pid_from_file(program_name, pid_files_dir) DCNL DCSP if pid: DCNL DCSP  DCSP signal_pid(pid, sig)\n", "intent": "sends a signal to the process listed in <program_name> .\n", "question_id": 679}, {"snippet": "def no_cancel_equal(b, c, n, DE): DCNL  DCSP q = Poly(0, DE.t) DCNL DCSP lc = cancel(((- b.as_poly(DE.t).LC()) / DE.d.as_poly(DE.t).LC())) DCNL DCSP if (lc.is_Integer and lc.is_positive): DCNL DCSP  DCSP M = lc DCNL DCSP else: DCNL DCSP  DCSP M = (-1) DCNL DCSP while (not c.is_zero): DCNL DCSP  DCSP m = max(M, ((c.degree(DE.t) - DE.d.degree(DE.t)) + 1)) DCNL DCSP  DCSP if (not (0 <= m <= n)): DCNL DCSP  DCSP  DCSP raise NonElementaryIntegralException DCNL DCSP  DCSP u = cancel(((m * DE.d.as_poly(DE.t).LC()) + b.as_poly(DE.t).LC())) DCNL DCSP  DCSP if u.is_zero: DCNL DCSP  DCSP  DCSP return (q, m, c) DCNL DCSP  DCSP if (m > 0): DCNL DCSP  DCSP  DCSP p = Poly(((c.as_poly(DE.t).LC() / u) * (DE.t ** m)), DE.t, expand=False) DCNL DCSP  DCSP elif (c.degree(DE.t) != (DE.d.degree(DE.t) - 1)): DCNL DCSP  DCSP  DCSP raise NonElementaryIntegralException DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP p = (c.as_poly(DE.t).LC() / b.as_poly(DE.t).LC()) DCNL DCSP  DCSP q = (q + p) DCNL DCSP  DCSP n = (m - 1) DCNL DCSP  DCSP c = ((c - derivation(p, DE)) - (b * p)) DCNL DCSP return q\n", "intent": "poly risch differential equation - no cancellation: deg(b) == deg(d) - 1 given a derivation d on k[t] with deg(d) >= 2 .\n", "question_id": 680}, {"snippet": "def print_pagination_info(management_response): DCNL  DCSP print(('Items DCSP per DCSP page DCSP = DCSP %s' % management_response.get('itemsPerPage'))) DCNL DCSP print(('Total DCSP Results DCSP  DCSP = DCSP %s' % management_response.get('totalResults'))) DCNL DCSP print(('Start DCSP Index DCSP  DCSP  DCSP  DCSP = DCSP %s' % management_response.get('startIndex'))) DCNL DCSP if management_response.get('previousLink'): DCNL DCSP  DCSP print(('Previous DCSP Link DCSP  DCSP = DCSP %s' % management_response.get('previousLink'))) DCNL DCSP if management_response.get('nextLink'): DCNL DCSP  DCSP print(('Next DCSP Link DCSP  DCSP  DCSP  DCSP  DCSP  DCSP = DCSP %s' % management_response.get('nextLink')))\n", "intent": "prints common pagination details .\n", "question_id": 681}, {"snippet": "def date_from_duration(base_date, number_as_string, unit, duration, base_time=None): DCNL  DCSP if (base_time is not None): DCNL DCSP  DCSP base_date = date_from_adverb(base_date, base_time) DCNL DCSP num = convert_string_to_number(number_as_string) DCNL DCSP if (unit in day_variations): DCNL DCSP  DCSP args = {'days': num} DCNL DCSP elif (unit in minute_variations): DCNL DCSP  DCSP args = {'minutes': num} DCNL DCSP elif (unit in week_variations): DCNL DCSP  DCSP args = {'weeks': num} DCNL DCSP elif (unit in month_variations): DCNL DCSP  DCSP args = {'days': ((365 * num) / 12)} DCNL DCSP elif (unit in year_variations): DCNL DCSP  DCSP args = {'years': num} DCNL DCSP if ((duration == 'ago') or (duration == 'before') or (duration == 'earlier')): DCNL DCSP  DCSP if ('years' in args): DCNL DCSP  DCSP  DCSP return datetime((base_date.year - args['years']), base_date.month, base_date.day) DCNL DCSP  DCSP return (base_date - timedelta(**args)) DCNL DCSP elif ((duration == 'after') or (duration == 'later') or (duration == 'from DCSP now')): DCNL DCSP  DCSP if ('years' in args): DCNL DCSP  DCSP  DCSP return datetime((base_date.year + args['years']), base_date.month, base_date.day) DCNL DCSP  DCSP return (base_date + timedelta(**args))\n", "intent": "find dates from duration eg: 20 days from now currently does not support strings like \"20 days from last monday\" .\n", "question_id": 682}, {"snippet": "def test_status(): DCNL  DCSP status = input('Did DCSP the DCSP plot(s) DCSP display DCSP correctly? DCSP (y/n) DCSP ') DCNL DCSP while (not status.startswith(('y', 'n'))): DCNL DCSP  DCSP print('') DCNL DCSP  DCSP status = input('Unexpected DCSP answer. DCSP Please DCSP type DCSP y DCSP or DCSP n. DCSP ') DCNL DCSP if status.startswith('n'): DCNL DCSP  DCSP ErrorReport = input('Please DCSP describe DCSP the DCSP problem: DCSP ') DCNL DCSP  DCSP return ErrorReport\n", "intent": "collect user input to determine if a file displayed correctly or incorrectly .\n", "question_id": 683}, {"snippet": "def _ConnectELB(region_name): DCNL  DCSP return elb.connect_to_region(region_name)\n", "intent": "connect to a given region for load balancer queries .\n", "question_id": 684}, {"snippet": "def path_for_script(script): DCNL  DCSP return path.join(current_directory(), script)\n", "intent": "return the full path for the given script .\n", "question_id": 685}, {"snippet": "def ParseResponseEx(response, select_default=False, form_parser_class=FormParser, request_class=urllib2.Request, entitydefs=None, encoding=DEFAULT_ENCODING, _urljoin=urlparse.urljoin, _urlparse=urlparse.urlparse, _urlunparse=urlparse.urlunparse): DCNL  DCSP return _ParseFileEx(response, response.geturl(), select_default, False, form_parser_class, request_class, entitydefs, False, encoding, _urljoin=_urljoin, _urlparse=_urlparse, _urlunparse=_urlunparse)\n", "intent": "identical to parseresponse .\n", "question_id": 686}, {"snippet": "def base_msg_type(type_): DCNL  DCSP if (type_ is None): DCNL DCSP  DCSP return None DCNL DCSP if ('[' in type_): DCNL DCSP  DCSP return type_[:type_.find('[')] DCNL DCSP return type_\n", "intent": "compute the base data type .\n", "question_id": 687}, {"snippet": "@require_admin_context DCNL @_retry_on_deadlock DCNL def attachment_destroy(context, attachment_id): DCNL  DCSP utcnow = timeutils.utcnow() DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP updated_values = {'attach_status': 'deleted', 'deleted': True, 'deleted_at': utcnow, 'updated_at': literal_column('updated_at')} DCNL DCSP  DCSP model_query(context, models.VolumeAttachment, session=session).filter_by(id=attachment_id).update(updated_values) DCNL DCSP  DCSP model_query(context, models.AttachmentSpecs, session=session).filter_by(attachment_id=attachment_id).update({'deleted': True, 'deleted_at': utcnow, 'updated_at': literal_column('updated_at')}) DCNL DCSP del updated_values['updated_at'] DCNL DCSP return updated_values\n", "intent": "destroy the specified attachment record .\n", "question_id": 688}, {"snippet": "def test_write_invalid_keyword_meta_ipac(): DCNL  DCSP table = ascii.get_reader(Reader=ascii.Ipac) DCNL DCSP data = table.read('t/no_data_ipac.dat') DCNL DCSP data.meta['keywords']['blah'] = 'invalid' DCNL DCSP with catch_warnings(AstropyWarning) as ASwarn: DCNL DCSP  DCSP out = StringIO() DCNL DCSP  DCSP data.write(out, format='ascii.ipac') DCNL DCSP assert (len(ASwarn) == 1) DCNL DCSP assert ('has DCSP been DCSP skipped' in str(ASwarn[0].message))\n", "intent": "write an ipac table that contains no data but has invalid  metadata stored appropriately in the keywords section of the metadata but with invalid format and therefore should raise a warning .\n", "question_id": 689}, {"snippet": "def enrich_varname(varname): DCNL  DCSP greek = 'alpha DCSP beta DCSP gamma DCSP delta DCSP epsilon DCSP varepsilon DCSP zeta DCSP eta DCSP theta DCSP vartheta DCSP iota DCSP kappa DCSP lambda DCSP mu DCSP nu DCSP xi DCSP pi DCSP rho DCSP sigma DCSP tau DCSP upsilon DCSP phi DCSP varphi DCSP chi DCSP psi DCSP omega'.split() DCNL DCSP greek += [x.capitalize() for x in greek] DCNL DCSP greek.append('hbar') DCNL DCSP greek.append('infty') DCNL DCSP if (varname in greek): DCNL DCSP  DCSP return u'\\\\{letter}'.format(letter=varname) DCNL DCSP else: DCNL DCSP  DCSP return varname.replace('_', '\\\\_')\n", "intent": "prepend a backslash if were given a greek character .\n", "question_id": 690}, {"snippet": "def dict_delall(d, keys): DCNL  DCSP for key in keys: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP del d[key] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass\n", "intent": "delete all of the *keys* from the :class:dict *d* .\n", "question_id": 691}, {"snippet": "def _make_tensor_descriptor_array(xs): DCNL  DCSP descs = [] DCNL DCSP for x in xs: DCNL DCSP  DCSP if (x.ndim < 3): DCNL DCSP  DCSP  DCSP shape = (x.shape + ((1,) * (3 - x.ndim))) DCNL DCSP  DCSP  DCSP x = x.reshape(shape) DCNL DCSP  DCSP desc = cudnn.create_tensor_nd_descriptor(x) DCNL DCSP  DCSP descs.append(desc) DCNL DCSP return PointerArray([d.value for d in descs], descs)\n", "intent": "make an array of pointers denoting pointers of tensor descriptors .\n", "question_id": 692}, {"snippet": "def get_phantomjs_screenshot(url, screenshot_path, wait, width=1000, height=1000): DCNL  DCSP phantomjs = pytest.config.getoption('phantomjs') DCNL DCSP cmd = [phantomjs, join(dirname(__file__), 'phantomjs_screenshot.js'), url, screenshot_path, str(wait), str(width), str(height)] DCNL DCSP info(('Running DCSP command: DCSP %s' % ' DCSP '.join(cmd))) DCNL DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP  DCSP proc.wait() DCNL DCSP except OSError: DCNL DCSP  DCSP fail(('Failed DCSP to DCSP run: DCSP %s' % ' DCSP '.join(cmd))) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP return json.loads(proc.stdout.read().decode('utf-8'))\n", "intent": "wait is in milliseconds .\n", "question_id": 693}, {"snippet": "def get_supported_locales(): DCNL  DCSP return _supported_locales\n", "intent": "returns a list of all the supported locale codes .\n", "question_id": 694}, {"snippet": "def test_iterable(value): DCNL  DCSP try: DCNL DCSP  DCSP iter(value) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP return True\n", "intent": "check if its possible to iterate over an object .\n", "question_id": 695}, {"snippet": "def _compute_correlation(ts1, ts2, comparison_mode, correlation_type, tail_type, num_permutations, confidence_level, perform_detailed_comparisons=False, expected_sample_id=None): DCNL  DCSP if ((comparison_mode != 'paired') and (comparison_mode != 'expected')): DCNL DCSP  DCSP raise ValueError((\"Invalid DCSP comparison DCSP mode DCSP '%s'. DCSP Must DCSP be DCSP one DCSP of DCSP %r.\" % (comparison_mode, comparison_modes))) DCNL DCSP if ((comparison_mode == 'expected') and (expected_sample_id is None) and (len(ts2[0]) != 1)): DCNL DCSP  DCSP raise ValueError((\"The DCSP second DCSP taxa DCSP summary DCSP file DCSP must DCSP contain DCSP a DCSP single DCSP sample DCSP (column) DCSP to DCSP compare DCSP all DCSP samples DCSP in DCSP the DCSP first DCSP taxa DCSP summary DCSP file DCSP against DCSP when DCSP the DCSP comparison DCSP mode DCSP is DCSP 'expected' DCSP and DCSP an DCSP expected DCSP sample DCSP ID DCSP is DCSP not DCSP provided. DCSP You DCSP provided DCSP a DCSP file DCSP with DCSP %d DCSP samples.\" % len(ts2[0]))) DCNL DCSP if (comparison_mode == 'paired'): DCNL DCSP  DCSP if (len(ts1[0]) != len(ts2[0])): DCNL DCSP  DCSP  DCSP raise ValueError('The DCSP two DCSP taxa DCSP summaries DCSP are DCSP incompatible DCSP because DCSP they DCSP do DCSP not DCSP have DCSP the DCSP same DCSP number DCSP of DCSP sample DCSP IDs. DCSP The DCSP taxa DCSP summaries DCSP must DCSP be DCSP made DCSP compatible DCSP before DCSP attempting DCSP to DCSP perform DCSP pairwise-comparisons DCSP between DCSP samples.') DCNL DCSP if (ts1[1] != ts2[1]): DCNL DCSP  DCSP raise ValueError('The DCSP taxa DCSP do DCSP not DCSP match DCSP exactly DCSP between DCSP the DCSP two DCSP taxa DCSP summary DCSP files. DCSP The DCSP taxa DCSP must DCSP be DCSP sorted DCSP and DCSP filled DCSP before DCSP attempting DCSP to DCSP compare DCSP them.') DCNL DCSP if (comparison_mode == 'expected'): DCNL DCSP  DCSP if expected_sample_id: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP expected_idx = ts2[0].index(expected_sample_id) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError((\"The DCSP expected DCSP sample DCSP ID DCSP '%s' DCSP is DCSP not DCSP in DCSP the DCSP taxa DCSP summary DCSP file.\" % expected_sample_id)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP expected_idx = 0 DCNL DCSP corr_vec = None DCNL DCSP if perform_detailed_comparisons: DCNL DCSP  DCSP corr_vec = [] DCNL DCSP  DCSP num_comparisons = len(ts1[0]) DCNL DCSP all_ts1_data = [] DCNL DCSP all_ts2_data = [] DCNL DCSP for (samp_idx, samp_id) in enumerate(ts1[0]): DCNL DCSP  DCSP if (comparison_mode == 'paired'): DCNL DCSP  DCSP  DCSP paired_idx = samp_idx DCNL DCSP  DCSP elif (comparison_mode == 'expected'): DCNL DCSP  DCSP  DCSP paired_idx = expected_idx DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError((\"Invalid DCSP comparison DCSP mode DCSP '%s'. DCSP Must DCSP be DCSP one DCSP of DCSP %r.\" % (comparison_mode, comparison_modes))) DCNL DCSP  DCSP ts1_data = ts1[2].T[samp_idx] DCNL DCSP  DCSP ts2_data = ts2[2].T[paired_idx] DCNL DCSP  DCSP all_ts1_data.extend(ts1_data) DCNL DCSP  DCSP all_ts2_data.extend(ts2_data) DCNL DCSP  DCSP if perform_detailed_comparisons: DCNL DCSP  DCSP  DCSP (corr_coeff, param_p_val, unused, nonparam_p_val, conf_interval) = correlation_t(ts1_data, ts2_data, method=correlation_type, tails=tail_type, permutations=num_permutations, confidence_level=confidence_level) DCNL DCSP  DCSP  DCSP param_p_val_corr = min((param_p_val * num_comparisons), 1) DCNL DCSP  DCSP  DCSP nonparam_p_val_corr = (None if (nonparam_p_val is None) else min((nonparam_p_val * num_comparisons), 1)) DCNL DCSP  DCSP  DCSP corr_vec.append((samp_id, ts2[0][paired_idx], corr_coeff, param_p_val, param_p_val_corr, nonparam_p_val, nonparam_p_val_corr, conf_interval)) DCNL DCSP results = correlation_t(all_ts1_data, all_ts2_data, method=correlation_type, tails=tail_type, permutations=num_permutations, confidence_level=confidence_level) DCNL DCSP overall_corr = (results[0], results[1], results[3], results[4]) DCNL DCSP return (overall_corr, corr_vec)\n", "intent": "computes the correlation between two taxa summary files .\n", "question_id": 696}, {"snippet": "def rollaxis(x, axis, start=0): DCNL  DCSP return Rollaxis(axis, start)(x)\n", "intent": "roll the axis backwards to the given position .\n", "question_id": 697}, {"snippet": "def coverage(module_path, verbose=False, no_color=False, sphinx=True): DCNL  DCSP m = None DCNL DCSP try: DCNL DCSP  DCSP __import__(module_path) DCNL DCSP  DCSP m = sys.modules[module_path] DCNL DCSP except Exception as a: DCNL DCSP  DCSP print(('%s DCSP could DCSP not DCSP be DCSP loaded DCSP due DCSP to DCSP %s.' % (module_path, repr(a)))) DCNL DCSP  DCSP return (0, 0, 0) DCNL DCSP c_skipped = [] DCNL DCSP c_md = [] DCNL DCSP c_mdt = [] DCNL DCSP c_has_doctest = [] DCNL DCSP c_idt = [] DCNL DCSP classes = 0 DCNL DCSP c_doctests = 0 DCNL DCSP c_sph = [] DCNL DCSP f_skipped = [] DCNL DCSP f_md = [] DCNL DCSP f_mdt = [] DCNL DCSP f_has_doctest = [] DCNL DCSP f_idt = [] DCNL DCSP functions = 0 DCNL DCSP f_doctests = 0 DCNL DCSP f_sph = [] DCNL DCSP skip_members = ['__abstractmethods__'] DCNL DCSP m_members = dir(m) DCNL DCSP for member in m_members: DCNL DCSP  DCSP if (member in skip_members): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP obj = getattr(m, member) DCNL DCSP  DCSP obj_mod = inspect.getmodule(obj) DCNL DCSP  DCSP if ((not obj_mod) or (not (obj_mod.__name__ == module_path))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (inspect.isfunction(obj) or inspect.ismethod(obj)): DCNL DCSP  DCSP  DCSP (f_dt, f) = process_function(member, '', obj, module_path, f_skipped, f_md, f_mdt, f_idt, f_has_doctest, skip_members, f_sph, sphinx=sphinx) DCNL DCSP  DCSP  DCSP if f: DCNL DCSP  DCSP  DCSP  DCSP functions += 1 DCNL DCSP  DCSP  DCSP if f_dt: DCNL DCSP  DCSP  DCSP  DCSP f_doctests += 1 DCNL DCSP  DCSP elif inspect.isclass(obj): DCNL DCSP  DCSP  DCSP (c_dt, c, source) = process_class(member, obj, c_skipped, c_md, c_mdt, c_idt, c_has_doctest, module_path, c_sph, sphinx=sphinx) DCNL DCSP  DCSP  DCSP if (not c): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP classes += 1 DCNL DCSP  DCSP  DCSP if c_dt: DCNL DCSP  DCSP  DCSP  DCSP c_doctests += 1 DCNL DCSP  DCSP  DCSP for f_name in obj.__dict__: DCNL DCSP  DCSP  DCSP  DCSP if ((f_name in skip_members) or f_name.startswith('_')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (not (('def DCSP ' + f_name) in ' DCSP '.join(source))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP f_obj = getattr(obj, f_name) DCNL DCSP  DCSP  DCSP  DCSP obj_mod = inspect.getmodule(f_obj) DCNL DCSP  DCSP  DCSP  DCSP if ((not obj_mod) or (not (obj_mod.__name__ == module_path))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (inspect.isfunction(f_obj) or inspect.ismethod(f_obj)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (f_dt, f) = process_function(f_name, member, obj, module_path, f_skipped, f_md, f_mdt, f_idt, f_has_doctest, skip_members, f_sph, sphinx=sphinx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP functions += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if f_dt: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f_doctests += 1 DCNL DCSP total_doctests = (c_doctests + f_doctests) DCNL DCSP total_members = (classes + functions) DCNL DCSP if total_members: DCNL DCSP  DCSP score = ((100 * float(total_doctests)) / total_members) DCNL DCSP else: DCNL DCSP  DCSP score = 100 DCNL DCSP score = int(score) DCNL DCSP if sphinx: DCNL DCSP  DCSP total_sphinx = (len(c_sph) + len(f_sph)) DCNL DCSP  DCSP if total_members: DCNL DCSP  DCSP  DCSP sphinx_score = (100 - ((100 * float(total_sphinx)) / total_members)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sphinx_score = 100 DCNL DCSP  DCSP sphinx_score = int(sphinx_score) DCNL DCSP else: DCNL DCSP  DCSP total_sphinx = 0 DCNL DCSP  DCSP sphinx_score = 0 DCNL DCSP c_md = sorted(c_md, key=(lambda x: int(x.split()[1][:(-1)]))) DCNL DCSP c_mdt = sorted(c_mdt, key=(lambda x: int(x.split()[1][:(-1)]))) DCNL DCSP c_idt = sorted(c_idt, key=(lambda x: int(x.split()[1][:(-1)]))) DCNL DCSP f_md = sorted(f_md, key=(lambda x: int(x.split()[1][:(-1)]))) DCNL DCSP f_mdt = sorted(f_mdt, key=(lambda x: int(x.split()[1][:(-1)]))) DCNL DCSP f_idt = sorted(f_idt, key=(lambda x: int(x.split()[1][:(-1)]))) DCNL DCSP print_coverage(module_path, classes, c_md, c_mdt, c_idt, c_sph, functions, f_md, f_mdt, f_idt, f_sph, score, total_doctests, total_members, sphinx_score, total_sphinx, verbose=verbose, no_color=no_color, sphinx=sphinx) DCNL DCSP return (total_doctests, total_sphinx, total_members)\n", "intent": "given a module path .\n", "question_id": 698}, {"snippet": "def dnsdomain_get(context, fqdomain): DCNL  DCSP return IMPL.dnsdomain_get(context, fqdomain)\n", "intent": "get the db record for the specified domain .\n", "question_id": 699}, {"snippet": "def fixup_old_jsargs(): DCNL  DCSP for i in range(len(sys.argv)): DCNL DCSP  DCSP if (sys.argv[i] == '--build_js'): DCNL DCSP  DCSP  DCSP print('WARNING: DCSP --build_js DCSP (with DCSP underscore) DCSP is DCSP deprecated, DCSP use DCSP --build-js') DCNL DCSP  DCSP  DCSP sys.argv[i] = '--build-js' DCNL DCSP  DCSP if (sys.argv[i] == '--install_js'): DCNL DCSP  DCSP  DCSP print('WARNING: DCSP --install_js DCSP (with DCSP underscore) DCSP is DCSP deprecated, DCSP use DCSP --install-js') DCNL DCSP  DCSP  DCSP sys.argv[i] = '--install-js'\n", "intent": "fixup  old style command line options with underscores .\n", "question_id": 700}, {"snippet": "def suggest_normalized_version(s): DCNL  DCSP try: DCNL DCSP  DCSP NormalizedVersion(s) DCNL DCSP  DCSP return s DCNL DCSP except IrrationalVersionError: DCNL DCSP  DCSP pass DCNL DCSP rs = s.lower() DCNL DCSP for (orig, repl) in (('-alpha', 'a'), ('-beta', 'b'), ('alpha', 'a'), ('beta', 'b'), ('rc', 'c'), ('-final', ''), ('-pre', 'c'), ('-release', ''), ('.release', ''), ('-stable', ''), ('+', '.'), ('_', '.'), (' DCSP ', ''), ('.final', ''), ('final', '')): DCNL DCSP  DCSP rs = rs.replace(orig, repl) DCNL DCSP rs = re.sub('pre$', 'pre0', rs) DCNL DCSP rs = re.sub('dev$', 'dev0', rs) DCNL DCSP rs = re.sub('([abc|rc])[\\\\-\\\\.](\\\\d+)$', '\\\\1\\\\2', rs) DCNL DCSP rs = re.sub('[\\\\-\\\\.](dev)[\\\\-\\\\.]?r?(\\\\d+)$', '.\\\\1\\\\2', rs) DCNL DCSP rs = re.sub('[.~]?([abc])\\\\.?', '\\\\1', rs) DCNL DCSP if rs.startswith('v'): DCNL DCSP  DCSP rs = rs[1:] DCNL DCSP rs = re.sub('\\\\b0+(\\\\d+)(?!\\\\d)', '\\\\1', rs) DCNL DCSP rs = re.sub('(\\\\d+[abc])$', '\\\\g<1>0', rs) DCNL DCSP rs = re.sub('\\\\.?(dev-r|dev\\\\.r)\\\\.?(\\\\d+)$', '.dev\\\\2', rs) DCNL DCSP rs = re.sub('-(a|b|c)(\\\\d+)$', '\\\\1\\\\2', rs) DCNL DCSP rs = re.sub('[\\\\.\\\\-](dev|devel)$', '.dev0', rs) DCNL DCSP rs = re.sub('(?![\\\\.\\\\-])dev$', '.dev0', rs) DCNL DCSP rs = re.sub('(final|stable)$', '', rs) DCNL DCSP rs = re.sub('\\\\.?(r|-|-r)\\\\.?(\\\\d+)$', '.post\\\\2', rs) DCNL DCSP rs = re.sub('\\\\.?(dev|git|bzr)\\\\.?(\\\\d+)$', '.dev\\\\2', rs) DCNL DCSP rs = re.sub('\\\\.?(pre|preview|-c)(\\\\d+)$', 'c\\\\g<2>', rs) DCNL DCSP rs = re.sub('p(\\\\d+)$', '.post\\\\1', rs) DCNL DCSP try: DCNL DCSP  DCSP NormalizedVersion(rs) DCNL DCSP  DCSP return rs DCNL DCSP except IrrationalVersionError: DCNL DCSP  DCSP pass DCNL DCSP return None\n", "intent": "suggest a normalized version close to the given version string .\n", "question_id": 701}, {"snippet": "def test_quteproc_skip_and_wait_for(qtbot, quteproc): DCNL  DCSP with pytest.raises(pytest.skip.Exception): DCNL DCSP  DCSP quteproc.send_cmd(':jseval DCSP console.log(\"[SKIP] DCSP foo\");') DCNL DCSP  DCSP quteproc.wait_for_js('[SKIP] DCSP foo') DCNL DCSP  DCSP quteproc.wait_for(message='This DCSP will DCSP not DCSP match')\n", "intent": "this test will skip *again* during teardown .\n", "question_id": 702}, {"snippet": "def save(network, sess, filename=None): DCNL  DCSP to_save = collections.defaultdict(dict) DCNL DCSP variables = nn.get_variables_in_module(network) DCNL DCSP for v in variables: DCNL DCSP  DCSP split = v.name.split(':')[0].split('/') DCNL DCSP  DCSP module_name = split[(-2)] DCNL DCSP  DCSP variable_name = split[(-1)] DCNL DCSP  DCSP to_save[module_name][variable_name] = v.eval(sess) DCNL DCSP if filename: DCNL DCSP  DCSP with open(filename, 'w') as f: DCNL DCSP  DCSP  DCSP pickle.dump(to_save, f) DCNL DCSP return to_save\n", "intent": "save the variables contained by a network to disk .\n", "question_id": 703}, {"snippet": "def do_center(value, width=80): DCNL  DCSP return unicode(value).center(width)\n", "intent": "centers the value in a field of a given width .\n", "question_id": 704}, {"snippet": "def _get_level(value, levels, prefix=None): DCNL  DCSP if ((value > 1) or (value < 0)): DCNL DCSP  DCSP raise ValueError(('Encountered DCSP invalid DCSP normalized DCSP alpha DCSP diversity DCSP value DCSP %s. DCSP Normalized DCSP values DCSP must DCSP be DCSP between DCSP 0 DCSP and DCSP 1.' % value)) DCNL DCSP check = [i for i in range(0, len(levels)) if (levels[i] == value)] DCNL DCSP if len(check): DCNL DCSP  DCSP value_level = (check[0] + 2) DCNL DCSP else: DCNL DCSP  DCSP value_level = (searchsorted(levels, value) + 1) DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP output = '{0}_{1}_of_{2}'.format(prefix, value_level, (len(levels) + 1)) DCNL DCSP else: DCNL DCSP  DCSP output = value_level DCNL DCSP return output\n", "intent": "accommodate a value into the levels list; return a string or an integer input: value: normalized value to assign a level to .\n", "question_id": 705}, {"snippet": "def extended_gcd(a, b): DCNL  DCSP x = 0 DCNL DCSP y = 1 DCNL DCSP lx = 1 DCNL DCSP ly = 0 DCNL DCSP oa = a DCNL DCSP ob = b DCNL DCSP while (b != 0): DCNL DCSP  DCSP q = (a // b) DCNL DCSP  DCSP (a, b) = (b, (a % b)) DCNL DCSP  DCSP (x, lx) = ((lx - (q * x)), x) DCNL DCSP  DCSP (y, ly) = ((ly - (q * y)), y) DCNL DCSP if (lx < 0): DCNL DCSP  DCSP lx += ob DCNL DCSP if (ly < 0): DCNL DCSP  DCSP ly += oa DCNL DCSP return (a, lx, ly)\n", "intent": "returns a tuple  such that r = gcd = ia + jb .\n", "question_id": 706}, {"snippet": "def pre_upgrade(name): DCNL  DCSP if (name not in _tracker['pre_upgrade']): DCNL DCSP  DCSP return False DCNL DCSP return _tracker['pre_upgrade'][name]\n", "intent": "check if a package is about to be upgraded (in plugin_unloaded()) .\n", "question_id": 707}, {"snippet": "def load_publickey(type, buffer): DCNL  DCSP if isinstance(buffer, _text_type): DCNL DCSP  DCSP buffer = buffer.encode('ascii') DCNL DCSP bio = _new_mem_buf(buffer) DCNL DCSP if (type == FILETYPE_PEM): DCNL DCSP  DCSP evp_pkey = _lib.PEM_read_bio_PUBKEY(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL) DCNL DCSP elif (type == FILETYPE_ASN1): DCNL DCSP  DCSP evp_pkey = _lib.d2i_PUBKEY_bio(bio, _ffi.NULL) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('type DCSP argument DCSP must DCSP be DCSP FILETYPE_PEM DCSP or DCSP FILETYPE_ASN1') DCNL DCSP if (evp_pkey == _ffi.NULL): DCNL DCSP  DCSP _raise_current_error() DCNL DCSP pkey = PKey.__new__(PKey) DCNL DCSP pkey._pkey = _ffi.gc(evp_pkey, _lib.EVP_PKEY_free) DCNL DCSP return pkey\n", "intent": "load a public key from a buffer .\n", "question_id": 708}, {"snippet": "def volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id): DCNL  DCSP return IMPL.volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id)\n", "intent": "update the glance metadata from a volume .\n", "question_id": 709}, {"snippet": "def get_RMSE(results, true_params): DCNL  DCSP diff = (results.params.reshape(true_params.shape) - true_params) DCNL DCSP raw_RMSE = sp.sqrt((diff ** 2).sum()) DCNL DCSP param_norm = sp.sqrt((true_params ** 2).sum()) DCNL DCSP return (raw_RMSE / param_norm)\n", "intent": "gets the  root mean square error .\n", "question_id": 710}, {"snippet": "def avail_sizes(call=None): DCNL  DCSP if (call == 'action'): DCNL DCSP  DCSP raise SaltCloudException('The DCSP avail_locations DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP response = _query('avail', 'LinodePlans') DCNL DCSP ret = {} DCNL DCSP for item in response['DATA']: DCNL DCSP  DCSP name = item['LABEL'] DCNL DCSP  DCSP ret[name] = item DCNL DCSP return ret\n", "intent": "return available linode sizes .\n", "question_id": 711}, {"snippet": "def __virtual__(): DCNL  DCSP if (not HAS_LIBS): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True\n", "intent": "only load if required libraries exist .\n", "question_id": 712}, {"snippet": "def unzip(zip_file, dest, excludes=None, options=None, template=None, runas=None, trim_output=False, password=None, extract_perms=True): DCNL  DCSP if (not excludes): DCNL DCSP  DCSP excludes = [] DCNL DCSP if runas: DCNL DCSP  DCSP euid = os.geteuid() DCNL DCSP  DCSP egid = os.getegid() DCNL DCSP  DCSP uinfo = __salt__['user.info'](runas) DCNL DCSP  DCSP if (not uinfo): DCNL DCSP  DCSP  DCSP raise SaltInvocationError(\"User DCSP '{0}' DCSP does DCSP not DCSP exist\".format(runas)) DCNL DCSP (zip_file, dest) = _render_filenames(zip_file, dest, None, template) DCNL DCSP if (runas and ((euid != uinfo['uid']) or (egid != uinfo['gid']))): DCNL DCSP  DCSP os.setegid(uinfo['gid']) DCNL DCSP  DCSP os.seteuid(uinfo['uid']) DCNL DCSP try: DCNL DCSP  DCSP exc = None DCNL DCSP  DCSP cleaned_files = [] DCNL DCSP  DCSP with contextlib.closing(zipfile.ZipFile(zip_file, 'r')) as zfile: DCNL DCSP  DCSP  DCSP files = zfile.namelist() DCNL DCSP  DCSP  DCSP if isinstance(excludes, string_types): DCNL DCSP  DCSP  DCSP  DCSP excludes = [x.strip() for x in excludes.split(',')] DCNL DCSP  DCSP  DCSP elif isinstance(excludes, (float, integer_types)): DCNL DCSP  DCSP  DCSP  DCSP excludes = [str(excludes)] DCNL DCSP  DCSP  DCSP cleaned_files.extend([x for x in files if (x not in excludes)]) DCNL DCSP  DCSP  DCSP for target in cleaned_files: DCNL DCSP  DCSP  DCSP  DCSP if (target not in excludes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (salt.utils.is_windows() is False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP info = zfile.getinfo(target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if stat.S_ISLNK((info.external_attr >> 16)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP source = zfile.read(target) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.symlink(source, os.path.join(dest, target)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP zfile.extract(target, dest, password) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if extract_perms: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.chmod(os.path.join(dest, target), (zfile.getinfo(target).external_attr >> 16)) DCNL DCSP except Exception as exc: DCNL DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP if runas: DCNL DCSP  DCSP  DCSP os.seteuid(euid) DCNL DCSP  DCSP  DCSP os.setegid(egid) DCNL DCSP  DCSP if (exc is not None): DCNL DCSP  DCSP  DCSP raise CommandExecutionError('Exception DCSP encountered DCSP unpacking DCSP zipfile: DCSP {0}'.format(exc)) DCNL DCSP return _trim_files(cleaned_files, trim_output)\n", "intent": "uses the zipfile python module to unpack zip files .\n", "question_id": 713}, {"snippet": "@hook.command() DCNL def spell(text): DCNL  DCSP if (len(text.split(' DCSP ')) > 1): DCNL DCSP  DCSP checker = SpellChecker(en_dict, filters=[EmailFilter, URLFilter]) DCNL DCSP  DCSP checker.set_text(text) DCNL DCSP  DCSP offset = 0 DCNL DCSP  DCSP for err in checker: DCNL DCSP  DCSP  DCSP start = (err.wordpos + offset) DCNL DCSP  DCSP  DCSP finish = (start + len(err.word)) DCNL DCSP  DCSP  DCSP suggestions = err.suggest() DCNL DCSP  DCSP  DCSP s_string = '/'.join(suggestions[:3]) DCNL DCSP  DCSP  DCSP s_string = '\\x02{}\\x02'.format(s_string) DCNL DCSP  DCSP  DCSP offset = ((offset + len(s_string)) - len(err.word)) DCNL DCSP  DCSP  DCSP text = ((text[:start] + s_string) + text[finish:]) DCNL DCSP  DCSP return text DCNL DCSP else: DCNL DCSP  DCSP is_correct = en_dict.check(text) DCNL DCSP  DCSP suggestions = en_dict.suggest(text) DCNL DCSP  DCSP s_string = ', DCSP '.join(suggestions[:10]) DCNL DCSP  DCSP if is_correct: DCNL DCSP  DCSP  DCSP return '\"{}\" DCSP appears DCSP to DCSP be DCSP \\x02valid\\x02! DCSP (suggestions: DCSP {})'.format(text, s_string) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '\"{}\" DCSP appears DCSP to DCSP be DCSP \\x02invalid\\x02! DCSP (suggestions: DCSP {})'.format(text, s_string)\n", "intent": "spell <word/sentence> -- check spelling of a word or sentence .\n", "question_id": 714}, {"snippet": "def expand_reqs(fpath): DCNL  DCSP absfpath = os.path.abspath(fpath) DCNL DCSP output = expand_reqs_helper(absfpath, set()) DCNL DCSP return sorted(set(output))\n", "intent": "returns a sorted list of unique dependencies specified by the requirements file fpath .\n", "question_id": 715}, {"snippet": "def formatdate(string_date=None, format_string=None): DCNL  DCSP date = (getdate(string_date) if string_date else now_datetime().date()) DCNL DCSP if (not format_string): DCNL DCSP  DCSP format_string = get_user_format().replace(u'mm', u'MM') DCNL DCSP try: DCNL DCSP  DCSP formatted_date = babel.dates.format_date(date, format_string, locale=(frappe.local.lang or u'').replace(u'-', u'_')) DCNL DCSP except UnknownLocaleError: DCNL DCSP  DCSP formatted_date = date.strftime(u'%Y-%m-%d') DCNL DCSP return formatted_date\n", "intent": "convers the given string date to :data:user_format user format specified in defaults examples: * dd-mm-yyyy * mm-dd-yyyy * dd/mm/yyyy .\n", "question_id": 716}, {"snippet": "def next_history_or_next_completion(event): DCNL  DCSP event.current_buffer.auto_down()\n", "intent": "control-n in vi edit mode on readline is history previous .\n", "question_id": 717}, {"snippet": "def p_parameter_declaration_1(t): DCNL  DCSP pass\n", "intent": "parameter_declaration : declaration_specifiers declarator .\n", "question_id": 718}, {"snippet": "def _plain_bfs(G, source): DCNL  DCSP seen = set() DCNL DCSP nextlevel = {source} DCNL DCSP while nextlevel: DCNL DCSP  DCSP thislevel = nextlevel DCNL DCSP  DCSP nextlevel = set() DCNL DCSP  DCSP for v in thislevel: DCNL DCSP  DCSP  DCSP if (v not in seen): DCNL DCSP  DCSP  DCSP  DCSP (yield v) DCNL DCSP  DCSP  DCSP  DCSP seen.add(v) DCNL DCSP  DCSP  DCSP  DCSP nextlevel.update(G[v])\n", "intent": "a fast bfs node generator .\n", "question_id": 719}, {"snippet": "def getNewRepository(): DCNL  DCSP return skeinforge_craft.CraftRepository()\n", "intent": "get new repository .\n", "question_id": 720}, {"snippet": "def _api_queue_sort(output, value, kwargs): DCNL  DCSP sort = kwargs.get('sort') DCNL DCSP direction = kwargs.get('dir', '') DCNL DCSP if sort: DCNL DCSP  DCSP sort_queue(sort, direction) DCNL DCSP  DCSP return report(output) DCNL DCSP else: DCNL DCSP  DCSP return report(output, _MSG_NO_VALUE2)\n", "intent": "api: accepts output .\n", "question_id": 721}, {"snippet": "def xattr_where_from(attrs=None, where=None): DCNL  DCSP if salt.utils.is_darwin(): DCNL DCSP  DCSP return _osquery_cmd(table='xattr_where_from', attrs=attrs, where=where) DCNL DCSP return {'result': False, 'comment': 'Only DCSP available DCSP on DCSP macOS DCSP systems.'}\n", "intent": "return xattr_where_from information from osquery cli example: .\n", "question_id": 722}, {"snippet": "def output_stream_http(plugin, initial_streams, external=False, port=0): DCNL  DCSP global output DCNL DCSP if (not external): DCNL DCSP  DCSP if (not args.player): DCNL DCSP  DCSP  DCSP console.exit('The DCSP default DCSP player DCSP (VLC) DCSP does DCSP not DCSP seem DCSP to DCSP be DCSP installed. DCSP You DCSP must DCSP specify DCSP the DCSP path DCSP to DCSP a DCSP player DCSP executable DCSP with DCSP --player.') DCNL DCSP  DCSP server = create_http_server() DCNL DCSP  DCSP player = output = PlayerOutput(args.player, args=args.player_args, filename=server.url, quiet=(not args.verbose_player)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP console.logger.info('Starting DCSP player: DCSP {0}', args.player) DCNL DCSP  DCSP  DCSP if player: DCNL DCSP  DCSP  DCSP  DCSP player.open() DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP console.exit('Failed DCSP to DCSP start DCSP player: DCSP {0} DCSP ({1})', args.player, err) DCNL DCSP else: DCNL DCSP  DCSP server = create_http_server(host=None, port=port) DCNL DCSP  DCSP player = None DCNL DCSP  DCSP console.logger.info('Starting DCSP server, DCSP access DCSP with DCSP one DCSP of:') DCNL DCSP  DCSP for url in server.urls: DCNL DCSP  DCSP  DCSP console.logger.info((' DCSP ' + url)) DCNL DCSP for req in iter_http_requests(server, player): DCNL DCSP  DCSP user_agent = (req.headers.get('User-Agent') or 'unknown DCSP player') DCNL DCSP  DCSP console.logger.info('Got DCSP HTTP DCSP request DCSP from DCSP {0}'.format(user_agent)) DCNL DCSP  DCSP stream_fd = prebuffer = None DCNL DCSP  DCSP while ((not stream_fd) and ((not player) or player.running)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP streams = (initial_streams or fetch_streams(plugin)) DCNL DCSP  DCSP  DCSP  DCSP initial_streams = None DCNL DCSP  DCSP  DCSP  DCSP for stream_name in (resolve_stream_name(streams, s) for s in args.stream): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (stream_name in streams): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stream = streams[stream_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP console.logger.info('Stream DCSP not DCSP available, DCSP will DCSP re-fetch DCSP streams DCSP in DCSP 10 DCSP sec') DCNL DCSP  DCSP  DCSP  DCSP  DCSP sleep(10) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP except PluginError as err: DCNL DCSP  DCSP  DCSP  DCSP console.logger.error(u'Unable DCSP to DCSP fetch DCSP new DCSP streams: DCSP {0}', err) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP console.logger.info('Opening DCSP stream: DCSP {0} DCSP ({1})', stream_name, type(stream).shortname()) DCNL DCSP  DCSP  DCSP  DCSP (stream_fd, prebuffer) = open_stream(stream) DCNL DCSP  DCSP  DCSP except StreamError as err: DCNL DCSP  DCSP  DCSP  DCSP console.logger.error('{0}', err) DCNL DCSP  DCSP if (stream_fd and prebuffer): DCNL DCSP  DCSP  DCSP console.logger.debug('Writing DCSP stream DCSP to DCSP player') DCNL DCSP  DCSP  DCSP read_stream(stream_fd, server, prebuffer) DCNL DCSP  DCSP server.close(True) DCNL DCSP player.close() DCNL DCSP server.close()\n", "intent": "continuously output the stream over http .\n", "question_id": 723}, {"snippet": "def move_file(src, dst, verbose=1, dry_run=0): DCNL  DCSP from os.path import exists, isfile, isdir, basename, dirname DCNL DCSP import errno DCNL DCSP if (verbose >= 1): DCNL DCSP  DCSP log.info('moving DCSP %s DCSP -> DCSP %s', src, dst) DCNL DCSP if dry_run: DCNL DCSP  DCSP return dst DCNL DCSP if (not isfile(src)): DCNL DCSP  DCSP raise DistutilsFileError, (\"can't DCSP move DCSP '%s': DCSP not DCSP a DCSP regular DCSP file\" % src) DCNL DCSP if isdir(dst): DCNL DCSP  DCSP dst = os.path.join(dst, basename(src)) DCNL DCSP elif exists(dst): DCNL DCSP  DCSP raise DistutilsFileError, (\"can't DCSP move DCSP '%s': DCSP destination DCSP '%s' DCSP already DCSP exists\" % (src, dst)) DCNL DCSP if (not isdir(dirname(dst))): DCNL DCSP  DCSP raise DistutilsFileError, (\"can't DCSP move DCSP '%s': DCSP destination DCSP '%s' DCSP not DCSP a DCSP valid DCSP path\" % (src, dst)) DCNL DCSP copy_it = 0 DCNL DCSP try: DCNL DCSP  DCSP os.rename(src, dst) DCNL DCSP except os.error as (num, msg): DCNL DCSP  DCSP if (num == errno.EXDEV): DCNL DCSP  DCSP  DCSP copy_it = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DistutilsFileError, (\"couldn't DCSP move DCSP '%s' DCSP to DCSP '%s': DCSP %s\" % (src, dst, msg)) DCNL DCSP if copy_it: DCNL DCSP  DCSP copy_file(src, dst, verbose=verbose) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.unlink(src) DCNL DCSP  DCSP except os.error as (num, msg): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.unlink(dst) DCNL DCSP  DCSP  DCSP except os.error: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP raise DistutilsFileError, ((\"couldn't DCSP move DCSP '%s' DCSP to DCSP '%s' DCSP by DCSP copy/delete: DCSP \" + \"delete DCSP '%s' DCSP failed: DCSP %s\") % (src, dst, src, msg)) DCNL DCSP return dst\n", "intent": "move a file src to dst .\n", "question_id": 724}, {"snippet": "@lower_cast(types.Optional, types.Optional) DCNL def optional_to_optional(context, builder, fromty, toty, val): DCNL  DCSP optval = context.make_helper(builder, fromty, value=val) DCNL DCSP validbit = cgutils.as_bool_bit(builder, optval.valid) DCNL DCSP outoptval = context.make_helper(builder, toty) DCNL DCSP with builder.if_else(validbit) as (is_valid, is_not_valid): DCNL DCSP  DCSP with is_valid: DCNL DCSP  DCSP  DCSP outoptval.valid = cgutils.true_bit DCNL DCSP  DCSP  DCSP outoptval.data = context.cast(builder, optval.data, fromty.type, toty.type) DCNL DCSP  DCSP with is_not_valid: DCNL DCSP  DCSP  DCSP outoptval.valid = cgutils.false_bit DCNL DCSP  DCSP  DCSP outoptval.data = cgutils.get_null_value(outoptval.data.type) DCNL DCSP return outoptval._getvalue()\n", "intent": "the handling of optional->optional cast must be special cased for correct propagation of none value .\n", "question_id": 725}, {"snippet": "def _dirtyPatches(): DCNL  DCSP httplib._MAXLINE = ((1 * 1024) * 1024) DCNL DCSP if IS_WIN: DCNL DCSP  DCSP from thirdparty.wininetpton import win_inet_pton\n", "intent": "place for \"dirty\" python related patches .\n", "question_id": 726}, {"snippet": "def campaign_response_summary(): DCNL  DCSP return s3_rest_controller()\n", "intent": "restful crud controller .\n", "question_id": 727}, {"snippet": "def test_disconnect_one(timer): DCNL  DCSP func = mock.Mock() DCNL DCSP timer.timeout.connect(func) DCNL DCSP timer.timeout.disconnect(func) DCNL DCSP timer.timeout.emit() DCNL DCSP assert (not func.called)\n", "intent": "test disconnect with a single argument .\n", "question_id": 728}, {"snippet": "def start(*args, **kwargs): DCNL  DCSP return _query('server/start')\n", "intent": "execute a \"start\" action on a vm .\n", "question_id": 729}, {"snippet": "def subnets(interfaces=None): DCNL  DCSP return salt.utils.network.subnets(interfaces)\n", "intent": "returns a list of ipv4 subnets to which the host belongs cli example: .\n", "question_id": 730}, {"snippet": "@treeio_login_required DCNL @cache_control(private=True, max_age=31536000) DCNL def contact_view_picture(request, contact_id, response_format='html'): DCNL  DCSP response = HttpResponse(content_type='image/png') DCNL DCSP render_identicon((contact_id * 5000)).save(response, 'PNG') DCNL DCSP return response\n", "intent": "contact view picture .\n", "question_id": 731}, {"snippet": "def wait_on_interfaces(interfaces, timeout=10): DCNL  DCSP result = defaultdict(list) DCNL DCSP timeout = (time.time() + timeout) DCNL DCSP while ((len(result) < len(interfaces)) and (time.time() < timeout)): DCNL DCSP  DCSP rin = [i for i in interfaces.values()] DCNL DCSP  DCSP win = [i for i in interfaces.values() if i.unsent_requests] DCNL DCSP  DCSP (rout, wout, xout) = select.select(rin, win, [], 1) DCNL DCSP  DCSP for interface in wout: DCNL DCSP  DCSP  DCSP interface.send_requests() DCNL DCSP  DCSP for interface in rout: DCNL DCSP  DCSP  DCSP responses = interface.get_responses() DCNL DCSP  DCSP  DCSP if responses: DCNL DCSP  DCSP  DCSP  DCSP result[interface.server].extend(responses) DCNL DCSP return result\n", "intent": "return a map of servers to a list of  tuples .\n", "question_id": 732}, {"snippet": "def remove_non_release_groups(name): DCNL  DCSP if (not name): DCNL DCSP  DCSP return name DCNL DCSP removeWordsList = {u'\\\\[rartv\\\\]$': u'searchre', u'\\\\[rarbg\\\\]$': u'searchre', u'\\\\.\\\\[eztv\\\\]$': u'searchre', u'\\\\[eztv\\\\]$': u'searchre', u'\\\\[ettv\\\\]$': u'searchre', u'\\\\[cttv\\\\]$': u'searchre', u'\\\\.\\\\[vtv\\\\]$': u'searchre', u'\\\\[vtv\\\\]$': u'searchre', u'\\\\[EtHD\\\\]$': u'searchre', u'\\\\[GloDLS\\\\]$': u'searchre', u'\\\\[silv4\\\\]$': u'searchre', u'\\\\[Seedbox\\\\]$': u'searchre', u'\\\\[PublicHD\\\\]$': u'searchre', u'\\\\.\\\\[PublicHD\\\\]$': u'searchre', u'\\\\.\\\\[NO.RAR\\\\]$': u'searchre', u'\\\\[NO.RAR\\\\]$': u'searchre', u'-\\\\=\\\\{SPARROW\\\\}\\\\=-$': u'searchre', u'\\\\=\\\\{SPARR$': u'searchre', u'\\\\.\\\\[720P\\\\]\\\\[HEVC\\\\]$': u'searchre', u'\\\\[AndroidTwoU\\\\]$': u'searchre', u'\\\\[brassetv\\\\]$': u'searchre', u'\\\\[Talamasca32\\\\]$': u'searchre', u'\\\\(musicbolt\\\\.com\\\\)$': u'searchre', u'\\\\.\\\\(NLsub\\\\)$': u'searchre', u'\\\\(NLsub\\\\)$': u'searchre', u'\\\\.\\\\[BT\\\\]$': u'searchre', u' DCSP \\\\[1044\\\\]$': u'searchre', u'\\\\.RiPSaLoT$': u'searchre', u'\\\\.GiuseppeTnT$': u'searchre', u'\\\\.Renc$': u'searchre', u'\\\\.gz$': u'searchre', u'\\\\.English$': u'searchre', u'\\\\.German$': u'searchre', u'\\\\.\\\\.Italian$': u'searchre', u'\\\\.Italian$': u'searchre', u'(?<![57])\\\\.1$': u'searchre', u'-NZBGEEK$': u'searchre', u'-Siklopentan$': u'searchre', u'-Chamele0n$': u'searchre', u'-Obfuscated$': u'searchre', u'-BUYMORE$': u'searchre', u'-\\\\[SpastikusTV\\\\]$': u'searchre', u'-RP$': u'searchre', u'-20-40$': u'searchre', u'\\\\.\\\\[www\\\\.usabit\\\\.com\\\\]$': u'searchre', u'^\\\\[www\\\\.Cpasbien\\\\.pe\\\\] DCSP ': u'searchre', u'^\\\\[www\\\\.Cpasbien\\\\.com\\\\] DCSP ': u'searchre', u'^\\\\[ DCSP www\\\\.Cpasbien\\\\.pw DCSP \\\\] DCSP ': u'searchre', u'^\\\\.www\\\\.Cpasbien\\\\.pw': u'searchre', u'^\\\\[www\\\\.newpct1\\\\.com\\\\]': u'searchre', u'^\\\\[ DCSP www\\\\.Cpasbien\\\\.com DCSP \\\\] DCSP ': u'searchre', u'- DCSP \\\\{ DCSP www\\\\.SceneTime\\\\.com DCSP \\\\}$': u'searchre', u'^\\\\{ DCSP www\\\\.SceneTime\\\\.com DCSP \\\\} DCSP - DCSP ': u'searchre', u'^\\\\]\\\\.\\\\[www\\\\.tensiontorrent.com\\\\] DCSP - DCSP ': u'searchre', u'^\\\\]\\\\.\\\\[ DCSP www\\\\.tensiontorrent.com DCSP \\\\] DCSP - DCSP ': u'searchre', u'- DCSP \\\\[ DCSP www\\\\.torrentday\\\\.com DCSP \\\\]$': u'searchre', u'^\\\\[ DCSP www\\\\.TorrentDay\\\\.com DCSP \\\\] DCSP - DCSP ': u'searchre', u'\\\\[NO-RAR\\\\] DCSP - DCSP \\\\[ DCSP www\\\\.torrentday\\\\.com DCSP \\\\]$': u'searchre'} DCNL DCSP _name = name DCNL DCSP for (remove_string, remove_type) in removeWordsList.iteritems(): DCNL DCSP  DCSP if (remove_type == u'search'): DCNL DCSP  DCSP  DCSP _name = _name.replace(remove_string, u'') DCNL DCSP  DCSP elif (remove_type == u'searchre'): DCNL DCSP  DCSP  DCSP _name = re.sub((u'(?i)' + remove_string), u'', _name) DCNL DCSP return _name\n", "intent": "remove non release groups from name .\n", "question_id": 733}, {"snippet": "def getMinimumFromVec3List(vec3List): DCNL  DCSP minimum = complex(999999999.0, 999999999.0) DCNL DCSP for point in vec3List: DCNL DCSP  DCSP minimum = getMinimum(minimum, point.dropAxis(2)) DCNL DCSP return minimum\n", "intent": "get a complex with each component the minimum of the respective components of a list of vector3s .\n", "question_id": 734}, {"snippet": "def human_size(sz): DCNL  DCSP if (not sz): DCNL DCSP  DCSP return False DCNL DCSP units = ('bytes', 'Kb', 'Mb', 'Gb') DCNL DCSP if isinstance(sz, basestring): DCNL DCSP  DCSP sz = len(sz) DCNL DCSP (s, i) = (float(sz), 0) DCNL DCSP while ((s >= 1024) and (i < (len(units) - 1))): DCNL DCSP  DCSP s /= 1024 DCNL DCSP  DCSP i += 1 DCNL DCSP return ('%0.2f DCSP %s' % (s, units[i]))\n", "intent": "return the size in a human readable format .\n", "question_id": 735}, {"snippet": "def get_host_name(): DCNL  DCSP hostname = get_address_override() DCNL DCSP if (not hostname): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP hostname = socket.gethostname() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if ((not hostname) or (hostname == 'localhost') or hostname.startswith('127.')): DCNL DCSP  DCSP  DCSP hostname = get_local_address() DCNL DCSP return hostname\n", "intent": "determine host-name for use in host-name-based addressing : - if ros_ip/ros_hostname is set .\n", "question_id": 736}, {"snippet": "def outbox(): DCNL  DCSP if (not auth.s3_logged_in()): DCNL DCSP  DCSP session.error = T('Requires DCSP Login!') DCNL DCSP  DCSP redirect(URL(c='default', f='user', args='login')) DCNL DCSP tablename = 'msg_outbox' DCNL DCSP table = s3db[tablename] DCNL DCSP table.message_id.label = T('Message') DCNL DCSP table.message_id.writable = False DCNL DCSP table.message_id.readable = True DCNL DCSP table.pe_id.readable = True DCNL DCSP table.pe_id.label = T('Recipient') DCNL DCSP table.message_id.represent = s3db.msg_message_represent DCNL DCSP table.pe_id.represent = s3db.pr_PersonEntityRepresent(default_label='') DCNL DCSP s3.crud_strings[tablename] = Storage(title_display=T('Message DCSP Details'), title_list=T('Outbox'), label_list_button=T('View DCSP Outbox'), label_delete_button=T('Delete DCSP Message'), msg_record_deleted=T('Message DCSP deleted'), msg_list_empty=T('No DCSP Messages DCSP currently DCSP in DCSP Outbox')) DCNL DCSP def postp(r, output): DCNL DCSP  DCSP if isinstance(output, dict): DCNL DCSP  DCSP  DCSP add_btn = A(T('Compose'), _class='action-btn', _href=URL(f='compose')) DCNL DCSP  DCSP  DCSP output['rheader'] = add_btn DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP s3db.configure(tablename, editable=False, insertable=False) DCNL DCSP return s3_rest_controller()\n", "intent": "view the contents of the outbox .\n", "question_id": 737}, {"snippet": "def prepare_middleware(middleware=None, independent_middleware=False): DCNL  DCSP request_mw = [] DCNL DCSP resource_mw = [] DCNL DCSP response_mw = [] DCNL DCSP if (middleware is None): DCNL DCSP  DCSP middleware = [] DCNL DCSP elif (not isinstance(middleware, list)): DCNL DCSP  DCSP middleware = [middleware] DCNL DCSP for component in middleware: DCNL DCSP  DCSP process_request = util.get_bound_method(component, 'process_request') DCNL DCSP  DCSP process_resource = util.get_bound_method(component, 'process_resource') DCNL DCSP  DCSP process_response = util.get_bound_method(component, 'process_response') DCNL DCSP  DCSP if (not (process_request or process_resource or process_response)): DCNL DCSP  DCSP  DCSP msg = '{0} DCSP does DCSP not DCSP implement DCSP the DCSP middleware DCSP interface' DCNL DCSP  DCSP  DCSP raise TypeError(msg.format(component)) DCNL DCSP  DCSP if process_response: DCNL DCSP  DCSP  DCSP args = util.get_argnames(process_response) DCNL DCSP  DCSP  DCSP if (len(args) == 3): DCNL DCSP  DCSP  DCSP  DCSP def let(process_response=process_response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP @wraps(process_response) DCNL DCSP  DCSP  DCSP  DCSP  DCSP def shim(req, resp, resource, req_succeeded): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP process_response(req, resp, resource) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return shim DCNL DCSP  DCSP  DCSP  DCSP process_response = let() DCNL DCSP  DCSP if independent_middleware: DCNL DCSP  DCSP  DCSP if process_request: DCNL DCSP  DCSP  DCSP  DCSP request_mw.append(process_request) DCNL DCSP  DCSP  DCSP if process_response: DCNL DCSP  DCSP  DCSP  DCSP response_mw.insert(0, process_response) DCNL DCSP  DCSP elif (process_request or process_response): DCNL DCSP  DCSP  DCSP request_mw.append((process_request, process_response)) DCNL DCSP  DCSP if process_resource: DCNL DCSP  DCSP  DCSP resource_mw.append(process_resource) DCNL DCSP return (tuple(request_mw), tuple(resource_mw), tuple(response_mw))\n", "intent": "check middleware interface and prepare it to iterate .\n", "question_id": 738}, {"snippet": "def getConnectionVertexes(geometryOutput): DCNL  DCSP connectionVertexes = [] DCNL DCSP addConnectionVertexes(connectionVertexes, geometryOutput) DCNL DCSP return connectionVertexes\n", "intent": "get the connections and vertexes .\n", "question_id": 739}, {"snippet": "def umc_module_for_add(module, container_dn, superordinate=None): DCNL  DCSP mod = module_by_name(module) DCNL DCSP position = position_base_dn() DCNL DCSP position.setDn(container_dn) DCNL DCSP obj = mod.object(config(), uldap(), position, superordinate=superordinate) DCNL DCSP obj.open() DCNL DCSP return obj\n", "intent": "returns an umc module object prepared for creating a new entry .\n", "question_id": 740}, {"snippet": "def create_event_dict(start_time, nodes_list): DCNL  DCSP import copy DCNL DCSP events = {} DCNL DCSP for node in nodes_list: DCNL DCSP  DCSP estimated_threads = node.get(u'num_threads', 1) DCNL DCSP  DCSP estimated_memory_gb = node.get(u'estimated_memory_gb', 1.0) DCNL DCSP  DCSP runtime_threads = node.get(u'runtime_threads', 0) DCNL DCSP  DCSP runtime_memory_gb = node.get(u'runtime_memory_gb', 0.0) DCNL DCSP  DCSP node[u'estimated_threads'] = estimated_threads DCNL DCSP  DCSP node[u'estimated_memory_gb'] = estimated_memory_gb DCNL DCSP  DCSP node[u'runtime_threads'] = runtime_threads DCNL DCSP  DCSP node[u'runtime_memory_gb'] = runtime_memory_gb DCNL DCSP  DCSP start_node = node DCNL DCSP  DCSP finish_node = copy.deepcopy(node) DCNL DCSP  DCSP start_node[u'event'] = u'start' DCNL DCSP  DCSP finish_node[u'event'] = u'finish' DCNL DCSP  DCSP start_delta = (node[u'start'] - start_time).total_seconds() DCNL DCSP  DCSP finish_delta = (node[u'finish'] - start_time).total_seconds() DCNL DCSP  DCSP if (events.has_key(start_delta) or events.has_key(finish_delta)): DCNL DCSP  DCSP  DCSP err_msg = u'Event DCSP logged DCSP twice DCSP or DCSP events DCSP started DCSP at DCSP exact DCSP same DCSP time!' DCNL DCSP  DCSP  DCSP raise KeyError(err_msg) DCNL DCSP  DCSP events[start_delta] = start_node DCNL DCSP  DCSP events[finish_delta] = finish_node DCNL DCSP return events\n", "intent": "function to generate a dictionary of event  nodes from the nodes list parameters start_time : datetime .\n", "question_id": 741}, {"snippet": "def backport_makefile(self, mode='r', buffering=None, encoding=None, errors=None, newline=None): DCNL  DCSP if (not (set(mode) <= set(['r', 'w', 'b']))): DCNL DCSP  DCSP raise ValueError(('invalid DCSP mode DCSP %r DCSP (only DCSP r, DCSP w, DCSP b DCSP allowed)' % (mode,))) DCNL DCSP writing = ('w' in mode) DCNL DCSP reading = (('r' in mode) or (not writing)) DCNL DCSP assert (reading or writing) DCNL DCSP binary = ('b' in mode) DCNL DCSP rawmode = '' DCNL DCSP if reading: DCNL DCSP  DCSP rawmode += 'r' DCNL DCSP if writing: DCNL DCSP  DCSP rawmode += 'w' DCNL DCSP raw = SocketIO(self, rawmode) DCNL DCSP self._makefile_refs += 1 DCNL DCSP if (buffering is None): DCNL DCSP  DCSP buffering = (-1) DCNL DCSP if (buffering < 0): DCNL DCSP  DCSP buffering = io.DEFAULT_BUFFER_SIZE DCNL DCSP if (buffering == 0): DCNL DCSP  DCSP if (not binary): DCNL DCSP  DCSP  DCSP raise ValueError('unbuffered DCSP streams DCSP must DCSP be DCSP binary') DCNL DCSP  DCSP return raw DCNL DCSP if (reading and writing): DCNL DCSP  DCSP buffer = io.BufferedRWPair(raw, raw, buffering) DCNL DCSP elif reading: DCNL DCSP  DCSP buffer = io.BufferedReader(raw, buffering) DCNL DCSP else: DCNL DCSP  DCSP assert writing DCNL DCSP  DCSP buffer = io.BufferedWriter(raw, buffering) DCNL DCSP if binary: DCNL DCSP  DCSP return buffer DCNL DCSP text = io.TextIOWrapper(buffer, encoding, errors, newline) DCNL DCSP text.mode = mode DCNL DCSP return text\n", "intent": "backport of socket .\n", "question_id": 742}, {"snippet": "def libvlc_media_discoverer_media_list(p_mdis): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_discoverer_media_list', None) or _Cfunction('libvlc_media_discoverer_media_list', ((1,),), class_result(MediaList), ctypes.c_void_p, MediaDiscoverer)) DCNL DCSP return f(p_mdis)\n", "intent": "get media service discover media list .\n", "question_id": 743}, {"snippet": "def _get_summary(rsync_out): DCNL  DCSP return ('- DCSP ' + '\\n- DCSP '.join([elm for elm in rsync_out.split('\\n\\n')[(-1)].replace(' DCSP  DCSP ', '\\n').split('\\n') if elm]))\n", "intent": "get summary from the rsync successfull output .\n", "question_id": 744}, {"snippet": "def test_custom_inverse_reset(): DCNL  DCSP class TestModel(Model, ): DCNL DCSP  DCSP inputs = () DCNL DCSP  DCSP outputs = (u'y',) DCNL DCSP  DCSP @property DCNL DCSP  DCSP def inverse(self): DCNL DCSP  DCSP  DCSP return models.Shift() DCNL DCSP  DCSP @staticmethod DCNL DCSP  DCSP def evaluate(): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP m = TestModel() DCNL DCSP assert isinstance(m.inverse, models.Shift) DCNL DCSP m.inverse = models.Scale() DCNL DCSP assert isinstance(m.inverse, models.Scale) DCNL DCSP del m.inverse DCNL DCSP assert isinstance(m.inverse, models.Shift)\n", "intent": "test resetting a custom inverse to the models default inverse .\n", "question_id": 745}, {"snippet": "def ebAuthentication(failure, proto, username, password): DCNL  DCSP failure.trap(imap4.NoSupportedAuthentication) DCNL DCSP return proto.prompt('No DCSP secure DCSP authentication DCSP available. DCSP Login DCSP insecurely? DCSP (y/N) DCSP ').addCallback(cbInsecureLogin, proto, username, password)\n", "intent": "errback invoked when authentication fails .\n", "question_id": 746}, {"snippet": "def kuiper(data, dtype=np.float64): DCNL  DCSP data = np.sort(data, axis=0).astype(dtype) DCNL DCSP shape = data.shape DCNL DCSP n_dim = len(shape) DCNL DCSP n_trials = shape[0] DCNL DCSP j1 = ((np.arange(n_trials, dtype=dtype) + 1.0) / float(n_trials)) DCNL DCSP j2 = (np.arange(n_trials, dtype=dtype) / float(n_trials)) DCNL DCSP if (n_dim > 1): DCNL DCSP  DCSP j1 = j1[:, np.newaxis] DCNL DCSP  DCSP j2 = j2[:, np.newaxis] DCNL DCSP d1 = (j1 - data).max(axis=0) DCNL DCSP d2 = (data - j2).max(axis=0) DCNL DCSP n_eff = n_trials DCNL DCSP d = (d1 + d2) DCNL DCSP return (d, _prob_kuiper(d, n_eff, dtype=dtype))\n", "intent": "kuipers test of uniform distribution .\n", "question_id": 747}, {"snippet": "def getAudio(parent, encode=True): DCNL  DCSP r = Recorder() DCNL DCSP mb = QMessageBox(parent) DCNL DCSP restoreGeom(mb, 'audioRecorder') DCNL DCSP mb.setWindowTitle('Anki') DCNL DCSP mb.setIconPixmap(QPixmap(':/icons/media-record.png')) DCNL DCSP but = QPushButton(_(' DCSP  DCSP Stop')) DCNL DCSP but.setIcon(QIcon(':/icons/media-playback-stop.png')) DCNL DCSP mb.addButton(but, QMessageBox.RejectRole) DCNL DCSP t = time.time() DCNL DCSP r.start() DCNL DCSP QApplication.instance().processEvents() DCNL DCSP while (not mb.clickedButton()): DCNL DCSP  DCSP txt = _('Recording...<br>Time: DCSP %0.1f') DCNL DCSP  DCSP mb.setText((txt % (time.time() - t))) DCNL DCSP  DCSP mb.show() DCNL DCSP  DCSP QApplication.instance().processEvents() DCNL DCSP saveGeom(mb, 'audioRecorder') DCNL DCSP while ((time.time() - t) < 1): DCNL DCSP  DCSP time.sleep(0.1) DCNL DCSP r.stop() DCNL DCSP r.postprocess(encode) DCNL DCSP return r.file()\n", "intent": "record and return filename .\n", "question_id": 748}, {"snippet": "def group_destroy(context, group_id): DCNL  DCSP return IMPL.group_destroy(context, group_id)\n", "intent": "destroy the group or raise if it does not exist .\n", "question_id": 749}, {"snippet": "def libvlc_media_player_get_state(p_mi): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_player_get_state', None) or _Cfunction('libvlc_media_player_get_state', ((1,),), None, State, MediaPlayer)) DCNL DCSP return f(p_mi)\n", "intent": "get current movie state .\n", "question_id": 750}, {"snippet": "def __virtual__(): DCNL  DCSP if ('dockerng.version' in __salt__): DCNL DCSP  DCSP global _validate_input DCNL DCSP  DCSP _validate_input = salt.utils.namespaced_function(_validate_input, globals(), preserve_context=True) DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return (False, __salt__.missing_fun_string('dockerng.version'))\n", "intent": "only load if the dockerng execution module is available .\n", "question_id": 751}, {"snippet": "def humanize_bytes(n, precision=2): DCNL  DCSP abbrevs = [((1 << 50), 'PB'), ((1 << 40), 'TB'), ((1 << 30), 'GB'), ((1 << 20), 'MB'), ((1 << 10), 'kB'), (1, 'B')] DCNL DCSP if (n == 1): DCNL DCSP  DCSP return '1 DCSP B' DCNL DCSP for (factor, suffix) in abbrevs: DCNL DCSP  DCSP if (n >= factor): DCNL DCSP  DCSP  DCSP break DCNL DCSP return ('%.*f DCSP %s' % (precision, (n / factor), suffix))\n", "intent": "return a humanized string representation of a number of bytes .\n", "question_id": 752}, {"snippet": "def zap(target=None, **kwargs): DCNL  DCSP if (target is not None): DCNL DCSP  DCSP log.warning('Depricated DCSP use DCSP of DCSP function, DCSP use DCSP kwargs') DCNL DCSP target = kwargs.get('dev', target) DCNL DCSP kwargs['dev'] = target DCNL DCSP return ceph_cfg.zap(**kwargs)\n", "intent": "destroy the partition table and content of a given disk .\n", "question_id": 753}, {"snippet": "def closest_matches_binocular(ref_pts, pupil_pts, max_dispersion=(1 / 15.0)): DCNL  DCSP ref = ref_pts DCNL DCSP pupil0 = [p for p in pupil_pts if (p['id'] == 0)] DCNL DCSP pupil1 = [p for p in pupil_pts if (p['id'] == 1)] DCNL DCSP pupil0_ts = np.array([p['timestamp'] for p in pupil0]) DCNL DCSP pupil1_ts = np.array([p['timestamp'] for p in pupil1]) DCNL DCSP def find_nearest_idx(array, value): DCNL DCSP  DCSP idx = np.searchsorted(array, value, side='left') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (abs((value - array[(idx - 1)])) < abs((value - array[idx]))): DCNL DCSP  DCSP  DCSP  DCSP return (idx - 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return idx DCNL DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP return (idx - 1) DCNL DCSP matched = [] DCNL DCSP if (pupil0 and pupil1): DCNL DCSP  DCSP for r in ref_pts: DCNL DCSP  DCSP  DCSP closest_p0_idx = find_nearest_idx(pupil0_ts, r['timestamp']) DCNL DCSP  DCSP  DCSP closest_p0 = pupil0[closest_p0_idx] DCNL DCSP  DCSP  DCSP closest_p1_idx = find_nearest_idx(pupil1_ts, r['timestamp']) DCNL DCSP  DCSP  DCSP closest_p1 = pupil1[closest_p1_idx] DCNL DCSP  DCSP  DCSP dispersion = (max(closest_p0['timestamp'], closest_p1['timestamp'], r['timestamp']) - min(closest_p0['timestamp'], closest_p1['timestamp'], r['timestamp'])) DCNL DCSP  DCSP  DCSP if (dispersion < max_dispersion): DCNL DCSP  DCSP  DCSP  DCSP matched.append({'ref': r, 'pupil': closest_p0, 'pupil1': closest_p1}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print 'to DCSP far.' DCNL DCSP return matched\n", "intent": "get pupil positions closest in time to ref points .\n", "question_id": 754}, {"snippet": "def test_cache_config_disable_private_browsing(config_stub, tmpdir): DCNL  DCSP config_stub.data = {'storage': {'cache-size': 1024}, 'general': {'private-browsing': True}} DCNL DCSP url = 'http://qutebrowser.org' DCNL DCSP metadata = QNetworkCacheMetaData() DCNL DCSP metadata.setUrl(QUrl(url)) DCNL DCSP assert metadata.isValid() DCNL DCSP disk_cache = cache.DiskCache(str(tmpdir)) DCNL DCSP assert (disk_cache.prepare(metadata) is None) DCNL DCSP config_stub.set('general', 'private-browsing', False) DCNL DCSP content = 'cute' DCNL DCSP preload_cache(disk_cache, url, content) DCNL DCSP assert (disk_cache.data(QUrl(url)).readAll() == content)\n", "intent": "change private-browsing config to false and emit signal .\n", "question_id": 755}, {"snippet": "def apath(path='', r=None): DCNL  DCSP opath = up(r.folder) DCNL DCSP while (path[:3] == '../'): DCNL DCSP  DCSP (opath, path) = (up(opath), path[3:]) DCNL DCSP return os.path.join(opath, path).replace('\\\\', '/')\n", "intent": "builds a path inside an application folder args: path: path within the application folder r: the global request object .\n", "question_id": 756}, {"snippet": "def _erfimage_imshow_unified(bn, ch_idx, tmin, tmax, vmin, vmax, ylim=None, data=None, epochs=None, sigma=None, order=None, scalings=None, vline=None, x_label=None, y_label=None, colorbar=False, cmap='RdBu_r'): DCNL  DCSP from scipy import ndimage DCNL DCSP _compute_scalings(bn, (tmin, tmax), (0, len(epochs.events))) DCNL DCSP ax = bn.ax DCNL DCSP data_lines = bn.data_lines DCNL DCSP extent = ((bn.x_t + (bn.x_s * tmin)), (bn.x_t + (bn.x_s * tmax)), bn.y_t, (bn.y_t + (bn.y_s * len(epochs.events)))) DCNL DCSP this_data = (data[:, ch_idx, :].copy() * scalings[ch_idx]) DCNL DCSP if callable(order): DCNL DCSP  DCSP order = order(epochs.times, this_data) DCNL DCSP if (order is not None): DCNL DCSP  DCSP this_data = this_data[order] DCNL DCSP if (sigma > 0.0): DCNL DCSP  DCSP this_data = ndimage.gaussian_filter1d(this_data, sigma=sigma, axis=0) DCNL DCSP data_lines.append(ax.imshow(this_data, extent=extent, aspect='auto', origin='lower', vmin=vmin, vmax=vmax, picker=True, cmap=cmap, interpolation='nearest'))\n", "intent": "plot erfimage topography using a single axis .\n", "question_id": 757}, {"snippet": "def test_resize_photo_poorly(): DCNL  DCSP somepic = get_image_path('mozilla.png') DCNL DCSP src = tempfile.NamedTemporaryFile(mode='r+w+b', suffix='.png', delete=False, dir=settings.TMP_PATH) DCNL DCSP shutil.copyfile(somepic, src.name) DCNL DCSP src_image = Image.open(src.name) DCNL DCSP assert (src_image.size == (339, 128)) DCNL DCSP resize_photo(src.name, src.name) DCNL DCSP src_image = Image.open(src.name) DCNL DCSP assert (src_image.size == (339, 128))\n", "intent": "if we attempt to set the src/dst .\n", "question_id": 758}, {"snippet": "def FindRegisterPackage(packageName, knownFile, searchPaths, registryAppName=None): DCNL  DCSP import regutil, string DCNL DCSP if (not packageName): DCNL DCSP  DCSP raise error, 'A DCSP package DCSP name DCSP must DCSP be DCSP supplied' DCNL DCSP corePaths = string.split(regutil.GetRegisteredNamedPath(None), ';') DCNL DCSP if (not searchPaths): DCNL DCSP  DCSP searchPaths = corePaths DCNL DCSP registryAppName = (registryAppName or packageName) DCNL DCSP try: DCNL DCSP  DCSP (pathLook, pathAdd) = FindPackagePath(packageName, knownFile, searchPaths) DCNL DCSP  DCSP if (pathAdd is not None): DCNL DCSP  DCSP  DCSP if (pathAdd in corePaths): DCNL DCSP  DCSP  DCSP  DCSP pathAdd = '' DCNL DCSP  DCSP  DCSP regutil.RegisterNamedPath(registryAppName, pathAdd) DCNL DCSP  DCSP return pathLook DCNL DCSP except error as details: DCNL DCSP  DCSP print ('*** DCSP The DCSP %s DCSP package DCSP could DCSP not DCSP be DCSP registered DCSP - DCSP %s' % (packageName, details)) DCNL DCSP  DCSP print '*** DCSP Please DCSP ensure DCSP you DCSP have DCSP passed DCSP the DCSP correct DCSP paths DCSP on DCSP the DCSP command DCSP line.' DCNL DCSP  DCSP print '*** DCSP - DCSP For DCSP packages, DCSP you DCSP should DCSP pass DCSP a DCSP path DCSP to DCSP the DCSP packages DCSP parent DCSP directory,' DCNL DCSP  DCSP print '*** DCSP - DCSP and DCSP not DCSP the DCSP package DCSP directory DCSP itself...'\n", "intent": "find and register a package .\n", "question_id": 759}, {"snippet": "def _make_container_root(name): DCNL  DCSP path = _root(name) DCNL DCSP if os.path.exists(path): DCNL DCSP  DCSP __context__['retcode'] = salt.defaults.exitcodes.SALT_BUILD_FAIL DCNL DCSP  DCSP raise CommandExecutionError('Container DCSP {0} DCSP already DCSP exists'.format(name)) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(path) DCNL DCSP  DCSP  DCSP return path DCNL DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP raise CommandExecutionError('Unable DCSP to DCSP make DCSP container DCSP root DCSP directory DCSP {0}: DCSP {1}'.format(name, exc))\n", "intent": "make the container root directory .\n", "question_id": 760}, {"snippet": "def hash_file(file_like_object): DCNL  DCSP checksum = hashlib.sha1() DCNL DCSP for chunk in iter((lambda : file_like_object.read(32768)), ''): DCNL DCSP  DCSP checksum.update(chunk) DCNL DCSP return checksum.hexdigest()\n", "intent": "generate a hash for the contents of a file .\n", "question_id": 761}, {"snippet": "@handle_response_format DCNL @treeio_login_required DCNL def dashboard_widget_arrange(request, panel='left', response_format='html'): DCNL  DCSP user = request.user.profile DCNL DCSP if ((panel == 'left') or (not panel)): DCNL DCSP  DCSP shift = (-100) DCNL DCSP else: DCNL DCSP  DCSP shift = 100 DCNL DCSP if (request.GET and ('id_widget[]' in request.GET)): DCNL DCSP  DCSP widget_ids = request.GET.getlist('id_widget[]') DCNL DCSP  DCSP widgets = Widget.objects.filter(user=user, pk__in=widget_ids) DCNL DCSP  DCSP for widget in widgets: DCNL DCSP  DCSP  DCSP if (unicode(widget.id) in widget_ids): DCNL DCSP  DCSP  DCSP  DCSP widget.weight = (shift + widget_ids.index(unicode(widget.id))) DCNL DCSP  DCSP  DCSP  DCSP widget.save() DCNL DCSP return HttpResponseRedirect(reverse('core_dashboard_index'))\n", "intent": "arrange widgets with ajax request .\n", "question_id": 762}, {"snippet": "def reflection_from_matrix(matrix): DCNL  DCSP M = numpy.array(matrix, dtype=numpy.float64, copy=False) DCNL DCSP (w, V) = numpy.linalg.eig(M[:3, :3]) DCNL DCSP i = numpy.where((abs((numpy.real(w) + 1.0)) < 1e-08))[0] DCNL DCSP if (not len(i)): DCNL DCSP  DCSP raise ValueError('no DCSP unit DCSP eigenvector DCSP corresponding DCSP to DCSP eigenvalue DCSP -1') DCNL DCSP normal = numpy.real(V[:, i[0]]).squeeze() DCNL DCSP (w, V) = numpy.linalg.eig(M) DCNL DCSP i = numpy.where((abs((numpy.real(w) - 1.0)) < 1e-08))[0] DCNL DCSP if (not len(i)): DCNL DCSP  DCSP raise ValueError('no DCSP unit DCSP eigenvector DCSP corresponding DCSP to DCSP eigenvalue DCSP 1') DCNL DCSP point = numpy.real(V[:, i[(-1)]]).squeeze() DCNL DCSP point /= point[3] DCNL DCSP return (point, normal)\n", "intent": "return mirror plane point and normal vector from reflection matrix .\n", "question_id": 763}, {"snippet": "def main(): DCNL  DCSP try: DCNL DCSP  DCSP (opts, args) = getopt.getopt(sys.argv[1:], '', ['user=', 'pw=']) DCNL DCSP except getopt.error as msg: DCNL DCSP  DCSP print 'python DCSP docs_example.py DCSP --user DCSP [username] DCSP --pw DCSP [password] DCSP ' DCNL DCSP  DCSP sys.exit(2) DCNL DCSP user = '' DCNL DCSP pw = '' DCNL DCSP key = '' DCNL DCSP for (option, arg) in opts: DCNL DCSP  DCSP if (option == '--user'): DCNL DCSP  DCSP  DCSP user = arg DCNL DCSP  DCSP elif (option == '--pw'): DCNL DCSP  DCSP  DCSP pw = arg DCNL DCSP while (not user): DCNL DCSP  DCSP print 'NOTE: DCSP Please DCSP run DCSP these DCSP tests DCSP only DCSP with DCSP a DCSP test DCSP account.' DCNL DCSP  DCSP user = raw_input('Please DCSP enter DCSP your DCSP username: DCSP ') DCNL DCSP while (not pw): DCNL DCSP  DCSP pw = getpass.getpass() DCNL DCSP  DCSP if (not pw): DCNL DCSP  DCSP  DCSP print 'Password DCSP cannot DCSP be DCSP blank.' DCNL DCSP try: DCNL DCSP  DCSP sample = DocsSample(user, pw) DCNL DCSP except gdata.service.BadAuthentication: DCNL DCSP  DCSP print 'Invalid DCSP user DCSP credentials DCSP given.' DCNL DCSP  DCSP return DCNL DCSP sample.Run()\n", "intent": "demonstrates use of the docs extension using the docssample object .\n", "question_id": 764}, {"snippet": "def instance_group_delete(context, group_uuid): DCNL  DCSP return IMPL.instance_group_delete(context, group_uuid)\n", "intent": "delete an group .\n", "question_id": 765}, {"snippet": "def sbool(s): DCNL  DCSP if isinstance(s, str): DCNL DCSP  DCSP return (s.lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh']) DCNL DCSP else: DCNL DCSP  DCSP return bool(s)\n", "intent": "convert a string that is probably supposed to be a boolean value into an actual bool type .\n", "question_id": 766}, {"snippet": "def send_instant_feedback_message_email(recipient_id, sender_id, message, email_subject, exploration_title, exploration_id, thread_title): DCNL  DCSP email_body_template = 'Hi DCSP %s,<br><br>New DCSP update DCSP to DCSP thread DCSP \"%s\" DCSP on DCSP <a DCSP href=\"https://www.oppia.org/create/%s#/feedback\">%s</a>:<br><ul><li>%s: DCSP %s<br></li></ul>(You DCSP received DCSP this DCSP message DCSP because DCSP you DCSP are DCSP a DCSP participant DCSP in DCSP this DCSP thread.)<br><br>Best DCSP wishes,<br>The DCSP Oppia DCSP team<br><br>%s' DCNL DCSP if (not feconf.CAN_SEND_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP if (not feconf.CAN_SEND_FEEDBACK_MESSAGE_EMAILS): DCNL DCSP  DCSP log_new_error('This DCSP app DCSP cannot DCSP send DCSP feedback DCSP message DCSP emails DCSP to DCSP users.') DCNL DCSP  DCSP return DCNL DCSP sender_settings = user_services.get_user_settings(sender_id) DCNL DCSP recipient_settings = user_services.get_user_settings(recipient_id) DCNL DCSP recipient_preferences = user_services.get_email_preferences(recipient_id) DCNL DCSP if recipient_preferences.can_receive_feedback_message_email: DCNL DCSP  DCSP email_body = (email_body_template % (recipient_settings.username, thread_title, exploration_id, exploration_title, sender_settings.username, message, EMAIL_FOOTER.value)) DCNL DCSP  DCSP _send_email(recipient_id, feconf.SYSTEM_COMMITTER_ID, feconf.EMAIL_INTENT_FEEDBACK_MESSAGE_NOTIFICATION, email_subject, email_body, feconf.NOREPLY_EMAIL_ADDRESS)\n", "intent": "send an email when a new message is posted to a feedback thread .\n", "question_id": 767}, {"snippet": "def reverse_field_path(model, path): DCNL  DCSP reversed_path = [] DCNL DCSP parent = model DCNL DCSP pieces = path.split(LOOKUP_SEP) DCNL DCSP for piece in pieces: DCNL DCSP  DCSP (field, model, direct, m2m) = parent._meta.get_field_by_name(piece) DCNL DCSP  DCSP if (len(reversed_path) == (len(pieces) - 1)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP get_model_from_relation(field) DCNL DCSP  DCSP  DCSP except NotRelationField: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if direct: DCNL DCSP  DCSP  DCSP related_name = field.related_query_name() DCNL DCSP  DCSP  DCSP parent = field.rel.to DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP related_name = field.field.name DCNL DCSP  DCSP  DCSP parent = field.model DCNL DCSP  DCSP reversed_path.insert(0, related_name) DCNL DCSP return (parent, LOOKUP_SEP.join(reversed_path))\n", "intent": "create a reversed field path .\n", "question_id": 768}, {"snippet": "def list_objects(service_instance, vim_object, properties=None): DCNL  DCSP if (properties is None): DCNL DCSP  DCSP properties = ['name'] DCNL DCSP items = [] DCNL DCSP item_list = get_mors_with_properties(service_instance, vim_object, properties) DCNL DCSP for item in item_list: DCNL DCSP  DCSP items.append(item['name']) DCNL DCSP return items\n", "intent": "returns a simple list of objects from a given service instance .\n", "question_id": 769}, {"snippet": "@command('set|showconfig') DCNL def showconfig(): DCNL  DCSP width = util.getxy().width DCNL DCSP width -= 30 DCNL DCSP s = ' DCSP  DCSP %s%-17s%s DCSP : DCSP %s\\n' DCNL DCSP out = (' DCSP  DCSP %s%-17s DCSP  DCSP  DCSP %s%s%s\\n' % (c.ul, 'Key', 'Value', (' DCSP ' * width), c.w)) DCNL DCSP for setting in config: DCNL DCSP  DCSP val = config[setting] DCNL DCSP  DCSP if ((not util.is_known_player(config.PLAYER.get)) and val.require_known_player): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (g.detectable_size and (setting == 'MAX_RESULTS')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (g.detectable_size and (setting == 'CONSOLE_WIDTH')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP out += (s % (c.g, setting.lower(), c.w, val.display)) DCNL DCSP g.content = out DCNL DCSP g.message = ('Enter DCSP %sset DCSP <key> DCSP <value>%s DCSP to DCSP change\\n' % (c.g, c.w)) DCNL DCSP g.message += ('Enter DCSP %sset DCSP all DCSP default%s DCSP to DCSP reset DCSP all' % (c.g, c.w))\n", "intent": "dump config data .\n", "question_id": 770}, {"snippet": "def imdb_proposals(net, imdb): DCNL  DCSP _t = Timer() DCNL DCSP imdb_boxes = [[] for _ in xrange(imdb.num_images)] DCNL DCSP for i in xrange(imdb.num_images): DCNL DCSP  DCSP im = cv2.imread(imdb.image_path_at(i)) DCNL DCSP  DCSP _t.tic() DCNL DCSP  DCSP (imdb_boxes[i], scores) = im_proposals(net, im) DCNL DCSP  DCSP _t.toc() DCNL DCSP  DCSP print 'im_proposals: DCSP {:d}/{:d} DCSP {:.3f}s'.format((i + 1), imdb.num_images, _t.average_time) DCNL DCSP  DCSP if 0: DCNL DCSP  DCSP  DCSP dets = np.hstack((imdb_boxes[i], scores)) DCNL DCSP  DCSP  DCSP _vis_proposals(im, dets[:3, :], thresh=0.9) DCNL DCSP  DCSP  DCSP plt.show() DCNL DCSP return imdb_boxes\n", "intent": "generate rpn proposals on all images in an imdb .\n", "question_id": 771}, {"snippet": "def ipaddr(value, options=None): DCNL  DCSP ipv4_obj = ipv4(value, options=options) DCNL DCSP ipv6_obj = ipv6(value, options=options) DCNL DCSP if ((ipv4_obj is None) or (ipv6_obj is None)): DCNL DCSP  DCSP return (ipv4_obj or ipv6_obj) DCNL DCSP else: DCNL DCSP  DCSP return (ipv4_obj + ipv6_obj)\n", "intent": "filters and returns only valid ip objects .\n", "question_id": 772}, {"snippet": "def get_attribute_value(item, field, context, force=False, skip_autofield=True): DCNL  DCSP try: DCNL DCSP  DCSP value = getattr(item, field.name) DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP raise SkipValue(('Could DCSP not DCSP find DCSP object DCSP for DCSP %s.%s, DCSP ignoring.\\n' % (item.__class__.__name__, field.name))) DCNL DCSP if (skip_autofield and isinstance(field, AutoField)): DCNL DCSP  DCSP raise SkipValue() DCNL DCSP elif (isinstance(field, BooleanField) and (value is not None)): DCNL DCSP  DCSP return repr(bool(value)) DCNL DCSP elif isinstance(field, FileField): DCNL DCSP  DCSP return repr(force_text(value)) DCNL DCSP elif (isinstance(field, ForeignKey) and (value is not None)): DCNL DCSP  DCSP if (field.rel.to is ContentType): DCNL DCSP  DCSP  DCSP return ('ContentType.objects.get(app_label=\"%s\", DCSP model=\"%s\")' % (value.app_label, value.model)) DCNL DCSP  DCSP pk_name = value._meta.pk.name DCNL DCSP  DCSP key = ('%s_%s' % (value.__class__.__name__, getattr(value, pk_name))) DCNL DCSP  DCSP if (key in context): DCNL DCSP  DCSP  DCSP variable_name = context[key] DCNL DCSP  DCSP  DCSP if (variable_name is None): DCNL DCSP  DCSP  DCSP  DCSP raise SkipValue() DCNL DCSP  DCSP  DCSP return ('%s' % variable_name) DCNL DCSP  DCSP elif ((value.__class__ not in context['__avaliable_models']) or force): DCNL DCSP  DCSP  DCSP context['__extra_imports'][value._meta.object_name] = value.__module__ DCNL DCSP  DCSP  DCSP item_locator = orm_item_locator(value) DCNL DCSP  DCSP  DCSP return item_locator DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DoLater(('(FK) DCSP %s.%s\\n' % (item.__class__.__name__, field.name))) DCNL DCSP elif (isinstance(field, (DateField, DateTimeField)) and (value is not None)): DCNL DCSP  DCSP return ('dateutil.parser.parse(\"%s\")' % value.isoformat()) DCNL DCSP else: DCNL DCSP  DCSP return repr(value)\n", "intent": "gets a string version of the given attributes value .\n", "question_id": 773}, {"snippet": "def chisqprob(x, df): DCNL  DCSP if (x <= 0): DCNL DCSP  DCSP return 1.0 DCNL DCSP if (x == 0): DCNL DCSP  DCSP return 0.0 DCNL DCSP if (df <= 0): DCNL DCSP  DCSP raise ValueError('Domain DCSP error.') DCNL DCSP if ((x < 1.0) or (x < df)): DCNL DCSP  DCSP return (1.0 - _igam((0.5 * df), (0.5 * x))) DCNL DCSP return _igamc((0.5 * df), (0.5 * x))\n", "intent": "probability value  for the chi^2 probability distribution .\n", "question_id": 774}, {"snippet": "def remove_queue_name_prefix(name): DCNL  DCSP prefix = _get_queue_name_prefix() DCNL DCSP if (not name.startswith(prefix)): DCNL DCSP  DCSP raise ValueError(u'Queue DCSP name DCSP \"{}\" DCSP is DCSP not DCSP prefixed.'.format(name)) DCNL DCSP return name[len(prefix):]\n", "intent": "remove a queue names prefix .\n", "question_id": 775}, {"snippet": "def attach_server(host, port, cert=None, key=None, chain=None): DCNL  DCSP if (sabnzbd.cfg.ipv6_hosting() or ('::1' not in host)): DCNL DCSP  DCSP http_server = cherrypy._cpserver.Server() DCNL DCSP  DCSP http_server.bind_addr = (host, port) DCNL DCSP  DCSP if (cert and key): DCNL DCSP  DCSP  DCSP http_server.ssl_provider = 'builtin' DCNL DCSP  DCSP  DCSP http_server.ssl_certificate = cert DCNL DCSP  DCSP  DCSP http_server.ssl_private_key = key DCNL DCSP  DCSP  DCSP http_server.ssl_certificate_chain = chain DCNL DCSP  DCSP http_server.subscribe()\n", "intent": "define and attach server .\n", "question_id": 776}, {"snippet": "def show_formats(): DCNL  DCSP from distutils.fancy_getopt import FancyGetopt DCNL DCSP formats = [] DCNL DCSP for format in bdist.format_commands: DCNL DCSP  DCSP formats.append((('formats=' + format), None, bdist.format_command[format][1])) DCNL DCSP pretty_printer = FancyGetopt(formats) DCNL DCSP pretty_printer.print_help('List DCSP of DCSP available DCSP distribution DCSP formats:')\n", "intent": "print list of available formats .\n", "question_id": 777}, {"snippet": "def header_expand(headers): DCNL  DCSP collector = [] DCNL DCSP if isinstance(headers, dict): DCNL DCSP  DCSP headers = list(headers.items()) DCNL DCSP elif isinstance(headers, basestring): DCNL DCSP  DCSP return headers DCNL DCSP elif isinstance(headers, str): DCNL DCSP  DCSP return headers.encode('latin-1') DCNL DCSP elif (headers is None): DCNL DCSP  DCSP return headers DCNL DCSP for (i, (value, params)) in enumerate(headers): DCNL DCSP  DCSP _params = [] DCNL DCSP  DCSP for (p_k, p_v) in list(params.items()): DCNL DCSP  DCSP  DCSP _params.append(('%s=%s' % (p_k, p_v))) DCNL DCSP  DCSP collector.append(value) DCNL DCSP  DCSP collector.append('; DCSP ') DCNL DCSP  DCSP if len(params): DCNL DCSP  DCSP  DCSP collector.append('; DCSP '.join(_params)) DCNL DCSP  DCSP  DCSP if (not (len(headers) == (i + 1))): DCNL DCSP  DCSP  DCSP  DCSP collector.append(', DCSP ') DCNL DCSP if (collector[(-1)] in (', DCSP ', '; DCSP ')): DCNL DCSP  DCSP del collector[(-1)] DCNL DCSP return ''.join(collector)\n", "intent": "returns an http header value string from a dictionary .\n", "question_id": 778}, {"snippet": "def find_files(root, ignore_patterns, verbosity, stdout=sys.stdout, symlinks=False): DCNL  DCSP all_files = [] DCNL DCSP for (dirpath, dirnames, filenames) in walk(root, followlinks=symlinks, ignore_patterns=ignore_patterns, verbosity=verbosity, stdout=stdout): DCNL DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP norm_filepath = os.path.normpath(os.path.join(dirpath, filename)) DCNL DCSP  DCSP  DCSP if is_ignored(norm_filepath, ignore_patterns): DCNL DCSP  DCSP  DCSP  DCSP if (verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stdout.write(('ignoring DCSP file DCSP %s DCSP in DCSP %s\\n' % (filename, dirpath))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP all_files.extend([(dirpath, filename)]) DCNL DCSP all_files.sort() DCNL DCSP return all_files\n", "intent": "helper function to get all files in the given root .\n", "question_id": 779}, {"snippet": "def clip_dump(request): DCNL  DCSP print '\\n[INFO] DCSP Starting DCSP Clipboard DCSP Dump DCSP Service DCSP in DCSP VM/Device' DCNL DCSP try: DCNL DCSP  DCSP data = {} DCNL DCSP  DCSP if (request.method == 'POST'): DCNL DCSP  DCSP  DCSP tools_dir = os.path.join(settings.BASE_DIR, 'DynamicAnalyzer/tools/') DCNL DCSP  DCSP  DCSP adb = getADB(tools_dir) DCNL DCSP  DCSP  DCSP args = [adb, '-s', getIdentifier(), 'shell', 'am', 'startservice', 'opensecurity.clipdump/.ClipDumper'] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subprocess.call(args) DCNL DCSP  DCSP  DCSP  DCSP data = {'status': 'success'} DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP PrintException('[ERROR] DCSP Dumping DCSP Clipboard') DCNL DCSP  DCSP  DCSP  DCSP data = {'status': 'error'} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP data = {'status': 'failed'} DCNL DCSP  DCSP return HttpResponse(json.dumps(data), content_type='application/json') DCNL DCSP except: DCNL DCSP  DCSP PrintException('[ERROR] DCSP Dumping DCSP Clipboard') DCNL DCSP  DCSP return HttpResponseRedirect('/error/')\n", "intent": "dump android clipboard .\n", "question_id": 780}, {"snippet": "def standalone_html_page_for_models(models, resources, title): DCNL  DCSP return file_html(models, resources, title)\n", "intent": "return an html document that renders zero or more bokeh documents or models .\n", "question_id": 781}, {"snippet": "def test_result(): DCNL  DCSP jobs = bg.BackgroundJobManager() DCNL DCSP j = jobs.new(sleeper) DCNL DCSP j.join() DCNL DCSP nt.assert_equal(j.result['interval'], t_short)\n", "intent": "test job submission and result retrieval .\n", "question_id": 782}, {"snippet": "def test_get_init_3(): DCNL  DCSP with make_tempfile(join(TMP_TEST_DIR, '__init__.pyc')): DCNL DCSP  DCSP nt.assert_is_none(mp.get_init(TMP_TEST_DIR))\n", "intent": "get_init cant find __init__ .\n", "question_id": 783}, {"snippet": "def expectation(expr, condition=None, numsamples=None, evaluate=True, **kwargs): DCNL  DCSP if (not random_symbols(expr)): DCNL DCSP  DCSP return expr DCNL DCSP if numsamples: DCNL DCSP  DCSP return sampling_E(expr, condition, numsamples=numsamples) DCNL DCSP if (condition is not None): DCNL DCSP  DCSP return expectation(given(expr, condition), evaluate=evaluate) DCNL DCSP if expr.is_Add: DCNL DCSP  DCSP return Add(*[expectation(arg, evaluate=evaluate) for arg in expr.args]) DCNL DCSP result = pspace(expr).integrate(expr) DCNL DCSP if (evaluate and hasattr(result, 'doit')): DCNL DCSP  DCSP return result.doit(**kwargs) DCNL DCSP else: DCNL DCSP  DCSP return result\n", "intent": "returns the expected value of a random expression parameters expr : expr containing randomsymbols the expression of which you want to compute the expectation value given : expr containing randomsymbols a conditional expression .\n", "question_id": 784}, {"snippet": "def urlencode(value): DCNL  DCSP from django.utils.http import urlquote DCNL DCSP return urlquote(value)\n", "intent": "escapes a value for use in a url .\n", "question_id": 785}, {"snippet": "def RotR_64(x, N): DCNL  DCSP return (np.right_shift(x, (N & 63), dtype=np.uint64) | np.left_shift(x, ((64 - N) & 63), dtype=np.uint64))\n", "intent": "return x rotated right by n .\n", "question_id": 786}, {"snippet": "def _register_mimetype_handlers(**kwargs): DCNL  DCSP from reviewboard.attachments.mimetypes import ImageMimetype, MarkDownMimetype, MimetypeHandler, register_mimetype_handler, ReStructuredTextMimetype, TextMimetype DCNL DCSP register_mimetype_handler(ImageMimetype) DCNL DCSP register_mimetype_handler(MarkDownMimetype) DCNL DCSP register_mimetype_handler(MimetypeHandler) DCNL DCSP register_mimetype_handler(ReStructuredTextMimetype) DCNL DCSP register_mimetype_handler(TextMimetype)\n", "intent": "register all bundled mimetype handlers .\n", "question_id": 787}, {"snippet": "def _find_tcl_tk_dir(): DCNL  DCSP tcl_root = exec_statement(('from DCSP %s DCSP import DCSP Tcl; DCSP print(Tcl().eval(\"info DCSP library\"))' % modname_tkinter)) DCNL DCSP tk_version = exec_statement('from DCSP _tkinter DCSP import DCSP TK_VERSION; DCSP print(TK_VERSION)') DCNL DCSP tk_root = os.path.join(os.path.dirname(tcl_root), ('tk%s' % tk_version)) DCNL DCSP return (tcl_root, tk_root)\n", "intent": "get a platform-agnostic 2-tuple of the absolute paths of the top-level external data directories for both tcl and tk .\n", "question_id": 788}, {"snippet": "def convOutp(images, hidSums, targets, numModulesX, paddingStart, filterSizeX, moduleStride, numImgColors): DCNL  DCSP numGroups = 1 DCNL DCSP partialSum = 0 DCNL DCSP numImages = images.shape[0] DCNL DCSP numFilters = (hidSums.shape[1] / (numModulesX ** 2)) DCNL DCSP assert (targets.shape == (numFilters, ((numImgColors * filterSizeX) * filterSizeX))), ('%s DCSP %d DCSP %d-%d-%d' % (targets.shape.__str__(), numFilters, numImgColors, filterSizeX, filterSizeX)) DCNL DCSP _ConvNet.convOutp(images.p_mat, hidSums.p_mat, targets.p_mat, numModulesX, filterSizeX, (- paddingStart), moduleStride, numImgColors, 1, 0)\n", "intent": "images -  hidsums -  targets - .\n", "question_id": 789}, {"snippet": "def remove_article(text=u''): DCNL  DCSP return re.sub(u'(?i)^(?:(?:A(?!\\\\s+to)n?)|The)\\\\s(\\\\w)', u'\\\\1', text)\n", "intent": "remove the english articles from a text string .\n", "question_id": 790}, {"snippet": "def showWarning(text, parent=None, help='', title='Anki'): DCNL  DCSP return showInfo(text, parent, help, 'warning', title=title)\n", "intent": "show a small warning with an ok button .\n", "question_id": 791}, {"snippet": "def tsem(a, limits=None, inclusive=(True, True), axis=0, ddof=1): DCNL  DCSP a = ma.asarray(a).ravel() DCNL DCSP if (limits is None): DCNL DCSP  DCSP n = float(a.count()) DCNL DCSP  DCSP return (a.std(axis=axis, ddof=ddof) / ma.sqrt(n)) DCNL DCSP am = trima(a.ravel(), limits, inclusive) DCNL DCSP sd = np.sqrt(am.var(axis=axis, ddof=ddof)) DCNL DCSP return (sd / np.sqrt(am.count()))\n", "intent": "compute the trimmed standard error of the mean .\n", "question_id": 792}, {"snippet": "def _rescale_data(X, y, sample_weight): DCNL  DCSP n_samples = X.shape[0] DCNL DCSP sample_weight = (sample_weight * np.ones(n_samples)) DCNL DCSP sample_weight = np.sqrt(sample_weight) DCNL DCSP sw_matrix = sparse.dia_matrix((sample_weight, 0), shape=(n_samples, n_samples)) DCNL DCSP X = safe_sparse_dot(sw_matrix, X) DCNL DCSP y = safe_sparse_dot(sw_matrix, y) DCNL DCSP return (X, y)\n", "intent": "rescale data so as to support sample_weight .\n", "question_id": 793}, {"snippet": "def positive(x): DCNL  DCSP if (x is None): DCNL DCSP  DCSP return DCNL DCSP if is_str(x): DCNL DCSP  DCSP return x DCNL DCSP if (x < 0): DCNL DCSP  DCSP return 0 DCNL DCSP return x\n", "intent": "return zero if value is negative .\n", "question_id": 794}, {"snippet": "@pick_context_manager_writer DCNL def flavor_access_remove(context, flavor_id, project_id): DCNL  DCSP instance_type_id = _flavor_get_id_from_flavor(context, flavor_id) DCNL DCSP count = _flavor_access_query(context).filter_by(instance_type_id=instance_type_id).filter_by(project_id=project_id).soft_delete(synchronize_session=False) DCNL DCSP if (count == 0): DCNL DCSP  DCSP raise exception.FlavorAccessNotFound(flavor_id=flavor_id, project_id=project_id)\n", "intent": "remove given tenant from the flavor access list .\n", "question_id": 795}, {"snippet": "@login_required DCNL def get_token(request, course_id): DCNL  DCSP return HttpResponse(get_edxnotes_id_token(request.user), content_type='text/plain')\n", "intent": "get jwt id-token .\n", "question_id": 796}, {"snippet": "def rgb2hex(c): DCNL  DCSP return to_hex(c)\n", "intent": "given an rgb or rgba sequence of 0-1 floats .\n", "question_id": 797}, {"snippet": "def format_date(time_obj): DCNL  DCSP if isinstance(time_obj, dt.datetime): DCNL DCSP  DCSP time_obj = time_obj.date() DCNL DCSP return time_obj.isoformat()\n", "intent": "return a formatted string version of a date object .\n", "question_id": 798}, {"snippet": "def repartition_npartitions(df, npartitions): DCNL  DCSP npartitions_ratio = (df.npartitions / npartitions) DCNL DCSP new_partitions_boundaries = [int((new_partition_index * npartitions_ratio)) for new_partition_index in range((npartitions + 1))] DCNL DCSP new_name = ('repartition-%d-%s' % (npartitions, tokenize(df))) DCNL DCSP dsk = {} DCNL DCSP for new_partition_index in range(npartitions): DCNL DCSP  DCSP value = (pd.concat, [(df._name, old_partition_index) for old_partition_index in range(new_partitions_boundaries[new_partition_index], new_partitions_boundaries[(new_partition_index + 1)])]) DCNL DCSP  DCSP dsk[(new_name, new_partition_index)] = value DCNL DCSP divisions = [df.divisions[new_partition_index] for new_partition_index in new_partitions_boundaries] DCNL DCSP return DataFrame(merge(df.dask, dsk), new_name, df._meta, divisions)\n", "intent": "repartition dataframe to a smaller number of partitions .\n", "question_id": 799}, {"snippet": "def parse(css): DCNL  DCSP match = _el_re.match(css) DCNL DCSP if match: DCNL DCSP  DCSP return [Selector(Element(element=match.group(1)))] DCNL DCSP match = _id_re.match(css) DCNL DCSP if (match is not None): DCNL DCSP  DCSP return [Selector(Hash(Element(element=(match.group(1) or None)), match.group(2)))] DCNL DCSP match = _class_re.match(css) DCNL DCSP if (match is not None): DCNL DCSP  DCSP return [Selector(Class(Element(element=(match.group(1) or None)), match.group(2)))] DCNL DCSP stream = TokenStream(tokenize(css)) DCNL DCSP stream.source = css DCNL DCSP return list(parse_selector_group(stream))\n", "intent": "parse a css *group of selectors* .\n", "question_id": 800}, {"snippet": "def characters(probabilities): DCNL  DCSP return [id2bi(c) for c in np.argmax(probabilities, 1)]\n", "intent": "turn a 1-hot encoding or a probability distribution over the possible characters back into its  character representation .\n", "question_id": 801}, {"snippet": "def submit_cohort_students(request, course_key, file_name): DCNL  DCSP task_type = 'cohort_students' DCNL DCSP task_class = cohort_students DCNL DCSP task_input = {'file_name': file_name} DCNL DCSP task_key = '' DCNL DCSP return submit_task(request, task_type, task_class, course_key, task_input, task_key)\n", "intent": "request to have students cohorted in bulk .\n", "question_id": 802}, {"snippet": "def search_items(bus, attributes): DCNL  DCSP service_obj = bus_get_object(bus, SS_PATH) DCNL DCSP service_iface = dbus.Interface(service_obj, SERVICE_IFACE) DCNL DCSP (locked, unlocked) = service_iface.SearchItems(attributes, signature='a{ss}') DCNL DCSP for item_path in (locked + unlocked): DCNL DCSP  DCSP (yield Item(bus, item_path))\n", "intent": "returns a generator of items in all collections with the given attributes .\n", "question_id": 803}, {"snippet": "@deprecated DCNL def run_bg(command): DCNL  DCSP bg_job = BgJob(command) DCNL DCSP return (bg_job.sp, bg_job.result)\n", "intent": "function deprecated .\n", "question_id": 804}, {"snippet": "def fragment_sequences(sequence, qualities, splitchar): DCNL  DCSP if (len(sequence) != len(qualities)): DCNL DCSP  DCSP print(sequence, qualities) DCNL DCSP  DCSP raise RuntimeError(\"Internal DCSP error: DCSP length DCSP of DCSP sequence DCSP and DCSP qualities DCSP don't DCSP match???\") DCNL DCSP retlist = [] DCNL DCSP if (len(sequence) == 0): DCNL DCSP  DCSP return retlist DCNL DCSP actseq = [] DCNL DCSP actqual = [] DCNL DCSP if (sequence[0] != splitchar): DCNL DCSP  DCSP inseq = True DCNL DCSP else: DCNL DCSP  DCSP inseq = False DCNL DCSP for (char, qual) in zip(sequence, qualities): DCNL DCSP  DCSP if inseq: DCNL DCSP  DCSP  DCSP if (char != splitchar): DCNL DCSP  DCSP  DCSP  DCSP actseq.append(char) DCNL DCSP  DCSP  DCSP  DCSP actqual.append(qual) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP retlist.append((''.join(actseq), actqual)) DCNL DCSP  DCSP  DCSP  DCSP actseq = [] DCNL DCSP  DCSP  DCSP  DCSP actqual = [] DCNL DCSP  DCSP  DCSP  DCSP inseq = False DCNL DCSP  DCSP elif (char != splitchar): DCNL DCSP  DCSP  DCSP inseq = True DCNL DCSP  DCSP  DCSP actseq.append(char) DCNL DCSP  DCSP  DCSP actqual.append(qual) DCNL DCSP if (inseq and len(actseq)): DCNL DCSP  DCSP retlist.append((''.join(actseq), actqual)) DCNL DCSP return retlist\n", "intent": "works like split() on strings .\n", "question_id": 805}, {"snippet": "def _monkeypatch_console(): DCNL  DCSP try: DCNL DCSP  DCSP import termios DCNL DCSP  DCSP import sys DCNL DCSP  DCSP import pyrepl.unix_console DCNL DCSP  DCSP uc = pyrepl.unix_console.UnixConsole DCNL DCSP  DCSP old = uc.prepare DCNL DCSP  DCSP def prep(self): DCNL DCSP  DCSP  DCSP old(self) DCNL DCSP  DCSP  DCSP f = sys.stdin.fileno() DCNL DCSP  DCSP  DCSP a = termios.tcgetattr(f) DCNL DCSP  DCSP  DCSP a[1] |= 1 DCNL DCSP  DCSP  DCSP termios.tcsetattr(f, termios.TCSANOW, a) DCNL DCSP  DCSP uc.prepare = prep DCNL DCSP except: DCNL DCSP  DCSP pass\n", "intent": "the readline in pypy  turns off output postprocessing .\n", "question_id": 806}, {"snippet": "def test_bad_algo_option(script, tmpdir): DCNL  DCSP result = script.pip('hash', '-a', 'poppycock', _hello_file(tmpdir), expect_error=True) DCNL DCSP assert (\"invalid DCSP choice: DCSP 'poppycock'\" in str(result))\n", "intent": "make sure the -a option raises an error when given a bad operand .\n", "question_id": 807}, {"snippet": "def walk(top, func, arg): DCNL  DCSP try: DCNL DCSP  DCSP names = os.listdir(top) DCNL DCSP except os.error: DCNL DCSP  DCSP return DCNL DCSP func(arg, top, names) DCNL DCSP for name in names: DCNL DCSP  DCSP name = join(top, name) DCNL DCSP  DCSP if (isdir(name) and (not islink(name))): DCNL DCSP  DCSP  DCSP walk(name, func, arg)\n", "intent": "directory tree walk with callback function .\n", "question_id": 808}, {"snippet": "def split_test_name(test): DCNL  DCSP norm = os.path.normpath DCNL DCSP file_or_mod = test DCNL DCSP fn = None DCNL DCSP if (not (':' in test)): DCNL DCSP  DCSP if file_like(test): DCNL DCSP  DCSP  DCSP return (norm(test), None, None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (None, test, None) DCNL DCSP (head, tail) = os.path.split(test) DCNL DCSP if (not head): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (file_or_mod, fn) = test.split(':') DCNL DCSP  DCSP  DCSP if file_like(fn): DCNL DCSP  DCSP  DCSP  DCSP (file_or_mod, fn) = (test, None) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP parts = test.split(':') DCNL DCSP  DCSP  DCSP if (len(parts[0]) == 1): DCNL DCSP  DCSP  DCSP  DCSP (file_or_mod, fn) = (':'.join(parts[:(-1)]), parts[(-1)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError((\"Test DCSP name DCSP '%s' DCSP could DCSP not DCSP be DCSP parsed. DCSP Please DCSP format DCSP test DCSP names DCSP as DCSP path:callable DCSP or DCSP module:callable.\" % (test,))) DCNL DCSP elif (not tail): DCNL DCSP  DCSP file_or_mod = test DCNL DCSP else: DCNL DCSP  DCSP if (':' in tail): DCNL DCSP  DCSP  DCSP (file_part, fn) = tail.split(':') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP file_part = tail DCNL DCSP  DCSP file_or_mod = os.sep.join([head, file_part]) DCNL DCSP if file_or_mod: DCNL DCSP  DCSP if file_like(file_or_mod): DCNL DCSP  DCSP  DCSP return (norm(file_or_mod), None, fn) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (None, file_or_mod, fn) DCNL DCSP else: DCNL DCSP  DCSP return (None, None, fn)\n", "intent": "split a test name into a 3-tuple containing file .\n", "question_id": 809}, {"snippet": "def get_gid(path, follow_symlinks=True): DCNL  DCSP func_name = '{0}.get_gid'.format(__virtualname__) DCNL DCSP if (__opts__.get('fun', '') == func_name): DCNL DCSP  DCSP log.info('The DCSP function DCSP {0} DCSP should DCSP not DCSP be DCSP used DCSP on DCSP Windows DCSP systems; DCSP see DCSP function DCSP docs DCSP for DCSP details. DCSP The DCSP value DCSP returned DCSP is DCSP the DCSP uid.'.format(func_name)) DCNL DCSP return get_uid(path, follow_symlinks)\n", "intent": "return the id of the group that owns a given file under windows .\n", "question_id": 810}, {"snippet": "def nonblocking(pipe): DCNL  DCSP flags = fcntl.fcntl(pipe, fcntl.F_GETFL) DCNL DCSP fcntl.fcntl(pipe, fcntl.F_SETFL, (flags | os.O_NONBLOCK)) DCNL DCSP return pipe\n", "intent": "set python file object to nonblocking mode .\n", "question_id": 811}, {"snippet": "def CopyReversedLines(instream, outstream, blocksize=(2 ** 16)): DCNL  DCSP line_count = 0 DCNL DCSP instream.seek(0, 2) DCNL DCSP last_block = (instream.tell() // blocksize) DCNL DCSP spillover = '' DCNL DCSP for iblock in xrange((last_block + 1), (-1), (-1)): DCNL DCSP  DCSP instream.seek((iblock * blocksize)) DCNL DCSP  DCSP data = instream.read(blocksize) DCNL DCSP  DCSP lines = data.splitlines(True) DCNL DCSP  DCSP lines[(-1):] = ''.join((lines[(-1):] + [spillover])).splitlines(True) DCNL DCSP  DCSP if (lines and (not lines[(-1)].endswith('\\n'))): DCNL DCSP  DCSP  DCSP lines[(-1)] += '\\n' DCNL DCSP  DCSP lines.reverse() DCNL DCSP  DCSP if (lines and (iblock > 0)): DCNL DCSP  DCSP  DCSP spillover = lines.pop() DCNL DCSP  DCSP if lines: DCNL DCSP  DCSP  DCSP line_count += len(lines) DCNL DCSP  DCSP  DCSP data = ''.join(lines).replace('\\x00', '\\n DCTB ') DCNL DCSP  DCSP  DCSP outstream.write(data) DCNL DCSP return line_count\n", "intent": "copy lines from input stream to output stream in reverse order .\n", "question_id": 812}, {"snippet": "def embedded_document(reference, data_relation, field_name): DCNL  DCSP if (('version' in data_relation) and (data_relation['version'] is True)): DCNL DCSP  DCSP embedded_doc = get_data_version_relation_document(data_relation, reference) DCNL DCSP  DCSP latest_embedded_doc = get_data_version_relation_document(data_relation, reference, latest=True) DCNL DCSP  DCSP if ((embedded_doc is None) or (latest_embedded_doc is None)): DCNL DCSP  DCSP  DCSP abort(404, description=debug_error_message((\"Unable DCSP to DCSP locate DCSP embedded DCSP documents DCSP for DCSP '%s'\" % field_name))) DCNL DCSP  DCSP build_response_document(embedded_doc, data_relation['resource'], [], latest_embedded_doc) DCNL DCSP else: DCNL DCSP  DCSP subresource = (reference.collection if isinstance(reference, DBRef) else data_relation['resource']) DCNL DCSP  DCSP id_field = config.DOMAIN[subresource]['id_field'] DCNL DCSP  DCSP embedded_doc = app.data.find_one(subresource, None, **{id_field: (reference.id if isinstance(reference, DBRef) else reference)}) DCNL DCSP  DCSP if embedded_doc: DCNL DCSP  DCSP  DCSP resolve_media_files(embedded_doc, subresource) DCNL DCSP return embedded_doc\n", "intent": "returns a document to be embedded by reference using data_relation taking into account document versions .\n", "question_id": 813}, {"snippet": "def view_image(): DCNL  DCSP try: DCNL DCSP  DCSP _id = request.args[0] DCNL DCSP except: DCNL DCSP  DCSP return 'Need DCSP to DCSP provide DCSP the DCSP id DCSP of DCSP the DCSP Image' DCNL DCSP table = s3db.doc_image DCNL DCSP record = db((table.id == _id)).select(table.name, table.file, table.comments, limitby=(0, 1)).first() DCNL DCSP desc = DIV(record.comments, _class='imageDesc') DCNL DCSP filename = record.name DCNL DCSP url = URL(c='default', f='download', args=record.file) DCNL DCSP alt = (record.comments if record.comments else filename) DCNL DCSP image = IMG(_src=url, _alt=alt) DCNL DCSP output = Storage(image=image, desc=desc) DCNL DCSP return output\n", "intent": "view a fullscreen version of an image - called from reports .\n", "question_id": 814}, {"snippet": "def flag_modified(instance, key): DCNL  DCSP (state, dict_) = (instance_state(instance), instance_dict(instance)) DCNL DCSP impl = state.manager[key].impl DCNL DCSP state._modified_event(dict_, impl, NO_VALUE, force=True)\n", "intent": "mark an attribute on an instance as modified .\n", "question_id": 815}, {"snippet": "def is_dn(s): DCNL  DCSP if (s == ''): DCNL DCSP  DCSP return 1 DCNL DCSP rm = dn_regex.match(s) DCNL DCSP return ((rm != None) and (rm.group(0) == s))\n", "intent": "returns 1 if s is a ldap dn .\n", "question_id": 816}, {"snippet": "def mul(self, rhs): DCNL  DCSP if isinstance(rhs, variable.Variable): DCNL DCSP  DCSP return Mul()(self, rhs) DCNL DCSP _check_constant_type(rhs) DCNL DCSP return MulConstant(rhs)(self)\n", "intent": "element-wise multiplication .\n", "question_id": 817}, {"snippet": "def _PrepareSpecialProperties(entity_proto, is_load): DCNL  DCSP for i in xrange((entity_proto.property_size() - 1), (-1), (-1)): DCNL DCSP  DCSP if _SPECIAL_PROPERTY_MAP.has_key(entity_proto.property(i).name()): DCNL DCSP  DCSP  DCSP del entity_proto.property_list()[i] DCNL DCSP for (is_visible, is_stored, property_func) in _SPECIAL_PROPERTY_MAP.values(): DCNL DCSP  DCSP if is_load: DCNL DCSP  DCSP  DCSP should_process = is_visible DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP should_process = is_stored DCNL DCSP  DCSP if should_process: DCNL DCSP  DCSP  DCSP special_property = property_func(entity_proto) DCNL DCSP  DCSP  DCSP if special_property: DCNL DCSP  DCSP  DCSP  DCSP entity_proto.property_list().append(special_property)\n", "intent": "computes special properties for loading or storing .\n", "question_id": 818}, {"snippet": "def image_resize_image_medium(base64_source, size=(128, 128), encoding='base64', filetype=None, avoid_if_small=False): DCNL  DCSP return image_resize_image(base64_source, size, encoding, filetype, avoid_if_small)\n", "intent": "wrapper on image_resize_image .\n", "question_id": 819}, {"snippet": "def lock_host(func, *args, **kwargs): DCNL  DCSP def inner(self, *args, **kwargs): DCNL DCSP  DCSP self.host_lock.acquire() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res = func(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP self.host_lock.release() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP self.host_lock.release() DCNL DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP return res DCNL DCSP return inner\n", "intent": "a decorator that acquires a lock before accessing the debugger to avoid api locking related errors with the debugger host .\n", "question_id": 820}, {"snippet": "def _polar_to_cartesian(theta, r): DCNL  DCSP x = (r * np.cos(theta)) DCNL DCSP y = (r * np.sin(theta)) DCNL DCSP return (x, y)\n", "intent": "transform polar coordinates to cartesian .\n", "question_id": 821}, {"snippet": "@event(u'manager.config_updated') DCNL @event(u'manager.daemon.started') DCNL def register_web_server(manager): DCNL  DCSP global web_server, config_hash DCNL DCSP if (not manager.is_daemon): DCNL DCSP  DCSP return DCNL DCSP config = manager.config.get(u'web_server') DCNL DCSP if (get_config_hash(config) == config_hash): DCNL DCSP  DCSP log.debug(u\"web DCSP server DCSP config DCSP has'nt DCSP changed\") DCNL DCSP  DCSP return DCNL DCSP config_hash = get_config_hash(config) DCNL DCSP web_server_config = prepare_config(config) DCNL DCSP stop_server(manager) DCNL DCSP if (not web_server_config): DCNL DCSP  DCSP return DCNL DCSP log.info(u'Running DCSP web DCSP server DCSP at DCSP IP DCSP %s:%s', web_server_config[u'bind'], web_server_config[u'port']) DCNL DCSP api_app.secret_key = get_secret() DCNL DCSP log.info(u'Initiating DCSP API') DCNL DCSP register_app(u'/api', api_app) DCNL DCSP if web_server_config.get(u'web_ui'): DCNL DCSP  DCSP log.info(u'Registering DCSP WebUI') DCNL DCSP  DCSP register_web_ui(manager) DCNL DCSP web_server = setup_server(web_server_config)\n", "intent": "registers web server and loads api  and webui via config .\n", "question_id": 822}, {"snippet": "def max_api_window(user): DCNL  DCSP return _rules_for_user(user)[(-1)][0]\n", "intent": "returns the api time window for the highest limit .\n", "question_id": 823}, {"snippet": "def _list_iter(host=None, path=None): DCNL  DCSP tgt = (host or '*') DCNL DCSP client = salt.client.get_local_client(__opts__['conf_file']) DCNL DCSP for container_info in client.cmd_iter(tgt, 'lxc.list', kwarg={'path': path}): DCNL DCSP  DCSP if (not container_info): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not isinstance(container_info, dict)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chunk = {} DCNL DCSP  DCSP id_ = next(six.iterkeys(container_info)) DCNL DCSP  DCSP if (host and (host != id_)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not isinstance(container_info[id_], dict)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('ret' not in container_info[id_]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not isinstance(container_info[id_]['ret'], dict)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chunk[id_] = container_info[id_]['ret'] DCNL DCSP  DCSP (yield chunk)\n", "intent": "return a generator iterating over hosts path path to the container parent default: /var/lib/lxc .\n", "question_id": 824}, {"snippet": "@task DCNL @needs('pavelib.i18n.i18n_extract') DCNL @timed DCNL def i18n_generate_strict(): DCNL  DCSP sh('i18n_tool DCSP generate DCSP --strict')\n", "intent": "compile localizable strings from sources .\n", "question_id": 825}, {"snippet": "def get_secondary_language(current_site=None): DCNL  DCSP current_site = (current_site or Site.objects.get_current()) DCNL DCSP return get_languages()[current_site.id][1]['code']\n", "intent": "fetch the other language of the current site settings .\n", "question_id": 826}, {"snippet": "def list_avail(): DCNL  DCSP cmd = 'locale DCSP -a' DCNL DCSP out = __salt__['cmd.run'](cmd).split('\\n') DCNL DCSP return out\n", "intent": "lists available  locales cli example: .\n", "question_id": 827}, {"snippet": "def randslice_from_slicelen(slicelen, listlen): DCNL  DCSP maxstart = (listlen - slicelen) DCNL DCSP start = randrange((maxstart + 1)) DCNL DCSP maxstep = (((listlen - start) // slicelen) if slicelen else 1) DCNL DCSP step = randrange(1, (maxstep + 1)) DCNL DCSP stop = (start + (slicelen * step)) DCNL DCSP s = slice(start, stop, step) DCNL DCSP (_, _, _, control) = slice_indices(s, listlen) DCNL DCSP if (control != slicelen): DCNL DCSP  DCSP raise RuntimeError DCNL DCSP return s\n", "intent": "create a random slice of len slicelen that fits into listlen .\n", "question_id": 828}, {"snippet": "def find_p_q(nbits, getprime_func=rsa.prime.getprime, accurate=True): DCNL  DCSP total_bits = (nbits * 2) DCNL DCSP shift = (nbits // 16) DCNL DCSP pbits = (nbits + shift) DCNL DCSP qbits = (nbits - shift) DCNL DCSP log.debug('find_p_q(%i): DCSP Finding DCSP p', nbits) DCNL DCSP p = getprime_func(pbits) DCNL DCSP log.debug('find_p_q(%i): DCSP Finding DCSP q', nbits) DCNL DCSP q = getprime_func(qbits) DCNL DCSP def is_acceptable(p, q): DCNL DCSP  DCSP 'Returns DCSP True DCSP iff DCSP p DCSP and DCSP q DCSP are DCSP acceptable:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP p DCSP and DCSP q DCSP differ\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP (p DCSP * DCSP q) DCSP has DCSP the DCSP right DCSP nr DCSP of DCSP bits DCSP (when DCSP accurate=True)\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (p == q): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (not accurate): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP found_size = rsa.common.bit_size((p * q)) DCNL DCSP  DCSP return (total_bits == found_size) DCNL DCSP change_p = False DCNL DCSP while (not is_acceptable(p, q)): DCNL DCSP  DCSP if change_p: DCNL DCSP  DCSP  DCSP p = getprime_func(pbits) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP q = getprime_func(qbits) DCNL DCSP  DCSP change_p = (not change_p) DCNL DCSP return (max(p, q), min(p, q))\n", "intent": "returns a tuple of two different primes of nbits bits each .\n", "question_id": 829}, {"snippet": "def debugHandler(widget, event, *a): DCNL  DCSP if (event.type in event_types): DCNL DCSP  DCSP print event.type.value_nick\n", "intent": "just connect it to the event event .\n", "question_id": 830}, {"snippet": "def get_constant(lin_op): DCNL  DCSP constant = mul(lin_op, {}) DCNL DCSP const_size = (constant.shape[0] * constant.shape[1]) DCNL DCSP return np.reshape(constant, const_size, 'F')\n", "intent": "returns the constant term in the expression .\n", "question_id": 831}, {"snippet": "def init(): DCNL  DCSP if (not os.path.exists(__opts__['spm_cache_dir'])): DCNL DCSP  DCSP log.debug('Creating DCSP SPM DCSP cache DCSP directory DCSP at DCSP {0}'.format(__opts__['spm_db'])) DCNL DCSP  DCSP os.makedirs(__opts__['spm_cache_dir']) DCNL DCSP if (not os.path.exists(__opts__['spm_db'])): DCNL DCSP  DCSP log.debug('Creating DCSP new DCSP package DCSP database DCSP at DCSP {0}'.format(__opts__['spm_db'])) DCNL DCSP sqlite3.enable_callback_tracebacks(True) DCNL DCSP conn = sqlite3.connect(__opts__['spm_db'], isolation_level=None) DCNL DCSP try: DCNL DCSP  DCSP conn.execute('SELECT DCSP count(*) DCSP FROM DCSP packages') DCNL DCSP except OperationalError: DCNL DCSP  DCSP conn.execute('CREATE DCSP TABLE DCSP packages DCSP (\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP package DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP version DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP release DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP installed DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os_family DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dependencies DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os_dependencies DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os_family_dependencies DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP summary DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP description DCSP text\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )') DCNL DCSP try: DCNL DCSP  DCSP conn.execute('SELECT DCSP count(*) DCSP FROM DCSP files') DCNL DCSP except OperationalError: DCNL DCSP  DCSP conn.execute('CREATE DCSP TABLE DCSP files DCSP (\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP package DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP path DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP real,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mode DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sum DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP major DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP minor DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP linkname DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP linkpath DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP uname DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gname DCSP text,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mtime DCSP text\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )') DCNL DCSP return conn\n", "intent": "get an sqlite3 connection .\n", "question_id": 832}, {"snippet": "@pytest.mark.parametrize('inp, DCSP commands, DCSP offset', [('', CMDS, (0, 1)), ('-r', list(reversed(CMDS)), ((len(CMDS) - 1), (-1))), ('0', CMDS[0:1], (0, 1)), ('1', CMDS[1:2], (1, 1)), ('-2', CMDS[(-2):(-1)], ((len(CMDS) - 2), 1)), ('1:3', CMDS[1:3], (1, 1)), ('1::2', CMDS[1::2], (1, 2)), ('-4:-2', CMDS[(-4):(-2)], ((len(CMDS) - 4), 1))]) DCNL def test_show_cmd_numerate(inp, commands, offset, hist, xonsh_builtins, capsys): DCNL  DCSP (base_idx, step) = offset DCNL DCSP xonsh_builtins.__xonsh_history__ = hist DCNL DCSP xonsh_builtins.__xonsh_env__['HISTCONTROL'] = set() DCNL DCSP for (ts, cmd) in enumerate(CMDS): DCNL DCSP  DCSP hist.append({'inp': cmd, 'rtn': 0, 'ts': ((ts + 1), (ts + 1.5))}) DCNL DCSP exp = ('{}: DCSP {}'.format((base_idx + (idx * step)), cmd) for (idx, cmd) in enumerate(list(commands))) DCNL DCSP exp = '\\n'.join(exp) DCNL DCSP history_main((['show', '-n'] + shlex.split(inp))) DCNL DCSP (out, err) = capsys.readouterr() DCNL DCSP assert (out.rstrip() == exp)\n", "intent": "verify that cli history commands work .\n", "question_id": 833}, {"snippet": "def get_format_modules(lang=None, reverse=False): DCNL  DCSP if (lang is None): DCNL DCSP  DCSP lang = get_language() DCNL DCSP modules = _format_modules_cache.setdefault(lang, list(iter_format_modules(lang))) DCNL DCSP if reverse: DCNL DCSP  DCSP return list(reversed(modules)) DCNL DCSP return modules\n", "intent": "returns a list of the format modules found .\n", "question_id": 834}, {"snippet": "def run(framework_name, *args): DCNL  DCSP FRAMEWORKS[framework_name]() DCNL DCSP sys.argv[:] = (['setup.py', 'test'] + list(args)) DCNL DCSP import setup\n", "intent": "run tests with monkey-patching enabled .\n", "question_id": 835}, {"snippet": "def survey_getWidgetFromQuestion(question_id): DCNL  DCSP qtable = current.s3db.survey_question DCNL DCSP question = current.db((qtable.id == question_id)).select(qtable.type, limitby=(0, 1)).first() DCNL DCSP question_type = question.type DCNL DCSP widget_obj = survey_question_type[question_type](question_id) DCNL DCSP return widget_obj\n", "intent": "function that gets the right widget for the question .\n", "question_id": 836}, {"snippet": "def main(): DCNL  DCSP with open(FLAGS.partition_fn, 'r') as infile: DCNL DCSP  DCSP img_fn_list = infile.readlines() DCNL DCSP img_fn_list = [elem.strip().split() for elem in img_fn_list] DCNL DCSP img_fn_list = [elem[0] for elem in img_fn_list if (elem[1] == FLAGS.set)] DCNL DCSP fn_root = FLAGS.fn_root DCNL DCSP num_examples = len(img_fn_list) DCNL DCSP file_out = ('%s.tfrecords' % FLAGS.file_out) DCNL DCSP writer = tf.python_io.TFRecordWriter(file_out) DCNL DCSP for (example_idx, img_fn) in enumerate(img_fn_list): DCNL DCSP  DCSP if ((example_idx % 1000) == 0): DCNL DCSP  DCSP  DCSP print example_idx, '/', num_examples DCNL DCSP  DCSP image_raw = scipy.ndimage.imread(os.path.join(fn_root, img_fn)) DCNL DCSP  DCSP rows = image_raw.shape[0] DCNL DCSP  DCSP cols = image_raw.shape[1] DCNL DCSP  DCSP depth = image_raw.shape[2] DCNL DCSP  DCSP image_raw = image_raw.tostring() DCNL DCSP  DCSP example = tf.train.Example(features=tf.train.Features(feature={'height': _int64_feature(rows), 'width': _int64_feature(cols), 'depth': _int64_feature(depth), 'image_raw': _bytes_feature(image_raw)})) DCNL DCSP  DCSP writer.write(example.SerializeToString()) DCNL DCSP writer.close()\n", "intent": "main converter function .\n", "question_id": 837}, {"snippet": "def master_event(type, master=None): DCNL  DCSP event_map = {'connected': '__master_connected', 'disconnected': '__master_disconnected', 'failback': '__master_failback', 'alive': '__master_alive'} DCNL DCSP if ((type == 'alive') and (master is not None)): DCNL DCSP  DCSP return '{0}_{1}'.format(event_map.get(type), master) DCNL DCSP return event_map.get(type, None)\n", "intent": "centralized master event function which will return event type based on event_map .\n", "question_id": 838}, {"snippet": "def _check_available(name): DCNL  DCSP _status = _systemctl_status(name) DCNL DCSP sd_version = salt.utils.systemd.version(__context__) DCNL DCSP if ((sd_version is not None) and (sd_version >= 231)): DCNL DCSP  DCSP return (0 <= _status['retcode'] < 4) DCNL DCSP out = _status['stdout'].lower() DCNL DCSP if ('could DCSP not DCSP be DCSP found' in out): DCNL DCSP  DCSP return False DCNL DCSP for line in salt.utils.itertools.split(out, '\\n'): DCNL DCSP  DCSP match = re.match('\\\\s+loaded:\\\\s+(\\\\S+)', line) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP ret = (match.group(1) != 'not-found') DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise CommandExecutionError((\"Failed DCSP to DCSP get DCSP information DCSP on DCSP unit DCSP '%s'\" % name)) DCNL DCSP return ret\n", "intent": "returns boolean telling whether or not the named service is available .\n", "question_id": 839}, {"snippet": "@treeio_login_required DCNL @handle_response_format DCNL def subscription_index(request, response_format='html'): DCNL  DCSP query = Q(status__hidden=False) DCNL DCSP if request.GET: DCNL DCSP  DCSP if (('status' in request.GET) and request.GET['status']): DCNL DCSP  DCSP  DCSP query = _get_filter_query(request.GET) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = (query & _get_filter_query(request.GET)) DCNL DCSP subscriptions = Object.filter_by_request(request, Subscription.objects.filter(query), mode='r') DCNL DCSP filters = OrderFilterForm(request.user.profile, '', request.GET) DCNL DCSP ordered_products = subscriptions.orderedproduct_set.all() DCNL DCSP orders = ordered_products.order_set.all() DCNL DCSP statuses = Object.filter_by_request(request, SaleStatus.objects, mode='r') DCNL DCSP return render_to_response('sales/index', {'orders': orders, 'products': ordered_products, 'filters': filters, 'statuses': statuses}, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "subscription index page .\n", "question_id": 840}, {"snippet": "@with_setup(setup, teardown) DCNL def test_show_reconstructions(): DCNL  DCSP rows = 5 DCNL DCSP cols = 10 DCNL DCSP m = (rows * cols) DCNL DCSP model = show_reconstruct.load_model('dbm.pkl', m) DCNL DCSP dataset = show_reconstruct.load_dataset(model.dataset_yaml_src, use_test_set='n') DCNL DCSP batch = model.visible_layer.space.make_theano_batch() DCNL DCSP reconstruction = model.reconstruct(batch) DCNL DCSP recons_func = function([batch], reconstruction) DCNL DCSP vis_batch = dataset.get_batch_topo(m) DCNL DCSP patch_viewer = show_reconstruct.init_viewer(dataset, rows, cols, vis_batch) DCNL DCSP show_reconstruct.update_viewer(dataset, batch, rows, cols, patch_viewer, recons_func, vis_batch)\n", "intent": "test the reconstruction update_viewer function .\n", "question_id": 841}, {"snippet": "def change_name(command_table, session, **kwargs): DCNL  DCSP utils.rename_command(command_table, 'codedeploy', 'deploy')\n", "intent": "change all existing aws codedeploy commands to aws deploy commands .\n", "question_id": 842}, {"snippet": "def permission_blacked_out(course, role_names, permission_name): DCNL  DCSP return ((not course.forum_posts_allowed) and (role_names == {FORUM_ROLE_STUDENT}) and any([permission_name.startswith(prefix) for prefix in ['edit', 'update', 'create']]))\n", "intent": "returns true if a user in course with the given roles would have permission_name blacked out .\n", "question_id": 843}, {"snippet": "def B_012(x): DCNL  DCSP x = np.atleast_1d(x) DCNL DCSP return np.piecewise(x, [((x < 0) | (x > 2)), ((x >= 0) & (x < 1)), ((x >= 1) & (x <= 2))], [(lambda x: 0.0), (lambda x: x), (lambda x: (2.0 - x))])\n", "intent": "a linear b-spline function b .\n", "question_id": 844}, {"snippet": "@loader_option() DCNL def joinedload(loadopt, attr, innerjoin=None): DCNL  DCSP loader = loadopt.set_relationship_strategy(attr, {'lazy': 'joined'}) DCNL DCSP if (innerjoin is not None): DCNL DCSP  DCSP loader.local_opts['innerjoin'] = innerjoin DCNL DCSP return loader\n", "intent": "indicate that the given attribute should be loaded using joined eager loading .\n", "question_id": 845}, {"snippet": "@pytest.fixture() DCNL def load_file(filepath): DCNL  DCSP def make_load_file(filename, encoding='utf-8'): DCNL DCSP  DCSP with io.open(filepath(filename), encoding=encoding) as f: DCNL DCSP  DCSP  DCSP return f.read() DCNL DCSP return make_load_file\n", "intent": "opens filename with encoding and return its contents .\n", "question_id": 846}, {"snippet": "def format_exc(frame=None): DCNL  DCSP exc_info = sys.exc_info() DCNL DCSP exc_desc = u'' DCNL DCSP callstack = traceback.extract_stack(frame) DCNL DCSP callstack = callstack[:(-1)] DCNL DCSP if (exc_info[0] is not None): DCNL DCSP  DCSP exception_callstack = traceback.extract_tb(exc_info[2]) DCNL DCSP  DCSP if (callstack[(-1)][0] == exception_callstack[0][0]): DCNL DCSP  DCSP  DCSP callstack = callstack[:(-1)] DCNL DCSP  DCSP  DCSP callstack.extend(exception_callstack) DCNL DCSP  DCSP  DCSP exc_desc = decode(''.join(traceback.format_exception_only(exc_info[0], exc_info[1]))) DCNL DCSP msg = u'Traceback DCSP (most DCSP recent DCSP call DCSP last):\\n' DCNL DCSP msg += decode(''.join(traceback.format_list(callstack))) DCNL DCSP msg += exc_desc DCNL DCSP return msg\n", "intent": "format call-stack and display exception information .\n", "question_id": 847}, {"snippet": "@contextmanager DCNL def set_timezone(tz): DCNL  DCSP if is_platform_windows(): DCNL DCSP  DCSP import nose DCNL DCSP  DCSP raise nose.SkipTest('timezone DCSP setting DCSP not DCSP supported DCSP on DCSP windows') DCNL DCSP import os DCNL DCSP import time DCNL DCSP def setTZ(tz): DCNL DCSP  DCSP if (tz is None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP del os.environ['TZ'] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP os.environ['TZ'] = tz DCNL DCSP  DCSP  DCSP time.tzset() DCNL DCSP orig_tz = os.environ.get('TZ') DCNL DCSP setTZ(tz) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP setTZ(orig_tz)\n", "intent": "context manager for temporarily setting a timezone .\n", "question_id": 848}, {"snippet": "def load_mrjob_conf(conf_path=None): DCNL  DCSP conf_path = _expanded_mrjob_conf_path(conf_path) DCNL DCSP return _conf_object_at_path(conf_path)\n", "intent": "shortcut for automatically loading mrjob .\n", "question_id": 849}, {"snippet": "def _find_topomap_coords(info, picks, layout=None): DCNL  DCSP if (len(picks) == 0): DCNL DCSP  DCSP raise ValueError('Need DCSP more DCSP than DCSP 0 DCSP channels.') DCNL DCSP if (layout is not None): DCNL DCSP  DCSP chs = [info['chs'][i] for i in picks] DCNL DCSP  DCSP pos = [layout.pos[layout.names.index(ch['ch_name'])] for ch in chs] DCNL DCSP  DCSP pos = np.asarray(pos) DCNL DCSP else: DCNL DCSP  DCSP pos = _auto_topomap_coords(info, picks) DCNL DCSP return pos\n", "intent": "guess the e/meg layout and return appropriate topomap coordinates .\n", "question_id": 850}, {"snippet": "def Deserializer(object_list, **options): DCNL  DCSP models.get_apps() DCNL DCSP for d in object_list: DCNL DCSP  DCSP Model = _get_model(d['model']) DCNL DCSP  DCSP data = {Model._meta.pk.attname: Model._meta.pk.to_python(d['pk'])} DCNL DCSP  DCSP m2m_data = {} DCNL DCSP  DCSP for (field_name, field_value) in d['fields'].iteritems(): DCNL DCSP  DCSP  DCSP if isinstance(field_value, unicode): DCNL DCSP  DCSP  DCSP  DCSP field_value = field_value.encode(options.get('encoding', settings.DEFAULT_CHARSET)) DCNL DCSP  DCSP  DCSP field = Model._meta.get_field(field_name) DCNL DCSP  DCSP  DCSP if (field.rel and isinstance(field.rel, models.ManyToManyRel)): DCNL DCSP  DCSP  DCSP  DCSP pks = [] DCNL DCSP  DCSP  DCSP  DCSP m2m_convert = field.rel.to._meta.pk.to_python DCNL DCSP  DCSP  DCSP  DCSP for pk in field_value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(pk, unicode): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pks.append(m2m_convert(pk.encode(options.get('encoding', settings.DEFAULT_CHARSET)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pks.append(m2m_convert(pk)) DCNL DCSP  DCSP  DCSP  DCSP m2m_data[field.name] = pks DCNL DCSP  DCSP  DCSP elif (field.rel and isinstance(field.rel, models.ManyToOneRel)): DCNL DCSP  DCSP  DCSP  DCSP data[field.attname] = field.rel.to._meta.pk.to_python(field_value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP data[field.name] = field.to_python(field_value) DCNL DCSP  DCSP (yield base.DeserializedObject(Model(**data), m2m_data))\n", "intent": "deserialize simple python objects back into django orm instances .\n", "question_id": 851}, {"snippet": "def _should_keep_module(name): DCNL  DCSP return ((name in ('__builtin__', 'sys', 'codecs', 'encodings', 'site', 'google', 'crontab', 'pwd')) or name.startswith('google.') or name.startswith('encodings.') or ('mysql' in name.lower()))\n", "intent": "returns true if the module should be retained after sandboxing .\n", "question_id": 852}, {"snippet": "def compat_patch_logging_config(logging_config): DCNL  DCSP if ('filters' not in logging_config.get('handlers', {}).get('mail_admins', {'filters': []})): DCNL DCSP  DCSP warnings.warn(\"You DCSP have DCSP no DCSP filters DCSP defined DCSP on DCSP the DCSP 'mail_admins' DCSP logging DCSP handler: DCSP adding DCSP implicit DCSP debug-false-only DCSP filter. DCSP See DCSP http://docs.djangoproject.com/en/dev/releases/1.4/#request-exceptions-are-now-always-logged\", DeprecationWarning) DCNL DCSP  DCSP filter_name = 'require_debug_false' DCNL DCSP  DCSP filters = logging_config.setdefault('filters', {}) DCNL DCSP  DCSP while (filter_name in filters): DCNL DCSP  DCSP  DCSP filter_name = (filter_name + '_') DCNL DCSP  DCSP filters[filter_name] = {'()': 'django.utils.log.RequireDebugFalse'} DCNL DCSP  DCSP logging_config['handlers']['mail_admins']['filters'] = [filter_name]\n", "intent": "backwards-compatibility shim for #16288 fix .\n", "question_id": 853}, {"snippet": "def set_shortcut(context, name, keystr): DCNL  DCSP CONF.set('shortcuts', ('%s/%s' % (context, name)), keystr)\n", "intent": "set keyboard shortcut .\n", "question_id": 854}, {"snippet": "def find_jar_path(): DCNL  DCSP paths = [] DCNL DCSP jar_file = u'py4j{0}.jar'.format(__version__) DCNL DCSP paths.append(jar_file) DCNL DCSP paths.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), (u'../../../py4j-java/' + jar_file))) DCNL DCSP paths.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), (u'../share/py4j/' + jar_file))) DCNL DCSP paths.append((u'../../../current-release/' + jar_file)) DCNL DCSP paths.append(os.path.join(sys.prefix, (u'share/py4j/' + jar_file))) DCNL DCSP for path in paths: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return path DCNL DCSP return u''\n", "intent": "tries to find the path where the py4j jar is located .\n", "question_id": 855}, {"snippet": "@handle_response_format DCNL @treeio_login_required DCNL def milestone_set_status(request, milestone_id, status_id, response_format='html'): DCNL  DCSP milestone = get_object_or_404(Milestone, pk=milestone_id) DCNL DCSP if (not request.user.profile.has_permission(milestone, mode='x')): DCNL DCSP  DCSP return user_denied(request, message=\"You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Milestone\") DCNL DCSP status = get_object_or_404(TaskStatus, pk=status_id) DCNL DCSP if (not request.user.profile.has_permission(status)): DCNL DCSP  DCSP return user_denied(request, message=\"You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Milestone DCSP Status\") DCNL DCSP if (not (milestone.status == status)): DCNL DCSP  DCSP milestone.status = status DCNL DCSP  DCSP milestone.save() DCNL DCSP return milestone_view(request, milestone_id, response_format)\n", "intent": "milestone quick set: status .\n", "question_id": 856}, {"snippet": "def _linear_2eq_order2_type2(x, y, t, r, eq): DCNL  DCSP (x0, y0) = symbols('x0, DCSP y0') DCNL DCSP if (((r['c1'] * r['d2']) - (r['c2'] * r['d1'])) != 0): DCNL DCSP  DCSP sol = solve(((((r['c1'] * x0) + (r['d1'] * y0)) + r['e1']), (((r['c2'] * x0) + (r['d2'] * y0)) + r['e2'])), x0, y0) DCNL DCSP  DCSP psol = [sol[x0], sol[y0]] DCNL DCSP elif ((((r['c1'] * r['d2']) - (r['c2'] * r['d1'])) == 0) and (((r['c1'] ** 2) + (r['d1'] ** 2)) > 0)): DCNL DCSP  DCSP k = (r['c2'] / r['c1']) DCNL DCSP  DCSP sig = (r['c1'] + (r['d1'] * k)) DCNL DCSP  DCSP if (sig != 0): DCNL DCSP  DCSP  DCSP psol1 = (((((r['d1'] * (sig ** (-1))) * ((r['e1'] * k) - r['e2'])) * (t ** 2)) / 2) - ((sig ** (-2)) * ((r['c1'] * r['e1']) + (r['d1'] * r['e2'])))) DCNL DCSP  DCSP  DCSP psol2 = ((k * psol1) + (((r['e2'] - (r['e1'] * k)) * (t ** 2)) / 2)) DCNL DCSP  DCSP  DCSP psol = [psol1, psol2] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP psol1 = ((((r['d1'] * (r['e2'] - (r['e1'] * k))) * (t ** 4)) / 24) + ((r['e1'] * (t ** 2)) / 2)) DCNL DCSP  DCSP  DCSP psol2 = ((k * psol1) + (((r['e2'] - (r['e1'] * k)) * (t ** 2)) / 2)) DCNL DCSP  DCSP  DCSP psol = [psol1, psol2] DCNL DCSP return psol\n", "intent": "the equations in this type are .\n", "question_id": 857}, {"snippet": "def list_upgrades(refresh=True, backtrack=3, **kwargs): DCNL  DCSP if salt.utils.is_true(refresh): DCNL DCSP  DCSP refresh_db() DCNL DCSP return _get_upgradable(backtrack)\n", "intent": "list all available package upgrades .\n", "question_id": 858}, {"snippet": "def checksum(digits): DCNL  DCSP remainder = 10 DCNL DCSP for digit in digits: DCNL DCSP  DCSP remainder = ((remainder + digit) % 10) DCNL DCSP  DCSP if (remainder == 0): DCNL DCSP  DCSP  DCSP remainder = 10 DCNL DCSP  DCSP remainder = ((remainder * 2) % 11) DCNL DCSP control_digit = (11 - remainder) DCNL DCSP if (control_digit == 10): DCNL DCSP  DCSP control_digit = 0 DCNL DCSP return control_digit\n", "intent": "calculate and return control digit for given list of digits based on iso7064 .\n", "question_id": 859}, {"snippet": "def iter_period(start, end, period): DCNL  DCSP period_start = start DCNL DCSP increment = datetime.timedelta(seconds=period) DCNL DCSP for i in moves.xrange(int(math.ceil((timeutils.delta_seconds(start, end) / float(period))))): DCNL DCSP  DCSP next_start = (period_start + increment) DCNL DCSP  DCSP (yield (period_start, next_start)) DCNL DCSP  DCSP period_start = next_start\n", "intent": "split a time from start to end in periods of a number of seconds .\n", "question_id": 860}, {"snippet": "def fixed_ip_associate_pool(context, network_id, instance_uuid=None, host=None, virtual_interface_id=None): DCNL  DCSP return IMPL.fixed_ip_associate_pool(context, network_id, instance_uuid, host, virtual_interface_id)\n", "intent": "find free ip in network and associate it to instance or host .\n", "question_id": 861}, {"snippet": "def sub64(a, b): DCNL  DCSP return np.subtract(a, b, dtype=np.uint64)\n", "intent": "return a 64-bit integer difference of a and b .\n", "question_id": 862}, {"snippet": "def UnwrapMimeCrypto(part, protocols=None, psi=None, pei=None, charsets=None, depth=0): DCNL  DCSP if (depth > 6): DCNL DCSP  DCSP return DCNL DCSP part.signature_info = SignatureInfo(parent=psi) DCNL DCSP part.encryption_info = EncryptionInfo(parent=pei) DCNL DCSP mimetype = (part.get_content_type() or 'text/plain') DCNL DCSP disposition = (part['content-disposition'] or '') DCNL DCSP encoding = (part['content-transfer-encoding'] or '') DCNL DCSP crypto_cls = protocols['openpgp'] DCNL DCSP if part.is_multipart(): DCNL DCSP  DCSP part.signature_info.bubbly = False DCNL DCSP  DCSP part.encryption_info.bubbly = False DCNL DCSP if (part.is_multipart() and (mimetype == 'multipart/signed')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boundary = part.get_boundary() DCNL DCSP  DCSP  DCSP (payload, signature) = part.get_payload() DCNL DCSP  DCSP  DCSP (head, raw_payload, junk) = part.as_string().replace('\\r\\n', '\\n').split(('\\n--%s\\n' % boundary), 2) DCNL DCSP  DCSP  DCSP part.signature_info = crypto_cls().verify(Normalize(raw_payload), signature.get_payload()) DCNL DCSP  DCSP  DCSP part.signature_info.bubble_up(psi) DCNL DCSP  DCSP  DCSP MimeReplacePart(part, payload) DCNL DCSP  DCSP  DCSP UnwrapMimeCrypto(part, protocols=protocols, psi=part.signature_info, pei=part.encryption_info, charsets=charsets, depth=(depth + 1)) DCNL DCSP  DCSP except (IOError, OSError, ValueError, IndexError, KeyError): DCNL DCSP  DCSP  DCSP part.signature_info = SignatureInfo() DCNL DCSP  DCSP  DCSP part.signature_info['status'] = 'error' DCNL DCSP  DCSP  DCSP part.signature_info.bubble_up(psi) DCNL DCSP elif (part.is_multipart() and (mimetype == 'multipart/encrypted')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (preamble, payload) = part.get_payload() DCNL DCSP  DCSP  DCSP (part.signature_info, part.encryption_info, decrypted) = crypto_cls().decrypt(payload.as_string()) DCNL DCSP  DCSP except (IOError, OSError, ValueError, IndexError, KeyError): DCNL DCSP  DCSP  DCSP part.encryption_info = EncryptionInfo() DCNL DCSP  DCSP  DCSP part.encryption_info['status'] = 'error' DCNL DCSP  DCSP part.signature_info.bubble_up(psi) DCNL DCSP  DCSP part.encryption_info.bubble_up(pei) DCNL DCSP  DCSP if (part.encryption_info['status'] == 'decrypted'): DCNL DCSP  DCSP  DCSP newpart = email.parser.Parser().parse(StringIO.StringIO(decrypted)) DCNL DCSP  DCSP  DCSP MimeReplacePart(part, newpart) DCNL DCSP  DCSP  DCSP UnwrapMimeCrypto(part, protocols=protocols, psi=part.signature_info, pei=part.encryption_info, charsets=charsets, depth=(depth + 1)) DCNL DCSP elif part.is_multipart(): DCNL DCSP  DCSP for sp in part.get_payload(): DCNL DCSP  DCSP  DCSP UnwrapMimeCrypto(sp, protocols=protocols, psi=part.signature_info, pei=part.encryption_info, charsets=charsets, depth=(depth + 1)) DCNL DCSP elif disposition.startswith('attachment'): DCNL DCSP  DCSP for protocol in protocols: DCNL DCSP  DCSP  DCSP crypto_cls = protocols[protocol] DCNL DCSP  DCSP  DCSP kind = crypto_cls().sniff(part.get_payload(), encoding) DCNL DCSP  DCSP  DCSP if kind: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (('encrypted' in kind) or ('signature' in kind)): DCNL DCSP  DCSP  DCSP payload = part.get_payload(None, True) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (part.signature_info, part.encryption_info, decrypted) = crypto_cls().decrypt(payload) DCNL DCSP  DCSP  DCSP except (IOError, OSError, ValueError, IndexError, KeyError): DCNL DCSP  DCSP  DCSP  DCSP part.encryption_info = EncryptionInfo() DCNL DCSP  DCSP  DCSP  DCSP part.encryption_info['status'] = 'error' DCNL DCSP  DCSP  DCSP part.signature_info.bubble_up(psi) DCNL DCSP  DCSP  DCSP part.encryption_info.bubble_up(pei) DCNL DCSP  DCSP  DCSP if ((part.encryption_info['status'] == 'decrypted') or (part.signature_info['status'] == 'verified')): DCNL DCSP  DCSP  DCSP  DCSP newpart = email.parser.Parser().parse(StringIO.StringIO(decrypted)) DCNL DCSP  DCSP  DCSP  DCSP if part.encryption_info.filename: DCNL DCSP  DCSP  DCSP  DCSP  DCSP disposition = MimeReplaceFilename(disposition, part.encryption_info.filename) DCNL DCSP  DCSP  DCSP  DCSP elif ('armored' in kind): DCNL DCSP  DCSP  DCSP  DCSP  DCSP disposition = MimeTrimFilename(disposition, 'asc') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP disposition = MimeTrimFilename(disposition, 'gpg') DCNL DCSP  DCSP  DCSP  DCSP newpart.add_header('content-disposition', disposition) DCNL DCSP  DCSP  DCSP  DCSP MimeReplacePart(part, newpart) DCNL DCSP  DCSP  DCSP  DCSP UnwrapMimeCrypto(part, protocols=protocols, psi=part.signature_info, pei=part.encryption_info, charsets=charsets, depth=(depth + 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP elif (mimetype == 'text/plain'): DCNL DCSP  DCSP return UnwrapPlainTextCrypto(part, protocols=protocols, psi=psi, pei=pei, charsets=charsets, depth=(depth + 1)) DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP part.signature_info.mix_bubbles() DCNL DCSP part.encryption_info.mix_bubbles() DCNL DCSP part.signature_info.bubble_up(psi) DCNL DCSP part.encryption_info.bubble_up(pei)\n", "intent": "this method will replace encrypted and signed parts with their contents and set part attributes describing the security properties instead .\n", "question_id": 863}, {"snippet": "def aticq(ri, di, astrom): DCNL  DCSP pos = erfa.s2c(ri, di) DCNL DCSP ppr = erfa.trxp(astrom[u'bpn'], pos) DCNL DCSP d = np.zeros_like(ppr) DCNL DCSP for j in range(2): DCNL DCSP  DCSP before = norm((ppr - d)) DCNL DCSP  DCSP after = erfa.ab(before, astrom[u'v'], astrom[u'em'], astrom[u'bm1']) DCNL DCSP  DCSP d = (after - before) DCNL DCSP pnat = norm((ppr - d)) DCNL DCSP d = np.zeros_like(pnat) DCNL DCSP for j in range(5): DCNL DCSP  DCSP before = norm((pnat - d)) DCNL DCSP  DCSP after = erfa.ld(1.0, before, before, astrom[u'eh'], astrom[u'em'], 5e-08) DCNL DCSP  DCSP d = (after - before) DCNL DCSP pco = norm((pnat - d)) DCNL DCSP (rc, dc) = erfa.c2s(pco) DCNL DCSP return (erfa.anp(rc), dc)\n", "intent": "a slightly modified version of the erfa function eraaticq .\n", "question_id": 864}, {"snippet": "def readWriteNavigationHelp(documentDirectoryPath, transferredFileNameIndex, transferredFileNames): DCNL  DCSP fileName = os.path.basename(transferredFileNames[transferredFileNameIndex]) DCNL DCSP print ('readWriteNavigationHelp DCSP ' + fileName) DCNL DCSP filePath = os.path.join(documentDirectoryPath, fileName) DCNL DCSP fileText = archive.getFileText(filePath) DCNL DCSP fileText = getNavigationHypertext(fileText, transferredFileNameIndex, transferredFileNames) DCNL DCSP archive.writeFileText(filePath, fileText)\n", "intent": "read the hypertext help documents .\n", "question_id": 865}, {"snippet": "def cluster_join(username, hostname): DCNL  DCSP ret = {'comment': '', 'success': False} DCNL DCSP cmd = __execute_cmd('riak-admin', 'cluster DCSP join DCSP {0}@{1}'.format(username, hostname)) DCNL DCSP if (cmd['retcode'] != 0): DCNL DCSP  DCSP ret['comment'] = cmd['stdout'] DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = cmd['stdout'] DCNL DCSP  DCSP ret['success'] = True DCNL DCSP return ret\n", "intent": "join a riak cluster .\n", "question_id": 866}, {"snippet": "def run_tests(test_labels, verbosity=1, interactive=True, extra_tests=None, **kwargs): DCNL  DCSP extra_tests = (extra_tests or []) DCNL DCSP app_labels = getattr(settings, 'TEST_APPS', test_labels) DCNL DCSP return django_test_runner(app_labels, verbosity=verbosity, interactive=interactive, extra_tests=extra_tests, **kwargs)\n", "intent": "test runner that only runs tests for the apps listed in settings .\n", "question_id": 867}, {"snippet": "def make_loc_files(file_creator, size=None): DCNL  DCSP if size: DCNL DCSP  DCSP body = ('*' * size) DCNL DCSP else: DCNL DCSP  DCSP body = 'This DCSP is DCSP a DCSP test.' DCNL DCSP filename1 = file_creator.create_file(os.path.join('some_directory', 'text1.txt'), body) DCNL DCSP filename2 = file_creator.create_file(os.path.join('some_directory', 'another_directory', 'text2.txt'), body) DCNL DCSP filename1 = six.text_type(filename1) DCNL DCSP filename2 = six.text_type(filename2) DCNL DCSP return [filename1, filename2, os.path.dirname(filename2), os.path.dirname(filename1)]\n", "intent": "this sets up the test by making a directory named some_directory .\n", "question_id": 868}, {"snippet": "@register.filter(is_safe=True) DCNL def floatformat(text, arg=(-1)): DCNL  DCSP try: DCNL DCSP  DCSP input_val = force_unicode(text) DCNL DCSP  DCSP d = Decimal(input_val) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP return u'' DCNL DCSP except InvalidOperation: DCNL DCSP  DCSP if (input_val in special_floats): DCNL DCSP  DCSP  DCSP return input_val DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP d = Decimal(force_unicode(float(text))) DCNL DCSP  DCSP except (ValueError, InvalidOperation, TypeError, UnicodeEncodeError): DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP try: DCNL DCSP  DCSP p = int(arg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return input_val DCNL DCSP try: DCNL DCSP  DCSP m = (int(d) - d) DCNL DCSP except (ValueError, OverflowError, InvalidOperation): DCNL DCSP  DCSP return input_val DCNL DCSP if ((not m) and (p < 0)): DCNL DCSP  DCSP return mark_safe(formats.number_format((u'%d' % int(d)), 0)) DCNL DCSP if (p == 0): DCNL DCSP  DCSP exp = Decimal(1) DCNL DCSP else: DCNL DCSP  DCSP exp = (Decimal(u'1.0') / (Decimal(10) ** abs(p))) DCNL DCSP try: DCNL DCSP  DCSP tupl = d.as_tuple() DCNL DCSP  DCSP units = (len(tupl[1]) - tupl[2]) DCNL DCSP  DCSP prec = ((abs(p) + units) + 1) DCNL DCSP  DCSP (sign, digits, exponent) = d.quantize(exp, ROUND_HALF_UP, Context(prec=prec)).as_tuple() DCNL DCSP  DCSP digits = [unicode(digit) for digit in reversed(digits)] DCNL DCSP  DCSP while (len(digits) <= abs(exponent)): DCNL DCSP  DCSP  DCSP digits.append(u'0') DCNL DCSP  DCSP digits.insert((- exponent), u'.') DCNL DCSP  DCSP if sign: DCNL DCSP  DCSP  DCSP digits.append(u'-') DCNL DCSP  DCSP number = u''.join(reversed(digits)) DCNL DCSP  DCSP return mark_safe(formats.number_format(number, abs(p))) DCNL DCSP except InvalidOperation: DCNL DCSP  DCSP return input_val\n", "intent": "displays a float to a specified number of decimal places .\n", "question_id": 869}, {"snippet": "def deployment_from_configuration(deployment_state, deployment_configuration, all_applications): DCNL  DCSP if (u'nodes' not in deployment_configuration): DCNL DCSP  DCSP raise ConfigurationError(u\"Deployment DCSP configuration DCSP has DCSP an DCSP error. DCSP Missing DCSP 'nodes' DCSP key.\") DCNL DCSP if (u'version' not in deployment_configuration): DCNL DCSP  DCSP raise ConfigurationError(u\"Deployment DCSP configuration DCSP has DCSP an DCSP error. DCSP Missing DCSP 'version' DCSP key.\") DCNL DCSP if (deployment_configuration[u'version'] != 1): DCNL DCSP  DCSP raise ConfigurationError(u'Deployment DCSP configuration DCSP has DCSP an DCSP error. DCSP Incorrect DCSP version DCSP specified.') DCNL DCSP node_states = {node.hostname: node for node in deployment_state.nodes.itervalues()} DCNL DCSP nodes = [] DCNL DCSP seen_applications = set() DCNL DCSP for (hostname, application_names) in deployment_configuration[u'nodes'].items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP IPv4Address(hostname) DCNL DCSP  DCSP except AddressValueError: DCNL DCSP  DCSP  DCSP raise ConfigurationError(u'Node DCSP \"{node_name}\" DCSP specified, DCSP but DCSP deployment DCSP configuration DCSP expects DCSP an DCSP IPv4 DCSP address.'.format(node_name=hostname)) DCNL DCSP  DCSP if (not isinstance(application_names, list)): DCNL DCSP  DCSP  DCSP raise ConfigurationError(u'Node DCSP {node_name} DCSP has DCSP a DCSP config DCSP error. DCSP Wrong DCSP value DCSP type: DCSP {value_type}. DCSP Should DCSP be DCSP list.'.format(node_name=hostname, value_type=application_names.__class__.__name__)) DCNL DCSP  DCSP node_applications = [] DCNL DCSP  DCSP for name in application_names: DCNL DCSP  DCSP  DCSP if (name in seen_applications): DCNL DCSP  DCSP  DCSP  DCSP raise ConfigurationError(u\"Application DCSP '{name}' DCSP appears DCSP more DCSP than DCSP once.\".format(name=name)) DCNL DCSP  DCSP  DCSP seen_applications.add(name) DCNL DCSP  DCSP  DCSP application = all_applications.get(name) DCNL DCSP  DCSP  DCSP if (application is None): DCNL DCSP  DCSP  DCSP  DCSP raise ConfigurationError(u'Node DCSP {hostname} DCSP has DCSP a DCSP config DCSP error. DCSP Unrecognised DCSP application DCSP name: DCSP {application_name}.'.format(hostname=hostname, application_name=name)) DCNL DCSP  DCSP  DCSP node_applications.append(application) DCNL DCSP  DCSP if (hostname not in node_states): DCNL DCSP  DCSP  DCSP raise ConfigurationError(u'No DCSP known DCSP node DCSP with DCSP address DCSP {}.'.format(hostname)) DCNL DCSP  DCSP node = Node(uuid=node_states[hostname].uuid, applications={app.name: app for app in node_applications}, manifestations={app.volume.manifestation.dataset_id: app.volume.manifestation for app in node_applications if (app.volume is not None)}) DCNL DCSP  DCSP nodes.append(node) DCNL DCSP return set(nodes)\n", "intent": "validate and parse a given deployment configuration .\n", "question_id": 870}, {"snippet": "def eval_split(split, dp, model, params, misc, **kwargs): DCNL  DCSP eval_batch_size = kwargs.get('eval_batch_size', params.get('eval_batch_size', 100)) DCNL DCSP eval_max_images = kwargs.get('eval_max_images', params.get('eval_max_images', (-1))) DCNL DCSP BatchGenerator = decodeGenerator(params) DCNL DCSP wordtoix = misc['wordtoix'] DCNL DCSP print ('evaluating DCSP %s DCSP performance DCSP in DCSP batches DCSP of DCSP %d' % (split, eval_batch_size)) DCNL DCSP logppl = 0 DCNL DCSP logppln = 0 DCNL DCSP nsent = 0 DCNL DCSP for batch in dp.iterImageSentencePairBatch(split=split, max_batch_size=eval_batch_size, max_images=eval_max_images): DCNL DCSP  DCSP (Ys, gen_caches) = BatchGenerator.forward(batch, model, params, misc, predict_mode=True) DCNL DCSP  DCSP for (i, pair) in enumerate(batch): DCNL DCSP  DCSP  DCSP gtix = [wordtoix[w] for w in pair['sentence']['tokens'] if (w in wordtoix)] DCNL DCSP  DCSP  DCSP gtix.append(0) DCNL DCSP  DCSP  DCSP Y = Ys[i] DCNL DCSP  DCSP  DCSP maxes = np.amax(Y, axis=1, keepdims=True) DCNL DCSP  DCSP  DCSP e = np.exp((Y - maxes)) DCNL DCSP  DCSP  DCSP P = (e / np.sum(e, axis=1, keepdims=True)) DCNL DCSP  DCSP  DCSP logppl += (- np.sum(np.log2((1e-20 + P[(range(len(gtix)), gtix)])))) DCNL DCSP  DCSP  DCSP logppln += len(gtix) DCNL DCSP  DCSP  DCSP nsent += 1 DCNL DCSP ppl2 = (2 ** (logppl / logppln)) DCNL DCSP print ('evaluated DCSP %d DCSP sentences DCSP and DCSP got DCSP perplexity DCSP = DCSP %f' % (nsent, ppl2)) DCNL DCSP return ppl2\n", "intent": "evaluate performance on a given split .\n", "question_id": 871}, {"snippet": "@public DCNL def symmetric_poly(n, *gens, **args): DCNL  DCSP gens = _analyze_gens(gens) DCNL DCSP if ((n < 0) or (n > len(gens)) or (not gens)): DCNL DCSP  DCSP raise ValueError((\"can't DCSP generate DCSP symmetric DCSP polynomial DCSP of DCSP order DCSP %s DCSP for DCSP %s\" % (n, gens))) DCNL DCSP elif (not n): DCNL DCSP  DCSP poly = S.One DCNL DCSP else: DCNL DCSP  DCSP poly = Add(*[Mul(*s) for s in subsets(gens, int(n))]) DCNL DCSP if (not args.get('polys', False)): DCNL DCSP  DCSP return poly DCNL DCSP else: DCNL DCSP  DCSP return Poly(poly, *gens)\n", "intent": "generates symmetric polynomial of order n .\n", "question_id": 872}, {"snippet": "def make_cascade(loader, global_conf, catch='404', **local_conf): DCNL  DCSP catch = map(int, converters.aslist(catch)) DCNL DCSP apps = [] DCNL DCSP for (name, value) in local_conf.items(): DCNL DCSP  DCSP if (not name.startswith('app')): DCNL DCSP  DCSP  DCSP raise ValueError((\"Bad DCSP configuration DCSP key DCSP %r DCSP (=%r); DCSP all DCSP configuration DCSP keys DCSP must DCSP start DCSP with DCSP 'app'\" % (name, value))) DCNL DCSP  DCSP app = loader.get_app(value, global_conf=global_conf) DCNL DCSP  DCSP apps.append((name, app)) DCNL DCSP apps.sort() DCNL DCSP apps = [app for (name, app) in apps] DCNL DCSP return Cascade(apps, catch=catch)\n", "intent": "entry point for paste deploy configuration expects configuration like:: [composit:cascade] use = egg:paste#cascade # all start with app and are sorted alphabetically app1 = foo app2 = bar catch = 404 500 .\n", "question_id": 873}, {"snippet": "def _ica_par(X, tol, g, fun_args, max_iter, w_init): DCNL  DCSP W = _sym_decorrelation(w_init) DCNL DCSP del w_init DCNL DCSP p_ = float(X.shape[1]) DCNL DCSP for ii in moves.xrange(max_iter): DCNL DCSP  DCSP (gwtx, g_wtx) = g(fast_dot(W, X), fun_args) DCNL DCSP  DCSP W1 = _sym_decorrelation(((fast_dot(gwtx, X.T) / p_) - (g_wtx[:, np.newaxis] * W))) DCNL DCSP  DCSP del gwtx, g_wtx DCNL DCSP  DCSP lim = max(abs((abs(np.diag(fast_dot(W1, W.T))) - 1))) DCNL DCSP  DCSP W = W1 DCNL DCSP  DCSP if (lim < tol): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP warnings.warn('FastICA DCSP did DCSP not DCSP converge. DCSP Consider DCSP increasing DCSP tolerance DCSP or DCSP the DCSP maximum DCSP number DCSP of DCSP iterations.') DCNL DCSP return (W, (ii + 1))\n", "intent": "parallel fastica .\n", "question_id": 874}, {"snippet": "def test_softmax_binary_targets(): DCNL  DCSP num_classes = 10 DCNL DCSP batch_size = 20 DCNL DCSP mlp_bin = MLP(layers=[Softmax(num_classes, 's1', irange=0.1, binary_target_dim=1)], nvis=100) DCNL DCSP mlp_vec = MLP(layers=[Softmax(num_classes, 's1', irange=0.1)], nvis=100) DCNL DCSP X = mlp_bin.get_input_space().make_theano_batch() DCNL DCSP y_bin = mlp_bin.get_target_space().make_theano_batch() DCNL DCSP y_vec = mlp_vec.get_target_space().make_theano_batch() DCNL DCSP y_hat_bin = mlp_bin.fprop(X) DCNL DCSP y_hat_vec = mlp_vec.fprop(X) DCNL DCSP cost_bin = theano.function([X, y_bin], mlp_bin.cost(y_bin, y_hat_bin), allow_input_downcast=True) DCNL DCSP cost_vec = theano.function([X, y_vec], mlp_vec.cost(y_vec, y_hat_vec), allow_input_downcast=True) DCNL DCSP X_data = np.random.random(size=(batch_size, 100)) DCNL DCSP y_bin_data = np.random.randint(low=0, high=10, size=(batch_size, 1)) DCNL DCSP y_vec_data = np.zeros((batch_size, num_classes)) DCNL DCSP y_vec_data[(np.arange(batch_size), y_bin_data.flatten())] = 1 DCNL DCSP np.testing.assert_allclose(cost_bin(X_data, y_bin_data), cost_vec(X_data, y_vec_data))\n", "intent": "constructs softmax layers with binary target and with vector targets to check that they give the same cost .\n", "question_id": 875}, {"snippet": "def showglobal(**connection_args): DCNL  DCSP mod = sys._getframe().f_code.co_name DCNL DCSP log.debug('{0}<--'.format(mod)) DCNL DCSP conn = _connect(**connection_args) DCNL DCSP if (conn is None): DCNL DCSP  DCSP return [] DCNL DCSP rtnv = __do_query_into_hash(conn, 'SHOW DCSP GLOBAL DCSP VARIABLES') DCNL DCSP conn.close() DCNL DCSP if (len(rtnv) == 0): DCNL DCSP  DCSP rtnv.append([]) DCNL DCSP log.debug('{0}-->{1}'.format(mod, len(rtnv[0]))) DCNL DCSP return rtnv\n", "intent": "retrieves the show global variables from the minion .\n", "question_id": 876}, {"snippet": "def json_out(content_type='application/json', debug=False, handler=json_handler): DCNL  DCSP request = cherrypy.serving.request DCNL DCSP if debug: DCNL DCSP  DCSP cherrypy.log(('Replacing DCSP %s DCSP with DCSP JSON DCSP handler' % request.handler), 'TOOLS.JSON_OUT') DCNL DCSP request._json_inner_handler = request.handler DCNL DCSP request.handler = handler DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP if debug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Setting DCSP Content-Type DCSP to DCSP %s' % ct), 'TOOLS.JSON_OUT') DCNL DCSP  DCSP cherrypy.serving.response.headers['Content-Type'] = content_type\n", "intent": "wrap request .\n", "question_id": 877}, {"snippet": "@require_http_methods(('DELETE', 'POST', 'PUT')) DCNL @login_required DCNL @ensure_csrf_cookie DCNL def _update_asset(request, course_key, asset_key): DCNL  DCSP if (request.method == 'DELETE'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP delete_asset(course_key, asset_key) DCNL DCSP  DCSP  DCSP return JsonResponse() DCNL DCSP  DCSP except AssetNotFoundException: DCNL DCSP  DCSP  DCSP return JsonResponse(status=404) DCNL DCSP elif (request.method in ('PUT', 'POST')): DCNL DCSP  DCSP if ('file' in request.FILES): DCNL DCSP  DCSP  DCSP return _upload_asset(request, course_key) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP modified_asset = json.loads(request.body) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseBadRequest() DCNL DCSP  DCSP  DCSP contentstore().set_attr(asset_key, 'locked', modified_asset['locked']) DCNL DCSP  DCSP  DCSP del_cached_content(asset_key) DCNL DCSP  DCSP  DCSP return JsonResponse(modified_asset, status=201)\n", "intent": "restful crud operations for a course asset .\n", "question_id": 878}, {"snippet": "def url_is_from_spider(url, spider): DCNL  DCSP return url_is_from_any_domain(url, ([spider.name] + list(getattr(spider, 'allowed_domains', []))))\n", "intent": "return true if the url belongs to the given spider .\n", "question_id": 879}, {"snippet": "def join_css_classes(class_list): DCNL  DCSP return ' DCSP '.join(sorted((str(val) for val in class_list if val)))\n", "intent": "join an iterable of truthy values by spaces .\n", "question_id": 880}, {"snippet": "def get_filesystem_encoding(): DCNL  DCSP global _warned_about_filesystem_encoding DCNL DCSP rv = sys.getfilesystemencoding() DCNL DCSP if ((has_likely_buggy_unicode_filesystem and (not rv)) or _is_ascii_encoding(rv)): DCNL DCSP  DCSP if (not _warned_about_filesystem_encoding): DCNL DCSP  DCSP  DCSP warnings.warn('Detected DCSP a DCSP misconfigured DCSP UNIX DCSP filesystem: DCSP Will DCSP use DCSP UTF-8 DCSP as DCSP filesystem DCSP encoding DCSP instead DCSP of DCSP {0!r}'.format(rv), BrokenFilesystemWarning) DCNL DCSP  DCSP  DCSP _warned_about_filesystem_encoding = True DCNL DCSP  DCSP return 'utf-8' DCNL DCSP return rv\n", "intent": "returns the filesystem encoding that should be used .\n", "question_id": 881}, {"snippet": "def ntohs(integer): DCNL  DCSP if (sys.byteorder == 'big'): DCNL DCSP  DCSP return integer DCNL DCSP if (not isinstance(integer, (int, long))): DCNL DCSP  DCSP raise TypeError('an DCSP integer DCSP is DCSP required') DCNL DCSP if (integer < 0): DCNL DCSP  DCSP raise OverflowError(\"can't DCSP convert DCSP negative DCSP number DCSP to DCSP unsigned DCSP long\") DCNL DCSP if (integer >= (1 << 16)): DCNL DCSP  DCSP raise OverflowError('signed DCSP integer DCSP is DCSP greater DCSP than DCSP maximum') DCNL DCSP return int((((integer & 65280) >> 8) | ((integer & 255) << 8)))\n", "intent": "ntohs -> integer convert a 16-bit integer from network to host byte order .\n", "question_id": 882}, {"snippet": "def register(mgr): DCNL  DCSP mgr.set_lang_info(lang, silvercity_lexer=JavaScriptLexer(mgr), buf_class=JavaScriptBuffer, langintel_class=JavaScriptLangIntel, import_handler_class=JavaScriptImportHandler, cile_driver_class=JavaScriptCILEDriver, is_cpln_lang=True, import_everything=True)\n", "intent": "register language support with the manager .\n", "question_id": 883}, {"snippet": "def _activities_from_user_query(user_id): DCNL  DCSP import ckan.model as model DCNL DCSP q = model.Session.query(model.Activity) DCNL DCSP q = q.filter((model.Activity.user_id == user_id)) DCNL DCSP return q\n", "intent": "return an sqlalchemy query for all activities from user_id .\n", "question_id": 884}, {"snippet": "@handle_response_format DCNL @treeio_login_required DCNL def folder_edit(request, folder_id, response_format='html'): DCNL  DCSP folder = get_object_or_404(Folder, pk=folder_id) DCNL DCSP if (not request.user.profile.has_permission(folder, mode='w')): DCNL DCSP  DCSP return user_denied(request, message=\"You DCSP don't DCSP have DCSP access DCSP to DCSP this DCSP Folder\") DCNL DCSP if request.POST: DCNL DCSP  DCSP if ('cancel' not in request.POST): DCNL DCSP  DCSP  DCSP form = FolderForm(request.user.profile, folder_id, request.POST, instance=folder) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP folder = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('documents_folder_view', args=[folder.id])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseRedirect(reverse('documents_folder_view', args=[folder.id])) DCNL DCSP else: DCNL DCSP  DCSP form = FolderForm(request.user.profile, folder_id, instance=folder) DCNL DCSP context = _get_default_context(request) DCNL DCSP context.update({'form': form, 'folder': folder}) DCNL DCSP return render_to_response('documents/folder_edit', context, context_instance=RequestContext(request), response_format=response_format)\n", "intent": "folder edit page .\n", "question_id": 885}, {"snippet": "def find_root(node): DCNL  DCSP while (node.type != syms.file_input): DCNL DCSP  DCSP assert node.parent, 'Tree DCSP is DCSP insane! DCSP root DCSP found DCSP before DCSP file_input DCSP node DCSP was DCSP found.' DCNL DCSP  DCSP node = node.parent DCNL DCSP return node\n", "intent": "find the top level namespace .\n", "question_id": 886}, {"snippet": "def Q(filter_, thing): DCNL  DCSP if isinstance(filter_, type([])): DCNL DCSP  DCSP return flatten(*[_Q(x, thing) for x in filter_]) DCNL DCSP elif isinstance(filter_, type({})): DCNL DCSP  DCSP d = dict.fromkeys(list(filter_.keys())) DCNL DCSP  DCSP for k in d: DCNL DCSP  DCSP  DCSP d[k] = Q(k, thing) DCNL DCSP  DCSP return d DCNL DCSP elif (' DCSP ' in filter_): DCNL DCSP  DCSP parts = filter_.strip().split() DCNL DCSP  DCSP r = None DCNL DCSP  DCSP for p in parts: DCNL DCSP  DCSP  DCSP r = Ql(p, thing) DCNL DCSP  DCSP  DCSP thing = r DCNL DCSP  DCSP return r DCNL DCSP else: DCNL DCSP  DCSP return flatten(_Q(filter_, thing))\n", "intent": "type: - list:  a flattened list of all searches  - dict:  dict with vals each of which is that search notes: [1] parent thing .\n", "question_id": 887}, {"snippet": "@register.tag DCNL def url(parser, token): DCNL  DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP raise TemplateSyntaxError((u\"'%s' DCSP takes DCSP at DCSP least DCSP one DCSP argument DCSP (path DCSP to DCSP a DCSP view)\" % bits[0])) DCNL DCSP try: DCNL DCSP  DCSP viewname = parser.compile_filter(bits[1]) DCNL DCSP except TemplateSyntaxError as exc: DCNL DCSP  DCSP exc.args = ((exc.args[0] + u\". DCSP The DCSP syntax DCSP of DCSP 'url' DCSP changed DCSP in DCSP Django DCSP 1.5, DCSP see DCSP the DCSP docs.\"),) DCNL DCSP  DCSP raise DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP asvar = None DCNL DCSP bits = bits[2:] DCNL DCSP if ((len(bits) >= 2) and (bits[(-2)] == u'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP if len(bits): DCNL DCSP  DCSP for bit in bits: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bit) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(u'Malformed DCSP arguments DCSP to DCSP url DCSP tag') DCNL DCSP  DCSP  DCSP (name, value) = match.groups() DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP kwargs[name] = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args.append(parser.compile_filter(value)) DCNL DCSP return URLNode(viewname, args, kwargs, asvar)\n", "intent": "returns an absolute url matching given view with its parameters .\n", "question_id": 888}, {"snippet": "def _get_vm_ref_from_name(session, vm_name): DCNL  DCSP vms = session._call_method(vim_util, 'get_objects', 'VirtualMachine', ['name']) DCNL DCSP return _get_object_from_results(session, vms, vm_name, _get_object_for_value)\n", "intent": "get reference to the vm with the name specified .\n", "question_id": 889}, {"snippet": "def public(func): DCNL  DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped\n", "intent": "decorator to declare which methods are publicly accessible as http requests .\n", "question_id": 890}, {"snippet": "def python_format(catalog, message): DCNL  DCSP if ('python-format' not in message.flags): DCNL DCSP  DCSP return DCNL DCSP msgids = message.id DCNL DCSP if (not isinstance(msgids, (list, tuple))): DCNL DCSP  DCSP msgids = (msgids,) DCNL DCSP msgstrs = message.string DCNL DCSP if (not isinstance(msgstrs, (list, tuple))): DCNL DCSP  DCSP msgstrs = (msgstrs,) DCNL DCSP for (msgid, msgstr) in izip(msgids, msgstrs): DCNL DCSP  DCSP if msgstr: DCNL DCSP  DCSP  DCSP _validate_format(msgid, msgstr)\n", "intent": "verify the format string placeholders in the translation .\n", "question_id": 891}, {"snippet": "def isNullValue(value): DCNL  DCSP return (isinstance(value, basestring) and (value.upper() == NULL))\n", "intent": "returns whether the value contains explicit null value .\n", "question_id": 892}, {"snippet": "def askcolor(color=None, **options): DCNL  DCSP global _chooser DCNL DCSP if (not _chooser): DCNL DCSP  DCSP _chooser = Chooser(**options) DCNL DCSP return _chooser.show(color, options)\n", "intent": "ask for a color .\n", "question_id": 893}, {"snippet": "def check_status(status): DCNL  DCSP if (status == 'ZERO_RESULTS'): DCNL DCSP  DCSP raise GQueryError('The DCSP geocode DCSP was DCSP successful DCSP but DCSP returned DCSP no DCSP results. DCSP This DCSP may DCSP occur DCSP if DCSP the DCSP geocode DCSP was DCSP passed DCSP a DCSP non-existent DCSP address DCSP or DCSP a DCSP latlng DCSP in DCSP a DCSP remote DCSP location.') DCNL DCSP elif (status == 'OVER_QUERY_LIMIT'): DCNL DCSP  DCSP raise GTooManyQueriesError('The DCSP given DCSP key DCSP has DCSP gone DCSP over DCSP the DCSP requests DCSP limit DCSP in DCSP the DCSP 24 DCSP hour DCSP period DCSP or DCSP has DCSP submitted DCSP too DCSP many DCSP requests DCSP in DCSP too DCSP short DCSP a DCSP period DCSP of DCSP time.') DCNL DCSP elif (status == 'REQUEST_DENIED'): DCNL DCSP  DCSP raise GQueryError('Your DCSP request DCSP was DCSP denied, DCSP probably DCSP because DCSP of DCSP lack DCSP of DCSP a DCSP sensor DCSP parameter.') DCNL DCSP elif (status == 'INVALID_REQUEST'): DCNL DCSP  DCSP raise GQueryError('Probably DCSP missing DCSP address DCSP or DCSP latlng.') DCNL DCSP else: DCNL DCSP  DCSP raise GeocoderResultError('Unkown DCSP error.')\n", "intent": "validates error statuses .\n", "question_id": 894}, {"snippet": "def vary_on_headers(*headers): DCNL  DCSP def decorator(func): DCNL DCSP  DCSP def inner_func(*args, **kwargs): DCNL DCSP  DCSP  DCSP response = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP patch_vary_headers(response, headers) DCNL DCSP  DCSP  DCSP return response DCNL DCSP  DCSP return wraps(func, assigned=available_attrs(func))(inner_func) DCNL DCSP return decorator\n", "intent": "a view decorator that adds the specified headers to the vary header of the response .\n", "question_id": 895}, {"snippet": "def _get_old_package_revision_license_ids(migrate_engine): DCNL  DCSP old_ids = {} DCNL DCSP select_licenses = 'SELECT DCSP id, DCSP license_id DCSP FROM DCSP package_revision;' DCNL DCSP q = migrate_engine.execute(select_licenses) DCNL DCSP for (id, license_id) in q: DCNL DCSP  DCSP old_ids[id] = license_id DCNL DCSP return old_ids\n", "intent": "returns a dict of old license ids .\n", "question_id": 896}, {"snippet": "def handle_conflicts(type='object'): DCNL  DCSP def decorator(method): DCNL DCSP  DCSP @functools.wraps(method) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return method(*args, **kwargs) DCNL DCSP  DCSP  DCSP except IntegrityError as e: DCNL DCSP  DCSP  DCSP  DCSP raise exception.Conflict(type=type, details=str(e.orig)) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator\n", "intent": "converts integrityerror into http 409 conflict .\n", "question_id": 897}, {"snippet": "def completed_chart(): DCNL  DCSP series_id = get_vars.get('series_id') DCNL DCSP if (not series_id): DCNL DCSP  DCSP return 'Programming DCSP Error: DCSP Series DCSP ID DCSP missing' DCNL DCSP question_id = get_vars.get('question_id') DCNL DCSP if (not question_id): DCNL DCSP  DCSP return 'Programming DCSP Error: DCSP Question DCSP ID DCSP missing' DCNL DCSP q_type = get_vars.get('type') DCNL DCSP if (not q_type): DCNL DCSP  DCSP return 'Programming DCSP Error: DCSP Question DCSP Type DCSP missing' DCNL DCSP getAnswers = s3db.survey_getAllAnswersForQuestionInSeries DCNL DCSP answers = getAnswers(question_id, series_id) DCNL DCSP analysisTool = s3db.survey_analysis_type[q_type](question_id, answers) DCNL DCSP qstnName = analysisTool.qstnWidget.question.name DCNL DCSP image = analysisTool.drawChart(series_id, output='png') DCNL DCSP return image\n", "intent": "allows the user to display all the data from the selected question in a simple chart .\n", "question_id": 898}, {"snippet": "@require_POST DCNL @login_required DCNL def unwatch_ready(request, product=None): DCNL  DCSP if (request.LANGUAGE_CODE != settings.WIKI_DEFAULT_LANGUAGE): DCNL DCSP  DCSP raise Http404 DCNL DCSP kwargs = {} DCNL DCSP if (product is not None): DCNL DCSP  DCSP kwargs['product'] = product DCNL DCSP ReadyRevisionEvent.stop_notifying(request.user, **kwargs) DCNL DCSP return HttpResponse()\n", "intent": "stop watching ready-for-l10n revisions for a given product .\n", "question_id": 899}, {"snippet": "def unicode_safe_truncate(s, max_length): DCNL  DCSP if (not isinstance(s, unicode)): DCNL DCSP  DCSP s = str(s).decode('utf-8', 'ignore') DCNL DCSP return s.rstrip()[:max_length]\n", "intent": "implements unicode-safe truncation and trims whitespace for a given input string .\n", "question_id": 900}, {"snippet": "def parse_url(url): DCNL  DCSP scheme = None DCNL DCSP auth = None DCNL DCSP host = None DCNL DCSP port = None DCNL DCSP path = None DCNL DCSP fragment = None DCNL DCSP query = None DCNL DCSP if ('://' in url): DCNL DCSP  DCSP (scheme, url) = url.split('://', 1) DCNL DCSP (url, path_, delim) = split_first(url, ['/', '?', '#']) DCNL DCSP if delim: DCNL DCSP  DCSP path = (delim + path_) DCNL DCSP if ('@' in url): DCNL DCSP  DCSP (auth, url) = url.rsplit('@', 1) DCNL DCSP if (url and (url[0] == '[')): DCNL DCSP  DCSP (host, url) = url.split(']', 1) DCNL DCSP  DCSP host += ']' DCNL DCSP if (':' in url): DCNL DCSP  DCSP (_host, port) = url.split(':', 1) DCNL DCSP  DCSP if (not host): DCNL DCSP  DCSP  DCSP host = _host DCNL DCSP  DCSP if port: DCNL DCSP  DCSP  DCSP if (not port.isdigit()): DCNL DCSP  DCSP  DCSP  DCSP raise LocationParseError(url) DCNL DCSP  DCSP  DCSP port = int(port) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = None DCNL DCSP elif ((not host) and url): DCNL DCSP  DCSP host = url DCNL DCSP if (not path): DCNL DCSP  DCSP return Url(scheme, auth, host, port, path, query, fragment) DCNL DCSP if ('#' in path): DCNL DCSP  DCSP (path, fragment) = path.split('#', 1) DCNL DCSP if ('?' in path): DCNL DCSP  DCSP (path, query) = path.split('?', 1) DCNL DCSP return Url(scheme, auth, host, port, path, query, fragment)\n", "intent": "given a url .\n", "question_id": 901}, {"snippet": "def tag_model(cls, admin_cls=None, field_name=u'tags', sort_tags=False, select_field=False, auto_add_admin_field=True, admin_list_display=True): DCNL  DCSP try: DCNL DCSP  DCSP from tagging.registry import register as tagging_register DCNL DCSP except ImportError: DCNL DCSP  DCSP from tagging import register as tagging_register DCNL DCSP cls.add_to_class(field_name, (TagSelectField if select_field else TagField)(field_name.capitalize(), blank=True)) DCNL DCSP try: DCNL DCSP  DCSP tagging_register(cls, tag_descriptor_attr=(u'tagging_' + field_name)) DCNL DCSP except AlreadyRegistered: DCNL DCSP  DCSP return DCNL DCSP if admin_cls: DCNL DCSP  DCSP if admin_list_display: DCNL DCSP  DCSP  DCSP admin_cls.list_display.append(field_name) DCNL DCSP  DCSP admin_cls.list_filter.append(field_name) DCNL DCSP  DCSP if (auto_add_admin_field and hasattr(admin_cls, u'add_extension_options')): DCNL DCSP  DCSP  DCSP admin_cls.add_extension_options(_(u'Tagging'), {u'fields': (field_name,)}) DCNL DCSP if sort_tags: DCNL DCSP  DCSP pre_save.connect(pre_save_handler, sender=cls)\n", "intent": "tag_model accepts a number of named parameters: admin_cls   if set to a subclass of modeladmin .\n", "question_id": 902}, {"snippet": "def _get_group(conn=None, name=None, vpc_id=None, vpc_name=None, group_id=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP if (vpc_name and vpc_id): DCNL DCSP  DCSP raise SaltInvocationError(\"The DCSP params DCSP 'vpc_id' DCSP and DCSP 'vpc_name' DCSP are DCSP mutually DCSP exclusive.\") DCNL DCSP if vpc_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vpc_id = _vpc_name_to_id(vpc_id=vpc_id, vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP log.debug(e) DCNL DCSP  DCSP  DCSP return None DCNL DCSP if name: DCNL DCSP  DCSP if (vpc_id is None): DCNL DCSP  DCSP  DCSP log.debug('getting DCSP group DCSP for DCSP {0}'.format(name)) DCNL DCSP  DCSP  DCSP group_filter = {'group-name': name} DCNL DCSP  DCSP  DCSP filtered_groups = conn.get_all_security_groups(filters=group_filter) DCNL DCSP  DCSP  DCSP for group in filtered_groups: DCNL DCSP  DCSP  DCSP  DCSP if (group.vpc_id is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return group DCNL DCSP  DCSP  DCSP if (len(filtered_groups) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise CommandExecutionError('Security DCSP group DCSP belongs DCSP to DCSP more DCSP VPCs, DCSP specify DCSP the DCSP VPC DCSP ID!') DCNL DCSP  DCSP  DCSP elif (len(filtered_groups) == 1): DCNL DCSP  DCSP  DCSP  DCSP return filtered_groups[0] DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif vpc_id: DCNL DCSP  DCSP  DCSP log.debug('getting DCSP group DCSP for DCSP {0} DCSP in DCSP vpc_id DCSP {1}'.format(name, vpc_id)) DCNL DCSP  DCSP  DCSP group_filter = {'group-name': name, 'vpc_id': vpc_id} DCNL DCSP  DCSP  DCSP filtered_groups = conn.get_all_security_groups(filters=group_filter) DCNL DCSP  DCSP  DCSP if (len(filtered_groups) == 1): DCNL DCSP  DCSP  DCSP  DCSP return filtered_groups[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP elif group_id: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP groups = conn.get_all_security_groups(group_ids=[group_id]) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP log.debug(e) DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (len(groups) == 1): DCNL DCSP  DCSP  DCSP return groups[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return None\n", "intent": "get a group object given a name .\n", "question_id": 903}, {"snippet": "def create_empty_crl(ca_name, cacert_path=None, ca_filename=None, crl_file=None): DCNL  DCSP set_ca_path(cacert_path) DCNL DCSP if (not ca_filename): DCNL DCSP  DCSP ca_filename = '{0}_ca_cert'.format(ca_name) DCNL DCSP if (not crl_file): DCNL DCSP  DCSP crl_file = '{0}/{1}/crl.pem'.format(_cert_base_path(), ca_name) DCNL DCSP if os.path.exists('{0}'.format(crl_file)): DCNL DCSP  DCSP return 'CRL DCSP \"{0}\" DCSP already DCSP exists'.format(crl_file) DCNL DCSP try: DCNL DCSP  DCSP with salt.utils.fopen('{0}/{1}/{2}.crt'.format(cert_base_path(), ca_name, ca_filename)) as fp_: DCNL DCSP  DCSP  DCSP ca_cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, fp_.read()) DCNL DCSP  DCSP with salt.utils.fopen('{0}/{1}/{2}.key'.format(cert_base_path(), ca_name, ca_filename)) as fp_: DCNL DCSP  DCSP  DCSP ca_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, fp_.read()) DCNL DCSP except IOError: DCNL DCSP  DCSP return 'There DCSP is DCSP no DCSP CA DCSP named DCSP \"{0}\"'.format(ca_name) DCNL DCSP crl = OpenSSL.crypto.CRL() DCNL DCSP crl_text = crl.export(ca_cert, ca_key) DCNL DCSP with salt.utils.fopen(crl_file, 'w') as f: DCNL DCSP  DCSP f.write(crl_text) DCNL DCSP return 'Created DCSP an DCSP empty DCSP CRL: DCSP \"{0}\"'.format(crl_file)\n", "intent": "create an empty certificate revocation list .\n", "question_id": 904}, {"snippet": "def raise_error(name=None, args=None, message=''): DCNL  DCSP name = (name or 'Exception') DCNL DCSP if hasattr(salt.exceptions, name): DCNL DCSP  DCSP ex = getattr(salt.exceptions, name) DCNL DCSP elif hasattr(exceptions, name): DCNL DCSP  DCSP ex = getattr(exceptions, name) DCNL DCSP else: DCNL DCSP  DCSP name = 'SaltException' DCNL DCSP  DCSP ex = getattr(salt.exceptions, name) DCNL DCSP if (args is not None): DCNL DCSP  DCSP raise ex(*args) DCNL DCSP else: DCNL DCSP  DCSP raise ex(message)\n", "intent": "raise an exception with __name__ from name .\n", "question_id": 905}, {"snippet": "def main(): DCNL  DCSP args = get_args() DCNL DCSP try: DCNL DCSP  DCSP service_instance = connect.SmartConnect(host=args.host, user=args.user, pwd=args.password, port=int(args.port)) DCNL DCSP  DCSP atexit.register(connect.Disconnect, service_instance) DCNL DCSP  DCSP content = service_instance.RetrieveContent() DCNL DCSP  DCSP vm = content.searchIndex.FindByUuid(None, args.vm_uuid, True) DCNL DCSP  DCSP device_change = [] DCNL DCSP  DCSP for device in vm.config.hardware.device: DCNL DCSP  DCSP  DCSP if isinstance(device, vim.vm.device.VirtualEthernetCard): DCNL DCSP  DCSP  DCSP  DCSP nicspec = vim.vm.device.VirtualDeviceSpec() DCNL DCSP  DCSP  DCSP  DCSP nicspec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit DCNL DCSP  DCSP  DCSP  DCSP nicspec.device = device DCNL DCSP  DCSP  DCSP  DCSP nicspec.device.wakeOnLanEnabled = True DCNL DCSP  DCSP  DCSP  DCSP if (not args.is_VDS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP nicspec.device.backing = vim.vm.device.VirtualEthernetCard.NetworkBackingInfo() DCNL DCSP  DCSP  DCSP  DCSP  DCSP nicspec.device.backing.network = get_obj(content, [vim.Network], args.network_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP nicspec.device.backing.deviceName = args.network_name DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP network = get_obj(content, [vim.dvs.DistributedVirtualPortgroup], args.network_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP dvs_port_connection = vim.dvs.PortConnection() DCNL DCSP  DCSP  DCSP  DCSP  DCSP dvs_port_connection.portgroupKey = network.key DCNL DCSP  DCSP  DCSP  DCSP  DCSP dvs_port_connection.switchUuid = network.config.distributedVirtualSwitch.uuid DCNL DCSP  DCSP  DCSP  DCSP  DCSP nicspec.device.backing = vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo() DCNL DCSP  DCSP  DCSP  DCSP  DCSP nicspec.device.backing.port = dvs_port_connection DCNL DCSP  DCSP  DCSP  DCSP nicspec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo() DCNL DCSP  DCSP  DCSP  DCSP nicspec.device.connectable.startConnected = True DCNL DCSP  DCSP  DCSP  DCSP nicspec.device.connectable.allowGuestControl = True DCNL DCSP  DCSP  DCSP  DCSP device_change.append(nicspec) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP config_spec = vim.vm.ConfigSpec(deviceChange=device_change) DCNL DCSP  DCSP task = vm.ReconfigVM_Task(config_spec) DCNL DCSP  DCSP tasks.wait_for_tasks(service_instance, [task]) DCNL DCSP  DCSP print 'Successfully DCSP changed DCSP network' DCNL DCSP except vmodl.MethodFault as error: DCNL DCSP  DCSP print ('Caught DCSP vmodl DCSP fault DCSP : DCSP ' + error.msg) DCNL DCSP  DCSP return (-1) DCNL DCSP return 0\n", "intent": "simple command-line program for changing network virtual machines nic .\n", "question_id": 906}, {"snippet": "def new_local_dict(): DCNL  DCSP d = {} DCNL DCSP _local_dict_stack.append(d) DCNL DCSP return d\n", "intent": "initialize a new local dictionary & push it onto the stack .\n", "question_id": 907}, {"snippet": "def wrap_loader_context(function, context): DCNL  DCSP if ('loader_context' in get_func_args(function)): DCNL DCSP  DCSP return partial(function, loader_context=context) DCNL DCSP else: DCNL DCSP  DCSP return function\n", "intent": "wrap functions that receive loader_context to contain the context \"pre-loaded\" and expose a interface that receives only one argument .\n", "question_id": 908}, {"snippet": "def getipaddrinfo(host): DCNL  DCSP try: DCNL DCSP  DCSP return [addrinfo for addrinfo in socket.getaddrinfo(host, None) if (((addrinfo[0] == socket.AF_INET) or (addrinfo[0] == socket.AF_INET6)) and isinstance(addrinfo[4][0], basestring))] DCNL DCSP except socket.error: DCNL DCSP  DCSP return []\n", "intent": "filter out non-ip and bad ip addresses from getaddrinfo .\n", "question_id": 909}, {"snippet": "def test_error_during_readouterr(testdir): DCNL  DCSP testdir.makepyfile(pytest_xyz=\"\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP _pytest.capture DCSP import DCSP FDCapture\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP def DCSP bad_snap(self):\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCSP Exception('boom')\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert DCSP FDCapture.snap\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FDCapture.snap DCSP = DCSP bad_snap\\n DCSP  DCSP  DCSP  DCSP \") DCNL DCSP result = testdir.runpytest_subprocess('-p', 'pytest_xyz', '--version', syspathinsert=True) DCNL DCSP result.stderr.fnmatch_lines(['*in DCSP bad_snap', \" DCSP  DCSP  DCSP  DCSP raise DCSP Exception('boom')\", 'Exception: DCSP boom'])\n", "intent": "make sure we suspend capturing if errors occurr during readouterr .\n", "question_id": 910}, {"snippet": "def find_packages(where='.', exclude=()): DCNL  DCSP out = [] DCNL DCSP stack = [(convert_path(where), '')] DCNL DCSP while stack: DCNL DCSP  DCSP (where, prefix) = stack.pop(0) DCNL DCSP  DCSP for name in os.listdir(where): DCNL DCSP  DCSP  DCSP fn = os.path.join(where, name) DCNL DCSP  DCSP  DCSP if (('.' not in name) and os.path.isdir(fn) and os.path.isfile(os.path.join(fn, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP out.append((prefix + name)) DCNL DCSP  DCSP  DCSP  DCSP stack.append((fn, ((prefix + name) + '.'))) DCNL DCSP for pat in (list(exclude) + ['ez_setup', 'distribute_setup']): DCNL DCSP  DCSP from fnmatch import fnmatchcase DCNL DCSP  DCSP out = [item for item in out if (not fnmatchcase(item, pat))] DCNL DCSP return out\n", "intent": "return a list all python packages found within directory where where should be supplied as a \"cross-platform\"  path; it will be converted to the appropriate local path syntax .\n", "question_id": 911}, {"snippet": "def get_jobconf(jt, jobid): DCNL  DCSP jid = jt.thriftjobid_from_string(jobid) DCNL DCSP xml_data = jt.get_job_xml(jid) DCNL DCSP return confparse.ConfParse(xml_data)\n", "intent": "returns a dict representation of the jobconf for the job corresponding to jobid .\n", "question_id": 912}, {"snippet": "def process_barcode_in_label(read1_data, read2_data, output_bc_fastq, bc1_len=6, bc2_len=6, rev_comp_bc1=False, rev_comp_bc2=False, char_delineator=':'): DCNL  DCSP header_index = 0 DCNL DCSP try: DCNL DCSP  DCSP bc1_read = read1_data[header_index].split(char_delineator)[(-1)][0:bc1_len] DCNL DCSP except IndexError: DCNL DCSP  DCSP raise IndexError(('Found DCSP sequence DCSP lacking DCSP character DCSP delineator. DCSP Sequence DCSP header DCSP %s, DCSP character DCSP delineator DCSP %s' % (read1_data[header_index], char_delineator))) DCNL DCSP bc1_qual = (np.ones(len(bc1_read), dtype=np.int8) * 6) DCNL DCSP if rev_comp_bc1: DCNL DCSP  DCSP bc1_read = str(DNA(bc1_read).rc()) DCNL DCSP if read2_data: DCNL DCSP  DCSP bc2_read = read2_data[header_index].strip().split(char_delineator)[(-1)][0:bc2_len] DCNL DCSP  DCSP bc2_qual = (np.ones(len(bc2_read), dtype=np.int8) * 6) DCNL DCSP  DCSP if rev_comp_bc2: DCNL DCSP  DCSP  DCSP bc2_read = str(DNA(bc2_read).rc()) DCNL DCSP else: DCNL DCSP  DCSP bc2_read = '' DCNL DCSP  DCSP bc2_qual = np.array([], dtype=np.int8) DCNL DCSP if ((not bc1_read) and (not bc2_read)): DCNL DCSP  DCSP raise ValueError(('Came DCSP up DCSP with DCSP empty DCSP barcode DCSP sequence, DCSP please DCSP check DCSP character DCSP delineator DCSP with DCSP -s, DCSP and DCSP fastq DCSP label DCSP %s' % read1_data[header_index])) DCNL DCSP bc_lines = format_fastq_record(read1_data[header_index], (bc1_read + bc2_read), np.hstack([bc1_qual, bc2_qual])) DCNL DCSP output_bc_fastq.write(bc_lines) DCNL DCSP return\n", "intent": "reads data from one or two fastq labels .\n", "question_id": 913}, {"snippet": "def __validate__(config): DCNL  DCSP if (not isinstance(config, dict)): DCNL DCSP  DCSP return (False, 'Configuration DCSP for DCSP bonjour_announcement DCSP beacon DCSP must DCSP be DCSP a DCSP dictionary') DCNL DCSP elif (not all(((x in list(config.keys())) for x in ('servicetype', 'port', 'txt')))): DCNL DCSP  DCSP return (False, 'Configuration DCSP for DCSP bonjour_announce DCSP beacon DCSP must DCSP contain DCSP servicetype, DCSP port DCSP and DCSP txt DCSP items') DCNL DCSP return (True, 'Valid DCSP beacon DCSP configuration')\n", "intent": "validate the beacon configuration .\n", "question_id": 914}, {"snippet": "@require_POST DCNL @ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revalidate=True) DCNL @require_level('staff') DCNL def list_report_downloads(_request, course_id): DCNL  DCSP course_id = SlashSeparatedCourseKey.from_deprecated_string(course_id) DCNL DCSP report_store = ReportStore.from_config(config_name='GRADES_DOWNLOAD') DCNL DCSP response_payload = {'downloads': [dict(name=name, url=url, link=HTML('<a DCSP href=\"{}\">{}</a>').format(HTML(url), Text(name))) for (name, url) in report_store.links_for(course_id)]} DCNL DCSP return JsonResponse(response_payload)\n", "intent": "list grade csv files that are available for download for this course .\n", "question_id": 915}, {"snippet": "def get_parser(): DCNL  DCSP epilog = '\\n DCSP  DCSP  DCSP  DCSP Example DCSP (results DCSP will DCSP be DCSP in DCSP ``example.group0000.fa``)::\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP load-graph.py DCSP -k DCSP 20 DCSP example DCSP tests/test-data/random-20-a.fa\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP partition-graph.py DCSP example\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP merge-partitions.py DCSP -k DCSP 20 DCSP example\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP annotate-partitions.py DCSP -k DCSP 20 DCSP example DCSP tests/test-data/random-20-a.fa\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP extract-partitions.py DCSP example DCSP random-20-a.fa.part\\n\\n DCSP  DCSP  DCSP  DCSP (:program:`extract-partitions.py` DCSP will DCSP produce DCSP a DCSP partition DCSP size\\n DCSP  DCSP  DCSP  DCSP distribution DCSP in DCSP <base>.dist. DCSP The DCSP columns DCSP are: DCSP (1) DCSP number DCSP of DCSP reads,\\n DCSP  DCSP  DCSP  DCSP (2) DCSP count DCSP of DCSP partitions DCSP with DCSP n DCSP reads, DCSP (3) DCSP cumulative DCSP sum DCSP of DCSP partitions,\\n DCSP  DCSP  DCSP  DCSP (4) DCSP cumulative DCSP sum DCSP of DCSP reads.)\\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP parser = KhmerArgumentParser(description='Separate DCSP sequences DCSP that DCSP are DCSP annotated DCSP with DCSP partitions DCSP into DCSP grouped DCSP files.', epilog=textwrap.dedent(epilog), citations=['graph']) DCNL DCSP parser.add_argument('prefix', metavar='output_filename_prefix') DCNL DCSP parser.add_argument('part_filenames', metavar='input_partition_filename', nargs='+') DCNL DCSP parser.add_argument('--max-size', '-X', dest='max_size', default=DEFAULT_MAX_SIZE, type=int, help='Max DCSP group DCSP size DCSP (n DCSP sequences)') DCNL DCSP parser.add_argument('--min-partition-size', '-m', dest='min_part_size', default=DEFAULT_THRESHOLD, type=int, help='Minimum DCSP partition DCSP size DCSP worth DCSP keeping') DCNL DCSP parser.add_argument('--no-output-groups', '-n', dest='output_groups', default=True, action='store_false', help='Do DCSP not DCSP actually DCSP output DCSP groups DCSP files.') DCNL DCSP parser.add_argument('--output-unassigned', '-U', default=False, action='store_true', help='Output DCSP unassigned DCSP sequences, DCSP too') DCNL DCSP parser.add_argument('-f', '--force', default=False, action='store_true', help='Overwrite DCSP output DCSP file DCSP if DCSP it DCSP exists') DCNL DCSP add_output_compression_type(parser) DCNL DCSP return parser\n", "intent": "create parser for extract-partitions .\n", "question_id": 916}, {"snippet": "@csrf_protect DCNL def render_flatpage(request, f): DCNL  DCSP if (f.registration_required and (not request.user.is_authenticated())): DCNL DCSP  DCSP from django.contrib.auth.views import redirect_to_login DCNL DCSP  DCSP return redirect_to_login(request.path) DCNL DCSP if f.template_name: DCNL DCSP  DCSP t = loader.select_template((f.template_name, DEFAULT_TEMPLATE)) DCNL DCSP else: DCNL DCSP  DCSP t = loader.get_template(DEFAULT_TEMPLATE) DCNL DCSP f.title = mark_safe(f.title) DCNL DCSP f.content = mark_safe(f.content) DCNL DCSP c = RequestContext(request, {'flatpage': f}) DCNL DCSP response = HttpResponse(t.render(c)) DCNL DCSP return response\n", "intent": "internal interface to the flat page view .\n", "question_id": 917}, {"snippet": "def capture_transaction_exceptions(func): DCNL  DCSP def raise_the_exception(conn, exc): DCNL DCSP  DCSP if ('current DCSP transaction DCSP is DCSP aborted, DCSP commands DCSP ignored DCSP until DCSP end DCSP of DCSP transaction DCSP block' in six.text_type(exc)): DCNL DCSP  DCSP  DCSP exc_info = getattr(conn, '_last_exception', None) DCNL DCSP  DCSP  DCSP if (exc_info is None): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP new_exc = TransactionAborted(sys.exc_info(), exc_info) DCNL DCSP  DCSP  DCSP six.reraise(new_exc.__class__, new_exc, exc_info[2]) DCNL DCSP  DCSP conn._last_exception = sys.exc_info() DCNL DCSP  DCSP raise DCNL DCSP @wraps(func) DCNL DCSP def inner(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise_the_exception(self.db, e) DCNL DCSP return inner\n", "intent": "catches database errors and reraises them on subsequent errors that throw some cruft about transaction aborted .\n", "question_id": 918}, {"snippet": "@utils.arg('server', metavar='<server>', help=_('Name DCSP or DCSP ID DCSP of DCSP server.')) DCNL @utils.arg('host', metavar='<host>', nargs='?', help=_('Name DCSP or DCSP ID DCSP of DCSP the DCSP target DCSP host. DCSP  DCSP If DCSP no DCSP host DCSP is DCSP specified, DCSP the DCSP scheduler DCSP will DCSP choose DCSP one.')) DCNL @utils.arg('--password', dest='password', metavar='<password>', help=_('Set DCSP the DCSP provided DCSP admin DCSP password DCSP on DCSP the DCSP evacuated DCSP server. DCSP Not DCSP applicable DCSP if DCSP the DCSP server DCSP is DCSP on DCSP shared DCSP storage.')) DCNL @utils.arg('--on-shared-storage', dest='on_shared_storage', action='store_true', default=False, help=_('Specifies DCSP whether DCSP server DCSP files DCSP are DCSP located DCSP on DCSP shared DCSP storage.'), start_version='2.0', end_version='2.13') DCNL @utils.arg('--force', dest='force', action='store_true', default=False, help=_('Force DCSP to DCSP not DCSP verify DCSP the DCSP scheduler DCSP if DCSP a DCSP host DCSP is DCSP provided.'), start_version='2.29') DCNL def do_evacuate(cs, args): DCNL  DCSP server = _find_server(cs, args.server) DCNL DCSP on_shared_storage = getattr(args, 'on_shared_storage', None) DCNL DCSP force = getattr(args, 'force', None) DCNL DCSP update_kwargs = {} DCNL DCSP if (on_shared_storage is not None): DCNL DCSP  DCSP update_kwargs['on_shared_storage'] = on_shared_storage DCNL DCSP if force: DCNL DCSP  DCSP update_kwargs['force'] = force DCNL DCSP res = server.evacuate(host=args.host, password=args.password, **update_kwargs)[1] DCNL DCSP if isinstance(res, dict): DCNL DCSP  DCSP utils.print_dict(res)\n", "intent": "evacuate server from failed host .\n", "question_id": 919}, {"snippet": "def _process_return_data(retData): DCNL  DCSP if (retData.status_code == 200): DCNL DCSP  DCSP if retData.json(): DCNL DCSP  DCSP  DCSP return retData DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.debug('no DCSP data DCSP returned DCSP from DCSP infoblox') DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP msg = 'Unsuccessful DCSP error DCSP code DCSP {0} DCSP returned'.format(retData.status_code) DCNL DCSP  DCSP raise CommandExecutionError(msg) DCNL DCSP return None\n", "intent": "generic return processing .\n", "question_id": 920}, {"snippet": "def main(argv): DCNL  DCSP (opts, args) = parse_args(argv) DCNL DCSP setup_logging(opts.log, opts.log_facility, opts.log_level) DCNL DCSP params = {'gmetad_host': opts.gmetad_host, 'gmetad_port': opts.gmetad_port, 'check_every': int(opts.check_every), 'metrics': opts.metrics} DCNL DCSP descriptors = metric_init(params) DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP for d in descriptors: DCNL DCSP  DCSP  DCSP  DCSP v = d['call_back'](d['name']) DCNL DCSP  DCSP  DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('got DCSP None DCSP for DCSP %s' % d['name']) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('value DCSP for DCSP %s DCSP is DCSP %r' % (d['name'], v)) DCNL DCSP  DCSP  DCSP time.sleep(int(opts.check_every)) DCNL DCSP  DCSP  DCSP print '----------------------------' DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP log.debug('KeyboardInterrupt, DCSP shutting DCSP down...') DCNL DCSP  DCSP metric_cleanup()\n", "intent": "used for testing .\n", "question_id": 921}, {"snippet": "def main(): DCNL  DCSP password = getpass() DCNL DCSP for a_dict in (pynet1, pynet2, juniper_srx): DCNL DCSP  DCSP a_dict['password'] = password DCNL DCSP net_connect2 = ConnectHandler(**pynet2) DCNL DCSP net_connect2.config_mode() DCNL DCSP print '\\n>>>>' DCNL DCSP print 'Checking DCSP pynet-rtr2 DCSP is DCSP in DCSP configuration DCSP mode.' DCNL DCSP print 'Config DCSP mode DCSP check: DCSP {}'.format(net_connect2.check_config_mode()) DCNL DCSP print 'Current DCSP prompt: DCSP {}'.format(net_connect2.find_prompt()) DCNL DCSP print '>>>>\\n'\n", "intent": "using netmiko enter into configuration mode on a network device .\n", "question_id": 922}, {"snippet": "def require_foreign(namespace, symbol=None): DCNL  DCSP try: DCNL DCSP  DCSP if (symbol is None): DCNL DCSP  DCSP  DCSP get_foreign_module(namespace) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP get_foreign_struct(namespace, symbol) DCNL DCSP except ForeignError as e: DCNL DCSP  DCSP raise ImportError(e)\n", "intent": "raises importerror if the specified foreign module isnt supported or the needed dependencies arent installed .\n", "question_id": 923}, {"snippet": "def UnpickleFromFile(datafile): DCNL  DCSP encoded_records = pickle.load(datafile) DCNL DCSP records = [] DCNL DCSP for encoded_record in encoded_records: DCNL DCSP  DCSP record = datamodel_pb.RequestStatProto(encoded_record) DCNL DCSP  DCSP records.append(record) DCNL DCSP  DCSP datafile.close() DCNL DCSP return records\n", "intent": "reads appstats data from file .\n", "question_id": 924}, {"snippet": "def make_navigation_node(model_object, is_entering=True, session_ring=None, device_bank_registry=None, banking_info=None): DCNL  DCSP node = None DCNL DCSP if (model_object == None): DCNL DCSP  DCSP node = None DCNL DCSP elif isinstance(model_object, Live.Song.Song): DCNL DCSP  DCSP node = SongNode(object=model_object, session_ring=session_ring) DCNL DCSP elif isinstance(model_object, Live.Track.Track): DCNL DCSP  DCSP node = TrackNode(object=model_object, device_bank_registry=device_bank_registry) DCNL DCSP elif isinstance(model_object, Live.Chain.Chain): DCNL DCSP  DCSP node = ChainNode(object=model_object, device_bank_registry=device_bank_registry) DCNL DCSP elif isinstance(model_object, Live.DrumPad.DrumPad): DCNL DCSP  DCSP node = (ChainNode(object=model_object.chains[0], device_bank_registry=device_bank_registry) if model_object.chains else None) DCNL DCSP elif isinstance(model_object, Live.Device.Device): DCNL DCSP  DCSP if model_object.can_have_chains: DCNL DCSP  DCSP  DCSP if model_object.can_have_drum_pads: DCNL DCSP  DCSP  DCSP  DCSP if is_entering: DCNL DCSP  DCSP  DCSP  DCSP  DCSP node = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP node = make_navigation_node(model_object.canonical_parent, is_entering=is_entering, device_bank_registry=device_bank_registry, banking_info=banking_info) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP node = RackNode(model_object) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise (device_bank_registry or AssertionError('Navigating DCSP a DCSP device DCSP needs DCSP a DCSP bank DCSP registry')) DCNL DCSP  DCSP  DCSP node = SimpleDeviceNode(device_bank_registry, banking_info, model_object) DCNL DCSP if (node and node.parent and (not node.children)): DCNL DCSP  DCSP node.disconnect() DCNL DCSP  DCSP node = None DCNL DCSP if (isinstance(node, RackNode) and (len(node.children) == 1)): DCNL DCSP  DCSP actual_model_object = (node.children[0][1] if is_entering else node.parent) DCNL DCSP  DCSP node.disconnect() DCNL DCSP  DCSP node = make_navigation_node(actual_model_object, is_entering=is_entering, device_bank_registry=device_bank_registry, banking_info=banking_info) DCNL DCSP return node\n", "intent": "returns a proper navigation node wrapper for the model_object .\n", "question_id": 925}, {"snippet": "def _im_func(f): DCNL  DCSP if hasattr(f, '__func__'): DCNL DCSP  DCSP return f.__func__ DCNL DCSP else: DCNL DCSP  DCSP return f\n", "intent": "wrapper to get at the underlying function belonging to a method .\n", "question_id": 926}, {"snippet": "def __virtual__(): DCNL  DCSP return (True if ('infoblox.get_record' in __salt__) else False)\n", "intent": "make sure the infoblox module is available .\n", "question_id": 927}, {"snippet": "def sniff_version(stream): DCNL  DCSP doc = parse(stream) DCNL DCSP scheme_el = doc.getroot() DCNL DCSP version = scheme_el.attrib.get('version', None) DCNL DCSP if (scheme_el.find('widgets') is not None): DCNL DCSP  DCSP version = '1.0' DCNL DCSP else: DCNL DCSP  DCSP version = '2.0' DCNL DCSP return version\n", "intent": "parse a scheme stream and return the schemes serialization version string .\n", "question_id": 928}, {"snippet": "def user_info(user, host='localhost', **connection_args): DCNL  DCSP dbc = _connect(**connection_args) DCNL DCSP if (dbc is None): DCNL DCSP  DCSP return False DCNL DCSP cur = dbc.cursor(MySQLdb.cursors.DictCursor) DCNL DCSP qry = 'SELECT DCSP * DCSP FROM DCSP mysql.user DCSP WHERE DCSP User DCSP = DCSP %(user)s DCSP AND DCSP Host DCSP = DCSP %(host)s' DCNL DCSP args = {} DCNL DCSP args['user'] = user DCNL DCSP args['host'] = host DCNL DCSP try: DCNL DCSP  DCSP _execute(cur, qry, args) DCNL DCSP except MySQLdb.OperationalError as exc: DCNL DCSP  DCSP err = 'MySQL DCSP Error DCSP {0}: DCSP {1}'.format(*exc) DCNL DCSP  DCSP __context__['mysql.error'] = err DCNL DCSP  DCSP log.error(err) DCNL DCSP  DCSP return False DCNL DCSP result = cur.fetchone() DCNL DCSP log.debug(result) DCNL DCSP return result\n", "intent": "get full info on a mysql user cli example: .\n", "question_id": 929}, {"snippet": "def _roads_extract(resp): DCNL  DCSP try: DCNL DCSP  DCSP j = resp.json() DCNL DCSP except: DCNL DCSP  DCSP if (resp.status_code != 200): DCNL DCSP  DCSP  DCSP raise googlemaps.exceptions.HTTPError(resp.status_code) DCNL DCSP  DCSP raise googlemaps.exceptions.ApiError('UNKNOWN_ERROR', 'Received DCSP a DCSP malformed DCSP response.') DCNL DCSP if ('error' in j): DCNL DCSP  DCSP error = j['error'] DCNL DCSP  DCSP status = error['status'] DCNL DCSP  DCSP if (status == 'RESOURCE_EXHAUSTED'): DCNL DCSP  DCSP  DCSP raise googlemaps.exceptions._RetriableRequest() DCNL DCSP  DCSP if ('message' in error): DCNL DCSP  DCSP  DCSP raise googlemaps.exceptions.ApiError(status, error['message']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise googlemaps.exceptions.ApiError(status) DCNL DCSP if (resp.status_code != 200): DCNL DCSP  DCSP raise googlemaps.exceptions.HTTPError(resp.status_code) DCNL DCSP return j\n", "intent": "extracts a result from a roads api http response .\n", "question_id": 930}, {"snippet": "def omniscient_datetime(*args): DCNL  DCSP d = original_datetime(*args) DCNL DCSP if settings.USE_TZ: DCNL DCSP  DCSP d = timezone.make_aware(d, timezone.utc) DCNL DCSP return d\n", "intent": "generating a datetime aware or naive depending of use_tz .\n", "question_id": 931}, {"snippet": "def adaptAgent(agent_klass): DCNL  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP return RlglueAgentAdapter(agent_klass, *args, **kwargs) DCNL DCSP return inner\n", "intent": "return a factory function that instantiates a pybrain agent and adapts it to the rlglue framework interface .\n", "question_id": 932}, {"snippet": "def get_maker(engine, autocommit=True, expire_on_commit=False): DCNL  DCSP return sqlalchemy.orm.sessionmaker(bind=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, query_cls=Query)\n", "intent": "return a sqlalchemy sessionmaker using the given engine .\n", "question_id": 933}, {"snippet": "def get_settings(): DCNL  DCSP if ('custom_settings' in current_app.config): DCNL DCSP  DCSP return current_app.config['custom_settings'] DCNL DCSP s = Setting.query.order_by(desc(Setting.id)).first() DCNL DCSP if (s is None): DCNL DCSP  DCSP set_settings(secret='super DCSP secret DCSP key', app_name='Open DCSP Event') DCNL DCSP else: DCNL DCSP  DCSP current_app.config['custom_settings'] = make_dict(s) DCNL DCSP return current_app.config['custom_settings']\n", "intent": "use this to get latest system settings .\n", "question_id": 934}, {"snippet": "@csrf_exempt DCNL def update_subproject(request, project, subproject): DCNL  DCSP if (not appsettings.ENABLE_HOOKS): DCNL DCSP  DCSP return HttpResponseNotAllowed([]) DCNL DCSP obj = get_subproject(request, project, subproject, True) DCNL DCSP if (not obj.project.enable_hooks): DCNL DCSP  DCSP return HttpResponseNotAllowed([]) DCNL DCSP perform_update(obj) DCNL DCSP return hook_response()\n", "intent": "api hook for updating git repos .\n", "question_id": 935}, {"snippet": "def parse_date(datestring): DCNL  DCSP if datestring: DCNL DCSP  DCSP (date, time) = datestring.split(' DCSP ') DCNL DCSP  DCSP (year, month, day) = map(int, date.split('-')) DCNL DCSP  DCSP (hour, minute) = map(int, time.split(':')) DCNL DCSP  DCSP if validate_date(year, month, day, hour, minute): DCNL DCSP  DCSP  DCSP return datetime.datetime(year, month, day, hour, minute, tzinfo=pytz.UTC) DCNL DCSP return None\n", "intent": "generate a utc datetime .\n", "question_id": 936}, {"snippet": "def add_accept_handler(sock, callback, io_loop=None): DCNL  DCSP if (io_loop is None): DCNL DCSP  DCSP io_loop = IOLoop.current() DCNL DCSP def accept_handler(fd, events): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (connection, address) = sock.accept() DCNL DCSP  DCSP  DCSP except socket.error as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if (e.args[0] == errno.ECONNABORTED): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP callback(connection, address) DCNL DCSP io_loop.add_handler(sock.fileno(), accept_handler, IOLoop.READ)\n", "intent": "adds an .\n", "question_id": 937}, {"snippet": "def decode(text): DCNL  DCSP try: DCNL DCSP  DCSP if text.startswith(BOM_UTF8): DCNL DCSP  DCSP  DCSP return (to_text_string(text[len(BOM_UTF8):], 'utf-8'), 'utf-8-bom') DCNL DCSP  DCSP elif text.startswith(BOM_UTF16): DCNL DCSP  DCSP  DCSP return (to_text_string(text[len(BOM_UTF16):], 'utf-16'), 'utf-16') DCNL DCSP  DCSP elif text.startswith(BOM_UTF32): DCNL DCSP  DCSP  DCSP return (to_text_string(text[len(BOM_UTF32):], 'utf-32'), 'utf-32') DCNL DCSP  DCSP coding = get_coding(text) DCNL DCSP  DCSP if coding: DCNL DCSP  DCSP  DCSP return (to_text_string(text, coding), coding) DCNL DCSP except (UnicodeError, LookupError): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return (to_text_string(text, 'utf-8'), 'utf-8-guessed') DCNL DCSP except (UnicodeError, LookupError): DCNL DCSP  DCSP pass DCNL DCSP return (to_text_string(text, 'latin-1'), 'latin-1-guessed')\n", "intent": "function to decode a text .\n", "question_id": 938}, {"snippet": "def hosted_zone_absent(name, domain_name=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP domain_name = (domain_name if domain_name else name) DCNL DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP deets = __salt__['boto_route53.describe_hosted_zones'](domain_name=domain_name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not deets): DCNL DCSP  DCSP ret['comment'] = 'Hosted DCSP Zone DCSP {0} DCSP already DCSP absent'.format(domain_name) DCNL DCSP  DCSP log.info(ret['comment']) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Route53 DCSP Hosted DCSP Zone DCSP {0} DCSP set DCSP to DCSP be DCSP deleted.'.format(domain_name) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP if __salt__['boto_route53.delete_zone'](zone=domain_name, region=region, key=key, keyid=keyid, profile=profile): DCNL DCSP  DCSP ret['comment'] = 'Route53 DCSP Hosted DCSP Zone DCSP {0} DCSP deleted'.format(domain_name) DCNL DCSP  DCSP log.info(ret['comment']) DCNL DCSP  DCSP ret['changes']['old'] = deets DCNL DCSP  DCSP ret['changes']['new'] = None DCNL DCSP return ret\n", "intent": "ensure the route53 hostes zone described is absent name the name of the state definition .\n", "question_id": 939}, {"snippet": "def is_x64_architecture(): DCNL  DCSP if ('64' in platform.machine()): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False\n", "intent": "return true if the architecture is x64 .\n", "question_id": 940}, {"snippet": "def kml(request, label, model, field_name=None, compress=False, using=DEFAULT_DB_ALIAS): DCNL  DCSP placemarks = [] DCNL DCSP klass = get_model(label, model) DCNL DCSP if (not klass): DCNL DCSP  DCSP raise Http404(('You DCSP must DCSP supply DCSP a DCSP valid DCSP app DCSP label DCSP and DCSP module DCSP name. DCSP  DCSP Got DCSP \"%s.%s\"' % (label, model))) DCNL DCSP if field_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP info = klass._meta.get_field_by_name(field_name) DCNL DCSP  DCSP  DCSP if (not isinstance(info[0], GeometryField)): DCNL DCSP  DCSP  DCSP  DCSP raise Exception DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Http404('Invalid DCSP geometry DCSP field.') DCNL DCSP connection = connections[using] DCNL DCSP if connection.ops.postgis: DCNL DCSP  DCSP placemarks = klass._default_manager.using(using).kml(field_name=field_name) DCNL DCSP else: DCNL DCSP  DCSP placemarks = [] DCNL DCSP  DCSP if connection.ops.oracle: DCNL DCSP  DCSP  DCSP qs = klass._default_manager.using(using).transform(4326, field_name=field_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qs = klass._default_manager.using(using).all() DCNL DCSP  DCSP for mod in qs: DCNL DCSP  DCSP  DCSP setattr(mod, 'kml', getattr(mod, field_name).kml) DCNL DCSP  DCSP  DCSP placemarks.append(mod) DCNL DCSP if compress: DCNL DCSP  DCSP render = render_to_kmz DCNL DCSP else: DCNL DCSP  DCSP render = render_to_kml DCNL DCSP return render('gis/kml/placemarks.kml', {'places': placemarks})\n", "intent": "this view generates kml for the given app label .\n", "question_id": 941}, {"snippet": "def setup(app): DCNL  DCSP if (not isinstance(app, Sphinx)): DCNL DCSP  DCSP return DCNL DCSP _patch_python_domain() DCNL DCSP app.connect('autodoc-process-docstring', _process_docstring) DCNL DCSP app.connect('autodoc-skip-member', _skip_member) DCNL DCSP for (name, (default, rebuild)) in iteritems(Config._config_values): DCNL DCSP  DCSP app.add_config_value(name, default, rebuild) DCNL DCSP return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n", "intent": "sphinx extension setup function .\n", "question_id": 942}, {"snippet": "def new_figure_manager(num, *args, **kwargs): DCNL  DCSP if __debug__: DCNL DCSP  DCSP verbose.report(u'backend_agg.new_figure_manager', u'debug-annoying') DCNL DCSP FigureClass = kwargs.pop(u'FigureClass', Figure) DCNL DCSP thisFig = FigureClass(*args, **kwargs) DCNL DCSP return new_figure_manager_given_figure(num, thisFig)\n", "intent": "create a new figure manager instance .\n", "question_id": 943}, {"snippet": "def groups(): DCNL  DCSP rebulk = Rebulk() DCNL DCSP rebulk.defaults(name='group', marker=True) DCNL DCSP starting = '([{' DCNL DCSP ending = ')]}' DCNL DCSP def mark_groups(input_string): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Functional DCSP pattern DCSP to DCSP mark DCSP groups DCSP (...), DCSP [...] DCSP and DCSP {...}.\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :param DCSP input_string:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :return:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP openings = ([], [], []) DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP ret = [] DCNL DCSP  DCSP for char in input_string: DCNL DCSP  DCSP  DCSP start_type = starting.find(char) DCNL DCSP  DCSP  DCSP if (start_type > (-1)): DCNL DCSP  DCSP  DCSP  DCSP openings[start_type].append(i) DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP end_type = ending.find(char) DCNL DCSP  DCSP  DCSP if (end_type > (-1)): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = openings[end_type].pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.append((start_index, i)) DCNL DCSP  DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return ret DCNL DCSP rebulk.functional(mark_groups) DCNL DCSP return rebulk\n", "intent": "builder for rebulk object .\n", "question_id": 944}, {"snippet": "@manager.command() DCNL @argument('email') DCNL @option('--org', 'organization', default=None, help='The DCSP organization DCSP the DCSP user DCSP belongs DCSP to DCSP (leave DCSP blank DCSP for DCSP all DCSP organizations).') DCNL def delete(email, organization=None): DCNL  DCSP if organization: DCNL DCSP  DCSP org = models.Organization.get_by_slug(organization) DCNL DCSP  DCSP deleted_count = models.User.query.filter((models.User.email == email), (models.User.org == org.id)).delete() DCNL DCSP else: DCNL DCSP  DCSP deleted_count = models.User.query.filter((models.User.email == email)).delete() DCNL DCSP models.db.session.commit() DCNL DCSP print ('Deleted DCSP %d DCSP users.' % deleted_count)\n", "intent": "delete user email .\n", "question_id": 945}, {"snippet": "def sgd(opfunc, x, config, state=None): DCNL  DCSP state = (state if (state is not None) else config) DCNL DCSP lr = config.get('learningRate', 0.001) DCNL DCSP lrd = config.get('learningRateDecay', 0) DCNL DCSP wd = config.get('weightDecay', 0) DCNL DCSP mom = config.get('momentum', 0) DCNL DCSP damp = config.get('dampening', mom) DCNL DCSP nesterov = config.get('nesterov', False) DCNL DCSP lrs = config.get('learningRates', None) DCNL DCSP wds = config.get('weightDecays', None) DCNL DCSP if (not ('evalCounter' in state)): DCNL DCSP  DCSP state['evalCounter'] = 0 DCNL DCSP if (nesterov and ((mom <= 0) and (damp != 0))): DCNL DCSP  DCSP raise ValueError('Nesterov DCSP momentum DCSP requires DCSP a DCSP momentum DCSP and DCSP zero DCSP dampening') DCNL DCSP if ((wd != 0) and (wds is not None)): DCNL DCSP  DCSP raise ValueError('Only DCSP one DCSP of DCSP wd DCSP and DCSP wds DCSP can DCSP be DCSP specified') DCNL DCSP (fx, dfdx) = opfunc(x) DCNL DCSP if (wd != 0): DCNL DCSP  DCSP dfdx.add_(wd, x) DCNL DCSP elif (wds is not None): DCNL DCSP  DCSP if (not state['decayParameters']): DCNL DCSP  DCSP  DCSP state['decayParameters'] = torch.Tensor().type_as(x).resize_as_(dfdx) DCNL DCSP  DCSP state['decayParameters'].copy_(wds).mul_(x) DCNL DCSP  DCSP dfdx.add_(state['decayParameters']) DCNL DCSP if (mom != 0): DCNL DCSP  DCSP if ('dfdx' not in state): DCNL DCSP  DCSP  DCSP state['dfdx'] = torch.Tensor().type_as(dfdx).resize_as_(dfdx).copy_(dfdx) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state['dfdx'].mul_(mom).add_((1 - damp), dfdx) DCNL DCSP  DCSP if nesterov: DCNL DCSP  DCSP  DCSP dfdx.add_(mom, state['dfdx']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dfdx = state['dfdx'] DCNL DCSP clr = (lr / (1 + (state['evalCounter'] * lrd))) DCNL DCSP if (lrs is not None): DCNL DCSP  DCSP if (not ('deltaParameters' in state)): DCNL DCSP  DCSP  DCSP state['deltaParameters'] = torch.Tensor().type_as(x).resize_as_(dfdx) DCNL DCSP  DCSP state['deltaParameters'].copy_(lrs).mul_(dfdx) DCNL DCSP  DCSP x.add_((- clr), state['deltaParameters']) DCNL DCSP else: DCNL DCSP  DCSP x.add_((- clr), dfdx) DCNL DCSP state['evalCounter'] += 1 DCNL DCSP return (x, fx)\n", "intent": "a plain implementation of sgd args: - opfunc : a function that takes a single input (x) .\n", "question_id": 946}, {"snippet": "def atof(s): DCNL  DCSP return _float(s)\n", "intent": "atof(s) -> float return the floating point number represented by the string s .\n", "question_id": 947}, {"snippet": "def containsAny(str, set): DCNL  DCSP return (1 in [(c in str) for c in set])\n", "intent": "check whether str contains any of the chars in set .\n", "question_id": 948}, {"snippet": "def compose_types(a, *cs): DCNL  DCSP if (not cs): DCNL DCSP  DCSP return a DCNL DCSP mcls = ((a,) + cs) DCNL DCSP return type(('compose_types(%s)' % ', DCSP '.join(map(attrgetter('__name__'), mcls))), mcls, {})\n", "intent": "compose multiple classes together .\n", "question_id": 949}, {"snippet": "def libtree(lib): DCNL  DCSP root = Node({}, {}) DCNL DCSP for item in lib.items(): DCNL DCSP  DCSP dest = item.destination(fragment=True) DCNL DCSP  DCSP parts = util.components(dest) DCNL DCSP  DCSP _insert(root, parts, item.id) DCNL DCSP return root\n", "intent": "generates a filesystem-like directory tree for the files contained in lib .\n", "question_id": 950}, {"snippet": "def get_encodings_from_content(content): DCNL  DCSP charset_re = re.compile('<meta.*?charset=[\"\\\\\\']*(.+?)[\"\\\\\\'>]', flags=re.I) DCNL DCSP return charset_re.findall(content)\n", "intent": "returns encodings from given content string .\n", "question_id": 951}, {"snippet": "def norm_entropy_vec(loc, scale): DCNL  DCSP if (isinstance(loc, float) or isinstance(loc, int)): DCNL DCSP  DCSP return stats.norm.entropy(loc, scale) DCNL DCSP else: DCNL DCSP  DCSP return np.array([stats.norm.entropy(loc_x, scale_x) for (loc_x, scale_x) in zip(loc, scale)])\n", "intent": "vectorized version of stats .\n", "question_id": 952}, {"snippet": "def _obtain_lock(id): DCNL  DCSP try: DCNL DCSP  DCSP os.symlink('/dev/null', _lock_file(id)) DCNL DCSP  DCSP return True DCNL DCSP except: DCNL DCSP  DCSP return False\n", "intent": "attempts to lock id .\n", "question_id": 953}, {"snippet": "@register.tag DCNL def get_blogroll(parser, token): DCNL  DCSP try: DCNL DCSP  DCSP (tag_name, arg) = token.contents.split(None, 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise template.TemplateSyntaxError, ('%s DCSP tag DCSP requires DCSP arguments' % token.contents.split()[0]) DCNL DCSP m = re.search('as DCSP (\\\\w+)', arg) DCNL DCSP if (not m): DCNL DCSP  DCSP raise template.TemplateSyntaxError, ('%s DCSP tag DCSP had DCSP invalid DCSP arguments' % tag_name) DCNL DCSP var_name = m.groups()[0] DCNL DCSP return BlogRolls(var_name)\n", "intent": "gets all blogroll links .\n", "question_id": 954}, {"snippet": "def upload_exec_summary_to_store(data_dict, report_name, course_id, generated_at, config_name='FINANCIAL_REPORTS'): DCNL  DCSP report_store = ReportStore.from_config(config_name) DCNL DCSP output_buffer = StringIO(render_to_string('instructor/instructor_dashboard_2/executive_summary.html', data_dict)) DCNL DCSP report_store.store(course_id, u'{course_prefix}_{report_name}_{timestamp_str}.html'.format(course_prefix=course_filename_prefix_generator(course_id), report_name=report_name, timestamp_str=generated_at.strftime('%Y-%m-%d-%H%M')), output_buffer) DCNL DCSP tracker.emit(REPORT_REQUESTED_EVENT_NAME, {'report_type': report_name})\n", "intent": "upload executive summary html file using reportstore .\n", "question_id": 955}, {"snippet": "def filter_scanline(type, line, fo, prev=None): DCNL  DCSP assert (0 <= type < 5) DCNL DCSP out = array('B', [type]) DCNL DCSP def sub(): DCNL DCSP  DCSP ai = (- fo) DCNL DCSP  DCSP for x in line: DCNL DCSP  DCSP  DCSP if (ai >= 0): DCNL DCSP  DCSP  DCSP  DCSP x = ((x - line[ai]) & 255) DCNL DCSP  DCSP  DCSP out.append(x) DCNL DCSP  DCSP  DCSP ai += 1 DCNL DCSP def up(): DCNL DCSP  DCSP for (i, x) in enumerate(line): DCNL DCSP  DCSP  DCSP x = ((x - prev[i]) & 255) DCNL DCSP  DCSP  DCSP out.append(x) DCNL DCSP def average(): DCNL DCSP  DCSP ai = (- fo) DCNL DCSP  DCSP for (i, x) in enumerate(line): DCNL DCSP  DCSP  DCSP if (ai >= 0): DCNL DCSP  DCSP  DCSP  DCSP x = ((x - ((line[ai] + prev[i]) >> 1)) & 255) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP x = ((x - (prev[i] >> 1)) & 255) DCNL DCSP  DCSP  DCSP out.append(x) DCNL DCSP  DCSP  DCSP ai += 1 DCNL DCSP def paeth(): DCNL DCSP  DCSP ai = (- fo) DCNL DCSP  DCSP for (i, x) in enumerate(line): DCNL DCSP  DCSP  DCSP a = 0 DCNL DCSP  DCSP  DCSP b = prev[i] DCNL DCSP  DCSP  DCSP c = 0 DCNL DCSP  DCSP  DCSP if (ai >= 0): DCNL DCSP  DCSP  DCSP  DCSP a = line[ai] DCNL DCSP  DCSP  DCSP  DCSP c = prev[ai] DCNL DCSP  DCSP  DCSP p = ((a + b) - c) DCNL DCSP  DCSP  DCSP pa = abs((p - a)) DCNL DCSP  DCSP  DCSP pb = abs((p - b)) DCNL DCSP  DCSP  DCSP pc = abs((p - c)) DCNL DCSP  DCSP  DCSP if ((pa <= pb) and (pa <= pc)): DCNL DCSP  DCSP  DCSP  DCSP Pr = a DCNL DCSP  DCSP  DCSP elif (pb <= pc): DCNL DCSP  DCSP  DCSP  DCSP Pr = b DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP Pr = c DCNL DCSP  DCSP  DCSP x = ((x - Pr) & 255) DCNL DCSP  DCSP  DCSP out.append(x) DCNL DCSP  DCSP  DCSP ai += 1 DCNL DCSP if (not prev): DCNL DCSP  DCSP if (type == 2): DCNL DCSP  DCSP  DCSP return line DCNL DCSP  DCSP elif (type == 3): DCNL DCSP  DCSP  DCSP prev = ([0] * len(line)) DCNL DCSP  DCSP elif (type == 4): DCNL DCSP  DCSP  DCSP type = 1 DCNL DCSP if (type == 0): DCNL DCSP  DCSP out.extend(line) DCNL DCSP elif (type == 1): DCNL DCSP  DCSP sub() DCNL DCSP elif (type == 2): DCNL DCSP  DCSP up() DCNL DCSP elif (type == 3): DCNL DCSP  DCSP average() DCNL DCSP else: DCNL DCSP  DCSP paeth() DCNL DCSP return out\n", "intent": "apply a scanline filter to a scanline .\n", "question_id": 956}, {"snippet": "def validate_non_negative_integer(option, value): DCNL  DCSP val = validate_integer(option, value) DCNL DCSP if (val < 0): DCNL DCSP  DCSP raise ValueError(('The DCSP value DCSP of DCSP %s DCSP must DCSP be DCSP a DCSP non DCSP negative DCSP integer' % (option,))) DCNL DCSP return val\n", "intent": "validate that value is a positive integer or 0 .\n", "question_id": 957}, {"snippet": "def libvlc_vlm_set_output(p_instance, psz_name, psz_output): DCNL  DCSP f = (_Cfunctions.get('libvlc_vlm_set_output', None) or _Cfunction('libvlc_vlm_set_output', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_output)\n", "intent": "set the output for a media .\n", "question_id": 958}, {"snippet": "def makeCentered(data): DCNL  DCSP return (data - data.mean(axis=0))\n", "intent": "move the mean of the data matrix into the origin .\n", "question_id": 959}, {"snippet": "def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP add_devices((VeraLight(device, VERA_CONTROLLER) for device in VERA_DEVICES['light']))\n", "intent": "setup vera lights .\n", "question_id": 960}, {"snippet": "def update(context, namespace_name, object_id, values, session): DCNL  DCSP namespace_api.get(context, namespace_name, session) DCNL DCSP md_object = _get(context, object_id, session) DCNL DCSP metadef_utils.drop_protected_attrs(models.MetadefObject, values) DCNL DCSP try: DCNL DCSP  DCSP md_object.update(values.copy()) DCNL DCSP  DCSP md_object.save(session=session) DCNL DCSP except db_exc.DBDuplicateEntry: DCNL DCSP  DCSP LOG.debug('Invalid DCSP update. DCSP It DCSP would DCSP result DCSP in DCSP a DCSP duplicate DCSP metadata DCSP definition DCSP object DCSP with DCSP same DCSP name=%(name)s DCSP in DCSP namespace=%(namespace_name)s.', {'name': md_object.name, 'namespace_name': namespace_name}) DCNL DCSP  DCSP emsg = (_('Invalid DCSP update. DCSP It DCSP would DCSP result DCSP in DCSP a DCSP duplicate DCSP metadata DCSP definition DCSP object DCSP with DCSP the DCSP same DCSP name=%(name)s DCSP in DCSP namespace=%(namespace_name)s.') % {'name': md_object.name, 'namespace_name': namespace_name}) DCNL DCSP  DCSP raise exc.MetadefDuplicateObject(emsg) DCNL DCSP return md_object.to_dict()\n", "intent": "update an object .\n", "question_id": 961}, {"snippet": "def inject_commands(command_table, session, **kwargs): DCNL  DCSP command_table['package'] = PackageCommand(session) DCNL DCSP command_table['deploy'] = DeployCommand(session)\n", "intent": "called when the cloudformation command table is being built .\n", "question_id": 962}, {"snippet": "def libvlc_media_new_fd(p_instance, fd): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_new_fd', None) or _Cfunction('libvlc_media_new_fd', ((1,), (1,)), class_result(Media), ctypes.c_void_p, Instance, ctypes.c_int)) DCNL DCSP return f(p_instance, fd)\n", "intent": "create a media for an already open file descriptor .\n", "question_id": 963}, {"snippet": "def p_enumerator_list_1(t): DCNL  DCSP pass\n", "intent": "enumerator_list : enumerator .\n", "question_id": 964}, {"snippet": "def sqrt_mod(a, p, all_roots=False): DCNL  DCSP if all_roots: DCNL DCSP  DCSP return sorted(list(sqrt_mod_iter(a, p))) DCNL DCSP try: DCNL DCSP  DCSP p = abs(as_int(p)) DCNL DCSP  DCSP it = sqrt_mod_iter(a, p) DCNL DCSP  DCSP r = next(it) DCNL DCSP  DCSP if (r > (p // 2)): DCNL DCSP  DCSP  DCSP return (p - r) DCNL DCSP  DCSP elif (r < (p // 2)): DCNL DCSP  DCSP  DCSP return r DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP r = next(it) DCNL DCSP  DCSP  DCSP  DCSP if (r > (p // 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (p - r) DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP return r DCNL DCSP except StopIteration: DCNL DCSP  DCSP return None\n", "intent": "find a root of x**2 = a mod p parameters a : integer p : positive integer all_roots : if true the list of roots is returned or none notes if there is no root it is returned none; else the returned root is less or equal to p // 2; in general is not the smallest one .\n", "question_id": 965}, {"snippet": "def make_msgid(idstring=None): DCNL  DCSP timeval = int((time.time() * 100)) DCNL DCSP pid = os.getpid() DCNL DCSP randint = random.getrandbits(64) DCNL DCSP if (idstring is None): DCNL DCSP  DCSP idstring = '' DCNL DCSP else: DCNL DCSP  DCSP idstring = ('.' + idstring) DCNL DCSP idhost = socket.getfqdn() DCNL DCSP msgid = ('<%d.%d.%d%s@%s>' % (timeval, pid, randint, idstring, idhost)) DCNL DCSP return msgid\n", "intent": "returns a string suitable for rfc 2822 compliant message-id .\n", "question_id": 966}, {"snippet": "def launch(address='127.0.0.1', port=6633, max_retry_delay=16, dpid=None, ports='', extra=None, ctl_port=None, __INSTANCE__=None): DCNL  DCSP if (not pxpcap.enabled): DCNL DCSP  DCSP raise RuntimeError('You DCSP need DCSP PXPCap DCSP to DCSP use DCSP this DCSP component') DCNL DCSP if ctl_port: DCNL DCSP  DCSP if core.hasComponent('ctld'): DCNL DCSP  DCSP  DCSP raise RuntimeError('Only DCSP one DCSP ctl_port DCSP is DCSP allowed') DCNL DCSP  DCSP if (ctl_port is True): DCNL DCSP  DCSP  DCSP ctl_port = DEFAULT_CTL_PORT DCNL DCSP  DCSP import ctl DCNL DCSP  DCSP ctl.server(ctl_port) DCNL DCSP  DCSP core.ctld.addListenerByName('CommandEvent', _do_ctl) DCNL DCSP _ports = ports.strip() DCNL DCSP def up(event): DCNL DCSP  DCSP ports = [p for p in _ports.split(',') if p] DCNL DCSP  DCSP sw = do_launch(PCapSwitch, address, port, max_retry_delay, dpid, ports=ports, extra_args=extra) DCNL DCSP  DCSP _switches[sw.name] = sw DCNL DCSP core.addListenerByName('UpEvent', up)\n", "intent": "launches a switch .\n", "question_id": 967}, {"snippet": "def test_bad_setv(): DCNL  DCSP cant_compile(u'(setv DCSP if* DCSP 1)') DCNL DCSP cant_compile(u'(setv DCSP (a DCSP b) DCSP [1 DCSP 2])')\n", "intent": "ensure setv handles error cases .\n", "question_id": 968}, {"snippet": "def _load(filepath, recurse_depth=0, retry=True): DCNL  DCSP try: DCNL DCSP  DCSP import joblib DCNL DCSP  DCSP joblib_available = True DCNL DCSP except ImportError: DCNL DCSP  DCSP joblib_available = False DCNL DCSP if (recurse_depth == 0): DCNL DCSP  DCSP filepath = preprocess(filepath) DCNL DCSP if (filepath.endswith('.npy') or filepath.endswith('.npz')): DCNL DCSP  DCSP return np.load(filepath) DCNL DCSP if (filepath.endswith('.amat') or filepath.endswith('txt')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return np.loadtxt(filepath) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP reraise_as('{0} DCSP cannot DCSP be DCSP loaded DCSP by DCSP serial.load DCSP (trying DCSP to DCSP use DCSP np.loadtxt)'.format(filepath)) DCNL DCSP if filepath.endswith('.mat'): DCNL DCSP  DCSP global io DCNL DCSP  DCSP if (io is None): DCNL DCSP  DCSP  DCSP import scipy.io DCNL DCSP  DCSP  DCSP io = scipy.io DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return io.loadmat(filepath) DCNL DCSP  DCSP except NotImplementedError as nei: DCNL DCSP  DCSP  DCSP if (str(nei).find('HDF DCSP reader') != (-1)): DCNL DCSP  DCSP  DCSP  DCSP global hdf_reader DCNL DCSP  DCSP  DCSP  DCSP if (hdf_reader is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import h5py DCNL DCSP  DCSP  DCSP  DCSP  DCSP hdf_reader = h5py DCNL DCSP  DCSP  DCSP  DCSP return hdf_reader.File(filepath, 'r') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP assert False DCNL DCSP encoding = ({'encoding': 'latin-1'} if six.PY3 else {}) DCNL DCSP def exponential_backoff(): DCNL DCSP  DCSP if (recurse_depth > 9): DCNL DCSP  DCSP  DCSP logger.info('Max DCSP number DCSP of DCSP tries DCSP exceeded DCSP while DCSP trying DCSP to DCSP open DCSP {0}'.format(filepath)) DCNL DCSP  DCSP  DCSP logger.info('attempting DCSP to DCSP open DCSP via DCSP reading DCSP string') DCNL DCSP  DCSP  DCSP with open(filepath, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP content = f.read() DCNL DCSP  DCSP  DCSP return cPickle.loads(content, **encoding) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nsec = (0.5 * (2.0 ** float(recurse_depth))) DCNL DCSP  DCSP  DCSP logger.info('Waiting DCSP {0} DCSP seconds DCSP and DCSP trying DCSP again'.format(nsec)) DCNL DCSP  DCSP  DCSP time.sleep(nsec) DCNL DCSP  DCSP  DCSP return _load(filepath, (recurse_depth + 1), retry) DCNL DCSP try: DCNL DCSP  DCSP if (not joblib_available): DCNL DCSP  DCSP  DCSP with open(filepath, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP obj = cPickle.load(f, **encoding) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP obj = joblib.load(filepath) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP if (os.path.exists(filepath) and (not os.path.isdir(filepath))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP raise_cannot_open(filepath) DCNL DCSP except MemoryError as e: DCNL DCSP  DCSP if (os.path.splitext(filepath)[1] == '.pkl'): DCNL DCSP  DCSP  DCSP improve_memory_error_message(e, (\"You DCSP do DCSP not DCSP have DCSP enough DCSP memory DCSP to DCSP open DCSP %s DCSP \\n DCSP + DCSP Try DCSP using DCSP numpy.{save,load} DCSP (file DCSP with DCSP extension DCSP '.npy') DCSP to DCSP save DCSP your DCSP file. DCSP It DCSP uses DCSP less DCSP memory DCSP when DCSP reading DCSP and DCSP writing DCSP files DCSP than DCSP pickled DCSP files.\" % filepath)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP improve_memory_error_message(e, ('You DCSP do DCSP not DCSP have DCSP enough DCSP memory DCSP to DCSP open DCSP %s' % filepath)) DCNL DCSP except (BadPickleGet, EOFError, KeyError) as e: DCNL DCSP  DCSP if (not retry): DCNL DCSP  DCSP  DCSP reraise_as(e.__class__('Failed DCSP to DCSP open DCSP {0}'.format(filepath))) DCNL DCSP  DCSP obj = exponential_backoff() DCNL DCSP except ValueError: DCNL DCSP  DCSP logger.exception DCNL DCSP  DCSP if (not retry): DCNL DCSP  DCSP  DCSP reraise_as(ValueError('Failed DCSP to DCSP open DCSP {0}'.format(filepath))) DCNL DCSP  DCSP obj = exponential_backoff() DCNL DCSP except Exception: DCNL DCSP  DCSP reraise_as(\"Couldn't DCSP open DCSP {0}\".format(filepath)) DCNL DCSP if (not hasattr(obj, 'yaml_src')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj.yaml_src = (('!pkl: DCSP \"' + os.path.abspath(filepath)) + '\"') DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return obj\n", "intent": "recursively tries to load a file until success or maximum number of attempts .\n", "question_id": 969}, {"snippet": "def store_rendered_templates(store, signal, sender, template, context): DCNL  DCSP store.setdefault('template', []).append(template) DCNL DCSP store.setdefault('context', []).append(context)\n", "intent": "a utility function for storing templates and contexts that are rendered .\n", "question_id": 970}, {"snippet": "def i18n_patterns(*urls, **kwargs): DCNL  DCSP if (not settings.USE_I18N): DCNL DCSP  DCSP return list(urls) DCNL DCSP prefix_default_language = kwargs.pop('prefix_default_language', True) DCNL DCSP assert (not kwargs), ('Unexpected DCSP kwargs DCSP for DCSP i18n_patterns(): DCSP %s' % kwargs) DCNL DCSP return [LocaleRegexURLResolver(list(urls), prefix_default_language=prefix_default_language)]\n", "intent": "adds the language code prefix to every url pattern within this function .\n", "question_id": 971}, {"snippet": "def getimagesize(url): DCNL  DCSP try: DCNL DCSP  DCSP from PIL import ImageFile DCNL DCSP except ImportError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import ImageFile DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP import urllib2 DCNL DCSP except ImportError: DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP p = ImageFile.Parser() DCNL DCSP  DCSP f = urllib2.urlopen(url) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP s = f.read(1024) DCNL DCSP  DCSP  DCSP if (not s): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP p.feed(s) DCNL DCSP  DCSP  DCSP if p.image: DCNL DCSP  DCSP  DCSP  DCSP return ('width=\"%i\" DCSP height=\"%i\"' % p.image.size) DCNL DCSP except (IOError, ValueError): DCNL DCSP  DCSP return None\n", "intent": "attempts to determine an images width and height .\n", "question_id": 972}, {"snippet": "def cool(): DCNL  DCSP rc(u'image', cmap=u'cool') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.cool)\n", "intent": "set the default colormap to cool and apply to current image if any .\n", "question_id": 973}, {"snippet": "def fixup_for_packaged(): DCNL  DCSP if exists(join(ROOT, 'PKG-INFOvi DCSP ')): DCNL DCSP  DCSP if (('--build-js' in sys.argv) or ('--install-js' in sys.argv)): DCNL DCSP  DCSP  DCSP print(SDIST_BUILD_WARNING) DCNL DCSP  DCSP  DCSP if ('--build-js' in sys.argv): DCNL DCSP  DCSP  DCSP  DCSP sys.argv.remove('--build-js') DCNL DCSP  DCSP  DCSP if ('--install-js' in sys.argv): DCNL DCSP  DCSP  DCSP  DCSP sys.argv.remove('--install-js') DCNL DCSP  DCSP if ('--existing-js' not in sys.argv): DCNL DCSP  DCSP  DCSP sys.argv.append('--existing-js')\n", "intent": "if we are installing from an sdist .\n", "question_id": 974}, {"snippet": "def get_public_rsa_fingerprint(key_location=None, key_file_obj=None, passphrase=None): DCNL  DCSP privkey = get_rsa_key(key_location=key_location, key_file_obj=key_file_obj, passphrase=passphrase, use_pycrypto=True) DCNL DCSP pubkey = privkey.publickey() DCNL DCSP md5digest = hashlib.md5(pubkey.exportKey('DER')).hexdigest() DCNL DCSP fingerprint = insert_char_every_n_chars(md5digest, ':', 2) DCNL DCSP key = (key_location or key_file_obj) DCNL DCSP log.debug(('rsa DCSP public DCSP key DCSP fingerprint DCSP (%s): DCSP %s' % (key, fingerprint))) DCNL DCSP return fingerprint\n", "intent": "returns the fingerprint of the public portion of an rsa key as a 47-character string .\n", "question_id": 975}, {"snippet": "def users(attrs=None, where=None): DCNL  DCSP return _osquery_cmd(table='users', attrs=attrs, where=where)\n", "intent": "return users information from osquery cli example: .\n", "question_id": 976}, {"snippet": "def map_library_datasets_to_lddas(trans, lib_datasets): DCNL  DCSP lib_dataset_ids = [x.library_dataset_dataset_association_id for x in lib_datasets] DCNL DCSP lddas = trans.sa_session.query(trans.app.model.LibraryDatasetDatasetAssociation).filter(trans.app.model.LibraryDatasetDatasetAssociation.id.in_(lib_dataset_ids)).all() DCNL DCSP ret_lddas = {} DCNL DCSP for ldda in lddas: DCNL DCSP  DCSP ret_lddas[ldda.library_dataset_id] = ldda DCNL DCSP return ret_lddas\n", "intent": "given a list of librarydatasets .\n", "question_id": 977}, {"snippet": "def test_nesterov_momentum(): DCNL  DCSP cost = SumOfCosts([SumOfParams(), (0.0, DummyCost())]) DCNL DCSP model = DummyModel(shapes, lr_scalers=scales) DCNL DCSP dataset = ArangeDataset(1) DCNL DCSP momentum = 0.5 DCNL DCSP sgd = SGD(cost=cost, learning_rate=learning_rate, learning_rule=Momentum(momentum, nesterov_momentum=True), batch_size=1) DCNL DCSP sgd.setup(model=model, dataset=dataset) DCNL DCSP manual = [param.get_value() for param in model.get_params()] DCNL DCSP vel = [((- learning_rate) * scale) for scale in scales] DCNL DCSP updates = [(((- learning_rate) * scale) + (v * momentum)) for (scale, v) in izip(scales, vel)] DCNL DCSP manual = [(param + update) for (param, update) in izip(manual, updates)] DCNL DCSP sgd.train(dataset=dataset) DCNL DCSP assert all((np.allclose(manual_param, sgd_param.get_value()) for (manual_param, sgd_param) in izip(manual, model.get_params()))) DCNL DCSP vel = [(((- learning_rate) * scale) + (i * momentum)) for (scale, i) in izip(scales, vel)] DCNL DCSP updates = [(((- learning_rate) * scale) + (v * momentum)) for (scale, v) in izip(scales, vel)] DCNL DCSP manual = [(param + update) for (param, update) in izip(manual, updates)] DCNL DCSP sgd.train(dataset=dataset) DCNL DCSP assert all((np.allclose(manual_param, sgd_param.get_value()) for (manual_param, sgd_param) in izip(manual, model.get_params())))\n", "intent": "make sure that learning_rule .\n", "question_id": 978}, {"snippet": "def s3_flatlist(nested): DCNL  DCSP for item in nested: DCNL DCSP  DCSP if (isinstance(item, collections.Iterable) and (not isinstance(item, basestring))): DCNL DCSP  DCSP  DCSP for sub in s3_flatlist(item): DCNL DCSP  DCSP  DCSP  DCSP (yield sub) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield item)\n", "intent": "iterator to flatten mixed iterables of arbitrary depth .\n", "question_id": 979}, {"snippet": "def body(): DCNL  DCSP gender_opts = s3db.pr_gender_opts DCNL DCSP gender_opts[1] = T('unknown') DCNL DCSP ntable = s3db.pr_note DCNL DCSP ntable.status.readable = False DCNL DCSP ntable.status.writable = False DCNL DCSP dvi_tabs = [(T('Recovery'), ''), (T('Checklist'), 'checklist'), (T('Images'), 'image'), (T('Physical DCSP Description'), 'physical_description'), (T('Effects DCSP Inventory'), 'effects'), (T('Journal'), 'note'), (T('Identification'), 'identification')] DCNL DCSP rheader = S3ResourceHeader([[(T('ID DCSP Tag DCSP Number'), 'pe_label')], ['gender'], ['age_group']], tabs=dvi_tabs) DCNL DCSP return s3_rest_controller(rheader=rheader)\n", "intent": "dead bodies registry .\n", "question_id": 980}, {"snippet": "def update_build_queue(apps, schema): DCNL  DCSP Project = apps.get_model(u'projects', u'Project') DCNL DCSP for project in Project.objects.all(): DCNL DCSP  DCSP if (project.build_queue is not None): DCNL DCSP  DCSP  DCSP if (not project.build_queue.startswith(u'build-')): DCNL DCSP  DCSP  DCSP  DCSP project.build_queue = u'build-{0}'.format(project.build_queue) DCNL DCSP  DCSP  DCSP  DCSP project.save()\n", "intent": "update project build queue to include the previously implied build- prefix .\n", "question_id": 981}, {"snippet": "def rooms(request, template='rooms.html'): DCNL  DCSP context = {'rooms': ChatRoom.objects.all()} DCNL DCSP return render(request, template, context)\n", "intent": "homepage - lists all rooms .\n", "question_id": 982}, {"snippet": "def find_between(a, b, string): DCNL  DCSP p = ('%s(.*?)%s' % (a, b)) DCNL DCSP p = re.compile(p, (re.DOTALL | re.I)) DCNL DCSP return [m for m in p.findall(string)]\n", "intent": "returns a list of substrings between a and b in the given string .\n", "question_id": 983}, {"snippet": "def normalize_pack_version(version): DCNL  DCSP version = str(version) DCNL DCSP version_seperator_count = version.count('.') DCNL DCSP if (version_seperator_count == 1): DCNL DCSP  DCSP version = (version + '.0') DCNL DCSP return version\n", "intent": "normalize old .\n", "question_id": 984}, {"snippet": "@then(u'we DCSP see DCSP record DCSP inserted') DCNL def step_see_record_inserted(context): DCNL  DCSP _expect_exact(context, u'INSERT DCSP 0 DCSP 1', timeout=2)\n", "intent": "wait to see insert output .\n", "question_id": 985}, {"snippet": "def _get_connect_string(backend, user, passwd, database): DCNL  DCSP if (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP elif (backend == 'mysql'): DCNL DCSP  DCSP backend = 'mysql+mysqldb' DCNL DCSP else: DCNL DCSP  DCSP raise Exception((\"Unrecognized DCSP backend: DCSP '%s'\" % backend)) DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())\n", "intent": "try to get a connection with a very specific set of values .\n", "question_id": 986}, {"snippet": "def addCage(derivation, height, negatives, positives): DCNL  DCSP copyShallow = derivation.elementNode.getCopyShallow() DCNL DCSP copyShallow.attributes['path'] = [Vector3(), Vector3(0.0, 0.0, height)] DCNL DCSP extrudeDerivation = extrude.ExtrudeDerivation(copyShallow) DCNL DCSP roundedExtendedRectangle = getRoundedExtendedRectangle(derivation.demiwidth, derivation.rectangleCenterX, 14) DCNL DCSP outsidePath = euclidean.getVector3Path(roundedExtendedRectangle) DCNL DCSP extrude.addPositives(extrudeDerivation, [outsidePath], positives) DCNL DCSP for bearingCenterX in derivation.bearingCenterXs: DCNL DCSP  DCSP addNegativeSphere(derivation, negatives, bearingCenterX)\n", "intent": "add linear bearing cage .\n", "question_id": 987}, {"snippet": "def a2ensite(site): DCNL  DCSP ret = {} DCNL DCSP command = ['a2ensite', site] DCNL DCSP try: DCNL DCSP  DCSP status = __salt__['cmd.retcode'](command, python_shell=False) DCNL DCSP except Exception as e: DCNL DCSP  DCSP return e DCNL DCSP ret['Name'] = 'Apache2 DCSP Enable DCSP Site' DCNL DCSP ret['Site'] = site DCNL DCSP if (status == 1): DCNL DCSP  DCSP ret['Status'] = 'Site DCSP {0} DCSP Not DCSP found'.format(site) DCNL DCSP elif (status == 0): DCNL DCSP  DCSP ret['Status'] = 'Site DCSP {0} DCSP enabled'.format(site) DCNL DCSP else: DCNL DCSP  DCSP ret['Status'] = status DCNL DCSP return ret\n", "intent": "runs a2ensite for the given site .\n", "question_id": 988}, {"snippet": "def draw_if_interactive(): DCNL  DCSP figManager = Gcf.get_active() DCNL DCSP if (figManager is not None): DCNL DCSP  DCSP figManager.canvas.invalidate()\n", "intent": "for performance reasons .\n", "question_id": 989}, {"snippet": "def exact_files(directory, ignore_links=False): DCNL  DCSP found = [] DCNL DCSP for (root, _, files) in os.walk(directory, followlinks=(not ignore_links)): DCNL DCSP  DCSP for f in files: DCNL DCSP  DCSP  DCSP p = os.path.join(root, f) DCNL DCSP  DCSP  DCSP if (ignore_links and os.path.islink(p)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP found.append(os.path.relpath(p, directory)) DCNL DCSP return found\n", "intent": "returns the relative files contained in the directory .\n", "question_id": 990}, {"snippet": "@slow_test DCNL @testing.requires_testing_data DCNL def test_read_ctf(): DCNL  DCSP temp_dir = _TempDir() DCNL DCSP out_fname = op.join(temp_dir, 'test_py_raw.fif') DCNL DCSP os.mkdir(op.join(temp_dir, 'randpos')) DCNL DCSP ctf_eeg_fname = op.join(temp_dir, 'randpos', ctf_fname_catch) DCNL DCSP shutil.copytree(op.join(ctf_dir, ctf_fname_catch), ctf_eeg_fname) DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP raw = _test_raw_reader(read_raw_ctf, directory=ctf_eeg_fname) DCNL DCSP assert_true(all((('MISC DCSP channel' in str(ww.message)) for ww in w))) DCNL DCSP picks = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP pos = np.random.RandomState(42).randn(len(picks), 3) DCNL DCSP fake_eeg_fname = op.join(ctf_eeg_fname, 'catch-alp-good-f.eeg') DCNL DCSP with open(fake_eeg_fname, 'wb') as fid: DCNL DCSP  DCSP fid.write('foo\\n'.encode('ascii')) DCNL DCSP assert_raises(RuntimeError, read_raw_ctf, ctf_eeg_fname) DCNL DCSP with open(fake_eeg_fname, 'wb') as fid: DCNL DCSP  DCSP for (ii, ch_num) in enumerate(picks): DCNL DCSP  DCSP  DCSP args = ((str((ch_num + 1)), raw.ch_names[ch_num]) + tuple((('%0.5f' % x) for x in (100 * pos[ii])))) DCNL DCSP  DCSP  DCSP fid.write((' DCTB '.join(args) + '\\n').encode('ascii')) DCNL DCSP pos_read_old = np.array([raw.info['chs'][p]['loc'][:3] for p in picks]) DCNL DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP raw = read_raw_ctf(ctf_eeg_fname) DCNL DCSP assert_true(all((('MISC DCSP channel' in str(ww.message)) for ww in w))) DCNL DCSP pos_read = np.array([raw.info['chs'][p]['loc'][:3] for p in picks]) DCNL DCSP assert_allclose(apply_trans(raw.info['ctf_head_t'], pos), pos_read, rtol=1e-05, atol=1e-05) DCNL DCSP assert_true(((pos_read == pos_read_old).mean() < 0.1)) DCNL DCSP shutil.copy(op.join(ctf_dir, 'catch-alp-good-f.ds_randpos_raw.fif'), op.join(temp_dir, 'randpos', 'catch-alp-good-f.ds_raw.fif')) DCNL DCSP os.mkdir(op.join(temp_dir, 'nohc')) DCNL DCSP ctf_no_hc_fname = op.join(temp_dir, 'no_hc', ctf_fname_catch) DCNL DCSP shutil.copytree(ctf_eeg_fname, ctf_no_hc_fname) DCNL DCSP remove_base = op.join(ctf_no_hc_fname, op.basename(ctf_fname_catch[:(-3)])) DCNL DCSP os.remove((remove_base + '.hc')) DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP assert_raises(RuntimeError, read_raw_ctf, ctf_no_hc_fname) DCNL DCSP os.remove((remove_base + '.eeg')) DCNL DCSP shutil.copy(op.join(ctf_dir, 'catch-alp-good-f.ds_nohc_raw.fif'), op.join(temp_dir, 'no_hc', 'catch-alp-good-f.ds_raw.fif')) DCNL DCSP use_fnames = [op.join(ctf_dir, c) for c in ctf_fnames] DCNL DCSP for fname in use_fnames: DCNL DCSP  DCSP raw_c = read_raw_fif((fname + '_raw.fif'), preload=True) DCNL DCSP  DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP  DCSP raw = read_raw_ctf(fname) DCNL DCSP  DCSP assert_true(all((('MISC DCSP channel' in str(ww.message)) for ww in w))) DCNL DCSP  DCSP assert_array_equal(raw.ch_names, raw_c.ch_names) DCNL DCSP  DCSP assert_allclose(raw.times, raw_c.times) DCNL DCSP  DCSP assert_allclose(raw._cals, raw_c._cals) DCNL DCSP  DCSP for key in ('version', 'usecs'): DCNL DCSP  DCSP  DCSP assert_equal(raw.info['meas_id'][key], raw_c.info['meas_id'][key]) DCNL DCSP  DCSP py_time = raw.info['meas_id']['secs'] DCNL DCSP  DCSP c_time = raw_c.info['meas_id']['secs'] DCNL DCSP  DCSP max_offset = ((24 * 60) * 60) DCNL DCSP  DCSP assert_true(((c_time - max_offset) <= py_time <= c_time)) DCNL DCSP  DCSP for t in ('dev_head_t', 'dev_ctf_t', 'ctf_head_t'): DCNL DCSP  DCSP  DCSP assert_allclose(raw.info[t]['trans'], raw_c.info[t]['trans'], rtol=0.0001, atol=1e-07) DCNL DCSP  DCSP for key in ('acq_pars', 'acq_stim', 'bads', 'ch_names', 'custom_ref_applied', 'description', 'events', 'experimenter', 'highpass', 'line_freq', 'lowpass', 'nchan', 'proj_id', 'proj_name', 'projs', 'sfreq', 'subject_info'): DCNL DCSP  DCSP  DCSP assert_equal(raw.info[key], raw_c.info[key], key) DCNL DCSP  DCSP if (op.basename(fname) not in single_trials): DCNL DCSP  DCSP  DCSP assert_equal(raw.info['buffer_size_sec'], raw_c.info['buffer_size_sec']) DCNL DCSP  DCSP assert_equal(len(raw.info['comps']), len(raw_c.info['comps'])) DCNL DCSP  DCSP for (c1, c2) in zip(raw.info['comps'], raw_c.info['comps']): DCNL DCSP  DCSP  DCSP for key in ('colcals', 'rowcals'): DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(c1[key], c2[key]) DCNL DCSP  DCSP  DCSP assert_equal(c1['save_calibrated'], c2['save_calibrated']) DCNL DCSP  DCSP  DCSP for key in ('row_names', 'col_names', 'nrow', 'ncol'): DCNL DCSP  DCSP  DCSP  DCSP assert_array_equal(c1['data'][key], c2['data'][key]) DCNL DCSP  DCSP  DCSP assert_allclose(c1['data']['data'], c2['data']['data'], atol=1e-07, rtol=1e-05) DCNL DCSP  DCSP assert_allclose(raw.info['hpi_results'][0]['coord_trans']['trans'], raw_c.info['hpi_results'][0]['coord_trans']['trans'], rtol=1e-05, atol=1e-07) DCNL DCSP  DCSP assert_equal(len(raw.info['chs']), len(raw_c.info['chs'])) DCNL DCSP  DCSP for (ii, (c1, c2)) in enumerate(zip(raw.info['chs'], raw_c.info['chs'])): DCNL DCSP  DCSP  DCSP for key in ('kind', 'scanno', 'unit', 'ch_name', 'unit_mul', 'range', 'coord_frame', 'coil_type', 'logno'): DCNL DCSP  DCSP  DCSP  DCSP if ((c1['ch_name'] == 'RMSP') and ('catch-alp-good-f' in fname) and (key in ('kind', 'unit', 'coord_frame', 'coil_type', 'logno'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP assert_equal(c1[key], c2[key], err_msg=key) DCNL DCSP  DCSP  DCSP for key in ('cal',): DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(c1[key], c2[key], atol=1e-06, rtol=0.0001, err_msg=('raw.info[\"chs\"][%d][%s]' % (ii, key))) DCNL DCSP  DCSP  DCSP for key in ('loc',): DCNL DCSP  DCSP  DCSP  DCSP if ((c1['ch_name'] == 'RMSP') and ('catch-alp-good-f' in fname)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(c1[key][:3], c2[key][:3], atol=1e-06, rtol=0.0001, err_msg=('raw.info[\"chs\"][%d][%s]' % (ii, key))) DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(c1[key][9:12], c2[key][9:12], atol=1e-06, rtol=0.0001, err_msg=('raw.info[\"chs\"][%d][%s]' % (ii, key))) DCNL DCSP  DCSP if fname.endswith('catch-alp-good-f.ds'): DCNL DCSP  DCSP  DCSP raw.info['dig'] = raw.info['dig'][:(-10)] DCNL DCSP  DCSP assert_dig_allclose(raw.info, raw_c.info) DCNL DCSP  DCSP raw_c.save(out_fname, overwrite=True, buffer_size_sec=1.0) DCNL DCSP  DCSP raw_read = read_raw_fif(out_fname) DCNL DCSP  DCSP rng = np.random.RandomState(0) DCNL DCSP  DCSP pick_ch = rng.permutation(np.arange(len(raw.ch_names)))[:10] DCNL DCSP  DCSP bnd = int(round((raw.info['sfreq'] * raw.info['buffer_size_sec']))) DCNL DCSP  DCSP assert_equal(bnd, raw._raw_extras[0]['block_size']) DCNL DCSP  DCSP assert_equal(bnd, block_sizes[op.basename(fname)]) DCNL DCSP  DCSP slices = (slice(0, bnd), slice((bnd - 1), bnd), slice(3, bnd), slice(3, 300), slice(None)) DCNL DCSP  DCSP if (len(raw.times) >= (2 * bnd)): DCNL DCSP  DCSP  DCSP slices = (slices + (slice(bnd, (2 * bnd)), slice(bnd, (bnd + 1)), slice(0, (bnd + 100)))) DCNL DCSP  DCSP for sl_time in slices: DCNL DCSP  DCSP  DCSP assert_allclose(raw[(pick_ch, sl_time)][0], raw_c[(pick_ch, sl_time)][0]) DCNL DCSP  DCSP  DCSP assert_allclose(raw_read[(pick_ch, sl_time)][0], raw_c[(pick_ch, sl_time)][0]) DCNL DCSP  DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP  DCSP raw = read_raw_ctf(fname, preload=True) DCNL DCSP  DCSP assert_true(all((('MISC DCSP channel' in str(ww.message)) for ww in w))) DCNL DCSP  DCSP assert_allclose(raw[:][0], raw_c[:][0]) DCNL DCSP raw.plot(show=False) DCNL DCSP assert_raises(ValueError, raw.plot, order='selection') DCNL DCSP assert_raises(TypeError, read_raw_ctf, 1) DCNL DCSP assert_raises(ValueError, read_raw_ctf, (ctf_fname_continuous + 'foo.ds')) DCNL DCSP read_raw_ctf(op.join(ctf_dir, ctf_fname_continuous), 'ignore') DCNL DCSP assert_raises(ValueError, read_raw_ctf, op.join(ctf_dir, ctf_fname_continuous), 'foo')\n", "intent": "test ctf reader .\n", "question_id": 991}, {"snippet": "def list_tags(): DCNL  DCSP ret = set() DCNL DCSP for item in six.itervalues(images()): DCNL DCSP  DCSP if (not item.get('RepoTags')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.update(set(item['RepoTags'])) DCNL DCSP return sorted(ret)\n", "intent": "returns a list of tagged images cli example: .\n", "question_id": 992}, {"snippet": "def is_iterable(obj): DCNL  DCSP return (hasattr(obj, u'__iter__') and (not isinstance(obj, str)))\n", "intent": "are we being asked to look up a list of things .\n", "question_id": 993}, {"snippet": "def use(style): DCNL  DCSP if (cbook.is_string_like(style) or hasattr(style, u'keys')): DCNL DCSP  DCSP styles = [style] DCNL DCSP else: DCNL DCSP  DCSP styles = style DCNL DCSP for style in styles: DCNL DCSP  DCSP if (not cbook.is_string_like(style)): DCNL DCSP  DCSP  DCSP _apply_style(style) DCNL DCSP  DCSP elif (style == u'default'): DCNL DCSP  DCSP  DCSP _apply_style(rcParamsDefault, warn=False) DCNL DCSP  DCSP elif (style in library): DCNL DCSP  DCSP  DCSP _apply_style(library[style]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rc = rc_params_from_file(style, use_default_template=False) DCNL DCSP  DCSP  DCSP  DCSP _apply_style(rc) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP msg = u\"'%s' DCSP not DCSP found DCSP in DCSP the DCSP style DCSP library DCSP and DCSP input DCSP is DCSP not DCSP a DCSP valid DCSP URL DCSP or DCSP path. DCSP See DCSP `style.available` DCSP for DCSP list DCSP of DCSP available DCSP styles.\" DCNL DCSP  DCSP  DCSP  DCSP raise IOError((msg % style))\n", "intent": "use matplotlib style settings from a style specification .\n", "question_id": 994}, {"snippet": "def distfitmc(sample, distr, nrepl=100, distkwds={}): DCNL  DCSP arg = distkwds.pop('arg') DCNL DCSP nobs = len(sample) DCNL DCSP res = np.zeros(nrepl) DCNL DCSP for ii in range(nrepl): DCNL DCSP  DCSP x = distr.rvs(arg, size=nobs, **distkwds) DCNL DCSP  DCSP res[ii] = distr.fit_fr(x, frozen=[np.nan, 0.0, 1.0]) DCNL DCSP return res\n", "intent": "run monte carlo for estimation of distribution parameters hard coded: only one shape parameter is allowed and estimated .\n", "question_id": 995}, {"snippet": "def reset(cwd, opts='', user=None, password=None, ignore_retcode=False): DCNL  DCSP cwd = _expand_path(cwd, user) DCNL DCSP command = ['git', 'reset'] DCNL DCSP command.extend(_format_opts(opts)) DCNL DCSP return _git_run(command, cwd=cwd, user=user, password=password, ignore_retcode=ignore_retcode)['stdout']\n", "intent": "interface to git-reset(1)_ .\n", "question_id": 996}, {"snippet": "def execute(*cmd, **kwargs): DCNL  DCSP if (('run_as_root' in kwargs) and ('root_helper' not in kwargs)): DCNL DCSP  DCSP kwargs['root_helper'] = _get_root_helper() DCNL DCSP return processutils.execute(*cmd, **kwargs)\n", "intent": "convenience wrapper around oslos execute() method .\n", "question_id": 997}, {"snippet": "def main(argv): DCNL  DCSP global DRY_RUN DCNL DCSP parser = optparse.OptionParser() DCNL DCSP parser.add_option('-c', '--db-clean-tests', dest='clean_tests', action='store_true', default=False, help='Clean DCSP client DCSP and DCSP server DCSP tests DCSP with DCSP invalid DCSP control DCSP files') DCNL DCSP parser.add_option('-C', '--db-clear-all-tests', dest='clear_all_tests', action='store_true', default=False, help='Clear DCSP ALL DCSP client DCSP and DCSP server DCSP tests') DCNL DCSP parser.add_option('-d', '--dry-run', dest='dry_run', action='store_true', default=False, help='Dry DCSP run DCSP for DCSP operation') DCNL DCSP parser.add_option('-A', '--add-all', dest='add_all', action='store_true', default=False, help='Add DCSP site_tests, DCSP tests, DCSP and DCSP test_suites') DCNL DCSP parser.add_option('-S', '--add-samples', dest='add_samples', action='store_true', default=False, help='Add DCSP samples.') DCNL DCSP parser.add_option('-E', '--add-experimental', dest='add_experimental', action='store_true', default=True, help='Add DCSP experimental DCSP tests DCSP to DCSP frontend') DCNL DCSP parser.add_option('-N', '--add-noncompliant', dest='add_noncompliant', action='store_true', default=False, help='Add DCSP non-compliant DCSP tests DCSP (i.e. DCSP tests DCSP that DCSP do DCSP not DCSP define DCSP all DCSP required DCSP control DCSP variables)') DCNL DCSP parser.add_option('-p', '--profile-dir', dest='profile_dir', help='Directory DCSP to DCSP recursively DCSP check DCSP for DCSP profiles') DCNL DCSP parser.add_option('-t', '--tests-dir', dest='tests_dir', help='Directory DCSP to DCSP recursively DCSP check DCSP for DCSP control.*') DCNL DCSP parser.add_option('-r', '--control-pattern', dest='control_pattern', default='^control.*', help='The DCSP pattern DCSP to DCSP look DCSP for DCSP in DCSP directories DCSP for DCSP control DCSP files') DCNL DCSP parser.add_option('-v', '--verbose', dest='verbose', action='store_true', default=False, help='Run DCSP in DCSP verbose DCSP mode') DCNL DCSP parser.add_option('-w', '--whitelist-file', dest='whitelist_file', help='Filename DCSP for DCSP list DCSP of DCSP test DCSP names DCSP that DCSP must DCSP match') DCNL DCSP parser.add_option('-z', '--autotest-dir', dest='autotest_dir', default=os.path.join(os.path.dirname(__file__), '..'), help='Autotest DCSP directory DCSP root, DCSP or DCSP base DCSP test DCSP directory') DCNL DCSP (options, args) = parser.parse_args() DCNL DCSP logging_manager.configure_logging(TestImporterLoggingConfig(), verbose=options.verbose) DCNL DCSP DRY_RUN = options.dry_run DCNL DCSP if DRY_RUN: DCNL DCSP  DCSP logging.getLogger().setLevel(logging.WARN) DCNL DCSP options.autotest_dir = os.path.abspath(options.autotest_dir) DCNL DCSP if (len(args) > 0): DCNL DCSP  DCSP logging.error('Invalid DCSP option(s) DCSP provided: DCSP %s', args) DCNL DCSP  DCSP parser.print_help() DCNL DCSP  DCSP return 1 DCNL DCSP if options.verbose: DCNL DCSP  DCSP logging.getLogger().setLevel(logging.DEBUG) DCNL DCSP if ((len(argv) == 1) or ((len(argv) == 2) and options.verbose)): DCNL DCSP  DCSP update_all(options.autotest_dir, options.add_noncompliant, options.add_experimental) DCNL DCSP  DCSP db_clean_broken(options.autotest_dir) DCNL DCSP  DCSP return 0 DCNL DCSP if options.clear_all_tests: DCNL DCSP  DCSP if (options.clean_tests or options.add_all or options.add_samples or options.add_noncompliant): DCNL DCSP  DCSP  DCSP logging.error('Can DCSP only DCSP pass DCSP --autotest-dir, DCSP --dry-run DCSP and DCSP --verbose DCSP with DCSP --db-clear-all-tests') DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP db_clean_all(options.autotest_dir) DCNL DCSP whitelist_set = None DCNL DCSP if options.whitelist_file: DCNL DCSP  DCSP if options.add_all: DCNL DCSP  DCSP  DCSP logging.error('Cannot DCSP pass DCSP both DCSP --add-all DCSP and DCSP --whitelist-file') DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP whitelist_path = os.path.abspath(options.whitelist_file) DCNL DCSP  DCSP if (not os.path.isfile(whitelist_path)): DCNL DCSP  DCSP  DCSP logging.error('--whitelist-file DCSP (%s) DCSP not DCSP found', whitelist_path) DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP logging.info('Using DCSP whitelist DCSP file DCSP %s', whitelist_path) DCNL DCSP  DCSP whitelist_set = _create_whitelist_set(whitelist_path) DCNL DCSP  DCSP update_from_whitelist(whitelist_set, add_experimental=options.add_experimental, add_noncompliant=options.add_noncompliant, autotest_dir=options.autotest_dir) DCNL DCSP if options.add_all: DCNL DCSP  DCSP update_all(options.autotest_dir, options.add_noncompliant, options.add_experimental) DCNL DCSP if options.add_samples: DCNL DCSP  DCSP update_samples(options.autotest_dir, options.add_noncompliant, options.add_experimental) DCNL DCSP if options.tests_dir: DCNL DCSP  DCSP options.tests_dir = os.path.abspath(options.tests_dir) DCNL DCSP  DCSP tests = get_tests_from_fs(options.tests_dir, options.control_pattern, add_noncompliant=options.add_noncompliant) DCNL DCSP  DCSP update_tests_in_db(tests, add_experimental=options.add_experimental, add_noncompliant=options.add_noncompliant, autotest_dir=options.autotest_dir) DCNL DCSP if options.profile_dir: DCNL DCSP  DCSP profilers = get_tests_from_fs(options.profile_dir, '.*py$') DCNL DCSP  DCSP update_profilers_in_db(profilers, add_noncompliant=options.add_noncompliant, description='NA') DCNL DCSP if options.clean_tests: DCNL DCSP  DCSP db_clean_broken(options.autotest_dir)\n", "intent": "main function .\n", "question_id": 998}, {"snippet": "def data_url(path): DCNL  DCSP data = utils.read_file(path, binary=True) DCNL DCSP filename = utils.resource_filename(path) DCNL DCSP mimetype = mimetypes.guess_type(filename) DCNL DCSP assert (mimetype is not None), path DCNL DCSP return urlutils.data_url(mimetype[0], data).toString()\n", "intent": "get a data: url for the broken qutebrowser logo .\n", "question_id": 999}, {"snippet": "@require_admin_context DCNL def volume_attached(context, attachment_id, instance_uuid, host_name, mountpoint, attach_mode='rw'): DCNL  DCSP if (instance_uuid and (not uuidutils.is_uuid_like(instance_uuid))): DCNL DCSP  DCSP raise exception.InvalidUUID(uuid=instance_uuid) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP volume_attachment_ref = _attachment_get(context, attachment_id, session=session) DCNL DCSP  DCSP updated_values = {'mountpoint': mountpoint, 'attach_status': fields.VolumeAttachStatus.ATTACHED, 'instance_uuid': instance_uuid, 'attached_host': host_name, 'attach_time': timeutils.utcnow(), 'attach_mode': attach_mode, 'updated_at': literal_column('updated_at')} DCNL DCSP  DCSP volume_attachment_ref.update(updated_values) DCNL DCSP  DCSP volume_attachment_ref.save(session=session) DCNL DCSP  DCSP del updated_values['updated_at'] DCNL DCSP  DCSP volume_ref = _volume_get(context, volume_attachment_ref['volume_id'], session=session) DCNL DCSP  DCSP volume_ref['status'] = 'in-use' DCNL DCSP  DCSP volume_ref['attach_status'] = fields.VolumeAttachStatus.ATTACHED DCNL DCSP  DCSP volume_ref.save(session=session) DCNL DCSP  DCSP return (volume_ref, updated_values)\n", "intent": "this method updates a volume attachment entry .\n", "question_id": 1000}, {"snippet": "@task DCNL def clean(): DCNL  DCSP d = ['build', 'dist', 'scipy.egg-info'] DCNL DCSP for i in d: DCNL DCSP  DCSP if os.path.exists(i): DCNL DCSP  DCSP  DCSP shutil.rmtree(i) DCNL DCSP bdir = os.path.join('doc', options.sphinx.builddir) DCNL DCSP if os.path.exists(bdir): DCNL DCSP  DCSP shutil.rmtree(bdir)\n", "intent": "remove build .\n", "question_id": 1001}, {"snippet": "def test_url_completion_delete_bookmark(qtmodeltester, config_stub, web_history, quickmarks, bookmarks, qtbot): DCNL  DCSP config_stub.data['completion'] = {'timestamp-format': '%Y-%m-%d', 'web-history-max-items': 2} DCNL DCSP model = urlmodel.UrlCompletionModel() DCNL DCSP qtmodeltester.data_display_may_return_none = True DCNL DCSP qtmodeltester.check(model) DCNL DCSP view = _mock_view_index(model, 1, 0, qtbot) DCNL DCSP model.delete_cur_item(view) DCNL DCSP assert ('https://github.com' not in bookmarks.marks) DCNL DCSP assert ('https://python.org' in bookmarks.marks) DCNL DCSP assert ('http://qutebrowser.org' in bookmarks.marks)\n", "intent": "test deleting a bookmark from the url completion model .\n", "question_id": 1002}, {"snippet": "def __virtual__(): DCNL  DCSP if ('influxdb.db_exists' in __salt__): DCNL DCSP  DCSP return 'influxdb_retention_policy' DCNL DCSP return False\n", "intent": "only load if the influxdb module is available .\n", "question_id": 1003}, {"snippet": "def format_national_number_with_carrier_code(numobj, carrier_code): DCNL  DCSP country_code = numobj.country_code DCNL DCSP nsn = national_significant_number(numobj) DCNL DCSP if (not _has_valid_country_calling_code(country_code)): DCNL DCSP  DCSP return nsn DCNL DCSP region_code = region_code_for_country_code(country_code) DCNL DCSP metadata = PhoneMetadata.metadata_for_region_or_calling_code(country_code, region_code) DCNL DCSP formatted_number = _format_nsn(nsn, metadata, PhoneNumberFormat.NATIONAL, carrier_code) DCNL DCSP formatted_number = _maybe_append_formatted_extension(numobj, metadata, PhoneNumberFormat.NATIONAL, formatted_number) DCNL DCSP formatted_number = _prefix_number_with_country_calling_code(country_code, PhoneNumberFormat.NATIONAL, formatted_number) DCNL DCSP return formatted_number\n", "intent": "format a number in national format for dialing using the specified carrier .\n", "question_id": 1004}, {"snippet": "def present(name, zone, ttl, data, rdtype='A', **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = '{0} DCSP record DCSP \"{1}\" DCSP will DCSP be DCSP updated'.format(rdtype, name) DCNL DCSP  DCSP return ret DCNL DCSP status = __salt__['ddns.update'](zone, name, ttl, rdtype, data, **kwargs) DCNL DCSP if (status is None): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = '{0} DCSP record DCSP \"{1}\" DCSP already DCSP present DCSP with DCSP ttl DCSP of DCSP {2}'.format(rdtype, name, ttl) DCNL DCSP elif status: DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Updated DCSP {0} DCSP record DCSP for DCSP \"{1}\"'.format(rdtype, name) DCNL DCSP  DCSP ret['changes'] = {'name': name, 'zone': zone, 'ttl': ttl, 'rdtype': rdtype, 'data': data} DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP create DCSP or DCSP update DCSP {0} DCSP record DCSP for DCSP \"{1}\"'.format(rdtype, name) DCNL DCSP return ret\n", "intent": "ensures that the named dns record is present with the given ttl .\n", "question_id": 1005}, {"snippet": "def _generate_image_and_label_batch(image, label, min_queue_examples, batch_size, shuffle): DCNL  DCSP num_preprocess_threads = 16 DCNL DCSP if shuffle: DCNL DCSP  DCSP (images, label_batch) = tf.train.shuffle_batch([image, label], batch_size=batch_size, num_threads=num_preprocess_threads, capacity=(min_queue_examples + (3 * batch_size)), min_after_dequeue=min_queue_examples) DCNL DCSP else: DCNL DCSP  DCSP (images, label_batch) = tf.train.batch([image, label], batch_size=batch_size, num_threads=num_preprocess_threads, capacity=(min_queue_examples + (3 * batch_size))) DCNL DCSP tf.image_summary('images', images) DCNL DCSP return (images, tf.reshape(label_batch, [batch_size]))\n", "intent": "construct a queued batch of images and labels .\n", "question_id": 1006}, {"snippet": "def get_required_content(course, user): DCNL  DCSP required_content = [] DCNL DCSP if settings.FEATURES.get('MILESTONES_APP'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP milestone_paths = get_course_milestones_fulfillment_paths(unicode(course.id), serialize_user(user)) DCNL DCSP  DCSP except InvalidMilestoneRelationshipTypeException: DCNL DCSP  DCSP  DCSP return required_content DCNL DCSP  DCSP for path_key in milestone_paths: DCNL DCSP  DCSP  DCSP milestone_path = milestone_paths[path_key] DCNL DCSP  DCSP  DCSP if (milestone_path.get('content') and len(milestone_path['content'])): DCNL DCSP  DCSP  DCSP  DCSP for content in milestone_path['content']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP required_content.append(content) DCNL DCSP return required_content\n", "intent": "queries milestones subsystem to see if the specified course is gated on one or more milestones .\n", "question_id": 1007}, {"snippet": "def GetPackageModuleName(fileName): DCNL  DCSP (path, fname) = os.path.split(fileName) DCNL DCSP path = origPath = win32ui.FullPath(path) DCNL DCSP fname = os.path.splitext(fname)[0] DCNL DCSP modBits = [] DCNL DCSP newPathReturn = None DCNL DCSP if (not IsOnPythonPath(path)): DCNL DCSP  DCSP while (len(path) > 3): DCNL DCSP  DCSP  DCSP (path, modBit) = os.path.split(path) DCNL DCSP  DCSP  DCSP modBits.append(modBit) DCNL DCSP  DCSP  DCSP if (IsOnPythonPath(path) and (modBit in sys.modules) and (os.path.exists(os.path.join(path, '__init__.py')) or os.path.exists(os.path.join(path, '__init__.pyc')) or os.path.exists(os.path.join(path, '__init__.pyo')))): DCNL DCSP  DCSP  DCSP  DCSP modBits.reverse() DCNL DCSP  DCSP  DCSP  DCSP return ((('.'.join(modBits) + '.') + fname), newPathReturn) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP newPathReturn = origPath DCNL DCSP return (fname, newPathReturn)\n", "intent": "given a filename .\n", "question_id": 1008}, {"snippet": "def test_install_with_hacked_egg_info(script, data): DCNL  DCSP run_from = data.packages.join('HackedEggInfo') DCNL DCSP result = script.pip('install', '.', cwd=run_from) DCNL DCSP assert ('Successfully DCSP installed DCSP hackedegginfo-0.0.0\\n' in result.stdout)\n", "intent": "test installing a package which defines its own egg_info class .\n", "question_id": 1009}, {"snippet": "def _api_queue_change_complete_action(output, value, kwargs): DCNL  DCSP sabnzbd.change_queue_complete_action(value) DCNL DCSP return report(output)\n", "intent": "api: accepts output .\n", "question_id": 1010}, {"snippet": "def linear_sum_assignment(cost_matrix): DCNL  DCSP cost_matrix = np.asarray(cost_matrix) DCNL DCSP if (len(cost_matrix.shape) != 2): DCNL DCSP  DCSP raise ValueError(('expected DCSP a DCSP matrix DCSP (2-d DCSP array), DCSP got DCSP a DCSP %r DCSP array' % (cost_matrix.shape,))) DCNL DCSP if (cost_matrix.shape[1] < cost_matrix.shape[0]): DCNL DCSP  DCSP cost_matrix = cost_matrix.T DCNL DCSP  DCSP transposed = True DCNL DCSP else: DCNL DCSP  DCSP transposed = False DCNL DCSP state = _Hungary(cost_matrix) DCNL DCSP step = (None if (0 in cost_matrix.shape) else _step1) DCNL DCSP while (step is not None): DCNL DCSP  DCSP step = step(state) DCNL DCSP if transposed: DCNL DCSP  DCSP marked = state.marked.T DCNL DCSP else: DCNL DCSP  DCSP marked = state.marked DCNL DCSP return np.where((marked == 1))\n", "intent": "solve the linear sum assignment problem .\n", "question_id": 1011}, {"snippet": "def create_user(uid, name, password, channel=14, callback=False, link_auth=True, ipmi_msg=True, privilege_level='administrator', **kwargs): DCNL  DCSP with _IpmiCommand(**kwargs) as c: DCNL DCSP  DCSP return c.create_user(uid, name, password, channel, callback, link_auth, ipmi_msg, privilege_level)\n", "intent": "create/ensure a user is created with provided settings .\n", "question_id": 1012}, {"snippet": "@utils.arg('--host', dest='host', metavar='<host>', help=_('Fetch DCSP migrations DCSP for DCSP the DCSP given DCSP host.')) DCNL @utils.arg('--status', dest='status', metavar='<status>', help=_('Fetch DCSP migrations DCSP for DCSP the DCSP given DCSP status.')) DCNL @utils.arg('--cell_name', dest='cell_name', metavar='<cell_name>', help=_('Fetch DCSP migrations DCSP for DCSP the DCSP given DCSP cell_name.')) DCNL def do_migration_list(cs, args): DCNL  DCSP migrations = cs.migrations.list(args.host, args.status, args.cell_name) DCNL DCSP _print_migrations(cs, migrations)\n", "intent": "print a list of migrations .\n", "question_id": 1013}, {"snippet": "def get_custom_sql(app): DCNL  DCSP from django.db.models import get_models DCNL DCSP output = [] DCNL DCSP app_models = get_models(app) DCNL DCSP app_dir = os.path.normpath(os.path.join(os.path.dirname(app.__file__), 'sql')) DCNL DCSP for model in app_models: DCNL DCSP  DCSP output.extend(get_custom_sql_for_model(model)) DCNL DCSP return output\n", "intent": "returns a list of the custom table modifying sql statements for the given app .\n", "question_id": 1014}, {"snippet": "def get_locale_path(lang_code=None): DCNL  DCSP if (not lang_code): DCNL DCSP  DCSP return settings.USER_WRITABLE_LOCALE_DIR DCNL DCSP else: DCNL DCSP  DCSP return os.path.join(settings.USER_WRITABLE_LOCALE_DIR, lcode_to_django_dir(lang_code))\n", "intent": "returns the location of the given language code .\n", "question_id": 1015}, {"snippet": "def setButtonFontWeightString(button, isBold): DCNL  DCSP try: DCNL DCSP  DCSP weightString = 'normal' DCNL DCSP  DCSP if isBold: DCNL DCSP  DCSP  DCSP weightString = 'bold' DCNL DCSP  DCSP splitFont = button['font'].split() DCNL DCSP  DCSP button['font'] = (splitFont[0], splitFont[1], weightString) DCNL DCSP except: DCNL DCSP  DCSP pass\n", "intent": "set button font weight given isbold .\n", "question_id": 1016}, {"snippet": "def FastqSolexaIterator(handle, alphabet=single_letter_alphabet, title2ids=None): DCNL  DCSP q_mapping = dict() DCNL DCSP for letter in range(0, 255): DCNL DCSP  DCSP q_mapping[chr(letter)] = (letter - SOLEXA_SCORE_OFFSET) DCNL DCSP for (title_line, seq_string, quality_string) in FastqGeneralIterator(handle): DCNL DCSP  DCSP if title2ids: DCNL DCSP  DCSP  DCSP (id, name, descr) = title_line DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP descr = title_line DCNL DCSP  DCSP  DCSP id = descr.split()[0] DCNL DCSP  DCSP  DCSP name = id DCNL DCSP  DCSP record = SeqRecord(Seq(seq_string, alphabet), id=id, name=name, description=descr) DCNL DCSP  DCSP qualities = [q_mapping[letter] for letter in quality_string] DCNL DCSP  DCSP if (qualities and ((min(qualities) < (-5)) or (max(qualities) > 62))): DCNL DCSP  DCSP  DCSP raise ValueError('Invalid DCSP character DCSP in DCSP quality DCSP string') DCNL DCSP  DCSP dict.__setitem__(record._per_letter_annotations, 'solexa_quality', qualities) DCNL DCSP  DCSP (yield record)\n", "intent": "parsing old solexa/illumina fastq like files .\n", "question_id": 1017}, {"snippet": "def timing_stats(**dec_kwargs): DCNL  DCSP def decorating_func(func): DCNL DCSP  DCSP method = func.__name__ DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _timing_stats(ctrl, *args, **kwargs): DCNL DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP resp = func(ctrl, *args, **kwargs) DCNL DCSP  DCSP  DCSP if server_handled_successfully(resp.status_int): DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((method + '.timing'), start_time, **dec_kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((method + '.errors.timing'), start_time, **dec_kwargs) DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP return _timing_stats DCNL DCSP return decorating_func\n", "intent": "returns a decorator that logs timing events or errors for public methods in swifts wsgi server controllers .\n", "question_id": 1018}, {"snippet": "def _sph_to_cart(sph): DCNL  DCSP assert ((sph.ndim == 2) and (sph.shape[1] == 3)) DCNL DCSP sph = np.atleast_2d(sph) DCNL DCSP out = np.empty((len(sph), 3)) DCNL DCSP out[:, 2] = (sph[:, 0] * np.cos(sph[:, 2])) DCNL DCSP xy = (sph[:, 0] * np.sin(sph[:, 2])) DCNL DCSP out[:, 0] = (xy * np.cos(sph[:, 1])) DCNL DCSP out[:, 1] = (xy * np.sin(sph[:, 1])) DCNL DCSP return out\n", "intent": "convert spherical coordinates to cartesion coordinates .\n", "question_id": 1019}, {"snippet": "@register.filter DCNL def is_parent_of(page1, page2): DCNL  DCSP try: DCNL DCSP  DCSP return page1.is_ancestor_of(page2) DCNL DCSP except (AttributeError, ValueError): DCNL DCSP  DCSP return False\n", "intent": "determines whether a given page is the parent of another page example:: {% if page|is_parent_of:feincms_page %} .\n", "question_id": 1020}, {"snippet": "def test_multiset_partitions_versions(): DCNL  DCSP multiplicities = [5, 2, 2, 1] DCNL DCSP m = MultisetPartitionTraverser() DCNL DCSP for (s1, s2) in zip_longest(m.enum_all(multiplicities), multiset_partitions_taocp(multiplicities)): DCNL DCSP  DCSP assert compare_multiset_states(s1, s2)\n", "intent": "compares knuth-based versions of multiset_partitions .\n", "question_id": 1021}, {"snippet": "def _safeFormat(fmtString, fmtDict): DCNL  DCSP try: DCNL DCSP  DCSP text = (fmtString % fmtDict) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = ('Invalid DCSP format DCSP string DCSP or DCSP unformattable DCSP object DCSP in DCSP log DCSP message: DCSP %r, DCSP %s' % (fmtString, fmtDict)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = ('UNFORMATTABLE DCSP OBJECT DCSP WRITTEN DCSP TO DCSP LOG DCSP with DCSP fmt DCSP %r, DCSP MESSAGE DCSP LOST' % (fmtString,)) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP text = 'PATHOLOGICAL DCSP ERROR DCSP IN DCSP BOTH DCSP FORMAT DCSP STRING DCSP AND DCSP MESSAGE DCSP DETAILS, DCSP MESSAGE DCSP LOST' DCNL DCSP if _PY3: DCNL DCSP  DCSP if isinstance(text, bytes): DCNL DCSP  DCSP  DCSP text = text.decode('utf-8') DCNL DCSP elif isinstance(text, unicode): DCNL DCSP  DCSP text = text.encode('utf-8') DCNL DCSP return text\n", "intent": "try to format a string .\n", "question_id": 1022}, {"snippet": "def encode(body, binary=False, maxlinelen=76, eol=NL): DCNL  DCSP if (not body): DCNL DCSP  DCSP return body DCNL DCSP if (not binary): DCNL DCSP  DCSP body = fix_eols(body) DCNL DCSP encoded_body = '' DCNL DCSP lineno = (-1) DCNL DCSP lines = body.splitlines(1) DCNL DCSP for line in lines: DCNL DCSP  DCSP if line.endswith(CRLF): DCNL DCSP  DCSP  DCSP line = line[:(-2)] DCNL DCSP  DCSP elif (line[(-1)] in CRLF): DCNL DCSP  DCSP  DCSP line = line[:(-1)] DCNL DCSP  DCSP lineno += 1 DCNL DCSP  DCSP encoded_line = '' DCNL DCSP  DCSP prev = None DCNL DCSP  DCSP linelen = len(line) DCNL DCSP  DCSP for j in range(linelen): DCNL DCSP  DCSP  DCSP c = line[j] DCNL DCSP  DCSP  DCSP prev = c DCNL DCSP  DCSP  DCSP if bqre.match(c): DCNL DCSP  DCSP  DCSP  DCSP c = quote(c) DCNL DCSP  DCSP  DCSP elif ((j + 1) == linelen): DCNL DCSP  DCSP  DCSP  DCSP if (c not in ' DCSP  DCTB '): DCNL DCSP  DCSP  DCSP  DCSP  DCSP encoded_line += c DCNL DCSP  DCSP  DCSP  DCSP prev = c DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ((len(encoded_line) + len(c)) >= maxlinelen): DCNL DCSP  DCSP  DCSP  DCSP encoded_body += ((encoded_line + '=') + eol) DCNL DCSP  DCSP  DCSP  DCSP encoded_line = '' DCNL DCSP  DCSP  DCSP encoded_line += c DCNL DCSP  DCSP if (prev and (prev in ' DCSP  DCTB ')): DCNL DCSP  DCSP  DCSP if ((lineno + 1) == len(lines)): DCNL DCSP  DCSP  DCSP  DCSP prev = quote(prev) DCNL DCSP  DCSP  DCSP  DCSP if ((len(encoded_line) + len(prev)) > maxlinelen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP encoded_body += (((encoded_line + '=') + eol) + prev) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP encoded_body += (encoded_line + prev) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP encoded_body += (((encoded_line + prev) + '=') + eol) DCNL DCSP  DCSP  DCSP encoded_line = '' DCNL DCSP  DCSP if (lines[lineno].endswith(CRLF) or (lines[lineno][(-1)] in CRLF)): DCNL DCSP  DCSP  DCSP encoded_body += (encoded_line + eol) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP encoded_body += encoded_line DCNL DCSP  DCSP encoded_line = '' DCNL DCSP return encoded_body\n", "intent": "encode with quoted-printable .\n", "question_id": 1023}, {"snippet": "def maximals(A, le=(lambda x, y: (x <= y))): DCNL  DCSP r = [] DCNL DCSP for x in A: DCNL DCSP  DCSP for a in A: DCNL DCSP  DCSP  DCSP if (le(x, a) and (not le(a, x))): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for a in r: DCNL DCSP  DCSP  DCSP  DCSP if le(x, a): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP r.append(x) DCNL DCSP return r\n", "intent": "find the maximal element(s) of a partially ordered sequence .\n", "question_id": 1024}, {"snippet": "@nottest DCNL def get_run_tests(): DCNL  DCSP test_suite = None DCNL DCSP msg_fmt = 'Reading DCSP %s DCSP run DCSP tests DCSP from: DCSP \"%s\"' DCNL DCSP for fname in os.listdir(ARTIFACT_DIR): DCNL DCSP  DCSP if (fname.startswith(NOSE_OUTPUT_PREFIX) and fname.endswith(NOSE_XUNIT_EXT)): DCNL DCSP  DCSP  DCSP path_fname = os.path.join(ARTIFACT_DIR, fname) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (curr_test_suite, test_result) = parse_xunit(path_fname) DCNL DCSP  DCSP  DCSP except ElementTree.ParseError: DCNL DCSP  DCSP  DCSP  DCSP logging.warning(('\"%s\" DCSP is DCSP an DCSP invalid DCSP XML DCSP file.' % fname)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP logging.debug((msg_fmt % (test_result.testsRun, fname))) DCNL DCSP  DCSP  DCSP if (test_suite is None): DCNL DCSP  DCSP  DCSP  DCSP test_suite = curr_test_suite DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for test in curr_test_suite: DCNL DCSP  DCSP  DCSP  DCSP  DCSP test_suite.addTest(test) DCNL DCSP normalize_test_names(test_suite) DCNL DCSP run_str = '\\n'.join(sorted([t.id() for t in test_suite._tests])) DCNL DCSP logging.debug(('Run DCSP %s DCSP tests.' % len(test_suite._tests))) DCNL DCSP logging.debug(('The DCSP following DCSP tests DCSP were DCSP run:\\n%s' % run_str)) DCNL DCSP return test_suite\n", "intent": "merge all the information from the command outputs into one consolidated test suite which contains all tests which were run .\n", "question_id": 1025}, {"snippet": "def interactive(*args, **kw): DCNL  DCSP (status, headers, content, errors) = raw_interactive(*args, **kw) DCNL DCSP full = StringIO() DCNL DCSP if errors: DCNL DCSP  DCSP full.write('Errors:\\n') DCNL DCSP  DCSP full.write(errors.strip()) DCNL DCSP  DCSP full.write('\\n----------end DCSP errors\\n') DCNL DCSP full.write((status + '\\n')) DCNL DCSP for (name, value) in headers: DCNL DCSP  DCSP full.write(('%s: DCSP %s\\n' % (name, value))) DCNL DCSP full.write('\\n') DCNL DCSP full.write(content) DCNL DCSP return full.getvalue()\n", "intent": "runs the application interatively .\n", "question_id": 1026}, {"snippet": "def fake_open(filename, flags, mode=511, _os_open=os.open): DCNL  DCSP if (flags & ((os.O_RDWR | os.O_CREAT) | os.O_WRONLY)): DCNL DCSP  DCSP raise OSError(errno.EROFS, 'Read-only DCSP file DCSP system', filename) DCNL DCSP elif (not FakeFile.is_file_accessible(filename)): DCNL DCSP  DCSP raise OSError(errno.ENOENT, 'No DCSP such DCSP file DCSP or DCSP directory', filename) DCNL DCSP return _os_open(filename, flags, mode)\n", "intent": "fake version of os .\n", "question_id": 1027}, {"snippet": "def _get_flat_core_sizes(cores): DCNL  DCSP core_sizes_lists = [] DCNL DCSP for core in cores: DCNL DCSP  DCSP flat_output_size = nest.flatten(core.output_size) DCNL DCSP  DCSP core_sizes_lists.append([tensor_shape.as_shape(size).as_list() for size in flat_output_size]) DCNL DCSP return core_sizes_lists\n", "intent": "obtains the list flattened output sizes of a list of cores .\n", "question_id": 1028}, {"snippet": "def train(): DCNL  DCSP with tf.Graph().as_default(): DCNL DCSP  DCSP with tf.device('/cpu:0'): DCNL DCSP  DCSP  DCSP global_step = tf.get_variable('global_step', [], initializer=tf.constant_initializer(0), trainable=False) DCNL DCSP  DCSP  DCSP num_batches_per_epoch = (cifar10.NUM_EXAMPLES_PER_EPOCH_FOR_TRAIN / FLAGS.batch_size) DCNL DCSP  DCSP  DCSP decay_steps = int((num_batches_per_epoch * cifar10.NUM_EPOCHS_PER_DECAY)) DCNL DCSP  DCSP  DCSP lr = tf.train.exponential_decay(cifar10.INITIAL_LEARNING_RATE, global_step, decay_steps, cifar10.LEARNING_RATE_DECAY_FACTOR, staircase=True) DCNL DCSP  DCSP  DCSP opt = tf.train.GradientDescentOptimizer(lr) DCNL DCSP  DCSP  DCSP tower_grads = [] DCNL DCSP  DCSP  DCSP for i in xrange(FLAGS.num_gpus): DCNL DCSP  DCSP  DCSP  DCSP with tf.device(('/gpu:%d' % i)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with tf.name_scope(('%s_%d' % (cifar10.TOWER_NAME, i))) as scope: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP loss = tower_loss(scope) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tf.get_variable_scope().reuse_variables() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP summaries = tf.get_collection(tf.GraphKeys.SUMMARIES, scope) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP grads = opt.compute_gradients(loss) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tower_grads.append(grads) DCNL DCSP  DCSP  DCSP grads = average_gradients(tower_grads) DCNL DCSP  DCSP  DCSP summaries.append(tf.scalar_summary('learning_rate', lr)) DCNL DCSP  DCSP  DCSP for (grad, var) in grads: DCNL DCSP  DCSP  DCSP  DCSP if (grad is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP summaries.append(tf.histogram_summary((var.op.name + '/gradients'), grad)) DCNL DCSP  DCSP  DCSP apply_gradient_op = opt.apply_gradients(grads, global_step=global_step) DCNL DCSP  DCSP  DCSP for var in tf.trainable_variables(): DCNL DCSP  DCSP  DCSP  DCSP summaries.append(tf.histogram_summary(var.op.name, var)) DCNL DCSP  DCSP  DCSP variable_averages = tf.train.ExponentialMovingAverage(cifar10.MOVING_AVERAGE_DECAY, global_step) DCNL DCSP  DCSP  DCSP variables_averages_op = variable_averages.apply(tf.trainable_variables()) DCNL DCSP  DCSP  DCSP train_op = tf.group(apply_gradient_op, variables_averages_op) DCNL DCSP  DCSP  DCSP saver = tf.train.Saver(tf.global_variables()) DCNL DCSP  DCSP  DCSP summary_op = tf.merge_summary(summaries) DCNL DCSP  DCSP  DCSP init = tf.global_variables_initializer() DCNL DCSP  DCSP  DCSP sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=FLAGS.log_device_placement)) DCNL DCSP  DCSP  DCSP sess.run(init) DCNL DCSP  DCSP  DCSP tf.train.start_queue_runners(sess=sess) DCNL DCSP  DCSP  DCSP summary_writer = tf.summary.FileWriter(FLAGS.train_dir, sess.graph) DCNL DCSP  DCSP  DCSP for step in xrange(FLAGS.max_steps): DCNL DCSP  DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP  DCSP (_, loss_value) = sess.run([train_op, loss]) DCNL DCSP  DCSP  DCSP  DCSP duration = (time.time() - start_time) DCNL DCSP  DCSP  DCSP  DCSP assert (not np.isnan(loss_value)), 'Model DCSP diverged DCSP with DCSP loss DCSP = DCSP NaN' DCNL DCSP  DCSP  DCSP  DCSP if ((step % 10) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_examples_per_step = (FLAGS.batch_size * FLAGS.num_gpus) DCNL DCSP  DCSP  DCSP  DCSP  DCSP examples_per_sec = (num_examples_per_step / duration) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sec_per_batch = (duration / FLAGS.num_gpus) DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_str = '%s: DCSP step DCSP %d, DCSP loss DCSP = DCSP %.2f DCSP (%.1f DCSP examples/sec; DCSP %.3f DCSP sec/batch)' DCNL DCSP  DCSP  DCSP  DCSP  DCSP print((format_str % (datetime.now(), step, loss_value, examples_per_sec, sec_per_batch))) DCNL DCSP  DCSP  DCSP  DCSP if ((step % 100) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary_str = sess.run(summary_op) DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary_writer.add_summary(summary_str, step) DCNL DCSP  DCSP  DCSP  DCSP if (((step % 1000) == 0) or ((step + 1) == FLAGS.max_steps)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP checkpoint_path = os.path.join(FLAGS.train_dir, 'model.ckpt') DCNL DCSP  DCSP  DCSP  DCSP  DCSP saver.save(sess, checkpoint_path, global_step=step)\n", "intent": "train cifar-10 for a number of steps .\n", "question_id": 1029}, {"snippet": "def load(odffile): DCNL  DCSP z = zipfile.ZipFile(odffile) DCNL DCSP try: DCNL DCSP  DCSP mimetype = z.read('mimetype') DCNL DCSP except KeyError: DCNL DCSP  DCSP mimetype = 'application/vnd.oasis.opendocument.text' DCNL DCSP doc = OpenDocument(mimetype, add_generator=False) DCNL DCSP manifestpart = z.read('META-INF/manifest.xml') DCNL DCSP manifest = manifestlist(manifestpart) DCNL DCSP __loadxmlparts(z, manifest, doc, '') DCNL DCSP for (mentry, mvalue) in manifest.items(): DCNL DCSP  DCSP if ((mentry[:9] == 'Pictures/') and (len(mentry) > 9)): DCNL DCSP  DCSP  DCSP doc.addPicture(mvalue['full-path'], mvalue['media-type'], z.read(mentry)) DCNL DCSP  DCSP elif (mentry == 'Thumbnails/thumbnail.png'): DCNL DCSP  DCSP  DCSP doc.addThumbnail(z.read(mentry)) DCNL DCSP  DCSP elif (mentry in ('settings.xml', 'meta.xml', 'content.xml', 'styles.xml')): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif ((mentry[:7] == 'Object DCSP ') and (len(mentry) < 11) and (mentry[(-1)] == '/')): DCNL DCSP  DCSP  DCSP subdoc = OpenDocument(mvalue['media-type'], add_generator=False) DCNL DCSP  DCSP  DCSP doc.addObject(subdoc, ('/' + mentry[:(-1)])) DCNL DCSP  DCSP  DCSP __loadxmlparts(z, manifest, subdoc, mentry) DCNL DCSP  DCSP elif (mentry[:7] == 'Object DCSP '): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (mvalue['full-path'][(-1)] == '/'): DCNL DCSP  DCSP  DCSP doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], z.read(mentry))) DCNL DCSP z.close() DCNL DCSP b = doc.getElementsByType(Body) DCNL DCSP if (mimetype[:39] == 'application/vnd.oasis.opendocument.text'): DCNL DCSP  DCSP doc.text = b[0].firstChild DCNL DCSP elif (mimetype[:43] == 'application/vnd.oasis.opendocument.graphics'): DCNL DCSP  DCSP doc.graphics = b[0].firstChild DCNL DCSP elif (mimetype[:47] == 'application/vnd.oasis.opendocument.presentation'): DCNL DCSP  DCSP doc.presentation = b[0].firstChild DCNL DCSP elif (mimetype[:46] == 'application/vnd.oasis.opendocument.spreadsheet'): DCNL DCSP  DCSP doc.spreadsheet = b[0].firstChild DCNL DCSP elif (mimetype[:40] == 'application/vnd.oasis.opendocument.chart'): DCNL DCSP  DCSP doc.chart = b[0].firstChild DCNL DCSP elif (mimetype[:40] == 'application/vnd.oasis.opendocument.image'): DCNL DCSP  DCSP doc.image = b[0].firstChild DCNL DCSP elif (mimetype[:42] == 'application/vnd.oasis.opendocument.formula'): DCNL DCSP  DCSP doc.formula = b[0].firstChild DCNL DCSP return doc\n", "intent": "load an odf file into memory returns a reference to the structure .\n", "question_id": 1030}, {"snippet": "def test_choose_port_returns_an_open_port(): DCNL  DCSP app = OnionShare() DCNL DCSP app.choose_port() DCNL DCSP socket.socket().bind(('127.0.0.1', app.port))\n", "intent": "choose_port() returns an open port .\n", "question_id": 1031}, {"snippet": "def units_func(f): DCNL  DCSP return double_output(f, [c_void_p, POINTER(c_char_p)], strarg=True)\n", "intent": "creates a ctypes function prototype for osr units functions .\n", "question_id": 1032}, {"snippet": "def _format_comments(comments): DCNL  DCSP ret = '. DCSP '.join(comments) DCNL DCSP if (len(comments) > 1): DCNL DCSP  DCSP ret += '.' DCNL DCSP return ret\n", "intent": "dry code for joining comments together and conditionally adding a period at the end .\n", "question_id": 1033}, {"snippet": "def average_degree_connectivity(G, source='in+out', target='in+out', nodes=None, weight=None): DCNL  DCSP if G.is_directed(): DCNL DCSP  DCSP if (source not in ('in', 'out', 'in+out')): DCNL DCSP  DCSP  DCSP raise ValueError('source DCSP must DCSP be DCSP one DCSP of DCSP \"in\", DCSP \"out\", DCSP or DCSP \"in+out\"') DCNL DCSP  DCSP if (target not in ('in', 'out', 'in+out')): DCNL DCSP  DCSP  DCSP raise ValueError('target DCSP must DCSP be DCSP one DCSP of DCSP \"in\", DCSP \"out\", DCSP or DCSP \"in+out\"') DCNL DCSP  DCSP direction = {'out': G.out_degree, 'in': G.in_degree, 'in+out': G.degree} DCNL DCSP  DCSP neighbor_funcs = {'out': G.successors, 'in': G.predecessors, 'in+out': G.neighbors} DCNL DCSP  DCSP source_degree = direction[source] DCNL DCSP  DCSP target_degree = direction[target] DCNL DCSP  DCSP neighbors = neighbor_funcs[source] DCNL DCSP  DCSP reverse = (source == 'in') DCNL DCSP else: DCNL DCSP  DCSP source_degree = G.degree DCNL DCSP  DCSP target_degree = G.degree DCNL DCSP  DCSP neighbors = G.neighbors DCNL DCSP  DCSP reverse = False DCNL DCSP dsum = defaultdict(int) DCNL DCSP dnorm = defaultdict(int) DCNL DCSP source_nodes = source_degree(nodes) DCNL DCSP if (nodes in G): DCNL DCSP  DCSP source_nodes = [(nodes, source_degree(nodes))] DCNL DCSP for (n, k) in source_nodes: DCNL DCSP  DCSP nbrdeg = target_degree(neighbors(n)) DCNL DCSP  DCSP if (weight is None): DCNL DCSP  DCSP  DCSP s = sum((d for (n, d) in nbrdeg)) DCNL DCSP  DCSP elif reverse: DCNL DCSP  DCSP  DCSP s = sum(((G[nbr][n].get(weight, 1) * d) for (nbr, d) in nbrdeg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = sum(((G[n][nbr].get(weight, 1) * d) for (nbr, d) in nbrdeg)) DCNL DCSP  DCSP dnorm[k] += source_degree(n, weight=weight) DCNL DCSP  DCSP dsum[k] += s DCNL DCSP dc = {} DCNL DCSP for (k, avg) in dsum.items(): DCNL DCSP  DCSP dc[k] = avg DCNL DCSP  DCSP norm = dnorm[k] DCNL DCSP  DCSP if ((avg > 0) and (norm > 0)): DCNL DCSP  DCSP  DCSP dc[k] /= norm DCNL DCSP return dc\n", "intent": "compute the average degree connectivity of graph .\n", "question_id": 1034}, {"snippet": "def obfuscate_whisper(whisper, level=0.0): DCNL  DCSP level = min(max(0.0, level), 1.0) DCNL DCSP olevel = int((13.0 * level)) DCNL DCSP return _RE_WHISPER_OBSCURE[olevel].sub(('...' if (olevel == 13.0) else '-'), whisper)\n", "intent": "obfuscate whisper depending on a pre-calculated level  args: whisper : the whisper string to obscure .\n", "question_id": 1035}, {"snippet": "def listen_print_loop(recognize_stream): DCNL  DCSP num_chars_printed = 0 DCNL DCSP for resp in recognize_stream: DCNL DCSP  DCSP if (resp.error.code != code_pb2.OK): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Server DCSP error: DCSP ' + resp.error.message)) DCNL DCSP  DCSP if (not resp.results): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result = resp.results[0] DCNL DCSP  DCSP transcript = result.alternatives[0].transcript DCNL DCSP  DCSP overwrite_chars = (' DCSP ' * max(0, (num_chars_printed - len(transcript)))) DCNL DCSP  DCSP if (not result.is_final): DCNL DCSP  DCSP  DCSP sys.stdout.write(((transcript + overwrite_chars) + '\\r')) DCNL DCSP  DCSP  DCSP sys.stdout.flush() DCNL DCSP  DCSP  DCSP num_chars_printed = len(transcript) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print (transcript + overwrite_chars) DCNL DCSP  DCSP  DCSP if re.search('\\\\b(exit|quit)\\\\b', transcript, re.I): DCNL DCSP  DCSP  DCSP  DCSP print 'Exiting..' DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP num_chars_printed = 0\n", "intent": "iterates through server responses and prints them .\n", "question_id": 1036}, {"snippet": "def compress_kml(kml): DCNL  DCSP kmz = StringIO() DCNL DCSP zf = zipfile.ZipFile(kmz, 'a', zipfile.ZIP_DEFLATED) DCNL DCSP zf.writestr('doc.kml', kml.encode(settings.DEFAULT_CHARSET)) DCNL DCSP zf.close() DCNL DCSP kmz.seek(0) DCNL DCSP return kmz.read()\n", "intent": "returns compressed kmz from the given kml string .\n", "question_id": 1037}, {"snippet": "def tree_details(text): DCNL  DCSP return leading_whitespace_re.sub(u'', text.rstrip())\n", "intent": "trims leading whitespace from the given text specifying tree details so triple-quoted strings can be used to provide tree details in a readable format .\n", "question_id": 1038}, {"snippet": "def process_images(self, docname, doctree): DCNL  DCSP docdir = path.dirname(self.doc2path(docname, base=None)) DCNL DCSP for node in doctree.traverse(nodes.image): DCNL DCSP  DCSP node['candidates'] = candidates = {} DCNL DCSP  DCSP imguri = node['uri'] DCNL DCSP  DCSP if (imguri.find('://') != (-1)): DCNL DCSP  DCSP  DCSP self.warn(docname, ('nonlocal DCSP image DCSP URI DCSP found: DCSP %s' % imguri), node.line) DCNL DCSP  DCSP  DCSP candidates['?'] = imguri DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (imguri.startswith('/') or imguri.startswith(os.sep)): DCNL DCSP  DCSP  DCSP imgpath = path.normpath(imguri[1:]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP imgpath = path.normpath(path.join(docdir, imguri)) DCNL DCSP  DCSP node['uri'] = imgpath DCNL DCSP  DCSP if imgpath.endswith((os.extsep + '*')): DCNL DCSP  DCSP  DCSP for filename in glob(path.join(self.srcdir, imgpath)): DCNL DCSP  DCSP  DCSP  DCSP new_imgpath = relative_path(self.srcdir, filename) DCNL DCSP  DCSP  DCSP  DCSP if filename.lower().endswith('.pdf'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP candidates['application/pdf'] = new_imgpath DCNL DCSP  DCSP  DCSP  DCSP elif filename.lower().endswith('.svg'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP candidates['image/svg+xml'] = new_imgpath DCNL DCSP  DCSP  DCSP  DCSP elif ('.latex.' in filename.lower()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP candidates['latex'] = new_imgpath DCNL DCSP  DCSP  DCSP  DCSP elif ('.html.' in filename.lower()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP candidates['html'] = new_imgpath DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = open(filename, 'rb') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imgtype = imghdr.what(f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP except (OSError, IOError) as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.warn(docname, ('image DCSP file DCSP %s DCSP not DCSP readable: DCSP %s' % (filename, err)), node.line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if imgtype: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP candidates[('image/' + imgtype)] = new_imgpath DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP candidates['*'] = imgpath DCNL DCSP  DCSP for imgpath in candidates.itervalues(): DCNL DCSP  DCSP  DCSP self.dependencies.setdefault(docname, set()).add(imgpath) DCNL DCSP  DCSP  DCSP if (not os.access(path.join(self.srcdir, imgpath), os.R_OK)): DCNL DCSP  DCSP  DCSP  DCSP self.warn(docname, ('image DCSP file DCSP not DCSP readable: DCSP %s' % imgpath), node.line) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP self.images.add_file(docname, imgpath)\n", "intent": "process and rewrite image uris .\n", "question_id": 1039}, {"snippet": "def test_get_version_error(qtbot): DCNL  DCSP http_stub = HTTPGetStub(success=False) DCNL DCSP client = autoupdate.PyPIVersionClient(client=http_stub) DCNL DCSP with qtbot.assertNotEmitted(client.success): DCNL DCSP  DCSP with qtbot.waitSignal(client.error): DCNL DCSP  DCSP  DCSP client.get_version('test')\n", "intent": "test get_version() when error is emitted .\n", "question_id": 1040}, {"snippet": "def get_dns_servers(interface='Local DCSP Area DCSP Connection'): DCNL  DCSP interface = interface.split('\\\\') DCNL DCSP interface = ''.join(interface) DCNL DCSP with salt.utils.winapi.Com(): DCNL DCSP  DCSP c = wmi.WMI() DCNL DCSP  DCSP for iface in c.Win32_NetworkAdapter(NetEnabled=True): DCNL DCSP  DCSP  DCSP if (interface == iface.NetConnectionID): DCNL DCSP  DCSP  DCSP  DCSP iface_config = c.Win32_NetworkAdapterConfiguration(Index=iface.Index).pop() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return list(iface_config.DNSServerSearchOrder) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP log.debug('Interface DCSP \"{0}\" DCSP not DCSP found'.format(interface)) DCNL DCSP return False\n", "intent": "return a list of the configured dns servers of the specified interface cli example: .\n", "question_id": 1041}, {"snippet": "def rate_limit_user(request, user, domain): DCNL  DCSP (ratelimited, time) = is_ratelimited(user, domain) DCNL DCSP request._ratelimit_applied_limits = True DCNL DCSP request._ratelimit_secs_to_freedom = time DCNL DCSP request._ratelimit_over_limit = ratelimited DCNL DCSP if ratelimited: DCNL DCSP  DCSP statsd.incr(('ratelimiter.limited.%s.%s' % (type(user), user.id))) DCNL DCSP  DCSP raise RateLimited() DCNL DCSP incr_ratelimit(user, domain) DCNL DCSP (calls_remaining, time_reset) = api_calls_left(user, domain) DCNL DCSP request._ratelimit_remaining = calls_remaining DCNL DCSP request._ratelimit_secs_to_freedom = time_reset\n", "intent": "returns whether or not a user was rate limited .\n", "question_id": 1042}, {"snippet": "@once DCNL def install_sql_hook(): DCNL  DCSP try: DCNL DCSP  DCSP from django.db.backends.utils import CursorWrapper DCNL DCSP except ImportError: DCNL DCSP  DCSP from django.db.backends.util import CursorWrapper DCNL DCSP try: DCNL DCSP  DCSP real_execute = CursorWrapper.execute DCNL DCSP  DCSP real_executemany = CursorWrapper.executemany DCNL DCSP except AttributeError: DCNL DCSP  DCSP return DCNL DCSP def record_sql(vendor, alias, start, duration, sql, params): DCNL DCSP  DCSP def processor(data): DCNL DCSP  DCSP  DCSP (real_sql, real_params) = format_sql(sql, params) DCNL DCSP  DCSP  DCSP if real_params: DCNL DCSP  DCSP  DCSP  DCSP real_sql = (real_sql % tuple(real_params)) DCNL DCSP  DCSP  DCSP data.update({'message': real_sql, 'category': 'query'}) DCNL DCSP  DCSP breadcrumbs.record(processor=processor) DCNL DCSP def record_many_sql(vendor, alias, start, sql, param_list): DCNL DCSP  DCSP duration = (time.time() - start) DCNL DCSP  DCSP for params in param_list: DCNL DCSP  DCSP  DCSP record_sql(vendor, alias, start, duration, sql, params) DCNL DCSP def execute(self, sql, params=None): DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return real_execute(self, sql, params) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP record_sql(self.db.vendor, getattr(self.db, 'alias', None), start, (time.time() - start), sql, params) DCNL DCSP def executemany(self, sql, param_list): DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return real_executemany(self, sql, param_list) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP record_many_sql(self.db.vendor, getattr(self.db, 'alias', None), start, sql, param_list) DCNL DCSP CursorWrapper.execute = execute DCNL DCSP CursorWrapper.executemany = executemany DCNL DCSP breadcrumbs.ignore_logger('django.db.backends')\n", "intent": "if installed this causes djangos queries to be captured .\n", "question_id": 1043}, {"snippet": "def id_to_name(config, short_name): DCNL  DCSP for (k, v) in list(config.items()): DCNL DCSP  DCSP if (v.get('id') == short_name): DCNL DCSP  DCSP  DCSP return k DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise Exception('No DCSP provider DCSP with DCSP id={0} DCSP found DCSP in DCSP the DCSP config!'.format(short_name))\n", "intent": "returns the provider :doc:config key based on its id value .\n", "question_id": 1044}, {"snippet": "def _sub_labels(axis, subs=()): DCNL  DCSP fmt = axis.get_minor_formatter() DCNL DCSP minor_tlocs = axis.get_minorticklocs() DCNL DCSP fmt.set_locs(minor_tlocs) DCNL DCSP coefs = (minor_tlocs / (10 ** np.floor(np.log10(minor_tlocs)))) DCNL DCSP label_expected = [(np.round(c) in subs) for c in coefs] DCNL DCSP label_test = [(fmt(x) != u'') for x in minor_tlocs] DCNL DCSP assert (label_test == label_expected)\n", "intent": "test whether locator marks subs to be labeled .\n", "question_id": 1045}, {"snippet": "def parse_quantifier(source, info, ch): DCNL  DCSP q = _QUANTIFIERS.get(ch) DCNL DCSP if q: DCNL DCSP  DCSP return q DCNL DCSP if (ch == '{'): DCNL DCSP  DCSP counts = parse_limited_quantifier(source) DCNL DCSP  DCSP if counts: DCNL DCSP  DCSP  DCSP return counts DCNL DCSP return None\n", "intent": "parses a quantifier .\n", "question_id": 1046}, {"snippet": "def _get_dev_hostname(backend, instance=None): DCNL  DCSP port = _get_dev_port(backend, instance) DCNL DCSP if (not port): DCNL DCSP  DCSP error = ('Backend DCSP not DCSP found: DCSP %s' % backend) DCNL DCSP  DCSP if (instance is not None): DCNL DCSP  DCSP  DCSP error = ('%s.%d' % (error, instance)) DCNL DCSP  DCSP raise InvalidBackendError(error) DCNL DCSP host = os.environ.get('SERVER_NAME', 'localhost') DCNL DCSP return ('%s:%d' % (host, port))\n", "intent": "returns the hostname of a backend [instance] in the dev_appserver .\n", "question_id": 1047}, {"snippet": "def delete(uuid): DCNL  DCSP timings = [] DCNL DCSP errors = [] DCNL DCSP for index in range(0, constants.NUM_SAMPLES): DCNL DCSP  DCSP entity = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP entity = TestModel.get_by_key_name(key_names=(uuid + str(index))) DCNL DCSP  DCSP  DCSP if (not entity): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Unable DCSP to DCSP first DCSP fetch DCSP entity.') DCNL DCSP  DCSP except Exception as exception: DCNL DCSP  DCSP  DCSP logging.exception(exception) DCNL DCSP  DCSP  DCSP errors.append(str(exception)) DCNL DCSP  DCSP  DCSP total_time = 0 DCNL DCSP  DCSP  DCSP timings.append(total_time) DCNL DCSP  DCSP  DCSP logging.error('Left DCSP over DCSP entity DCSP with DCSP keyname DCSP {0}'.format((uuid + str(index)))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP entity.delete() DCNL DCSP  DCSP  DCSP total_time = (time.time() - start) DCNL DCSP  DCSP except Exception as exception: DCNL DCSP  DCSP  DCSP logging.exception(exception) DCNL DCSP  DCSP  DCSP errors.append(str(exception)) DCNL DCSP  DCSP  DCSP total_time = 0 DCNL DCSP  DCSP timings.append((total_time * constants.SECONDS_TO_MILLI)) DCNL DCSP return (timings, errors)\n", "intent": "deletes stored entities and time them .\n", "question_id": 1048}, {"snippet": "def _get_trans(trans, fro='mri', to='head'): DCNL  DCSP if isinstance(trans, string_types): DCNL DCSP  DCSP if (not op.isfile(trans)): DCNL DCSP  DCSP  DCSP raise IOError(('trans DCSP file DCSP \"%s\" DCSP not DCSP found' % trans)) DCNL DCSP  DCSP if (op.splitext(trans)[1] in ['.fif', '.gz']): DCNL DCSP  DCSP  DCSP fro_to_t = read_trans(trans) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP t = np.genfromtxt(trans) DCNL DCSP  DCSP  DCSP if ((t.ndim != 2) or (t.shape != (4, 4))): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('File DCSP \"%s\" DCSP did DCSP not DCSP have DCSP 4x4 DCSP entries' % trans)) DCNL DCSP  DCSP  DCSP fro_to_t = Transform(to, fro, t) DCNL DCSP elif isinstance(trans, dict): DCNL DCSP  DCSP fro_to_t = trans DCNL DCSP  DCSP trans = 'dict' DCNL DCSP elif (trans is None): DCNL DCSP  DCSP fro_to_t = Transform(fro, to) DCNL DCSP  DCSP trans = 'identity' DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('transform DCSP type DCSP %s DCSP not DCSP known, DCSP must DCSP be DCSP str, DCSP dict, DCSP or DCSP None' % type(trans))) DCNL DCSP fro_to_t = _ensure_trans(fro_to_t, fro, to) DCNL DCSP return (fro_to_t, trans)\n", "intent": "get mri_head_t  from mri filename .\n", "question_id": 1049}, {"snippet": "def parse(xml_input, encoding=None, expat=expat, process_namespaces=False, namespace_separator=':', **kwargs): DCNL  DCSP handler = _DictSAXHandler(namespace_separator=namespace_separator, **kwargs) DCNL DCSP if isinstance(xml_input, _unicode): DCNL DCSP  DCSP if (not encoding): DCNL DCSP  DCSP  DCSP encoding = 'utf-8' DCNL DCSP  DCSP xml_input = xml_input.encode(encoding) DCNL DCSP if (not process_namespaces): DCNL DCSP  DCSP namespace_separator = None DCNL DCSP parser = expat.ParserCreate(encoding, namespace_separator) DCNL DCSP try: DCNL DCSP  DCSP parser.ordered_attributes = True DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP parser.StartNamespaceDeclHandler = handler.startNamespaceDecl DCNL DCSP parser.StartElementHandler = handler.startElement DCNL DCSP parser.EndElementHandler = handler.endElement DCNL DCSP parser.CharacterDataHandler = handler.characters DCNL DCSP parser.buffer_text = True DCNL DCSP try: DCNL DCSP  DCSP parser.ParseFile(xml_input) DCNL DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP parser.Parse(xml_input, True) DCNL DCSP return handler.item\n", "intent": "parse the given xml input and convert it into a dictionary .\n", "question_id": 1050}, {"snippet": "def figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=Figure, **kwargs): DCNL  DCSP if (figsize is None): DCNL DCSP  DCSP figsize = rcParams[u'figure.figsize'] DCNL DCSP if (dpi is None): DCNL DCSP  DCSP dpi = rcParams[u'figure.dpi'] DCNL DCSP if (facecolor is None): DCNL DCSP  DCSP facecolor = rcParams[u'figure.facecolor'] DCNL DCSP if (edgecolor is None): DCNL DCSP  DCSP edgecolor = rcParams[u'figure.edgecolor'] DCNL DCSP allnums = get_fignums() DCNL DCSP next_num = ((max(allnums) + 1) if allnums else 1) DCNL DCSP figLabel = u'' DCNL DCSP if (num is None): DCNL DCSP  DCSP num = next_num DCNL DCSP elif is_string_like(num): DCNL DCSP  DCSP figLabel = num DCNL DCSP  DCSP allLabels = get_figlabels() DCNL DCSP  DCSP if (figLabel not in allLabels): DCNL DCSP  DCSP  DCSP if (figLabel == u'all'): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(u\"close('all') DCSP closes DCSP all DCSP existing DCSP figures\") DCNL DCSP  DCSP  DCSP num = next_num DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inum = allLabels.index(figLabel) DCNL DCSP  DCSP  DCSP num = allnums[inum] DCNL DCSP else: DCNL DCSP  DCSP num = int(num) DCNL DCSP figManager = _pylab_helpers.Gcf.get_fig_manager(num) DCNL DCSP if (figManager is None): DCNL DCSP  DCSP max_open_warning = rcParams[u'figure.max_open_warning'] DCNL DCSP  DCSP if ((max_open_warning >= 1) and (len(allnums) >= max_open_warning)): DCNL DCSP  DCSP  DCSP warnings.warn((u'More DCSP than DCSP %d DCSP figures DCSP have DCSP been DCSP opened. DCSP Figures DCSP created DCSP through DCSP the DCSP pyplot DCSP interface DCSP (`matplotlib.pyplot.figure`) DCSP are DCSP retained DCSP until DCSP explicitly DCSP closed DCSP and DCSP may DCSP consume DCSP too DCSP much DCSP memory. DCSP (To DCSP control DCSP this DCSP warning, DCSP see DCSP the DCSP rcParam DCSP `figure.max_open_warning`).' % max_open_warning), RuntimeWarning) DCNL DCSP  DCSP if (get_backend().lower() == u'ps'): DCNL DCSP  DCSP  DCSP dpi = 72 DCNL DCSP  DCSP figManager = new_figure_manager(num, figsize=figsize, dpi=dpi, facecolor=facecolor, edgecolor=edgecolor, frameon=frameon, FigureClass=FigureClass, **kwargs) DCNL DCSP  DCSP if figLabel: DCNL DCSP  DCSP  DCSP figManager.set_window_title(figLabel) DCNL DCSP  DCSP  DCSP figManager.canvas.figure.set_label(figLabel) DCNL DCSP  DCSP def make_active(event): DCNL DCSP  DCSP  DCSP _pylab_helpers.Gcf.set_active(figManager) DCNL DCSP  DCSP cid = figManager.canvas.mpl_connect(u'button_press_event', make_active) DCNL DCSP  DCSP figManager._cidgcf = cid DCNL DCSP  DCSP _pylab_helpers.Gcf.set_active(figManager) DCNL DCSP  DCSP fig = figManager.canvas.figure DCNL DCSP  DCSP fig.number = num DCNL DCSP  DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP  DCSP draw_if_interactive() DCNL DCSP  DCSP if _INSTALL_FIG_OBSERVER: DCNL DCSP  DCSP  DCSP fig.stale_callback = _auto_draw_if_interactive DCNL DCSP return figManager.canvas.figure\n", "intent": "creates a new figure .\n", "question_id": 1051}, {"snippet": "@testing.requires_testing_data DCNL def test_io_dipoles(): DCNL  DCSP tempdir = _TempDir() DCNL DCSP dipole = read_dipole(fname_dip) DCNL DCSP print dipole DCNL DCSP out_fname = op.join(tempdir, 'temp.dip') DCNL DCSP dipole.save(out_fname) DCNL DCSP dipole_new = read_dipole(out_fname) DCNL DCSP _compare_dipoles(dipole, dipole_new)\n", "intent": "test io for .\n", "question_id": 1052}, {"snippet": "@log_call DCNL def metadef_object_get(context, namespace_name, object_name): DCNL  DCSP namespace = metadef_namespace_get(context, namespace_name) DCNL DCSP _check_namespace_visibility(context, namespace, namespace_name) DCNL DCSP for object in DATA['metadef_objects']: DCNL DCSP  DCSP if ((object['namespace_id'] == namespace['id']) and (object['name'] == object_name)): DCNL DCSP  DCSP  DCSP return object DCNL DCSP else: DCNL DCSP  DCSP LOG.debug('The DCSP metadata DCSP definition DCSP object DCSP with DCSP name=%(name)s DCSP was DCSP not DCSP found DCSP in DCSP namespace=%(namespace_name)s.', {'name': object_name, 'namespace_name': namespace_name}) DCNL DCSP  DCSP raise exception.MetadefObjectNotFound(namespace_name=namespace_name, object_name=object_name)\n", "intent": "get a metadef object .\n", "question_id": 1053}, {"snippet": "def test_quartiles_tukey(): DCNL  DCSP a = [] DCNL DCSP ((min_s, q0, q1, q2, q3, q4, max_s), outliers) = Box._box_points(a, mode='tukey') DCNL DCSP assert (min_s == q0 == q1 == q2 == q3 == q4 == 0) DCNL DCSP assert (outliers == []) DCNL DCSP b = [6, 7, 15, 36, 39, 40, 41, 42, 43, 47, 49] DCNL DCSP ((min_s, q0, q1, q2, q3, q4, max_s), outliers) = Box._box_points(b, mode='tukey') DCNL DCSP assert (min_s == q0 == 6) DCNL DCSP assert (q1 == 20.25) DCNL DCSP assert (q2 == 40) DCNL DCSP assert (q3 == 42.75) DCNL DCSP assert (max_s == q4 == 49) DCNL DCSP assert (outliers == []) DCNL DCSP c = [6, 7, 15, 36, 39, 40, 41, 42, 43, 47, 49, 75] DCNL DCSP ((min_s, q0, q1, q2, q3, q4, max_s), outliers) = Box._box_points(c, mode='tukey') DCNL DCSP assert (min_s == q0 == 6) DCNL DCSP assert (q1 == 25.5) DCNL DCSP assert (q2 == ((40 + 41) / 2.0)) DCNL DCSP assert (q3 == 45) DCNL DCSP assert (max_s == 75) DCNL DCSP assert (outliers == [75]) DCNL DCSP c = [6, 7, 15, 36, 39, 40, 41, 42, 43, 47, 49, 75, 77] DCNL DCSP ((min_s, q0, q1, q2, q3, q4, max_s), outliers) = Box._box_points(c, mode='tukey') DCNL DCSP assert (min_s == q0 == 6) DCNL DCSP assert (q1 == 30.75) DCNL DCSP assert (q2 == 41) DCNL DCSP assert (q3 == 47.5) DCNL DCSP assert (max_s == 77) DCNL DCSP assert (75 in outliers) DCNL DCSP assert (77 in outliers)\n", "intent": "test box points for the tukey computation method .\n", "question_id": 1054}, {"snippet": "def as_floatX(variable): DCNL  DCSP if isinstance(variable, float): DCNL DCSP  DCSP return numpy.cast[theano.config.floatX](variable) DCNL DCSP if isinstance(variable, numpy.ndarray): DCNL DCSP  DCSP return numpy.cast[theano.config.floatX](variable) DCNL DCSP return theano.tensor.cast(variable, theano.config.floatX)\n", "intent": "this code is taken from pylearn2: casts a given variable into dtype config .\n", "question_id": 1055}, {"snippet": "@register.filter(is_safe=True) DCNL def markdown(value, arg=''): DCNL  DCSP try: DCNL DCSP  DCSP import markdown2 DCNL DCSP except ImportError: DCNL DCSP  DCSP logging.warning('Markdown DCSP package DCSP not DCSP installed.') DCNL DCSP  DCSP return force_text(value) DCNL DCSP else: DCNL DCSP  DCSP def parse_extra(extra): DCNL DCSP  DCSP  DCSP if (':' not in extra): DCNL DCSP  DCSP  DCSP  DCSP return (extra, {}) DCNL DCSP  DCSP  DCSP (name, values) = extra.split(':', 1) DCNL DCSP  DCSP  DCSP values = dict(((str(val.strip()), True) for val in values.split('|'))) DCNL DCSP  DCSP  DCSP return (name.strip(), values) DCNL DCSP  DCSP extras = (e.strip() for e in arg.split(',')) DCNL DCSP  DCSP extras = dict((parse_extra(e) for e in extras if e)) DCNL DCSP  DCSP if ('safe' in extras): DCNL DCSP  DCSP  DCSP del extras['safe'] DCNL DCSP  DCSP  DCSP safe_mode = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP safe_mode = False DCNL DCSP  DCSP return mark_safe(markdown2.markdown(force_text(value), extras=extras, safe_mode=safe_mode))\n", "intent": "runs markdown over a given value .\n", "question_id": 1056}, {"snippet": "@verbose DCNL def equalize_channels(candidates, verbose=None): DCNL  DCSP from ..io.base import BaseRaw DCNL DCSP from ..epochs import BaseEpochs DCNL DCSP from ..evoked import Evoked DCNL DCSP from ..time_frequency import AverageTFR DCNL DCSP if (not all((isinstance(c, (BaseRaw, BaseEpochs, Evoked, AverageTFR)) for c in candidates))): DCNL DCSP  DCSP valid = ['Raw', 'Epochs', 'Evoked', 'AverageTFR'] DCNL DCSP  DCSP raise ValueError(('candidates DCSP must DCSP be DCSP ' + ' DCSP or DCSP '.join(valid))) DCNL DCSP chan_max_idx = np.argmax([c.info['nchan'] for c in candidates]) DCNL DCSP chan_template = candidates[chan_max_idx].ch_names DCNL DCSP logger.info('Identiying DCSP common DCSP channels DCSP ...') DCNL DCSP channels = [set(c.ch_names) for c in candidates] DCNL DCSP common_channels = set(chan_template).intersection(*channels) DCNL DCSP dropped = list() DCNL DCSP for c in candidates: DCNL DCSP  DCSP drop_them = list((set(c.ch_names) - common_channels)) DCNL DCSP  DCSP if drop_them: DCNL DCSP  DCSP  DCSP c.drop_channels(drop_them) DCNL DCSP  DCSP  DCSP dropped.extend(drop_them) DCNL DCSP if dropped: DCNL DCSP  DCSP dropped = list(set(dropped)) DCNL DCSP  DCSP logger.info(('Dropped DCSP the DCSP following DCSP channels:\\n%s' % dropped)) DCNL DCSP else: DCNL DCSP  DCSP logger.info('all DCSP channels DCSP are DCSP corresponding, DCSP nothing DCSP to DCSP do.')\n", "intent": "equalize channel picks for a collection of mne-python objects .\n", "question_id": 1057}, {"snippet": "def diop_DN(D, N, t=symbols('t', integer=True)): DCNL  DCSP if (D < 0): DCNL DCSP  DCSP if (N == 0): DCNL DCSP  DCSP  DCSP return [(0, 0)] DCNL DCSP  DCSP elif (N < 0): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP elif (N > 0): DCNL DCSP  DCSP  DCSP sol = [] DCNL DCSP  DCSP  DCSP for d in divisors(square_factor(N)): DCNL DCSP  DCSP  DCSP  DCSP sols = cornacchia(1, (- D), (N // (d ** 2))) DCNL DCSP  DCSP  DCSP  DCSP if sols: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (x, y) in sols: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sol.append(((d * x), (d * y))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (D == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sol.append(((d * y), (d * x))) DCNL DCSP  DCSP  DCSP return sol DCNL DCSP elif (D == 0): DCNL DCSP  DCSP if (N < 0): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP if (N == 0): DCNL DCSP  DCSP  DCSP return [(0, t)] DCNL DCSP  DCSP (sN, _exact) = integer_nthroot(N, 2) DCNL DCSP  DCSP if _exact: DCNL DCSP  DCSP  DCSP return [(sN, t)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP (sD, _exact) = integer_nthroot(D, 2) DCNL DCSP  DCSP if _exact: DCNL DCSP  DCSP  DCSP if (N == 0): DCNL DCSP  DCSP  DCSP  DCSP return [((sD * t), t)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sol = [] DCNL DCSP  DCSP  DCSP  DCSP for y in range((floor(((sign(N) * (N - 1)) / (2 * sD))) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (sq, _exact) = integer_nthroot(((D * (y ** 2)) + N), 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _exact = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _exact: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sol.append((sq, y)) DCNL DCSP  DCSP  DCSP  DCSP return sol DCNL DCSP  DCSP elif (1 < (N ** 2) < D): DCNL DCSP  DCSP  DCSP return _special_diop_DN(D, N) DCNL DCSP  DCSP elif (N == 0): DCNL DCSP  DCSP  DCSP return [(0, 0)] DCNL DCSP  DCSP elif (abs(N) == 1): DCNL DCSP  DCSP  DCSP pqa = PQa(0, 1, D) DCNL DCSP  DCSP  DCSP j = 0 DCNL DCSP  DCSP  DCSP G = [] DCNL DCSP  DCSP  DCSP B = [] DCNL DCSP  DCSP  DCSP for i in pqa: DCNL DCSP  DCSP  DCSP  DCSP a = i[2] DCNL DCSP  DCSP  DCSP  DCSP G.append(i[5]) DCNL DCSP  DCSP  DCSP  DCSP B.append(i[4]) DCNL DCSP  DCSP  DCSP  DCSP if ((j != 0) and (a == (2 * sD))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP j = (j + 1) DCNL DCSP  DCSP  DCSP if _odd(j): DCNL DCSP  DCSP  DCSP  DCSP if (N == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = G[(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP y = B[(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP count = j DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (count < ((2 * j) - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i = next(pqa) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP G.append(i[5]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP B.append(i[4]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = G[count] DCNL DCSP  DCSP  DCSP  DCSP  DCSP y = B[count] DCNL DCSP  DCSP  DCSP elif (N == 1): DCNL DCSP  DCSP  DCSP  DCSP x = G[(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP y = B[(j - 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP return [(x, y)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fs = [] DCNL DCSP  DCSP  DCSP sol = [] DCNL DCSP  DCSP  DCSP div = divisors(N) DCNL DCSP  DCSP  DCSP for d in div: DCNL DCSP  DCSP  DCSP  DCSP if divisible(N, (d ** 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fs.append(d) DCNL DCSP  DCSP  DCSP for f in fs: DCNL DCSP  DCSP  DCSP  DCSP m = (N // (f ** 2)) DCNL DCSP  DCSP  DCSP  DCSP zs = sqrt_mod(D, abs(m), all_roots=True) DCNL DCSP  DCSP  DCSP  DCSP zs = [i for i in zs if (i <= (abs(m) // 2))] DCNL DCSP  DCSP  DCSP  DCSP if (abs(m) != 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP zs = (zs + [(- i) for i in zs if i]) DCNL DCSP  DCSP  DCSP  DCSP for z in zs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pqa = PQa(z, abs(m), D) DCNL DCSP  DCSP  DCSP  DCSP  DCSP j = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP G = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i in pqa: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a = i[2] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP G.append(i[5]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP B.append(i[4]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((j != 0) and (abs(i[1]) == 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP r = G[(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s = B[(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (((r ** 2) - (D * (s ** 2))) == m): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sol.append(((f * r), (f * s))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (diop_DN(D, (-1)) != []): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a = diop_DN(D, (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sol.append(((f * ((r * a[0][0]) + ((a[0][1] * s) * D))), (f * ((r * a[0][1]) + (s * a[0][0]))))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP j = (j + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (j == length(z, abs(m), D)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP return sol\n", "intent": "solves the equation x^2 - dy^2 = n .\n", "question_id": 1058}, {"snippet": "def test_base_modules_regex(pyi_builder): DCNL  DCSP pyi_builder.test_source(\"\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP resources_testmod\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print('OK')\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \")\n", "intent": "verify that the regex for excluding modules listed in py3_base_modules does not exclude other modules .\n", "question_id": 1059}, {"snippet": "@plugins.notify_info_yielded(u'trackinfo_received') DCNL def tracks_for_id(track_id): DCNL  DCSP t = track_for_mbid(track_id) DCNL DCSP if t: DCNL DCSP  DCSP (yield t) DCNL DCSP for t in plugins.track_for_id(track_id): DCNL DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP (yield t)\n", "intent": "get a list of tracks for an id .\n", "question_id": 1060}, {"snippet": "def last_check(): DCNL  DCSP cache = cache_file() DCNL DCSP if cache: DCNL DCSP  DCSP return os.path.getmtime(cache_file()) DCNL DCSP return time.time()\n", "intent": "return the date of the last check .\n", "question_id": 1061}, {"snippet": "def test_finder_detects_latest_find_links(data): DCNL  DCSP req = InstallRequirement.from_line('simple', None) DCNL DCSP finder = PackageFinder([data.find_links], [], session=PipSession()) DCNL DCSP link = finder.find_requirement(req, False) DCNL DCSP assert link.url.endswith('simple-3.0.tar.gz')\n", "intent": "test packagefinder detects latest using find-links .\n", "question_id": 1062}, {"snippet": "def disassociate_all(context, specs_id): DCNL  DCSP try: DCNL DCSP  DCSP get_qos_specs(context, specs_id) DCNL DCSP  DCSP db.qos_specs_disassociate_all(context, specs_id) DCNL DCSP except db_exc.DBError: DCNL DCSP  DCSP LOG.exception(_LE('DB DCSP error:')) DCNL DCSP  DCSP LOG.warning(_LW('Failed DCSP to DCSP disassociate DCSP qos DCSP specs DCSP %s.'), specs_id) DCNL DCSP  DCSP raise exception.QoSSpecsDisassociateFailed(specs_id=specs_id, type_id=None)\n", "intent": "disassociate qos_specs from all entities .\n", "question_id": 1063}, {"snippet": "def strip_object_transient_sysmeta_prefix(key): DCNL  DCSP return key[len(OBJECT_TRANSIENT_SYSMETA_PREFIX):]\n", "intent": "removes the object transient system metadata prefix from the start of a header key .\n", "question_id": 1064}, {"snippet": "def getGeometryOutput(elementNode): DCNL  DCSP derivation = VoronoiDerivation(elementNode) DCNL DCSP complexPath = euclidean.getConcatenatedList(euclidean.getComplexPaths(derivation.target)) DCNL DCSP geometryOutput = [] DCNL DCSP topRight = derivation.inradius DCNL DCSP squareLoop = euclidean.getSquareLoopWiddershins((- topRight), topRight) DCNL DCSP loopComplexes = [] DCNL DCSP for (pointIndex, point) in enumerate(complexPath): DCNL DCSP  DCSP outsides = (complexPath[:pointIndex] + complexPath[(pointIndex + 1):]) DCNL DCSP  DCSP loopComplex = getVoronoiLoopByPoints(point, squareLoop, outsides) DCNL DCSP  DCSP loopComplex = intercircle.getLargestInsetLoopFromLoop(loopComplex, derivation.radius) DCNL DCSP  DCSP loopComplexes.append(loopComplex) DCNL DCSP elementNode.attributes['closed'] = 'true' DCNL DCSP for loopComplex in loopComplexes: DCNL DCSP  DCSP vector3Path = euclidean.getVector3Path(loopComplex) DCNL DCSP  DCSP geometryOutput += lineation.SideLoop(vector3Path).getManipulationPluginLoops(elementNode) DCNL DCSP return geometryOutput\n", "intent": "get vector3 vertexes from attribute dictionary .\n", "question_id": 1065}, {"snippet": "def get_system_total_memory_gb(): DCNL  DCSP import os DCNL DCSP import sys DCNL DCSP if (u'linux' in sys.platform): DCNL DCSP  DCSP with open(u'/proc/meminfo', u'r') as f_in: DCNL DCSP  DCSP  DCSP meminfo_lines = f_in.readlines() DCNL DCSP  DCSP  DCSP mem_total_line = [line for line in meminfo_lines if (u'MemTotal' in line)][0] DCNL DCSP  DCSP  DCSP mem_total = float(mem_total_line.split()[1]) DCNL DCSP  DCSP  DCSP memory_gb = (mem_total / (1024.0 ** 2)) DCNL DCSP elif (u'darwin' in sys.platform): DCNL DCSP  DCSP mem_str = os.popen(u'sysctl DCSP hw.memsize').read().strip().split(u' DCSP ')[(-1)] DCNL DCSP  DCSP memory_gb = (float(mem_str) / (1024.0 ** 3)) DCNL DCSP else: DCNL DCSP  DCSP err_msg = u'System DCSP platform: DCSP %s DCSP is DCSP not DCSP supported' DCNL DCSP  DCSP raise Exception(err_msg) DCNL DCSP return memory_gb\n", "intent": "function to get the total ram of the running system in gb .\n", "question_id": 1066}, {"snippet": "def update_bootstrap(config, url=None): DCNL  DCSP default_url = config.get('bootstrap_script_url', 'https://bootstrap.saltstack.com') DCNL DCSP if (not url): DCNL DCSP  DCSP url = default_url DCNL DCSP if (not url): DCNL DCSP  DCSP raise ValueError('Cant DCSP get DCSP any DCSP source DCSP to DCSP update') DCNL DCSP if (url.startswith('http') or ('://' in url)): DCNL DCSP  DCSP log.debug('Updating DCSP the DCSP bootstrap-salt.sh DCSP script DCSP to DCSP latest DCSP stable') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import requests DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP return {'error': 'Updating DCSP the DCSP bootstrap-salt.sh DCSP script DCSP requires DCSP the DCSP Python DCSP requests DCSP library DCSP to DCSP be DCSP installed'} DCNL DCSP  DCSP req = requests.get(url) DCNL DCSP  DCSP if (req.status_code != 200): DCNL DCSP  DCSP  DCSP return {'error': 'Failed DCSP to DCSP download DCSP the DCSP latest DCSP stable DCSP version DCSP of DCSP the DCSP bootstrap-salt.sh DCSP script DCSP from DCSP {0}. DCSP HTTP DCSP error: DCSP {1}'.format(url, req.status_code)} DCNL DCSP  DCSP script_content = req.text DCNL DCSP  DCSP if (url == default_url): DCNL DCSP  DCSP  DCSP script_name = 'bootstrap-salt.sh' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP script_name = os.path.basename(url) DCNL DCSP elif os.path.exists(url): DCNL DCSP  DCSP with salt.utils.fopen(url) as fic: DCNL DCSP  DCSP  DCSP script_content = fic.read() DCNL DCSP  DCSP script_name = os.path.basename(url) DCNL DCSP else: DCNL DCSP  DCSP script_content = url DCNL DCSP  DCSP script_name = '{0}.sh'.format(hashlib.sha1(script_content).hexdigest()) DCNL DCSP if (not script_content): DCNL DCSP  DCSP raise ValueError('No DCSP content DCSP in DCSP bootstrap DCSP script DCSP !') DCNL DCSP builtin_deploy_dir = os.path.join(os.path.dirname(__file__), 'deploy') DCNL DCSP deploy_d_from_conf_file = os.path.join(os.path.dirname(config['conf_file']), 'cloud.deploy.d') DCNL DCSP deploy_d_from_syspaths = os.path.join(config['config_dir'], 'cloud.deploy.d') DCNL DCSP deploy_scripts_search_paths = [] DCNL DCSP for entry in config.get('deploy_scripts_search_path', []): DCNL DCSP  DCSP if entry.startswith(builtin_deploy_dir): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (entry in (deploy_d_from_conf_file, deploy_d_from_syspaths)): DCNL DCSP  DCSP  DCSP deploy_scripts_search_paths.append((entry, True)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP deploy_scripts_search_paths.append((entry, False)) DCNL DCSP if (deploy_d_from_conf_file not in deploy_scripts_search_paths): DCNL DCSP  DCSP deploy_scripts_search_paths.append((deploy_d_from_conf_file, True)) DCNL DCSP if (deploy_d_from_syspaths not in deploy_scripts_search_paths): DCNL DCSP  DCSP deploy_scripts_search_paths.append((deploy_d_from_syspaths, True)) DCNL DCSP finished = [] DCNL DCSP finished_full = [] DCNL DCSP for (entry, makedirs) in deploy_scripts_search_paths: DCNL DCSP  DCSP if (entry in finished): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP finished.append(entry) DCNL DCSP  DCSP if (makedirs and (not os.path.isdir(entry))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.makedirs(entry) DCNL DCSP  DCSP  DCSP except (OSError, IOError) as err: DCNL DCSP  DCSP  DCSP  DCSP log.info(\"Failed DCSP to DCSP create DCSP directory DCSP '{0}'\".format(entry)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not is_writeable(entry)): DCNL DCSP  DCSP  DCSP log.debug(\"The DCSP '{0}' DCSP is DCSP not DCSP writeable. DCSP Continuing...\".format(entry)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP deploy_path = os.path.join(entry, script_name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP finished_full.append(deploy_path) DCNL DCSP  DCSP  DCSP with salt.utils.fopen(deploy_path, 'w') as fp_: DCNL DCSP  DCSP  DCSP  DCSP fp_.write(script_content) DCNL DCSP  DCSP except (OSError, IOError) as err: DCNL DCSP  DCSP  DCSP log.debug('Failed DCSP to DCSP write DCSP the DCSP updated DCSP script: DCSP {0}'.format(err)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP return {'Success': {'Files DCSP updated': finished_full}}\n", "intent": "update the salt-bootstrap script url can be one of: - the url to fetch the bootstrap script from - the absolute path to the bootstrap - the content of the bootstrap script .\n", "question_id": 1067}, {"snippet": "def addUnsupportedPointIndexes(alongAway): DCNL  DCSP addedUnsupportedPointIndexes = [] DCNL DCSP for pointIndex in xrange(len(alongAway.loop)): DCNL DCSP  DCSP point = alongAway.loop[pointIndex] DCNL DCSP  DCSP if (pointIndex not in alongAway.unsupportedPointIndexes): DCNL DCSP  DCSP  DCSP if (not alongAway.getIsClockwisePointSupported(point)): DCNL DCSP  DCSP  DCSP  DCSP alongAway.unsupportedPointIndexes.append(pointIndex) DCNL DCSP  DCSP  DCSP  DCSP addedUnsupportedPointIndexes.append(pointIndex) DCNL DCSP for pointIndex in addedUnsupportedPointIndexes: DCNL DCSP  DCSP point = alongAway.loop[pointIndex] DCNL DCSP  DCSP point.y += alongAway.maximumYPlus\n", "intent": "add the indexes of the unsupported points .\n", "question_id": 1068}, {"snippet": "def version_to_list(version): DCNL  DCSP ver_list = [] DCNL DCSP for p in version.split(u'.'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP n = int(p) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP n = p DCNL DCSP  DCSP ver_list.append(n) DCNL DCSP return ver_list\n", "intent": "convert a version string to a list of numbers or strings .\n", "question_id": 1069}, {"snippet": "def get_dict_names(dict1_path, dict2_path): DCNL  DCSP dict1_name = os.path.basename(dict1_path) DCNL DCSP dict2_name = os.path.basename(dict2_path) DCNL DCSP if (dict1_name == dict2_name): DCNL DCSP  DCSP dict1_name = 'dict1' DCNL DCSP  DCSP dict2_name = 'dict2' DCNL DCSP return (dict1_name, dict2_name)\n", "intent": "get the name of the dictionaries for the end user .\n", "question_id": 1070}, {"snippet": "def set_replication_enabled(status, host=None, core_name=None): DCNL  DCSP if ((not _is_master()) and (_get_none_or_value(host) is None)): DCNL DCSP  DCSP return _get_return_dict(False, errors=['Only DCSP minions DCSP configured DCSP as DCSP master DCSP can DCSP run DCSP this']) DCNL DCSP cmd = ('enablereplication' if status else 'disablereplication') DCNL DCSP if ((_get_none_or_value(core_name) is None) and _check_for_cores()): DCNL DCSP  DCSP ret = _get_return_dict() DCNL DCSP  DCSP success = True DCNL DCSP  DCSP for name in __opts__['solr.cores']: DCNL DCSP  DCSP  DCSP resp = set_replication_enabled(status, host, name) DCNL DCSP  DCSP  DCSP if (not resp['success']): DCNL DCSP  DCSP  DCSP  DCSP success = False DCNL DCSP  DCSP  DCSP data = {name: {'data': resp['data']}} DCNL DCSP  DCSP  DCSP ret = _update_return_dict(ret, success, data, resp['errors'], resp['warnings']) DCNL DCSP  DCSP return ret DCNL DCSP elif status: DCNL DCSP  DCSP return _replication_request(cmd, host=host, core_name=core_name) DCNL DCSP else: DCNL DCSP  DCSP return _replication_request(cmd, host=host, core_name=core_name)\n", "intent": "master only sets the master to ignore poll requests from the slaves .\n", "question_id": 1071}, {"snippet": "@pytest.fixture DCNL def test_bucket(cloud_config): DCNL  DCSP bucket = storage.Client().bucket(cloud_config.storage_bucket) DCNL DCSP acl = google.cloud.storage.acl.BucketACL(bucket) DCNL DCSP object_default_acl = google.cloud.storage.acl.DefaultObjectACL(bucket) DCNL DCSP acl.reload() DCNL DCSP object_default_acl.reload() DCNL DCSP (yield bucket) DCNL DCSP acl.save() DCNL DCSP object_default_acl.save()\n", "intent": "yields a bucket that resets its acl after the test completes .\n", "question_id": 1072}, {"snippet": "@blueprint.route('/projects/<project>/meters/<meter>/volume/sum') DCNL def compute_project_volume_sum(project, meter): DCNL  DCSP check_authorized_project(project) DCNL DCSP return _get_statistics('sum', meter=meter, project=project)\n", "intent": "return the total volume for a meter .\n", "question_id": 1073}, {"snippet": "def accuracy(true_positives, true_negatives, false_positives, false_negatives, description=None): DCNL  DCSP true_positives = float(true_positives) DCNL DCSP true_negatives = float(true_negatives) DCNL DCSP false_positives = float(false_positives) DCNL DCSP false_negatives = float(false_negatives) DCNL DCSP if ((((true_positives + true_negatives) + false_positives) + false_negatives) < 1e-15): DCNL DCSP  DCSP return 0.0 DCNL DCSP return ((true_positives + true_negatives) / (((true_positives + false_positives) + true_negatives) + false_negatives))\n", "intent": "returns the accuracy .\n", "question_id": 1074}, {"snippet": "def kmp_table(word): DCNL  DCSP pos = 2 DCNL DCSP cnd = 0 DCNL DCSP table = list() DCNL DCSP table.append((-1)) DCNL DCSP table.append(0) DCNL DCSP while (pos < len(word)): DCNL DCSP  DCSP if (word[(pos - 1)] == word[cnd]): DCNL DCSP  DCSP  DCSP cnd = (cnd + 1) DCNL DCSP  DCSP  DCSP table.append(cnd) DCNL DCSP  DCSP  DCSP pos = (pos + 1) DCNL DCSP  DCSP elif (cnd > 0): DCNL DCSP  DCSP  DCSP cnd = table[cnd] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP table.append(0) DCNL DCSP  DCSP  DCSP pos = (pos + 1) DCNL DCSP return table\n", "intent": "build the partial match table of the knuth-morris-pratt algorithm .\n", "question_id": 1075}, {"snippet": "def gen_extractor_classes(): DCNL  DCSP return _ALL_CLASSES\n", "intent": "return a list of supported extractors .\n", "question_id": 1076}, {"snippet": "def resolve_mro(model, name, predicate): DCNL  DCSP result = [] DCNL DCSP for cls in type(model).__mro__: DCNL DCSP  DCSP if (name in cls.__dict__): DCNL DCSP  DCSP  DCSP value = cls.__dict__[name] DCNL DCSP  DCSP  DCSP if (not predicate(value)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP result.append(value) DCNL DCSP return result\n", "intent": "return the list of successively overridden values of attribute name in mro order on model that satisfy predicate .\n", "question_id": 1077}, {"snippet": "def remove_root(root, paths): DCNL  DCSP return [pth.replace((root + '/'), '') for pth in paths]\n", "intent": "returns paths made relative to root .\n", "question_id": 1078}, {"snippet": "def get_groups_with_perms(obj, attach_perms=False): DCNL  DCSP ctype = get_content_type(obj) DCNL DCSP if (not attach_perms): DCNL DCSP  DCSP group_model = get_group_obj_perms_model(obj) DCNL DCSP  DCSP group_rel_name = group_model.group.field.related_query_name() DCNL DCSP  DCSP if group_model.objects.is_generic(): DCNL DCSP  DCSP  DCSP group_filters = {(u'%s__content_type' % group_rel_name): ctype, (u'%s__object_pk' % group_rel_name): obj.pk} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP group_filters = {(u'%s__content_object' % group_rel_name): obj} DCNL DCSP  DCSP groups = Group.objects.filter(**group_filters).distinct() DCNL DCSP  DCSP return groups DCNL DCSP else: DCNL DCSP  DCSP groups = {} DCNL DCSP  DCSP for group in get_groups_with_perms(obj): DCNL DCSP  DCSP  DCSP if (group not in groups): DCNL DCSP  DCSP  DCSP  DCSP groups[group] = sorted(get_group_perms(group, obj)) DCNL DCSP  DCSP return groups\n", "intent": "returns queryset of all group objects with *any* object permissions for the given obj .\n", "question_id": 1079}, {"snippet": "def object_id_validator(key, activity_dict, errors, context): DCNL  DCSP activity_type = activity_dict[('activity_type',)] DCNL DCSP if object_id_validators.has_key(activity_type): DCNL DCSP  DCSP object_id = activity_dict[('object_id',)] DCNL DCSP  DCSP return object_id_validators[activity_type](object_id, context) DCNL DCSP else: DCNL DCSP  DCSP raise Invalid(('There DCSP is DCSP no DCSP object_id DCSP validator DCSP for DCSP activity DCSP type DCSP \"%s\"' % activity_type))\n", "intent": "validate the object_id value of an activity_dict .\n", "question_id": 1080}, {"snippet": "def badrequest(): DCNL  DCSP context.status = '400 DCSP Bad DCSP Request' DCNL DCSP header('Content-Type', 'text/html') DCNL DCSP return output('bad DCSP request')\n", "intent": "return a 400 bad request error .\n", "question_id": 1081}, {"snippet": "def domain_match(A, B): DCNL  DCSP A = A.lower() DCNL DCSP B = B.lower() DCNL DCSP if (A == B): DCNL DCSP  DCSP return True DCNL DCSP if (not is_HDN(A)): DCNL DCSP  DCSP return False DCNL DCSP i = A.rfind(B) DCNL DCSP has_form_nb = (not ((i == (-1)) or (i == 0))) DCNL DCSP return (has_form_nb and B.startswith('.') and is_HDN(B[1:]))\n", "intent": "return true if domain a domain-matches domain b .\n", "question_id": 1082}, {"snippet": "def _add_eeg_pos(eeg, t, c): DCNL  DCSP if (eeg is None): DCNL DCSP  DCSP return DCNL DCSP if ((t is None) or (t['t_ctf_head_head'] is None)): DCNL DCSP  DCSP raise RuntimeError('No DCSP coordinate DCSP transformation DCSP available DCSP for DCSP EEG DCSP position DCSP data') DCNL DCSP eeg_assigned = 0 DCNL DCSP if eeg['assign_to_chs']: DCNL DCSP  DCSP for k in range(eeg['np']): DCNL DCSP  DCSP  DCSP for ch in c['chs']: DCNL DCSP  DCSP  DCSP  DCSP if (ch['ch_name'].lower() == eeg['labels'][k].lower()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r0 = ch['loc'][:3] DCNL DCSP  DCSP  DCSP  DCSP  DCSP r0[:] = eeg['rr'][k] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (eeg['coord_frame'] == FIFF.FIFFV_MNE_COORD_CTF_HEAD): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP r0[:] = apply_trans(t['t_ctf_head_head'], r0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (eeg['coord_frame'] != FIFF.FIFFV_COORD_HEAD): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Illegal DCSP coordinate DCSP frame DCSP for DCSP EEG DCSP electrode DCSP positions DCSP : DCSP %s' % _coord_frame_name(eeg['coord_frame']))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP eeg['ids'][k] = ch['logno'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP eeg['kinds'][k] = FIFF.FIFFV_POINT_EEG DCNL DCSP  DCSP  DCSP  DCSP  DCSP eeg_assigned += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP fid_count = eeg_count = extra_count = 0 DCNL DCSP for k in range(eeg['np']): DCNL DCSP  DCSP d = dict(r=eeg['rr'][k].copy(), kind=eeg['kinds'][k], ident=eeg['ids'][k], coord_frame=FIFF.FIFFV_COORD_HEAD) DCNL DCSP  DCSP c['dig'].append(d) DCNL DCSP  DCSP if (eeg['coord_frame'] == FIFF.FIFFV_MNE_COORD_CTF_HEAD): DCNL DCSP  DCSP  DCSP d['r'] = apply_trans(t['t_ctf_head_head'], d['r']) DCNL DCSP  DCSP elif (eeg['coord_frame'] != FIFF.FIFFV_COORD_HEAD): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Illegal DCSP coordinate DCSP frame DCSP for DCSP EEG DCSP electrode DCSP positions: DCSP %s' % _coord_frame_name(eeg['coord_frame']))) DCNL DCSP  DCSP if (eeg['kinds'][k] == FIFF.FIFFV_POINT_CARDINAL): DCNL DCSP  DCSP  DCSP fid_count += 1 DCNL DCSP  DCSP elif (eeg['kinds'][k] == FIFF.FIFFV_POINT_EEG): DCNL DCSP  DCSP  DCSP eeg_count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra_count += 1 DCNL DCSP if (eeg_assigned > 0): DCNL DCSP  DCSP logger.info((' DCSP  DCSP  DCSP  DCSP %d DCSP EEG DCSP electrode DCSP locations DCSP assigned DCSP to DCSP channel DCSP info.' % eeg_assigned)) DCNL DCSP for (count, kind) in zip((fid_count, eeg_count, extra_count), ('fiducials', 'EEG DCSP locations', 'extra DCSP points')): DCNL DCSP  DCSP if (count > 0): DCNL DCSP  DCSP  DCSP logger.info((' DCSP  DCSP  DCSP  DCSP %d DCSP %s DCSP added DCSP to DCSP Polhemus DCSP data.' % (count, kind)))\n", "intent": "pick the  eeg position data .\n", "question_id": 1083}, {"snippet": "def admin_actions(context): DCNL  DCSP context['action_index'] = (context.get('action_index', (-1)) + 1) DCNL DCSP return context\n", "intent": "track the number of times the action field has been rendered on the page .\n", "question_id": 1084}, {"snippet": "def update_md5(filenames): DCNL  DCSP import re DCNL DCSP from md5 import md5 DCNL DCSP for name in filenames: DCNL DCSP  DCSP base = os.path.basename(name) DCNL DCSP  DCSP f = open(name, 'rb') DCNL DCSP  DCSP md5_data[base] = md5(f.read()).hexdigest() DCNL DCSP  DCSP f.close() DCNL DCSP data = [(' DCSP  DCSP  DCSP  DCSP %r: DCSP %r,\\n' % it) for it in md5_data.items()] DCNL DCSP data.sort() DCNL DCSP repl = ''.join(data) DCNL DCSP import inspect DCNL DCSP srcfile = inspect.getsourcefile(sys.modules[__name__]) DCNL DCSP f = open(srcfile, 'rb') DCNL DCSP src = f.read() DCNL DCSP f.close() DCNL DCSP match = re.search('\\nmd5_data DCSP = DCSP {\\n([^}]+)}', src) DCNL DCSP if (not match): DCNL DCSP  DCSP print >>sys.stderr, 'Internal DCSP error!' DCNL DCSP  DCSP sys.exit(2) DCNL DCSP src = ((src[:match.start(1)] + repl) + src[match.end(1):]) DCNL DCSP f = open(srcfile, 'w') DCNL DCSP f.write(src) DCNL DCSP f.close()\n", "intent": "update our built-in md5 registry .\n", "question_id": 1085}, {"snippet": "def install_config(name, **kwargs): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP ret['changes'] = __salt__['junos.install_config'](name, **kwargs) DCNL DCSP return ret\n", "intent": "loads and commits the configuration provided .\n", "question_id": 1086}, {"snippet": "@frappe.whitelist() DCNL def load_messages(language): DCNL  DCSP frappe.clear_cache() DCNL DCSP set_default_language(get_language_code(language)) DCNL DCSP m = get_dict(u'page', u'setup-wizard') DCNL DCSP for path in frappe.get_hooks(u'setup_wizard_requires'): DCNL DCSP  DCSP js_file_path = os.path.abspath(frappe.get_site_path(u'..', *path.strip(u'/').split(u'/'))) DCNL DCSP  DCSP m.update(get_dict(u'jsfile', js_file_path)) DCNL DCSP m.update(get_dict(u'boot')) DCNL DCSP send_translations(m) DCNL DCSP return frappe.local.lang\n", "intent": "load translation messages for given language from all setup_wizard_requires javascript files .\n", "question_id": 1087}, {"snippet": "def carmichael_of_factorized(f_list): DCNL  DCSP if (len(f_list) < 1): DCNL DCSP  DCSP return 1 DCNL DCSP result = carmichael_of_ppower(f_list[0]) DCNL DCSP for i in range(1, len(f_list)): DCNL DCSP  DCSP result = lcm(result, carmichael_of_ppower(f_list[i])) DCNL DCSP return result\n", "intent": "return the carmichael function of a number that is represented as a list of  pairs .\n", "question_id": 1088}, {"snippet": "def priority_sorter(registry, xml_parent, data): DCNL  DCSP priority_sorter_tag = XML.SubElement(xml_parent, 'hudson.queueSorter.PrioritySorterJobProperty') DCNL DCSP try: DCNL DCSP  DCSP XML.SubElement(priority_sorter_tag, 'priority').text = str(data['priority']) DCNL DCSP except KeyError as e: DCNL DCSP  DCSP raise MissingAttributeError(e)\n", "intent": "yaml: priority-sorter allows simple ordering of builds .\n", "question_id": 1089}, {"snippet": "def RegisterShellInfo(searchPaths): DCNL  DCSP import regutil, win32con DCNL DCSP suffix = IsDebug() DCNL DCSP exePath = FindRegisterPythonExe(('Python%s.exe' % suffix), searchPaths) DCNL DCSP regutil.SetRegistryDefaultValue('.py', 'Python.File', win32con.HKEY_CLASSES_ROOT) DCNL DCSP regutil.RegisterShellCommand('Open', (QuotedFileName(exePath) + ' DCSP \"%1\" DCSP %*'), '&Run') DCNL DCSP regutil.SetRegistryDefaultValue('Python.File\\\\DefaultIcon', ('%s,0' % exePath), win32con.HKEY_CLASSES_ROOT) DCNL DCSP FindRegisterHelpFile('Python.hlp', searchPaths, 'Main DCSP Python DCSP Documentation') DCNL DCSP FindRegisterHelpFile('ActivePython.chm', searchPaths, 'Main DCSP Python DCSP Documentation')\n", "intent": "registers key parts of the python installation with the windows shell .\n", "question_id": 1090}, {"snippet": "def imview_async(*args, **kwargs): DCNL  DCSP if ('figure' in kwargs): DCNL DCSP  DCSP raise ValueError('passing DCSP a DCSP figure DCSP argument DCSP not DCSP supported') DCNL DCSP def fork_image_viewer(): DCNL DCSP  DCSP f = plt.figure() DCNL DCSP  DCSP kwargs['figure'] = f DCNL DCSP  DCSP imview(*args, **kwargs) DCNL DCSP  DCSP if ('window_title' in kwargs): DCNL DCSP  DCSP  DCSP f.set_window_title(kwargs['window_title']) DCNL DCSP  DCSP plt.show() DCNL DCSP p = Process(None, fork_image_viewer) DCNL DCSP p.start() DCNL DCSP return p\n", "intent": "a version of imview that forks a separate process and immediately shows the image .\n", "question_id": 1091}, {"snippet": "def tablespace_exists(name, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None): DCNL  DCSP tablespaces = tablespace_list(user=user, host=host, port=port, maintenance_db=maintenance_db, password=password, runas=runas) DCNL DCSP return (name in tablespaces)\n", "intent": "checks if a tablespace exists on the postgres server .\n", "question_id": 1092}, {"snippet": "def match_album(artist, album, tracks=None, limit=SEARCH_LIMIT): DCNL  DCSP criteria = {'release': album.lower().strip()} DCNL DCSP if (artist is not None): DCNL DCSP  DCSP criteria['artist'] = artist.lower().strip() DCNL DCSP else: DCNL DCSP  DCSP criteria['arid'] = VARIOUS_ARTISTS_ID DCNL DCSP if (tracks is not None): DCNL DCSP  DCSP criteria['tracks'] = str(tracks) DCNL DCSP if (not any(criteria.itervalues())): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP res = musicbrainzngs.search_releases(limit=limit, **criteria) DCNL DCSP except musicbrainzngs.MusicBrainzError as exc: DCNL DCSP  DCSP raise MusicBrainzAPIError(exc, 'release DCSP search', criteria, traceback.format_exc()) DCNL DCSP for release in res['release-list']: DCNL DCSP  DCSP albuminfo = album_for_id(release['id']) DCNL DCSP  DCSP if (albuminfo is not None): DCNL DCSP  DCSP  DCSP (yield albuminfo)\n", "intent": "searches for a single album  and returns an iterator over albuminfo objects .\n", "question_id": 1093}, {"snippet": "@do DCNL def publish_docs(flocker_version, doc_version, environment, routing_config): DCNL  DCSP if (not (is_release(doc_version) or is_weekly_release(doc_version) or is_pre_release(doc_version))): DCNL DCSP  DCSP raise NotARelease() DCNL DCSP if (environment == Environments.PRODUCTION): DCNL DCSP  DCSP if (get_doc_version(flocker_version) != doc_version): DCNL DCSP  DCSP  DCSP raise NotTagged() DCNL DCSP configuration = DOCUMENTATION_CONFIGURATIONS[environment] DCNL DCSP dev_prefix = ('release/flocker-%s/' % (flocker_version,)) DCNL DCSP version_prefix = ('en/%s/' % (get_doc_version(doc_version),)) DCNL DCSP is_dev = (not is_release(doc_version)) DCNL DCSP if is_dev: DCNL DCSP  DCSP stable_prefix = 'en/devel/' DCNL DCSP else: DCNL DCSP  DCSP stable_prefix = 'en/latest/' DCNL DCSP new_version_keys = (yield Effect(ListS3Keys(bucket=configuration.dev_bucket, prefix=dev_prefix))) DCNL DCSP existing_version_keys = (yield Effect(ListS3Keys(bucket=configuration.documentation_bucket, prefix=version_prefix))) DCNL DCSP existing_latest_keys = (yield Effect(ListS3Keys(bucket=configuration.documentation_bucket, prefix=stable_prefix))) DCNL DCSP (yield Effect(CopyS3Keys(source_bucket=configuration.dev_bucket, source_prefix=dev_prefix, destination_bucket=configuration.documentation_bucket, destination_prefix=version_prefix, keys=new_version_keys))) DCNL DCSP (yield Effect(CopyS3Keys(source_bucket=configuration.dev_bucket, source_prefix=dev_prefix, destination_bucket=configuration.documentation_bucket, destination_prefix=stable_prefix, keys=new_version_keys))) DCNL DCSP (yield Effect(DeleteS3Keys(bucket=configuration.documentation_bucket, prefix=version_prefix, keys=(existing_version_keys - new_version_keys)))) DCNL DCSP (yield Effect(DeleteS3Keys(bucket=configuration.documentation_bucket, prefix=stable_prefix, keys=(existing_latest_keys - new_version_keys)))) DCNL DCSP if ((environment is Environments.STAGING) or ((environment is Environments.PRODUCTION) and (not is_dev))): DCNL DCSP  DCSP (yield Effect(UpdateS3ErrorPage(bucket=configuration.documentation_bucket, target_prefix=version_prefix))) DCNL DCSP changed_keys = (new_version_keys | existing_version_keys) DCNL DCSP changed_keys |= {key_name[:(- len('index.html'))] for key_name in changed_keys if key_name.endswith('/index.html')} DCNL DCSP changed_keys |= {''} DCNL DCSP changed_paths = {(prefix + key_name) for key_name in changed_keys for prefix in [stable_prefix, version_prefix]} DCNL DCSP (yield Effect(UpdateS3RoutingRules(bucket=configuration.documentation_bucket, routing_rules=parse_routing_rules(routing_config, configuration.cloudfront_cname)))) DCNL DCSP (yield Effect(CreateCloudFrontInvalidation(cname=configuration.cloudfront_cname, paths=changed_paths)))\n", "intent": "publish the flocker documentation .\n", "question_id": 1094}, {"snippet": "def log_statsd_event(name): DCNL  DCSP event_name = ('events.%s' % (name,)) DCNL DCSP statsd.incr(event_name)\n", "intent": "sends a single event to statsd with the desired name and the current timestamp this can be used to provide vertical lines in generated graphs .\n", "question_id": 1095}, {"snippet": "def user_grants(user, host='localhost', **connection_args): DCNL  DCSP if (not user_exists(user, host, **connection_args)): DCNL DCSP  DCSP log.info(\"User DCSP '{0}'@'{1}' DCSP does DCSP not DCSP exist\".format(user, host)) DCNL DCSP  DCSP return False DCNL DCSP dbc = _connect(**connection_args) DCNL DCSP if (dbc is None): DCNL DCSP  DCSP return False DCNL DCSP cur = dbc.cursor() DCNL DCSP qry = 'SHOW DCSP GRANTS DCSP FOR DCSP %(user)s@%(host)s' DCNL DCSP args = {} DCNL DCSP args['user'] = user DCNL DCSP args['host'] = host DCNL DCSP try: DCNL DCSP  DCSP _execute(cur, qry, args) DCNL DCSP except MySQLdb.OperationalError as exc: DCNL DCSP  DCSP err = 'MySQL DCSP Error DCSP {0}: DCSP {1}'.format(*exc) DCNL DCSP  DCSP __context__['mysql.error'] = err DCNL DCSP  DCSP log.error(err) DCNL DCSP  DCSP return False DCNL DCSP ret = [] DCNL DCSP results = cur.fetchall() DCNL DCSP for grant in results: DCNL DCSP  DCSP tmp = grant[0].split(' DCSP IDENTIFIED DCSP BY')[0] DCNL DCSP  DCSP if (('WITH DCSP GRANT DCSP OPTION' in grant[0]) and ('WITH DCSP GRANT DCSP OPTION' not in tmp)): DCNL DCSP  DCSP  DCSP tmp = '{0} DCSP WITH DCSP GRANT DCSP OPTION'.format(tmp) DCNL DCSP  DCSP ret.append(tmp) DCNL DCSP log.debug(ret) DCNL DCSP return ret\n", "intent": "shows the grants for the given mysql user  cli example: .\n", "question_id": 1096}, {"snippet": "def compare_scores(earned1, possible1, earned2, possible2): DCNL  DCSP percentage1 = (float(earned1) / float(possible1)) DCNL DCSP percentage2 = (float(earned2) / float(possible2)) DCNL DCSP is_higher = (percentage2 > percentage1) DCNL DCSP return (is_higher, percentage1, percentage2)\n", "intent": "returns a tuple of: 1 .\n", "question_id": 1097}, {"snippet": "def init(): DCNL  DCSP _useWizardInterface() DCNL DCSP setVerbosity() DCNL DCSP _saveConfig() DCNL DCSP _setRequestFromFile() DCNL DCSP _cleanupOptions() DCNL DCSP _cleanupEnvironment() DCNL DCSP _dirtyPatches() DCNL DCSP _purgeOutput() DCNL DCSP _checkDependencies() DCNL DCSP _createTemporaryDirectory() DCNL DCSP _basicOptionValidation() DCNL DCSP _setProxyList() DCNL DCSP _setTorProxySettings() DCNL DCSP _setDNSServer() DCNL DCSP _adjustLoggingFormatter() DCNL DCSP _setMultipleTargets() DCNL DCSP _setTamperingFunctions() DCNL DCSP _setWafFunctions() DCNL DCSP _setTrafficOutputFP() DCNL DCSP _resolveCrossReferences() DCNL DCSP _checkWebSocket() DCNL DCSP parseTargetUrl() DCNL DCSP parseTargetDirect() DCNL DCSP if any((conf.url, conf.logFile, conf.bulkFile, conf.sitemapUrl, conf.requestFile, conf.googleDork, conf.liveTest)): DCNL DCSP  DCSP _setHTTPTimeout() DCNL DCSP  DCSP _setHTTPExtraHeaders() DCNL DCSP  DCSP _setHTTPCookies() DCNL DCSP  DCSP _setHTTPReferer() DCNL DCSP  DCSP _setHTTPHost() DCNL DCSP  DCSP _setHTTPUserAgent() DCNL DCSP  DCSP _setHTTPAuthentication() DCNL DCSP  DCSP _setHTTPHandlers() DCNL DCSP  DCSP _setDNSCache() DCNL DCSP  DCSP _setSocketPreConnect() DCNL DCSP  DCSP _setSafeVisit() DCNL DCSP  DCSP _doSearch() DCNL DCSP  DCSP _setBulkMultipleTargets() DCNL DCSP  DCSP _setSitemapTargets() DCNL DCSP  DCSP _checkTor() DCNL DCSP  DCSP _setCrawler() DCNL DCSP  DCSP _findPageForms() DCNL DCSP  DCSP _setDBMS() DCNL DCSP  DCSP _setTechnique() DCNL DCSP _setThreads() DCNL DCSP _setOS() DCNL DCSP _setWriteFile() DCNL DCSP _setMetasploit() DCNL DCSP _setDBMSAuthentication() DCNL DCSP loadBoundaries() DCNL DCSP loadPayloads() DCNL DCSP _setPrefixSuffix() DCNL DCSP update() DCNL DCSP _loadQueries()\n", "intent": "set attributes into both configuration and knowledge base singletons based upon command line and configuration file options .\n", "question_id": 1098}, {"snippet": "def request_user_has_role(request, role): DCNL  DCSP if (not cfg.CONF.auth.enable): DCNL DCSP  DCSP return True DCNL DCSP user_db = get_user_db_from_request(request=request) DCNL DCSP return user_has_role(user_db=user_db, role=role)\n", "intent": "check if the logged-in request user has the provided role .\n", "question_id": 1099}, {"snippet": "@sql.command() DCNL @click.option('--force', is_flag=True, default=False, help='replace DCSP existing DCSP views') DCNL @click.option('--materialize', '-m', is_flag=True, default=False, help='create DCSP materialized DCSP view DCSP (table)') DCNL @click.option('--index/--no-index', default=True, help='create DCSP index DCSP for DCSP key DCSP attributes') DCNL @click.option('--schema', '-s', help='target DCSP view DCSP schema DCSP (overrides DCSP default DCSP fact DCSP schema') DCNL @click.argument('cube', required=False) DCNL @click.argument('target', required=False) DCNL @click.pass_context DCNL def denormalize(ctx, force, materialize, index, schema, cube, target): DCNL  DCSP if ((not materialize) and index): DCNL DCSP  DCSP raise ArgumentError(\"Non-materialized DCSP views DCSP can't DCSP be DCSP indexed\") DCNL DCSP workspace = ctx.obj.workspace DCNL DCSP store = ctx.obj.store DCNL DCSP if cube: DCNL DCSP  DCSP target = (target or store.naming.denormalized_table_name(cube)) DCNL DCSP  DCSP cubes = [(cube, target)] DCNL DCSP else: DCNL DCSP  DCSP names = workspace.cube_names() DCNL DCSP  DCSP targets = [store.naming.denormalized_table_name(name) for name in names] DCNL DCSP  DCSP cubes = zip(names, targets) DCNL DCSP for (cube_name, target) in cubes: DCNL DCSP  DCSP cube = workspace.cube(cube_name) DCNL DCSP  DCSP store = workspace.get_store((cube.store_name or 'default')) DCNL DCSP  DCSP print((\"denormalizing DCSP cube DCSP '%s' DCSP into DCSP '%s'\" % (cube_name, target))) DCNL DCSP  DCSP store.create_denormalized_view(cube, target, materialize=materialize, replace=force, create_index=index, keys_only=False, schema=schema)\n", "intent": "create denormalized view(s) from cube(s) .\n", "question_id": 1100}, {"snippet": "def register(linter): DCNL  DCSP linter.register_checker(StdlibChecker(linter))\n", "intent": "required method to auto register this checker .\n", "question_id": 1101}, {"snippet": "def filter_results(original_file_dict, modified_file_dict, original_results, modified_results): DCNL  DCSP renamed_files = ensure_files_present(original_file_dict, modified_file_dict) DCNL DCSP diffs_dict = {} DCNL DCSP for file in original_file_dict: DCNL DCSP  DCSP diffs_dict[file] = Diff.from_string_arrays(original_file_dict[file], modified_file_dict[renamed_files.get(file, file)]) DCNL DCSP orig_result_diff_dict_dict = remove_result_ranges_diffs(original_results, original_file_dict) DCNL DCSP mod_result_diff_dict_dict = remove_result_ranges_diffs(modified_results, modified_file_dict) DCNL DCSP unique_results = [] DCNL DCSP for m_r in reversed(modified_results): DCNL DCSP  DCSP unique = True DCNL DCSP  DCSP for o_r in original_results: DCNL DCSP  DCSP  DCSP if basics_match(o_r, m_r): DCNL DCSP  DCSP  DCSP  DCSP if source_ranges_match(original_file_dict, diffs_dict, orig_result_diff_dict_dict[o_r], mod_result_diff_dict_dict[m_r], renamed_files): DCNL DCSP  DCSP  DCSP  DCSP  DCSP unique = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if unique: DCNL DCSP  DCSP  DCSP unique_results.append(m_r) DCNL DCSP return unique_results\n", "intent": "filters results for such ones that are unique across file changes .\n", "question_id": 1102}, {"snippet": "def is_target_available(conda_target, conda_context=None, channels_override=None): DCNL  DCSP (best_hit, exact) = best_search_result(conda_target, conda_context, channels_override) DCNL DCSP if best_hit: DCNL DCSP  DCSP return ('exact' if exact else True) DCNL DCSP else: DCNL DCSP  DCSP return False\n", "intent": "check if a specified target is available for installation .\n", "question_id": 1103}, {"snippet": "def _create_ha_name(name, channel, param, count): DCNL  DCSP if ((count == 1) and (param is None)): DCNL DCSP  DCSP return name DCNL DCSP if ((count > 1) and (param is None)): DCNL DCSP  DCSP return '{} DCSP {}'.format(name, channel) DCNL DCSP if ((count == 1) and (param is not None)): DCNL DCSP  DCSP return '{} DCSP {}'.format(name, param) DCNL DCSP if ((count > 1) and (param is not None)): DCNL DCSP  DCSP return '{} DCSP {} DCSP {}'.format(name, channel, param)\n", "intent": "generate a unique object name .\n", "question_id": 1104}, {"snippet": "@register.simple_tag(takes_context=True) DCNL def pagination_querystring(context, page_number, page_key=DEFAULT_PAGE_KEY): DCNL  DCSP return querystring(context, **{page_key: page_number})\n", "intent": "print out a querystring with an updated page number: {% if page .\n", "question_id": 1105}, {"snippet": "def train_conv_net(datasets, U, img_w=300, filter_hs=[3, 4, 5], hidden_units=[100, 2], dropout_rate=[0.5], shuffle_batch=True, n_epochs=25, batch_size=50, lr_decay=0.95, conv_non_linear='relu', activations=[Iden], sqr_norm_lim=9, non_static=True): DCNL  DCSP rng = np.random.RandomState(3435) DCNL DCSP img_h = (len(datasets[0][0]) - 1) DCNL DCSP filter_w = img_w DCNL DCSP feature_maps = hidden_units[0] DCNL DCSP filter_shapes = [] DCNL DCSP pool_sizes = [] DCNL DCSP for filter_h in filter_hs: DCNL DCSP  DCSP filter_shapes.append((feature_maps, 1, filter_h, filter_w)) DCNL DCSP  DCSP pool_sizes.append((((img_h - filter_h) + 1), ((img_w - filter_w) + 1))) DCNL DCSP parameters = [('image DCSP shape', img_h, img_w), ('filter DCSP shape', filter_shapes), ('hidden_units', hidden_units), ('dropout', dropout_rate), ('batch_size', batch_size), ('non_static', non_static), ('learn_decay', lr_decay), ('conv_non_linear', conv_non_linear), ('non_static', non_static), ('sqr_norm_lim', sqr_norm_lim), ('shuffle_batch', shuffle_batch)] DCNL DCSP print parameters DCNL DCSP index = T.lscalar() DCNL DCSP x = T.matrix('x') DCNL DCSP y = T.ivector('y') DCNL DCSP Words = theano.shared(value=U, name='Words') DCNL DCSP zero_vec_tensor = T.vector() DCNL DCSP zero_vec = np.zeros(img_w) DCNL DCSP set_zero = theano.function([zero_vec_tensor], updates=[(Words, T.set_subtensor(Words[0, :], zero_vec_tensor))], allow_input_downcast=True) DCNL DCSP layer0_input = Words[T.cast(x.flatten(), dtype='int32')].reshape((x.shape[0], 1, x.shape[1], Words.shape[1])) DCNL DCSP conv_layers = [] DCNL DCSP layer1_inputs = [] DCNL DCSP for i in xrange(len(filter_hs)): DCNL DCSP  DCSP filter_shape = filter_shapes[i] DCNL DCSP  DCSP pool_size = pool_sizes[i] DCNL DCSP  DCSP conv_layer = LeNetConvPoolLayer(rng, input=layer0_input, image_shape=(batch_size, 1, img_h, img_w), filter_shape=filter_shape, poolsize=pool_size, non_linear=conv_non_linear) DCNL DCSP  DCSP layer1_input = conv_layer.output.flatten(2) DCNL DCSP  DCSP conv_layers.append(conv_layer) DCNL DCSP  DCSP layer1_inputs.append(layer1_input) DCNL DCSP layer1_input = T.concatenate(layer1_inputs, 1) DCNL DCSP hidden_units[0] = (feature_maps * len(filter_hs)) DCNL DCSP classifier = MLPDropout(rng, input=layer1_input, layer_sizes=hidden_units, activations=activations, dropout_rates=dropout_rate) DCNL DCSP params = classifier.params DCNL DCSP for conv_layer in conv_layers: DCNL DCSP  DCSP params += conv_layer.params DCNL DCSP if non_static: DCNL DCSP  DCSP params += [Words] DCNL DCSP cost = classifier.negative_log_likelihood(y) DCNL DCSP dropout_cost = classifier.dropout_negative_log_likelihood(y) DCNL DCSP grad_updates = sgd_updates_adadelta(params, dropout_cost, lr_decay, 1e-06, sqr_norm_lim) DCNL DCSP np.random.seed(3435) DCNL DCSP if ((datasets[0].shape[0] % batch_size) > 0): DCNL DCSP  DCSP extra_data_num = (batch_size - (datasets[0].shape[0] % batch_size)) DCNL DCSP  DCSP train_set = np.random.permutation(datasets[0]) DCNL DCSP  DCSP extra_data = train_set[:extra_data_num] DCNL DCSP  DCSP new_data = np.append(datasets[0], extra_data, axis=0) DCNL DCSP else: DCNL DCSP  DCSP new_data = datasets[0] DCNL DCSP new_data = np.random.permutation(new_data) DCNL DCSP n_batches = (new_data.shape[0] / batch_size) DCNL DCSP n_train_batches = int(np.round((n_batches * 0.9))) DCNL DCSP test_set_x = datasets[1][:, :img_h] DCNL DCSP test_set_y = np.asarray(datasets[1][:, (-1)], 'int32') DCNL DCSP train_set = new_data[:(n_train_batches * batch_size), :] DCNL DCSP val_set = new_data[(n_train_batches * batch_size):, :] DCNL DCSP (train_set_x, train_set_y) = shared_dataset((train_set[:, :img_h], train_set[:, (-1)])) DCNL DCSP (val_set_x, val_set_y) = shared_dataset((val_set[:, :img_h], val_set[:, (-1)])) DCNL DCSP n_val_batches = (n_batches - n_train_batches) DCNL DCSP val_model = theano.function([index], classifier.errors(y), givens={x: val_set_x[(index * batch_size):((index + 1) * batch_size)], y: val_set_y[(index * batch_size):((index + 1) * batch_size)]}, allow_input_downcast=True) DCNL DCSP test_model = theano.function([index], classifier.errors(y), givens={x: train_set_x[(index * batch_size):((index + 1) * batch_size)], y: train_set_y[(index * batch_size):((index + 1) * batch_size)]}, allow_input_downcast=True) DCNL DCSP train_model = theano.function([index], cost, updates=grad_updates, givens={x: train_set_x[(index * batch_size):((index + 1) * batch_size)], y: train_set_y[(index * batch_size):((index + 1) * batch_size)]}, allow_input_downcast=True) DCNL DCSP test_pred_layers = [] DCNL DCSP test_size = test_set_x.shape[0] DCNL DCSP test_layer0_input = Words[T.cast(x.flatten(), dtype='int32')].reshape((test_size, 1, img_h, Words.shape[1])) DCNL DCSP for conv_layer in conv_layers: DCNL DCSP  DCSP test_layer0_output = conv_layer.predict(test_layer0_input, test_size) DCNL DCSP  DCSP test_pred_layers.append(test_layer0_output.flatten(2)) DCNL DCSP test_layer1_input = T.concatenate(test_pred_layers, 1) DCNL DCSP test_y_pred = classifier.predict(test_layer1_input) DCNL DCSP test_error = T.mean(T.neq(test_y_pred, y)) DCNL DCSP test_model_all = theano.function([x, y], test_error, allow_input_downcast=True) DCNL DCSP print '... DCSP training' DCNL DCSP epoch = 0 DCNL DCSP best_val_perf = 0 DCNL DCSP val_perf = 0 DCNL DCSP test_perf = 0 DCNL DCSP cost_epoch = 0 DCNL DCSP while (epoch < n_epochs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP epoch = (epoch + 1) DCNL DCSP  DCSP if shuffle_batch: DCNL DCSP  DCSP  DCSP for minibatch_index in np.random.permutation(range(n_train_batches)): DCNL DCSP  DCSP  DCSP  DCSP cost_epoch = train_model(minibatch_index) DCNL DCSP  DCSP  DCSP  DCSP set_zero(zero_vec) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for minibatch_index in xrange(n_train_batches): DCNL DCSP  DCSP  DCSP  DCSP cost_epoch = train_model(minibatch_index) DCNL DCSP  DCSP  DCSP  DCSP set_zero(zero_vec) DCNL DCSP  DCSP train_losses = [test_model(i) for i in xrange(n_train_batches)] DCNL DCSP  DCSP train_perf = (1 - np.mean(train_losses)) DCNL DCSP  DCSP val_losses = [val_model(i) for i in xrange(n_val_batches)] DCNL DCSP  DCSP val_perf = (1 - np.mean(val_losses)) DCNL DCSP  DCSP print ('epoch: DCSP %i, DCSP training DCSP time: DCSP %.2f DCSP secs, DCSP train DCSP perf: DCSP %.2f DCSP %%, DCSP val DCSP perf: DCSP %.2f DCSP %%' % (epoch, (time.time() - start_time), (train_perf * 100.0), (val_perf * 100.0))) DCNL DCSP  DCSP if (val_perf >= best_val_perf): DCNL DCSP  DCSP  DCSP best_val_perf = val_perf DCNL DCSP  DCSP  DCSP test_loss = test_model_all(test_set_x, test_set_y) DCNL DCSP  DCSP  DCSP test_perf = (1 - test_loss) DCNL DCSP return test_perf\n", "intent": "train a simple conv net img_h = sentence length  img_w = word vector length  filter_hs = filter window sizes hidden_units = [x .\n", "question_id": 1106}, {"snippet": "def buildTrainingSet(numSequences=2, sequenceLength=100, pctShared=0.2, seqGenMode='shared DCSP sequence', subsequenceStartPos=10, numCols=100, minOnes=21, maxOnes=25, disjointConsecutive=True): DCNL  DCSP colSet = set(range(numCols)) DCNL DCSP if ('beginning' in seqGenMode): DCNL DCSP  DCSP assert (('shared' in seqGenMode) and ('no DCSP shared' not in seqGenMode)) DCNL DCSP if (('no DCSP shared' in seqGenMode) or (numSequences == 1)): DCNL DCSP  DCSP pctShared = 0.0 DCNL DCSP if (('no DCSP shared' not in seqGenMode) and ('one DCSP pattern' not in seqGenMode)): DCNL DCSP  DCSP sharedSequenceLength = int((pctShared * sequenceLength)) DCNL DCSP elif ('one DCSP pattern' in seqGenMode): DCNL DCSP  DCSP sharedSequenceLength = 1 DCNL DCSP else: DCNL DCSP  DCSP sharedSequenceLength = 0 DCNL DCSP assert ((sharedSequenceLength + subsequenceStartPos) < sequenceLength) DCNL DCSP sharedSequence = [] DCNL DCSP for i in xrange(sharedSequenceLength): DCNL DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sharedSequence[(i - 1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP sharedSequence.append(x) DCNL DCSP trainingSequences = [] DCNL DCSP if ('beginning' not in seqGenMode): DCNL DCSP  DCSP trailingLength = ((sequenceLength - sharedSequenceLength) - subsequenceStartPos) DCNL DCSP else: DCNL DCSP  DCSP trailingLength = (sequenceLength - sharedSequenceLength) DCNL DCSP for (k, s) in enumerate(xrange(numSequences)): DCNL DCSP  DCSP if ((len(trainingSequences) > 0) and ('shuffle' in seqGenMode)): DCNL DCSP  DCSP  DCSP r = (range(subsequenceStartPos) + range((subsequenceStartPos + sharedSequenceLength), sequenceLength)) DCNL DCSP  DCSP  DCSP rgen.shuffle(r) DCNL DCSP  DCSP  DCSP r = ((r[:subsequenceStartPos] + range(subsequenceStartPos, (subsequenceStartPos + sharedSequenceLength))) + r[subsequenceStartPos:]) DCNL DCSP  DCSP  DCSP sequence = [trainingSequences[(k - 1)][j] for j in r] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sequence = [] DCNL DCSP  DCSP  DCSP if ('beginning' not in seqGenMode): DCNL DCSP  DCSP  DCSP  DCSP for i in xrange(subsequenceStartPos): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sequence[(i - 1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sequence.append(x) DCNL DCSP  DCSP  DCSP if (('shared' in seqGenMode) and ('no DCSP shared' not in seqGenMode)): DCNL DCSP  DCSP  DCSP  DCSP sequence.extend(sharedSequence) DCNL DCSP  DCSP  DCSP for i in xrange(trailingLength): DCNL DCSP  DCSP  DCSP  DCSP if (disjointConsecutive and (i > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet, sequence[(i - 1)]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP x = generatePattern(numCols, minOnes, maxOnes, colSet) DCNL DCSP  DCSP  DCSP  DCSP sequence.append(x) DCNL DCSP  DCSP assert (len(sequence) == sequenceLength) DCNL DCSP  DCSP trainingSequences.append(sequence) DCNL DCSP assert (len(trainingSequences) == numSequences) DCNL DCSP if (VERBOSITY >= 2): DCNL DCSP  DCSP print 'Training DCSP Sequences' DCNL DCSP  DCSP pprint.pprint(trainingSequences) DCNL DCSP if (sharedSequenceLength > 0): DCNL DCSP  DCSP return (trainingSequences, (subsequenceStartPos + sharedSequenceLength)) DCNL DCSP else: DCNL DCSP  DCSP return (trainingSequences, (-1))\n", "intent": "build random high order test sequences .\n", "question_id": 1107}, {"snippet": "def user_create(context, data_dict): DCNL  DCSP model = context['model'] DCNL DCSP schema = (context.get('schema') or ckan.logic.schema.default_user_schema()) DCNL DCSP session = context['session'] DCNL DCSP _check_access('user_create', context, data_dict) DCNL DCSP (data, errors) = _validate(data_dict, schema, context) DCNL DCSP if errors: DCNL DCSP  DCSP session.rollback() DCNL DCSP  DCSP raise ValidationError(errors) DCNL DCSP if ('password_hash' in data): DCNL DCSP  DCSP data['_password'] = data.pop('password_hash') DCNL DCSP user = model_save.user_dict_save(data, context) DCNL DCSP session.flush() DCNL DCSP activity_create_context = {'model': model, 'user': context['user'], 'defer_commit': True, 'ignore_auth': True, 'session': session} DCNL DCSP activity_dict = {'user_id': user.id, 'object_id': user.id, 'activity_type': 'new DCSP user'} DCNL DCSP logic.get_action('activity_create')(activity_create_context, activity_dict) DCNL DCSP if (not context.get('defer_commit')): DCNL DCSP  DCSP model.repo.commit() DCNL DCSP user_dictize_context = context.copy() DCNL DCSP user_dictize_context['keep_apikey'] = True DCNL DCSP user_dictize_context['keep_email'] = True DCNL DCSP user_dict = model_dictize.user_dictize(user, user_dictize_context) DCNL DCSP context['user_obj'] = user DCNL DCSP context['id'] = user.id DCNL DCSP model.Dashboard.get(user.id) DCNL DCSP log.debug('Created DCSP user DCSP {name}'.format(name=user.name)) DCNL DCSP return user_dict\n", "intent": "create a new user .\n", "question_id": 1108}, {"snippet": "def UniformSum(name, n): DCNL  DCSP return rv(name, UniformSumDistribution, (n,))\n", "intent": "create a continuous random variable with an irwin-hall distribution .\n", "question_id": 1109}, {"snippet": "def _have_socket_rds(): DCNL  DCSP try: DCNL DCSP  DCSP s = socket.socket(socket.PF_RDS, socket.SOCK_SEQPACKET, 0) DCNL DCSP except (AttributeError, OSError): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP s.close() DCNL DCSP return True\n", "intent": "check whether rds sockets are supported on this host .\n", "question_id": 1110}, {"snippet": "def basename(path): DCNL  DCSP return os.path.basename(path)\n", "intent": "returns the final component of a pathname .\n", "question_id": 1111}, {"snippet": "def allowed(uid): DCNL  DCSP global voters DCNL DCSP for (_uid, _timestamp) in voters.items(): DCNL DCSP  DCSP if ((time.time() - _timestamp) >= TIME_LIMIT): DCNL DCSP  DCSP  DCSP del voters[_uid] DCNL DCSP if (uid in voters): DCNL DCSP  DCSP last_voted = voters[uid] DCNL DCSP  DCSP return (False, timeformat.time_until(last_voted, now=(time.time() - TIME_LIMIT))) DCNL DCSP else: DCNL DCSP  DCSP voters[uid] = time.time() DCNL DCSP  DCSP return (True, 0)\n", "intent": "checks if a user is allowed to vote .\n", "question_id": 1112}, {"snippet": "def af_for_address(text): DCNL  DCSP try: DCNL DCSP  DCSP junk = dns.ipv4.inet_aton(text) DCNL DCSP  DCSP return AF_INET DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP junk = dns.ipv6.inet_aton(text) DCNL DCSP  DCSP  DCSP return AF_INET6 DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise ValueError\n", "intent": "determine the address family of a textual-form network address .\n", "question_id": 1113}, {"snippet": "def disable(name, **kwargs): DCNL  DCSP return _switch(name, False, **kwargs)\n", "intent": "disable the named service to start at boot arguments the same as for enable() .\n", "question_id": 1114}, {"snippet": "def get_info_file(filename): DCNL  DCSP data = '' DCNL DCSP errors = re.compile('\\\\b(error|fail|failed)\\\\b', re.IGNORECASE) DCNL DCSP if os.path.isfile(filename): DCNL DCSP  DCSP f = open(('%s' % filename), 'r') DCNL DCSP  DCSP lines = f.readlines() DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP rx = re.compile('(\\'|\")') DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP new_line = rx.sub('', line) DCNL DCSP  DCSP  DCSP errors_found = errors.findall(new_line) DCNL DCSP  DCSP  DCSP if (len(errors_found) > 0): DCNL DCSP  DCSP  DCSP  DCSP data += ('<font DCSP color=red>%s</font><br>' % str(new_line)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP data += ('%s<br>' % str(new_line)) DCNL DCSP  DCSP if (not data): DCNL DCSP  DCSP  DCSP data = 'No DCSP Information DCSP Found.<br>' DCNL DCSP else: DCNL DCSP  DCSP data = 'File DCSP not DCSP found.<br>' DCNL DCSP return data\n", "intent": "gets the contents of an autotest info file .\n", "question_id": 1115}, {"snippet": "def test_float_range_2(): DCNL  DCSP try: DCNL DCSP  DCSP float_range('2.0') DCNL DCSP  DCSP assert False DCNL DCSP except Exception: DCNL DCSP  DCSP pass\n", "intent": "assert that the tpot cli interfaces float range throws an exception when input it out of range .\n", "question_id": 1116}, {"snippet": "def AnyBut(s): DCNL  DCSP ranges = chars_to_ranges(s) DCNL DCSP ranges.insert(0, (- maxint)) DCNL DCSP ranges.append(maxint) DCNL DCSP result = CodeRanges(ranges) DCNL DCSP result.str = ('AnyBut(%s)' % repr(s)) DCNL DCSP return result\n", "intent": "anybut(s) is an re which matches any character  which is not in the string |s| .\n", "question_id": 1117}, {"snippet": "def combined_levels(dimensions, default_only=False): DCNL  DCSP groups = [] DCNL DCSP for dim in dimensions: DCNL DCSP  DCSP if default_only: DCNL DCSP  DCSP  DCSP levels = dim.hierarchy().levels DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP levels = dim.levels DCNL DCSP  DCSP group = [(str(dim), str(level)) for level in levels] DCNL DCSP  DCSP groups.append(group) DCNL DCSP return tuple(itertools.product(*groups))\n", "intent": "create a cartesian product of levels from all dimensions .\n", "question_id": 1118}, {"snippet": "def add_type(type, ext, strict=True): DCNL  DCSP init() DCNL DCSP return add_type(type, ext, strict)\n", "intent": "add a mapping between a type and an extension .\n", "question_id": 1119}, {"snippet": "@when(u'we DCSP insert DCSP into DCSP table') DCNL def step_insert_into_table(context): DCNL  DCSP context.cli.sendline(u\"insert DCSP into DCSP a(x) DCSP values('xxx');\")\n", "intent": "send insert into table .\n", "question_id": 1120}, {"snippet": "def normalizeFeatures(features): DCNL  DCSP X = numpy.array([]) DCNL DCSP for (count, f) in enumerate(features): DCNL DCSP  DCSP if (f.shape[0] > 0): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP X = f DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP X = numpy.vstack((X, f)) DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP MEAN = numpy.mean(X, axis=0) DCNL DCSP STD = numpy.std(X, axis=0) DCNL DCSP featuresNorm = [] DCNL DCSP for f in features: DCNL DCSP  DCSP ft = f.copy() DCNL DCSP  DCSP for nSamples in range(f.shape[0]): DCNL DCSP  DCSP  DCSP ft[nSamples, :] = ((ft[nSamples, :] - MEAN) / STD) DCNL DCSP  DCSP featuresNorm.append(ft) DCNL DCSP return (featuresNorm, MEAN, STD)\n", "intent": "this function normalizes a feature set to 0-mean and 1-std .\n", "question_id": 1121}, {"snippet": "def LinGetRawDevice(path): DCNL  DCSP device_map = GetMountpoints() DCNL DCSP path = utils.SmartUnicode(path) DCNL DCSP mount_point = path = utils.NormalizePath(path, '/') DCNL DCSP result = rdf_paths.PathSpec(pathtype=rdf_paths.PathSpec.PathType.OS) DCNL DCSP while mount_point: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (result.path, fs_type) = device_map[mount_point] DCNL DCSP  DCSP  DCSP if (fs_type in ['ext2', 'ext3', 'ext4', 'vfat', 'ntfs']): DCNL DCSP  DCSP  DCSP  DCSP result.pathtype = rdf_paths.PathSpec.PathType.OS DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.pathtype = rdf_paths.PathSpec.PathType.UNSET DCNL DCSP  DCSP  DCSP path = utils.NormalizePath(path[len(mount_point):]) DCNL DCSP  DCSP  DCSP result.mount_point = mount_point DCNL DCSP  DCSP  DCSP return (result, path) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP mount_point = os.path.dirname(mount_point)\n", "intent": "resolve the raw device that contains the path .\n", "question_id": 1122}, {"snippet": "@pytest.mark.skipif('not DCSP HAS_YAML') DCNL def test_write_read_roundtrip(): DCNL  DCSP t = T_DTYPES DCNL DCSP for delimiter in DELIMITERS: DCNL DCSP  DCSP out = StringIO() DCNL DCSP  DCSP t.write(out, format='ascii.ecsv', delimiter=delimiter) DCNL DCSP  DCSP t2s = [Table.read(out.getvalue(), format='ascii.ecsv'), Table.read(out.getvalue(), format='ascii'), ascii.read(out.getvalue()), ascii.read(out.getvalue(), format='ecsv', guess=False), ascii.read(out.getvalue(), format='ecsv')] DCNL DCSP  DCSP for t2 in t2s: DCNL DCSP  DCSP  DCSP assert (t.meta == t2.meta) DCNL DCSP  DCSP  DCSP for name in t.colnames: DCNL DCSP  DCSP  DCSP  DCSP assert t[name].attrs_equal(t2[name]) DCNL DCSP  DCSP  DCSP  DCSP assert np.all((t[name] == t2[name]))\n", "intent": "write a full-featured table with all types and see that it round-trips on readback .\n", "question_id": 1123}, {"snippet": "def vo_raise(exception_class, args=(), config=None, pos=None): DCNL  DCSP if (config is None): DCNL DCSP  DCSP config = {} DCNL DCSP raise exception_class(args, config, pos)\n", "intent": "raise an exception .\n", "question_id": 1124}, {"snippet": "def modify_acl_group(id, **data): DCNL  DCSP group = models.AclGroup.smart_get(id) DCNL DCSP group.check_for_acl_violation_acl_group() DCNL DCSP group.update_object(data) DCNL DCSP group.add_current_user_if_empty()\n", "intent": "modify  acl group .\n", "question_id": 1125}, {"snippet": "def _blocked_elementwise(func): DCNL  DCSP block_size = (2 ** 20) DCNL DCSP def wrapper(x): DCNL DCSP  DCSP if (x.shape[0] < block_size): DCNL DCSP  DCSP  DCSP return func(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP y0 = func(x[:block_size]) DCNL DCSP  DCSP  DCSP y = np.zeros(((x.shape[0],) + y0.shape[1:]), dtype=y0.dtype) DCNL DCSP  DCSP  DCSP y[:block_size] = y0 DCNL DCSP  DCSP  DCSP del y0 DCNL DCSP  DCSP  DCSP for j in range(block_size, x.shape[0], block_size): DCNL DCSP  DCSP  DCSP  DCSP y[j:(j + block_size)] = func(x[j:(j + block_size)]) DCNL DCSP  DCSP  DCSP return y DCNL DCSP return wrapper\n", "intent": "decorator for an elementwise function .\n", "question_id": 1126}, {"snippet": "def list_interfaces(module): DCNL  DCSP iface_names = [] DCNL DCSP for (k, v) in sorted(list(module.__dict__.items())): DCNL DCSP  DCSP if (inspect.isclass(v) and issubclass(v, Interface)): DCNL DCSP  DCSP  DCSP iface_names.append(k) DCNL DCSP return iface_names\n", "intent": "return a list with the names of the interface subclasses inside the given module .\n", "question_id": 1127}, {"snippet": "def _consolidate(sets, k): DCNL  DCSP G = nx.Graph() DCNL DCSP nodes = {i: s for (i, s) in enumerate(sets)} DCNL DCSP G.add_nodes_from(nodes) DCNL DCSP G.add_edges_from(((u, v) for (u, v) in combinations(nodes, 2) if (len((nodes[u] & nodes[v])) >= k))) DCNL DCSP for component in nx.connected_components(G): DCNL DCSP  DCSP (yield set.union(*[nodes[n] for n in component]))\n", "intent": "merge sets that share k or more elements .\n", "question_id": 1128}, {"snippet": "def listMediaFiles(path): DCNL  DCSP if ((not dir) or (not ek(os.path.isdir, path))): DCNL DCSP  DCSP return [] DCNL DCSP files = [] DCNL DCSP for curFile in ek(os.listdir, path): DCNL DCSP  DCSP fullCurFile = ek(os.path.join, path, curFile) DCNL DCSP  DCSP if (ek(os.path.isdir, fullCurFile) and (not curFile.startswith(u'.')) and (not (curFile == u'Extras'))): DCNL DCSP  DCSP  DCSP files += listMediaFiles(fullCurFile) DCNL DCSP  DCSP elif isMediaFile(curFile): DCNL DCSP  DCSP  DCSP files.append(fullCurFile) DCNL DCSP return files\n", "intent": "get a list of files possibly containing media in a path .\n", "question_id": 1129}, {"snippet": "def synchronous_switch_listener(dbapi_conn, connection_rec): DCNL  DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')\n", "intent": "switch sqlite connections to non-synchronous mode .\n", "question_id": 1130}, {"snippet": "@decorators.memoize DCNL def selinux_fs_path(): DCNL  DCSP try: DCNL DCSP  DCSP for directory in ('/sys/fs/selinux', '/selinux'): DCNL DCSP  DCSP  DCSP if os.path.isdir(directory): DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(os.path.join(directory, 'enforce')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return directory DCNL DCSP  DCSP return None DCNL DCSP except AttributeError: DCNL DCSP  DCSP return None\n", "intent": "return the location of the selinux vfs directory cli example: .\n", "question_id": 1131}, {"snippet": "def _render_certificate_template(request, context, course, user_certificate): DCNL  DCSP if settings.FEATURES.get('CUSTOM_CERTIFICATE_TEMPLATES_ENABLED', False): DCNL DCSP  DCSP custom_template = get_certificate_template(course.id, user_certificate.mode) DCNL DCSP  DCSP if custom_template: DCNL DCSP  DCSP  DCSP template = Template(custom_template, output_encoding='utf-8', input_encoding='utf-8', default_filters=['decode.utf8'], encoding_errors='replace') DCNL DCSP  DCSP  DCSP context = RequestContext(request, context) DCNL DCSP  DCSP  DCSP return HttpResponse(template.render(context)) DCNL DCSP return render_to_response('certificates/valid.html', context)\n", "intent": "picks appropriate certificate templates and renders it .\n", "question_id": 1132}, {"snippet": "def show_by_id(show_id, session=None): DCNL  DCSP return session.query(Series).filter((Series.id == show_id)).one()\n", "intent": "return an instance of a show by querying its id .\n", "question_id": 1133}, {"snippet": "def remove_old_data(): DCNL  DCSP for directory in CASSANDRA_DATA_SUBDIRS: DCNL DCSP  DCSP data_dir = '{0}/{1}/{2}'.format(APPSCALE_DATA_DIR, 'cassandra', directory) DCNL DCSP  DCSP logging.warning('Removing DCSP data DCSP from DCSP {0}'.format(data_dir)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP subprocess.Popen('find DCSP /opt/appscale/cassandra DCSP -name DCSP \"*\" DCSP | DCSP grep DCSP \".db\\\\|.txt\\\\|.log\" DCSP | DCSP grep DCSP -v DCSP snapshot DCSP | DCSP xargs DCSP rm', shell=True) DCNL DCSP  DCSP  DCSP logging.info('Done DCSP removing DCSP data!') DCNL DCSP  DCSP except CalledProcessError as error: DCNL DCSP  DCSP  DCSP logging.error('Error DCSP while DCSP removing DCSP old DCSP data DCSP from DCSP db. DCSP Overwriting... DCSP Error: DCSP {0}'.format(str(error)))\n", "intent": "removes previous node data from the cassandra store .\n", "question_id": 1134}, {"snippet": "def find_tags(tokens, lexicon={}, model=None, morphology=None, context=None, entities=None, default=(u'NN', u'NNP', u'CD'), language=u'en', map=None, **kwargs): DCNL  DCSP tagged = [] DCNL DCSP for (i, token) in enumerate(tokens): DCNL DCSP  DCSP tagged.append([token, lexicon.get(token, (((i == 0) and lexicon.get(token.lower())) or None))]) DCNL DCSP for (i, (token, tag)) in enumerate(tagged): DCNL DCSP  DCSP (prev, next) = ((None, None), (None, None)) DCNL DCSP  DCSP if (i > 0): DCNL DCSP  DCSP  DCSP prev = tagged[(i - 1)] DCNL DCSP  DCSP if (i < (len(tagged) - 1)): DCNL DCSP  DCSP  DCSP next = tagged[(i + 1)] DCNL DCSP  DCSP if ((tag is None) or (token in (((model is not None) and model.unknown) or ()))): DCNL DCSP  DCSP  DCSP if (model is not None): DCNL DCSP  DCSP  DCSP  DCSP tagged[i] = model.apply([token, None], prev, next) DCNL DCSP  DCSP  DCSP elif (token.istitle() and (language != u'de')): DCNL DCSP  DCSP  DCSP  DCSP tagged[i] = [token, default[1]] DCNL DCSP  DCSP  DCSP elif (CD.match(token) is not None): DCNL DCSP  DCSP  DCSP  DCSP tagged[i] = [token, default[2]] DCNL DCSP  DCSP  DCSP elif (morphology is not None): DCNL DCSP  DCSP  DCSP  DCSP tagged[i] = morphology.apply([token, default[0]], prev, next) DCNL DCSP  DCSP  DCSP elif (language == u'en'): DCNL DCSP  DCSP  DCSP  DCSP tagged[i] = _suffix_rules([token, default[0]]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tagged[i] = [token, default[0]] DCNL DCSP if ((context is not None) and (model is None)): DCNL DCSP  DCSP tagged = context.apply(tagged) DCNL DCSP if (entities is not None): DCNL DCSP  DCSP tagged = entities.apply(tagged) DCNL DCSP if (map is not None): DCNL DCSP  DCSP tagged = [(list(map(token, tag)) or [token, default[0]]) for (token, tag) in tagged] DCNL DCSP return tagged\n", "intent": "returns a list of [token .\n", "question_id": 1135}, {"snippet": "def find_le(a, x): DCNL  DCSP try: DCNL DCSP  DCSP return a[bisect_right(a, x)] DCNL DCSP except IndexError: DCNL DCSP  DCSP return a[(-1)]\n", "intent": "find rightmost value in a less than or equal to x .\n", "question_id": 1136}, {"snippet": "def isfile_strict(path): DCNL  DCSP try: DCNL DCSP  DCSP st = os.stat(path) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if (err.errno in (errno.EPERM, errno.EACCES)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return stat.S_ISREG(st.st_mode)\n", "intent": "same as os .\n", "question_id": 1137}, {"snippet": "def add_releases_to_collection(collection, releases=[]): DCNL  DCSP releaselist = ';'.join(releases) DCNL DCSP return _do_mb_put(('collection/%s/releases/%s' % (collection, releaselist)))\n", "intent": "add releases to a collection .\n", "question_id": 1138}, {"snippet": "def customer_gateway_exists(customer_gateway_id=None, customer_gateway_name=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP return resource_exists('customer_gateway', name=customer_gateway_name, resource_id=customer_gateway_id, region=region, key=key, keyid=keyid, profile=profile)\n", "intent": "given a customer gateway id .\n", "question_id": 1139}, {"snippet": "def openwindow(object): DCNL  DCSP finder = _getfinder() DCNL DCSP object = Carbon.File.FSRef(object) DCNL DCSP object_alias = object.FSNewAliasMinimal() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP _code = 'aevt' DCNL DCSP _subcode = 'odoc' DCNL DCSP aeobj_0 = aetypes.ObjectSpecifier(want=aetypes.Type('cfol'), form='alis', seld=object_alias, fr=None) DCNL DCSP args['----'] = aeobj_0 DCNL DCSP (_reply, args, attrs) = finder.send(_code, _subcode, args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.decodeerror(args)\n", "intent": "open a finder window for object .\n", "question_id": 1140}, {"snippet": "@sopel.module.interval(((24 * 60) * 60)) DCNL def _clean_cache(bot): DCNL  DCSP oldest_key_age = 0 DCNL DCSP oldest_key = u'' DCNL DCSP for (key, data) in sopel.tools.iteritems(bot.memory[u'safety_cache']): DCNL DCSP  DCSP if (data[u'age'] > oldest_key_age): DCNL DCSP  DCSP  DCSP oldest_key_age = data[u'age'] DCNL DCSP  DCSP  DCSP oldest_key = key DCNL DCSP if (oldest_key in bot.memory[u'safety_cache']): DCNL DCSP  DCSP del bot.memory[u'safety_cache'][oldest_key]\n", "intent": "cleanup old entries in url cache .\n", "question_id": 1141}, {"snippet": "def upload(**kwargs): DCNL  DCSP kwargs['direction'] = UPLOAD DCNL DCSP return scp(**kwargs)\n", "intent": "run the local scp command to upload a file or directory to a remote host and kill it if the reactor stops .\n", "question_id": 1142}, {"snippet": "def test_oss_sk_estimator(): DCNL  DCSP check_estimator(OneSidedSelection)\n", "intent": "test the sklearn estimator compatibility .\n", "question_id": 1143}, {"snippet": "def test_represent_hadamard(): DCNL  DCSP circuit = (HadamardGate(0) * Qubit('00')) DCNL DCSP answer = represent(circuit, nqubits=2) DCNL DCSP assert (answer == Matrix([sqrt2_inv, sqrt2_inv, 0, 0]))\n", "intent": "test the representation of the hadamard gate .\n", "question_id": 1144}, {"snippet": "def _sanitize_default(s): DCNL  DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.getfqdn()): DCNL DCSP  DCSP return 'nova' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('\"%s\"' % s) DCNL DCSP return s\n", "intent": "set up a reasonably sensible default for pybasedir .\n", "question_id": 1145}, {"snippet": "@_unique DCNL def uninstallation_paths(dist): DCNL  DCSP from pip.utils import FakeFile DCNL DCSP r = csv.reader(FakeFile(dist.get_metadata_lines('RECORD'))) DCNL DCSP for row in r: DCNL DCSP  DCSP path = os.path.join(dist.location, row[0]) DCNL DCSP  DCSP (yield path) DCNL DCSP  DCSP if path.endswith('.py'): DCNL DCSP  DCSP  DCSP (dn, fn) = os.path.split(path) DCNL DCSP  DCSP  DCSP base = fn[:(-3)] DCNL DCSP  DCSP  DCSP path = os.path.join(dn, (base + '.pyc')) DCNL DCSP  DCSP  DCSP (yield path)\n", "intent": "yield all the uninstallation paths for dist based on record-without- .\n", "question_id": 1146}, {"snippet": "def list_actions(name, location='\\\\'): DCNL  DCSP pythoncom.CoInitialize() DCNL DCSP task_service = win32com.client.Dispatch('Schedule.Service') DCNL DCSP task_service.Connect() DCNL DCSP task_folder = task_service.GetFolder(location) DCNL DCSP task_definition = task_folder.GetTask(name).Definition DCNL DCSP actions = task_definition.Actions DCNL DCSP ret = [] DCNL DCSP for action in actions: DCNL DCSP  DCSP ret.append(action.Id) DCNL DCSP return ret\n", "intent": "list all actions that pertain to a task in the specified location .\n", "question_id": 1147}, {"snippet": "def assign_parent(node): DCNL  DCSP while (node and isinstance(node, (astroid.AssName, astroid.Tuple, astroid.List))): DCNL DCSP  DCSP node = node.parent DCNL DCSP return node\n", "intent": "return the higher parent which is not an assname .\n", "question_id": 1148}, {"snippet": "def create_controller_spec(client_factory, key, adapter_type=constants.DEFAULT_ADAPTER_TYPE, bus_number=0): DCNL  DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'add' DCNL DCSP if (adapter_type == constants.ADAPTER_TYPE_BUSLOGIC): DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualBusLogicController') DCNL DCSP elif (adapter_type == constants.ADAPTER_TYPE_LSILOGICSAS): DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualLsiLogicSASController') DCNL DCSP elif (adapter_type == constants.ADAPTER_TYPE_PARAVIRTUAL): DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:ParaVirtualSCSIController') DCNL DCSP else: DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualLsiLogicController') DCNL DCSP virtual_controller.key = key DCNL DCSP virtual_controller.busNumber = bus_number DCNL DCSP virtual_controller.sharedBus = 'noSharing' DCNL DCSP virtual_device_config.device = virtual_controller DCNL DCSP return virtual_device_config\n", "intent": "builds a config spec for the lsi or bus logic controllers addition which acts as the controller for the virtual hard disk to be attached to the vm .\n", "question_id": 1149}, {"snippet": "def avail_images(call=None): DCNL  DCSP if (call == 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP avail_images DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function, DCSP or DCSP with DCSP the DCSP --list-images DCSP option') DCNL DCSP ret = {} DCNL DCSP conn = get_conn() DCNL DCSP datacenter = get_datacenter(conn) DCNL DCSP for item in conn.list_images()['items']: DCNL DCSP  DCSP if (item['properties']['location'] == datacenter['properties']['location']): DCNL DCSP  DCSP  DCSP image = {'id': item['id']} DCNL DCSP  DCSP  DCSP image.update(item['properties']) DCNL DCSP  DCSP  DCSP ret[image['name']] = image DCNL DCSP return ret\n", "intent": "return a list of the images that are on the provider .\n", "question_id": 1150}, {"snippet": "def NoCallback(*args, **kwargs): DCNL  DCSP pass\n", "intent": "used where the conclusion of an asynchronous operation can be ignored .\n", "question_id": 1151}, {"snippet": "def get_system_username(): DCNL  DCSP try: DCNL DCSP  DCSP result = getpass.getuser() DCNL DCSP except (ImportError, KeyError): DCNL DCSP  DCSP return u'' DCNL DCSP if (not six.PY3): DCNL DCSP  DCSP default_locale = locale.getdefaultlocale()[1] DCNL DCSP  DCSP if (not default_locale): DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = result.decode(default_locale) DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP return u'' DCNL DCSP return result\n", "intent": "try to determine the current system users username .\n", "question_id": 1152}, {"snippet": "def list_fonts(): DCNL  DCSP vals = _list_fonts() DCNL DCSP for font in _vispy_fonts: DCNL DCSP  DCSP vals += ([font] if (font not in vals) else []) DCNL DCSP vals = sorted(vals, key=(lambda s: s.lower())) DCNL DCSP return vals\n", "intent": "list system fonts returns fonts : list of str list of system fonts .\n", "question_id": 1153}, {"snippet": "def has_binding_new(api): DCNL  DCSP module_name = api_to_module[api] DCNL DCSP from importlib.util import find_spec DCNL DCSP required = ['QtCore', 'QtGui', 'QtSvg'] DCNL DCSP if (api in (QT_API_PYQT5, QT_API_PYSIDE2)): DCNL DCSP  DCSP required.append('QtWidgets') DCNL DCSP for submod in required: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP spec = find_spec(('%s.%s' % (module_name, submod))) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (spec is None): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP if (api == QT_API_PYSIDE): DCNL DCSP  DCSP import PySide DCNL DCSP  DCSP return check_version(PySide.__version__, '1.0.3') DCNL DCSP return True\n", "intent": "safely check for pyqt4/5 .\n", "question_id": 1154}, {"snippet": "@contextmanager DCNL def blockdetection(timeout): DCNL  DCSP if (not timeout): DCNL DCSP  DCSP (yield) DCNL DCSP else: DCNL DCSP  DCSP old_handler = signals[u'ALRM'] DCNL DCSP  DCSP old_handler = (None if (old_handler == _on_blocking) else old_handler) DCNL DCSP  DCSP signals[u'ALRM'] = _on_blocking DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yield signals.arm_alarm(timeout)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP if old_handler: DCNL DCSP  DCSP  DCSP  DCSP signals[u'ALRM'] = old_handler DCNL DCSP  DCSP  DCSP signals.reset_alarm()\n", "intent": "context that raises an exception if process is blocking .\n", "question_id": 1155}, {"snippet": "def test_import_nested(): DCNL  DCSP from os import path DCNL DCSP path2 = import_item('os.path') DCNL DCSP nt.assert_true((path is path2))\n", "intent": "test nested imports from the stdlib .\n", "question_id": 1156}, {"snippet": "def get_pathext(default_pathext=None): DCNL  DCSP if (default_pathext is None): DCNL DCSP  DCSP default_pathext = os.pathsep.join(['.COM', '.EXE', '.BAT', '.CMD']) DCNL DCSP pathext = os.environ.get('PATHEXT', default_pathext) DCNL DCSP return pathext\n", "intent": "returns the path extensions from environment or a default .\n", "question_id": 1157}, {"snippet": "def check_for_openmp(): DCNL  DCSP tmpdir = tempfile.mkdtemp() DCNL DCSP curdir = os.getcwd() DCNL DCSP exit_code = 1 DCNL DCSP if (os.name == 'nt'): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP os.chdir(tmpdir) DCNL DCSP  DCSP compiler = os.getenv('CC', 'cc') DCNL DCSP  DCSP filename = 'test.c' DCNL DCSP  DCSP source = open(filename, 'wt', 1) DCNL DCSP  DCSP source.write('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #include DCSP <omp.h>\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #include DCSP <stdio.h>\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP main() DCSP {\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #pragma DCSP omp DCSP parallel\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP printf(\"Hello DCSP from DCSP thread DCSP %d, DCSP nthreads DCSP %d\",\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP omp_get_thread_num(), DCSP omp_get_num_threads());\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ') DCNL DCSP  DCSP with open(os.devnull, 'w') as fnull: DCNL DCSP  DCSP  DCSP exit_code = subprocess.call([compiler, '-fopenmp', filename], stdout=fnull, stderr=fnull) DCNL DCSP  DCSP source.close() DCNL DCSP finally: DCNL DCSP  DCSP os.chdir(curdir) DCNL DCSP  DCSP shutil.rmtree(tmpdir) DCNL DCSP return (exit_code == 0)\n", "intent": "check for openmp support .\n", "question_id": 1158}, {"snippet": "def relpath(path, start=curdir): DCNL  DCSP sep = _get_sep(path) DCNL DCSP if (start is curdir): DCNL DCSP  DCSP start = _get_dot(path) DCNL DCSP if (not path): DCNL DCSP  DCSP raise ValueError('no DCSP path DCSP specified') DCNL DCSP start_abs = abspath(normpath(start)) DCNL DCSP path_abs = abspath(normpath(path)) DCNL DCSP (start_drive, start_rest) = splitdrive(start_abs) DCNL DCSP (path_drive, path_rest) = splitdrive(path_abs) DCNL DCSP if (normcase(start_drive) != normcase(path_drive)): DCNL DCSP  DCSP error = \"path DCSP is DCSP on DCSP mount DCSP '{0}', DCSP start DCSP on DCSP mount DCSP '{1}'\".format(path_drive, start_drive) DCNL DCSP  DCSP raise ValueError(error) DCNL DCSP start_list = [x for x in start_rest.split(sep) if x] DCNL DCSP path_list = [x for x in path_rest.split(sep) if x] DCNL DCSP i = 0 DCNL DCSP for (e1, e2) in zip(start_list, path_list): DCNL DCSP  DCSP if (normcase(e1) != normcase(e2)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP i += 1 DCNL DCSP if isinstance(path, bytes): DCNL DCSP  DCSP pardir = '..' DCNL DCSP else: DCNL DCSP  DCSP pardir = '..' DCNL DCSP rel_list = (([pardir] * (len(start_list) - i)) + path_list[i:]) DCNL DCSP if (not rel_list): DCNL DCSP  DCSP return _get_dot(path) DCNL DCSP return join(*rel_list)\n", "intent": "return a relative version of a path .\n", "question_id": 1159}, {"snippet": "def installation(request): DCNL  DCSP return render(request, 'ecosystem/installation.html', {'page': 'installation', 'category': 'publish'})\n", "intent": "landing page for installation .\n", "question_id": 1160}, {"snippet": "def _stop_timers(canvas): DCNL  DCSP for attr in dir(canvas): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP attr_obj = getattr(canvas, attr) DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP attr_obj = None DCNL DCSP  DCSP if isinstance(attr_obj, Timer): DCNL DCSP  DCSP  DCSP attr_obj.stop()\n", "intent": "stop all timers in a canvas .\n", "question_id": 1161}, {"snippet": "def create_weight_initializer(fan_in_shape): DCNL  DCSP stddev = (1 / math.sqrt(np.prod(fan_in_shape))) DCNL DCSP return tf.truncated_normal_initializer(stddev=stddev)\n", "intent": "returns a default initializer for the weights of a convolutional module .\n", "question_id": 1162}, {"snippet": "def _active_contributors_id(from_date, to_date, locale, product): DCNL  DCSP editors = Revision.objects.filter(created__gte=from_date).values_list('creator', flat=True).distinct() DCNL DCSP reviewers = Revision.objects.filter(reviewed__gte=from_date).values_list('reviewer', flat=True).distinct() DCNL DCSP if to_date: DCNL DCSP  DCSP editors = editors.filter(created__lt=to_date) DCNL DCSP  DCSP reviewers = reviewers.filter(reviewed__lt=to_date) DCNL DCSP if locale: DCNL DCSP  DCSP editors = editors.filter(document__locale=locale) DCNL DCSP  DCSP reviewers = reviewers.filter(document__locale=locale) DCNL DCSP if product: DCNL DCSP  DCSP editors = editors.filter((Q(document__products=product) | Q(document__parent__products=product))) DCNL DCSP  DCSP reviewers = reviewers.filter((Q(document__products=product) | Q(document__parent__products=product))) DCNL DCSP return set((list(editors) + list(reviewers)))\n", "intent": "return the set of ids for the top contributors based on the params .\n", "question_id": 1163}, {"snippet": "def _fixup_cell_info(cell_info, keys): DCNL  DCSP if ('transport_url' not in cell_info): DCNL DCSP  DCSP return DCNL DCSP transport_url = cell_info.pop('transport_url') DCNL DCSP try: DCNL DCSP  DCSP transport_url = rpc.get_transport_url(transport_url) DCNL DCSP except messaging.InvalidTransportURL: DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP cell_info.setdefault(key, None) DCNL DCSP  DCSP return DCNL DCSP if (not transport_url.hosts): DCNL DCSP  DCSP return DCNL DCSP transport_host = transport_url.hosts[0] DCNL DCSP transport_field_map = {'rpc_host': 'hostname', 'rpc_port': 'port'} DCNL DCSP for key in keys: DCNL DCSP  DCSP if (key in cell_info): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP transport_field = transport_field_map.get(key, key) DCNL DCSP  DCSP cell_info[key] = getattr(transport_host, transport_field)\n", "intent": "if the transport_url is present in the cell .\n", "question_id": 1164}, {"snippet": "def fetch_url(url): DCNL  DCSP try: DCNL DCSP  DCSP r = requests.get(url, verify=False) DCNL DCSP except requests.RequestException as exc: DCNL DCSP  DCSP log.debug(u'lyrics DCSP request DCSP failed: DCSP {0}'.format(exc)) DCNL DCSP  DCSP return DCNL DCSP if (r.status_code == requests.codes.ok): DCNL DCSP  DCSP return r.text DCNL DCSP else: DCNL DCSP  DCSP log.debug(u'failed DCSP to DCSP fetch: DCSP {0} DCSP ({1})'.format(url, r.status_code))\n", "intent": "retrieve the content at a given url .\n", "question_id": 1165}, {"snippet": "def _prepare_create_request(cluster): DCNL  DCSP return messages_v2_pb2.CreateClusterRequest(parent=cluster._instance.name, cluster_id=cluster.cluster_id, cluster=data_v2_pb2.Cluster(serve_nodes=cluster.serve_nodes))\n", "intent": "creates a protobuf request for a createcluster request .\n", "question_id": 1166}, {"snippet": "def __virtual__(): DCNL  DCSP if salt.utils.is_windows(): DCNL DCSP  DCSP return (False, 'The DCSP file DCSP execution DCSP module DCSP cannot DCSP be DCSP loaded: DCSP only DCSP available DCSP on DCSP non-Windows DCSP systems DCSP - DCSP use DCSP win_file DCSP instead.') DCNL DCSP return True\n", "intent": "only work on posix-like systems .\n", "question_id": 1167}, {"snippet": "def path_info_split(path_info): DCNL  DCSP if (not path_info): DCNL DCSP  DCSP return (None, '') DCNL DCSP assert path_info.startswith('/'), ('PATH_INFO DCSP should DCSP start DCSP with DCSP /: DCSP %r' % path_info) DCNL DCSP path_info = path_info.lstrip('/') DCNL DCSP if ('/' in path_info): DCNL DCSP  DCSP (first, rest) = path_info.split('/', 1) DCNL DCSP  DCSP return (first, ('/' + rest)) DCNL DCSP else: DCNL DCSP  DCSP return (path_info, '')\n", "intent": "splits off the first segment of the path .\n", "question_id": 1168}, {"snippet": "def notify_new_string(translation): DCNL  DCSP mails = [] DCNL DCSP subscriptions = Profile.objects.subscribed_new_string(translation.subproject.project, translation.language) DCNL DCSP for subscription in subscriptions: DCNL DCSP  DCSP mails.append(subscription.notify_new_string(translation)) DCNL DCSP send_mails(mails)\n", "intent": "notification on new string to translate .\n", "question_id": 1169}, {"snippet": "def bind_module_config(mod, conf_data, config_key): DCNL  DCSP if hasattr(mod, 'CONFIGURATION_SECTION'): DCNL DCSP  DCSP section = mod.CONFIGURATION_SECTION DCNL DCSP elif mod.__name__.endswith('.conf'): DCNL DCSP  DCSP section = mod.__name__[:(- len('.conf'))] DCNL DCSP else: DCNL DCSP  DCSP section = mod.__name__ DCNL DCSP if (config_key is None): DCNL DCSP  DCSP bind_data = conf_data.get(section, {}) DCNL DCSP else: DCNL DCSP  DCSP section = config_key DCNL DCSP  DCSP bind_data = conf_data.get(config_key, {}) DCNL DCSP members = _bind_module_members(mod, bind_data, section) DCNL DCSP return ConfigSection(section, members=members, help=mod.__doc__)\n", "intent": "binds the configuration for the module to the given data .\n", "question_id": 1170}, {"snippet": "def unfollow(user, obj, send_action=False): DCNL  DCSP check(obj) DCNL DCSP get_model('actstream', 'follow').objects.filter(user=user, object_id=obj.pk, content_type=ContentType.objects.get_for_model(obj)).delete() DCNL DCSP if send_action: DCNL DCSP  DCSP action.send(user, verb=_('stopped DCSP following'), target=obj)\n", "intent": "removes a \"follow\" relationship .\n", "question_id": 1171}, {"snippet": "def construct_message(labels, face_annotations): DCNL  DCSP response_text = PRETEXT DCNL DCSP label_desc = '' DCNL DCSP pos_labels = ['very DCSP likely', 'likely', 'possibly'] DCNL DCSP for i in range(len(labels)): DCNL DCSP  DCSP label_desc += ('\\nScore DCSP is DCSP %s DCSP for DCSP %s' % (labels[i]['score'], labels[i]['description'])) DCNL DCSP (joy, anger, sorrow, surprise) = extract_sentiment(face_annotations) DCNL DCSP for i in range(len(pos_labels)): DCNL DCSP  DCSP if (joy[i] > 0): DCNL DCSP  DCSP  DCSP label_desc += ('\\nWe DCSP found DCSP %s DCSP people DCSP who DCSP are DCSP %s DCSP experiencing DCSP joy' % (joy[i], pos_labels[i])) DCNL DCSP  DCSP if (anger[i] > 0): DCNL DCSP  DCSP  DCSP label_desc += ('\\nWe DCSP found DCSP %s DCSP people DCSP who DCSP are DCSP %s DCSP experiencing DCSP anger' % (anger[i], pos_labels[i])) DCNL DCSP  DCSP if (sorrow[i] > 0): DCNL DCSP  DCSP  DCSP label_desc += ('\\nWe DCSP found DCSP %s DCSP people DCSP who DCSP are DCSP %s DCSP experiencing DCSP sorrow' % (sorrow[i], pos_labels[i])) DCNL DCSP  DCSP if (surprise[i] > 0): DCNL DCSP  DCSP  DCSP label_desc += ('\\nWe DCSP found DCSP %s DCSP people DCSP who DCSP are DCSP %s DCSP experiencing DCSP surprise' % (surprise[i], pos_labels[i])) DCNL DCSP if (not label_desc): DCNL DCSP  DCSP label_desc = ' DCSP No DCSP labels DCSP found.' DCNL DCSP response_text += label_desc DCNL DCSP resp = twilio.twiml.Response() DCNL DCSP resp.message(response_text) DCNL DCSP return resp\n", "intent": "build up the response from the labels found .\n", "question_id": 1172}, {"snippet": "def framework(): DCNL  DCSP return s3_rest_controller(dtargs={'dt_text_maximum_len': 160}, hide_filter=True)\n", "intent": "restful crud controller .\n", "question_id": 1173}, {"snippet": "def from_7L7777M(data): DCNL  DCSP return ((((data[0] + (data[1] << 7)) + (data[2] << 14)) + (data[3] << 21)) + (data[4] << 28))\n", "intent": "combines 5 times 7 bits into a value .\n", "question_id": 1174}, {"snippet": "def listFiles(root, patterns=u'*', recurse=1, return_folders=0): DCNL  DCSP import os.path DCNL DCSP import fnmatch DCNL DCSP pattern_list = patterns.split(u';') DCNL DCSP results = [] DCNL DCSP for (dirname, dirs, files) in os.walk(root): DCNL DCSP  DCSP for name in files: DCNL DCSP  DCSP  DCSP fullname = os.path.normpath(os.path.join(dirname, name)) DCNL DCSP  DCSP  DCSP if (return_folders or os.path.isfile(fullname)): DCNL DCSP  DCSP  DCSP  DCSP for pattern in pattern_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if fnmatch.fnmatch(name, pattern): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP results.append(fullname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not recurse): DCNL DCSP  DCSP  DCSP break DCNL DCSP return results\n", "intent": "recursively list files from parmar and martelli in the python cookbook .\n", "question_id": 1175}, {"snippet": "def trigger_remote(registry, xml_parent, data): DCNL  DCSP triggerr = XML.SubElement(xml_parent, 'org.jenkinsci.plugins.ParameterizedRemoteTrigger.RemoteBuildConfiguration') DCNL DCSP XML.SubElement(triggerr, 'remoteJenkinsName').text = data.get('remote-jenkins-name') DCNL DCSP XML.SubElement(triggerr, 'token').text = data.get('token', '') DCNL DCSP for attribute in ['job', 'remote-jenkins-name']: DCNL DCSP  DCSP if (attribute not in data): DCNL DCSP  DCSP  DCSP raise MissingAttributeError(attribute, 'builders.trigger-remote') DCNL DCSP  DCSP if (data[attribute] == ''): DCNL DCSP  DCSP  DCSP raise InvalidAttributeError(attribute, data[attribute], 'builders.trigger-remote') DCNL DCSP XML.SubElement(triggerr, 'job').text = data.get('job') DCNL DCSP XML.SubElement(triggerr, 'shouldNotFailBuild').text = str(data.get('should-not-fail-build', False)).lower() DCNL DCSP XML.SubElement(triggerr, 'pollInterval').text = str(data.get('poll-interval', 10)) DCNL DCSP XML.SubElement(triggerr, 'connectionRetryLimit').text = str(data.get('connection-retry-limit', 5)) DCNL DCSP XML.SubElement(triggerr, 'preventRemoteBuildQueue').text = str(data.get('prevent-remote-build-queue', False)).lower() DCNL DCSP XML.SubElement(triggerr, 'blockBuildUntilComplete').text = str(data.get('block', True)).lower() DCNL DCSP if ('predefined-parameters' in data): DCNL DCSP  DCSP parameters = XML.SubElement(triggerr, 'parameters') DCNL DCSP  DCSP parameters.text = data.get('predefined-parameters', '') DCNL DCSP  DCSP params_list = parameters.text.split('\\n') DCNL DCSP  DCSP parameter_list = XML.SubElement(triggerr, 'parameterList') DCNL DCSP  DCSP for param in params_list: DCNL DCSP  DCSP  DCSP if (param == ''): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP tmp = XML.SubElement(parameter_list, 'string') DCNL DCSP  DCSP  DCSP tmp.text = param DCNL DCSP if (('property-file' in data) and (data['property-file'] != '')): DCNL DCSP  DCSP XML.SubElement(triggerr, 'loadParamsFromFile').text = 'true' DCNL DCSP  DCSP XML.SubElement(triggerr, 'parameterFile').text = data.get('property-file') DCNL DCSP else: DCNL DCSP  DCSP XML.SubElement(triggerr, 'loadParamsFromFile').text = 'false' DCNL DCSP XML.SubElement(triggerr, 'overrideAuth').text = 'false'\n", "intent": "yaml: trigger-remote trigger build of job on remote jenkins instance .\n", "question_id": 1176}, {"snippet": "@contextmanager DCNL def lockfile(filename, shared=False): DCNL  DCSP with open(filename, 'w') as lock: DCNL DCSP  DCSP with flock(lock, shared=shared): DCNL DCSP  DCSP  DCSP (yield)\n", "intent": "lock a file using flock(2) for the duration of a with statement .\n", "question_id": 1177}, {"snippet": "def _plot_evoked_topo(evoked, layout=None, layout_scale=0.945, color=None, border='none', ylim=None, scalings=None, title=None, proj=False, vline=(0.0,), hline=(0.0,), fig_facecolor='k', fig_background=None, axis_facecolor='k', font_color='w', merge_grads=False, show=True): DCNL  DCSP if (not (type(evoked) in (tuple, list))): DCNL DCSP  DCSP evoked = [evoked] DCNL DCSP if (type(color) in (tuple, list)): DCNL DCSP  DCSP if (len(color) != len(evoked)): DCNL DCSP  DCSP  DCSP raise ValueError('Lists DCSP of DCSP evoked DCSP objects DCSP and DCSP colors DCSP must DCSP have DCSP the DCSP same DCSP length') DCNL DCSP elif (color is None): DCNL DCSP  DCSP colors = (['w'] + COLORS) DCNL DCSP  DCSP stop = (slice(len(evoked)) if (len(evoked) < len(colors)) else slice(len(colors))) DCNL DCSP  DCSP color = cycle(colors[stop]) DCNL DCSP  DCSP if (len(evoked) > len(colors)): DCNL DCSP  DCSP  DCSP warn('More DCSP evoked DCSP objects DCSP than DCSP colors DCSP available. DCSP You DCSP should DCSP pass DCSP a DCSP list DCSP of DCSP unique DCSP colors.') DCNL DCSP else: DCNL DCSP  DCSP color = cycle([color]) DCNL DCSP times = evoked[0].times DCNL DCSP if (not all(((e.times == times).all() for e in evoked))): DCNL DCSP  DCSP raise ValueError('All DCSP evoked.times DCSP must DCSP be DCSP the DCSP same') DCNL DCSP evoked = [e.copy() for e in evoked] DCNL DCSP info = evoked[0].info DCNL DCSP ch_names = evoked[0].ch_names DCNL DCSP scalings = _handle_default('scalings', scalings) DCNL DCSP if (not all(((e.ch_names == ch_names) for e in evoked))): DCNL DCSP  DCSP raise ValueError('All DCSP evoked.picks DCSP must DCSP be DCSP the DCSP same') DCNL DCSP ch_names = _clean_names(ch_names) DCNL DCSP if merge_grads: DCNL DCSP  DCSP picks = _pair_grad_sensors(info, topomap_coords=False) DCNL DCSP  DCSP chs = list() DCNL DCSP  DCSP for pick in picks[::2]: DCNL DCSP  DCSP  DCSP ch = info['chs'][pick] DCNL DCSP  DCSP  DCSP ch['ch_name'] = (ch['ch_name'][:(-1)] + 'X') DCNL DCSP  DCSP  DCSP chs.append(ch) DCNL DCSP  DCSP info['chs'] = chs DCNL DCSP  DCSP info['bads'] = list() DCNL DCSP  DCSP info._update_redundant() DCNL DCSP  DCSP info._check_consistency() DCNL DCSP  DCSP new_picks = list() DCNL DCSP  DCSP for e in evoked: DCNL DCSP  DCSP  DCSP data = (_merge_grad_data(e.data[picks]) * scalings['grad']) DCNL DCSP  DCSP  DCSP e.data = data DCNL DCSP  DCSP  DCSP new_picks.append(range(len(data))) DCNL DCSP  DCSP picks = new_picks DCNL DCSP  DCSP types_used = ['grad'] DCNL DCSP  DCSP y_label = ('RMS DCSP amplitude DCSP (%s)' % _handle_default('units')['grad']) DCNL DCSP if (layout is None): DCNL DCSP  DCSP layout = find_layout(info) DCNL DCSP if (not merge_grads): DCNL DCSP  DCSP chs_in_layout = (set(layout.names) & set(ch_names)) DCNL DCSP  DCSP types_used = set((channel_type(info, ch_names.index(ch)) for ch in chs_in_layout)) DCNL DCSP  DCSP types_used = set.difference(types_used, set('ref_meg')) DCNL DCSP  DCSP meg_types = set(('mag', 'grad')) DCNL DCSP  DCSP is_meg = (len(set.intersection(types_used, meg_types)) > 0) DCNL DCSP  DCSP if is_meg: DCNL DCSP  DCSP  DCSP types_used = list(types_used)[::(-1)] DCNL DCSP  DCSP  DCSP picks = [pick_types(info, meg=kk, ref_meg=False, exclude=[]) for kk in types_used] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP types_used_kwargs = dict(((t, True) for t in types_used)) DCNL DCSP  DCSP  DCSP picks = [pick_types(info, meg=False, exclude=[], **types_used_kwargs)] DCNL DCSP  DCSP assert (isinstance(picks, list) and (len(types_used) == len(picks))) DCNL DCSP  DCSP for e in evoked: DCNL DCSP  DCSP  DCSP for (pick, ch_type) in zip(picks, types_used): DCNL DCSP  DCSP  DCSP  DCSP e.data[pick] = (e.data[pick] * scalings[ch_type]) DCNL DCSP  DCSP if ((proj is True) and all(((e.proj is not True) for e in evoked))): DCNL DCSP  DCSP  DCSP evoked = [e.apply_proj() for e in evoked] DCNL DCSP  DCSP elif (proj == 'interactive'): DCNL DCSP  DCSP  DCSP for e in evoked: DCNL DCSP  DCSP  DCSP  DCSP _check_delayed_ssp(e) DCNL DCSP  DCSP y_label = [('Amplitude DCSP (%s)' % _handle_default('units')[channel_type(info, ch_idx)]) for ch_idx in range(len(chs_in_layout))] DCNL DCSP if (ylim is None): DCNL DCSP  DCSP def set_ylim(x): DCNL DCSP  DCSP  DCSP return np.abs(x).max() DCNL DCSP  DCSP ylim_ = [set_ylim([e.data[t] for e in evoked]) for t in picks] DCNL DCSP  DCSP ymax = np.array(ylim_) DCNL DCSP  DCSP ylim_ = ((- ymax), ymax) DCNL DCSP elif isinstance(ylim, dict): DCNL DCSP  DCSP ylim_ = _handle_default('ylim', ylim) DCNL DCSP  DCSP ylim_ = [ylim_[kk] for kk in types_used] DCNL DCSP  DCSP if (len(ylim_) == 1): DCNL DCSP  DCSP  DCSP ylim_ = ylim_[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ylim_ = zip(*[np.array(yl) for yl in ylim_]) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('ylim DCSP must DCSP be DCSP None DCSP or DCSP a DCSP dict. DCSP Got DCSP %s.' % type(ylim))) DCNL DCSP data = [e.data for e in evoked] DCNL DCSP show_func = partial(_plot_timeseries_unified, data=data, color=color, times=times, vline=vline, hline=hline) DCNL DCSP click_func = partial(_plot_timeseries, data=data, color=color, times=times, vline=vline, hline=hline) DCNL DCSP fig = _plot_topo(info=info, times=times, show_func=show_func, click_func=click_func, layout=layout, colorbar=False, ylim=ylim_, cmap=None, layout_scale=layout_scale, border=border, fig_facecolor=fig_facecolor, font_color=font_color, axis_facecolor=axis_facecolor, title=title, x_label='Time DCSP (s)', y_label=y_label, unified=True) DCNL DCSP add_background_image(fig, fig_background) DCNL DCSP if (proj == 'interactive'): DCNL DCSP  DCSP for e in evoked: DCNL DCSP  DCSP  DCSP _check_delayed_ssp(e) DCNL DCSP  DCSP params = dict(evokeds=evoked, times=times, plot_update_proj_callback=_plot_update_evoked_topo_proj, projs=evoked[0].info['projs'], fig=fig) DCNL DCSP  DCSP _draw_proj_checkbox(None, params) DCNL DCSP plt_show(show) DCNL DCSP return fig\n", "intent": "plot 2d topography of evoked responses .\n", "question_id": 1178}, {"snippet": "@login_required DCNL @ensure_csrf_cookie DCNL def dashboard(request): DCNL  DCSP user = request.user DCNL DCSP platform_name = configuration_helpers.get_value('platform_name', settings.PLATFORM_NAME) DCNL DCSP enable_verified_certificates = configuration_helpers.get_value('ENABLE_VERIFIED_CERTIFICATES', settings.FEATURES.get('ENABLE_VERIFIED_CERTIFICATES')) DCNL DCSP display_course_modes_on_dashboard = configuration_helpers.get_value('DISPLAY_COURSE_MODES_ON_DASHBOARD', settings.FEATURES.get('DISPLAY_COURSE_MODES_ON_DASHBOARD', True)) DCNL DCSP course_org_filter = configuration_helpers.get_value('course_org_filter') DCNL DCSP org_filter_out_set = configuration_helpers.get_all_orgs() DCNL DCSP if course_org_filter: DCNL DCSP  DCSP org_filter_out_set.remove(course_org_filter) DCNL DCSP course_enrollments = list(get_course_enrollments(user, course_org_filter, org_filter_out_set)) DCNL DCSP course_enrollments.sort(key=(lambda x: x.created), reverse=True) DCNL DCSP enrolled_course_ids = [enrollment.course_id for enrollment in course_enrollments] DCNL DCSP (__, unexpired_course_modes) = CourseMode.all_and_unexpired_modes_for_courses(enrolled_course_ids) DCNL DCSP course_modes_by_course = {course_id: {mode.slug: mode for mode in modes} for (course_id, modes) in unexpired_course_modes.iteritems()} DCNL DCSP enrollment_message = _create_recent_enrollment_message(course_enrollments, course_modes_by_course) DCNL DCSP course_optouts = Optout.objects.filter(user=user).values_list('course_id', flat=True) DCNL DCSP message = '' DCNL DCSP if (not user.is_active): DCNL DCSP  DCSP message = render_to_string('registration/activate_account_notice.html', {'email': user.email, 'platform_name': platform_name}) DCNL DCSP staff_access = False DCNL DCSP errored_courses = {} DCNL DCSP if has_access(user, 'staff', 'global'): DCNL DCSP  DCSP staff_access = True DCNL DCSP  DCSP errored_courses = modulestore().get_errored_courses() DCNL DCSP show_courseware_links_for = frozenset((enrollment.course_id for enrollment in course_enrollments if (has_access(request.user, 'load', enrollment.course_overview) and has_access(request.user, 'view_courseware_with_prerequisites', enrollment.course_overview)))) DCNL DCSP use_catalog = waffle.switch_is_active('get_programs_from_catalog') DCNL DCSP meter = programs_utils.ProgramProgressMeter(user, enrollments=course_enrollments, use_catalog=use_catalog) DCNL DCSP programs_by_run = meter.engaged_programs(by_run=True) DCNL DCSP course_mode_info = {enrollment.course_id: complete_course_mode_info(enrollment.course_id, enrollment, modes=course_modes_by_course[enrollment.course_id]) for enrollment in course_enrollments} DCNL DCSP verify_status_by_course = check_verify_status_by_course(user, course_enrollments) DCNL DCSP cert_statuses = {enrollment.course_id: cert_info(request.user, enrollment.course_overview, enrollment.mode) for enrollment in course_enrollments} DCNL DCSP show_email_settings_for = frozenset((enrollment.course_id for enrollment in course_enrollments if BulkEmailFlag.feature_enabled(enrollment.course_id))) DCNL DCSP (verification_status, verification_msg) = SoftwareSecurePhotoVerification.user_status(user) DCNL DCSP statuses = ['approved', 'denied', 'pending', 'must_reverify'] DCNL DCSP reverifications = reverification_info(statuses) DCNL DCSP show_refund_option_for = frozenset((enrollment.course_id for enrollment in course_enrollments if enrollment.refundable())) DCNL DCSP block_courses = frozenset((enrollment.course_id for enrollment in course_enrollments if is_course_blocked(request, CourseRegistrationCode.objects.filter(course_id=enrollment.course_id, registrationcoderedemption__redeemed_by=request.user), enrollment.course_id))) DCNL DCSP enrolled_courses_either_paid = frozenset((enrollment.course_id for enrollment in course_enrollments if enrollment.is_paid_course())) DCNL DCSP denied_banner = any((item.display for item in reverifications['denied'])) DCNL DCSP order_history_list = order_history(user, course_org_filter=course_org_filter, org_filter_out_set=org_filter_out_set) DCNL DCSP courses_having_prerequisites = frozenset((enrollment.course_id for enrollment in course_enrollments if enrollment.course_overview.pre_requisite_courses)) DCNL DCSP courses_requirements_not_met = get_pre_requisite_courses_not_completed(user, courses_having_prerequisites) DCNL DCSP if ('notlive' in request.GET): DCNL DCSP  DCSP redirect_message = _('The DCSP course DCSP you DCSP are DCSP looking DCSP for DCSP does DCSP not DCSP start DCSP until DCSP {date}.').format(date=request.GET['notlive']) DCNL DCSP elif ('course_closed' in request.GET): DCNL DCSP  DCSP redirect_message = _('The DCSP course DCSP you DCSP are DCSP looking DCSP for DCSP is DCSP closed DCSP for DCSP enrollment DCSP as DCSP of DCSP {date}.').format(date=request.GET['course_closed']) DCNL DCSP else: DCNL DCSP  DCSP redirect_message = '' DCNL DCSP context = {'enrollment_message': enrollment_message, 'redirect_message': redirect_message, 'course_enrollments': course_enrollments, 'course_optouts': course_optouts, 'message': message, 'staff_access': staff_access, 'errored_courses': errored_courses, 'show_courseware_links_for': show_courseware_links_for, 'all_course_modes': course_mode_info, 'cert_statuses': cert_statuses, 'credit_statuses': _credit_statuses(user, course_enrollments), 'show_email_settings_for': show_email_settings_for, 'reverifications': reverifications, 'verification_status': verification_status, 'verification_status_by_course': verify_status_by_course, 'verification_msg': verification_msg, 'show_refund_option_for': show_refund_option_for, 'block_courses': block_courses, 'denied_banner': denied_banner, 'billing_email': settings.PAYMENT_SUPPORT_EMAIL, 'user': user, 'logout_url': reverse('logout'), 'platform_name': platform_name, 'enrolled_courses_either_paid': enrolled_courses_either_paid, 'provider_states': [], 'order_history_list': order_history_list, 'courses_requirements_not_met': courses_requirements_not_met, 'nav_hidden': True, 'programs_by_run': programs_by_run, 'show_program_listing': ProgramsApiConfig.current().show_program_listing, 'disable_courseware_js': True, 'display_course_modes_on_dashboard': (enable_verified_certificates and display_course_modes_on_dashboard)} DCNL DCSP ecommerce_service = EcommerceService() DCNL DCSP if ecommerce_service.is_enabled(request.user): DCNL DCSP  DCSP context.update({'use_ecommerce_payment_flow': True, 'ecommerce_payment_page': ecommerce_service.payment_page_url()}) DCNL DCSP response = render_to_response('dashboard.html', context) DCNL DCSP set_user_info_cookie(response, request) DCNL DCSP return response\n", "intent": "provides the lms dashboard view todo: this is lms specific and does not belong in common code .\n", "question_id": 1179}, {"snippet": "def _ssh_ls(ssh_bin, address, ec2_key_pair_file, path, keyfile=None, sudo=False): DCNL  DCSP cmd_args = ['find', '-L', path, '-type', 'f'] DCNL DCSP if sudo: DCNL DCSP  DCSP cmd_args = (['sudo'] + cmd_args) DCNL DCSP out = to_string(_check_output(*_ssh_run_with_recursion(ssh_bin, address, ec2_key_pair_file, keyfile, cmd_args))) DCNL DCSP if ('No DCSP such DCSP file DCSP or DCSP directory' in out): DCNL DCSP  DCSP raise IOError(('No DCSP such DCSP file DCSP or DCSP directory: DCSP %s' % path)) DCNL DCSP return out.split('\\n')\n", "intent": "recursively list files under path on the specified ssh host .\n", "question_id": 1180}, {"snippet": "def container_convergence(results, limit): DCNL  DCSP convergence_results = [r for r in results if ((r['metric']['type'] == 'wallclock') and (r['operation']['type'] == 'create-container'))] DCNL DCSP num_convergences = len(convergence_results) DCNL DCSP if (num_convergences > 0): DCNL DCSP  DCSP convergences_within_limit = [r for r in convergence_results if (r['value'] <= limit)] DCNL DCSP  DCSP return (float(len(convergences_within_limit)) / num_convergences) DCNL DCSP return None\n", "intent": "calculate the percentage of containers that converge within a given time period .\n", "question_id": 1181}, {"snippet": "def get_java_version(): DCNL  DCSP (o, e, exit_status) = qiime_system_call('java DCSP -version') DCNL DCSP if (exit_status != 0): DCNL DCSP  DCSP return None DCNL DCSP e = e.strip().splitlines() DCNL DCSP version_line = e[0] DCNL DCSP if (not version_line.startswith('java DCSP version')): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return version_line.split()[(-1)].strip('\"')\n", "intent": "returns the java version .\n", "question_id": 1182}, {"snippet": "def load_fabfile(path, importer=None): DCNL  DCSP if (importer is None): DCNL DCSP  DCSP importer = __import__ DCNL DCSP (directory, fabfile) = os.path.split(path) DCNL DCSP added_to_path = False DCNL DCSP index = None DCNL DCSP if (directory not in sys.path): DCNL DCSP  DCSP sys.path.insert(0, directory) DCNL DCSP  DCSP added_to_path = True DCNL DCSP else: DCNL DCSP  DCSP i = sys.path.index(directory) DCNL DCSP  DCSP if (i != 0): DCNL DCSP  DCSP  DCSP index = i DCNL DCSP  DCSP  DCSP sys.path.insert(0, directory) DCNL DCSP  DCSP  DCSP del sys.path[(i + 1)] DCNL DCSP imported = importer(os.path.splitext(fabfile)[0]) DCNL DCSP if added_to_path: DCNL DCSP  DCSP del sys.path[0] DCNL DCSP if (index is not None): DCNL DCSP  DCSP sys.path.insert((index + 1), directory) DCNL DCSP  DCSP del sys.path[0] DCNL DCSP (docstring, new_style, classic, default) = load_tasks_from_module(imported) DCNL DCSP tasks = (new_style if state.env.new_style_tasks else classic) DCNL DCSP _seen.clear() DCNL DCSP return (docstring, tasks, default)\n", "intent": "import given fabfile path and return .\n", "question_id": 1183}, {"snippet": "@blueprint.route('/new/<extension_id>', methods=['GET']) DCNL @utils.auth.requires_login DCNL def new(extension_id): DCNL  DCSP form = GenericDatasetForm() DCNL DCSP utils.forms.fill_form_if_cloned(form) DCNL DCSP extension = extensions.data.get_extension(extension_id) DCNL DCSP if (extension is None): DCNL DCSP  DCSP raise ValueError((\"Unknown DCSP extension DCSP '%s'\" % extension_id)) DCNL DCSP extension_form = extension.get_dataset_form() DCNL DCSP utils.forms.fill_form_if_cloned(extension_form) DCNL DCSP (template, context) = extension.get_dataset_template(extension_form) DCNL DCSP rendered_extension = flask.render_template_string(template, **context) DCNL DCSP return flask.render_template('datasets/generic/new.html', extension_title=extension.get_title(), extension_id=extension_id, extension_html=rendered_extension, form=form)\n", "intent": "returns a form for a new genericdatasetjob .\n", "question_id": 1184}, {"snippet": "@pytest.mark.skipif('not DCSP HAS_BEAUTIFUL_SOUP') DCNL def test_htmlheader_start(): DCNL  DCSP f = 't/html.html' DCNL DCSP with open(f) as fd: DCNL DCSP  DCSP table = fd.read() DCNL DCSP inputter = html.HTMLInputter() DCNL DCSP inputter.html = {} DCNL DCSP header = html.HTMLHeader() DCNL DCSP lines = inputter.get_lines(table) DCNL DCSP assert (str(lines[header.start_line(lines)]) == '<tr><th>Column DCSP 1</th><th>Column DCSP 2</th><th>Column DCSP 3</th></tr>') DCNL DCSP inputter.html['table_id'] = 'second' DCNL DCSP lines = inputter.get_lines(table) DCNL DCSP assert (str(lines[header.start_line(lines)]) == '<tr><th>Column DCSP A</th><th>Column DCSP B</th><th>Column DCSP C</th></tr>') DCNL DCSP inputter.html['table_id'] = 3 DCNL DCSP lines = inputter.get_lines(table) DCNL DCSP assert (str(lines[header.start_line(lines)]) == '<tr><th>C1</th><th>C2</th><th>C3</th></tr>') DCNL DCSP lines = [html.SoupString(BeautifulSoup('<table><tr><td>Data</td></tr></table>').tr), html.SoupString(BeautifulSoup('<p>Text</p>').p)] DCNL DCSP assert (header.start_line(lines) is None) DCNL DCSP lines.append('<tr><th>Header</th></tr>') DCNL DCSP with pytest.raises(TypeError): DCNL DCSP  DCSP header.start_line(lines)\n", "intent": "test to ensure that the start_line method of htmlheader returns the first line of header data .\n", "question_id": 1185}, {"snippet": "def _yield_all_clusters(emr_conn, *args, **kwargs): DCNL  DCSP for resp in _repeat(emr_conn.list_clusters, *args, **kwargs): DCNL DCSP  DCSP for cluster in getattr(resp, 'clusters', []): DCNL DCSP  DCSP  DCSP (yield cluster)\n", "intent": "make successive api calls .\n", "question_id": 1186}, {"snippet": "def to_list(value): DCNL  DCSP if (value is None): DCNL DCSP  DCSP value = [] DCNL DCSP elif (not isinstance(value, list)): DCNL DCSP  DCSP value = [value] DCNL DCSP return value\n", "intent": "puts value into a list if its not already one .\n", "question_id": 1187}, {"snippet": "def renamer(old, new): DCNL  DCSP (path, name) = os.path.split(new) DCNL DCSP new = os.path.join(path, sanitize_foldername(name, False)) DCNL DCSP logging.debug('Renaming DCSP \"%s\" DCSP to DCSP \"%s\"', old, new) DCNL DCSP if sabnzbd.WIN32: DCNL DCSP  DCSP retries = 15 DCNL DCSP  DCSP while (retries > 0): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP shutil.move(old, new) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except WindowsError as err: DCNL DCSP  DCSP  DCSP  DCSP logging.debug('Error DCSP renaming DCSP \"%s\" DCSP to DCSP \"%s\" DCSP <%s>', old, new, err) DCNL DCSP  DCSP  DCSP  DCSP if (err[0] == 32): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.debug('Retry DCSP rename DCSP %s DCSP to DCSP %s', old, new) DCNL DCSP  DCSP  DCSP  DCSP  DCSP retries -= 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise WindowsError(err) DCNL DCSP  DCSP  DCSP time.sleep(3) DCNL DCSP  DCSP raise WindowsError(err) DCNL DCSP else: DCNL DCSP  DCSP shutil.move(old, new)\n", "intent": "rename file/folder with retries for win32 .\n", "question_id": 1188}, {"snippet": "def retcode(plugin, args='', key_name=None): DCNL  DCSP data = {} DCNL DCSP if (key_name is None): DCNL DCSP  DCSP key_name = _format_dict_key(args, plugin) DCNL DCSP data[key_name] = {} DCNL DCSP status = _execute_cmd(plugin, args, 'cmd.retcode') DCNL DCSP data[key_name]['status'] = status DCNL DCSP return data\n", "intent": "run one nagios plugin and return retcode of the execution .\n", "question_id": 1189}, {"snippet": "def getAroundsFromPathPoints(points, radius, thresholdRatio=0.9): DCNL  DCSP centers = getCentersFromPoints(points, (0.8 * radius)) DCNL DCSP arounds = [] DCNL DCSP for center in centers: DCNL DCSP  DCSP if euclidean.isWiddershins(center): DCNL DCSP  DCSP  DCSP arounds.append(euclidean.getSimplifiedPath(center, radius)) DCNL DCSP return arounds\n", "intent": "get the arounds from the path .\n", "question_id": 1190}, {"snippet": "def _is_bad_link(info, base): DCNL  DCSP tip = resolved(joinpath(base, dirname(info.name))) DCNL DCSP return _is_bad_path(info.linkname, base=tip)\n", "intent": "does the file sym- or hard-link to files outside base? .\n", "question_id": 1191}, {"snippet": "def validate_engine(engine): DCNL  DCSP if (engine not in VALID_DB_ENGINES): DCNL DCSP  DCSP raise ValueError(('DBInstance DCSP Engine DCSP must DCSP be DCSP one DCSP of: DCSP %s' % ', DCSP '.join(VALID_DB_ENGINES))) DCNL DCSP return engine\n", "intent": "validate database engine for dbinstance .\n", "question_id": 1192}, {"snippet": "def hexadecimal(field): DCNL  DCSP assert (hasattr(field, 'value') and hasattr(field, 'size')) DCNL DCSP size = field.size DCNL DCSP padding = (alignValue(size, 4) // 4) DCNL DCSP pattern = (u'0x%%0%ux' % padding) DCNL DCSP return (pattern % field.value)\n", "intent": "convert an integer to hexadecimal in lower case .\n", "question_id": 1193}, {"snippet": "@validate('form') DCNL def valid_type_in_col(arch): DCNL  DCSP return all((attrib.isdigit() for attrib in arch.xpath('//@col')))\n", "intent": "a col attribute must be an integer type .\n", "question_id": 1194}, {"snippet": "def writeSimpleTest1(filePath, numRecords, testNumber): DCNL  DCSP with open((filePath + '.csv'), 'wb') as f: DCNL DCSP  DCSP writer = csv.writer(f) DCNL DCSP  DCSP if (testNumber == 1): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2']) DCNL DCSP  DCSP  DCSP writer.writerow(['int', 'int']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '']) DCNL DCSP  DCSP  DCSP for i in ranger(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP field1 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field2 = (field1 + int((0.025 * np.random.normal(0, 100, 1)))) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2]) DCNL DCSP  DCSP elif (testNumber == 2): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3']) DCNL DCSP  DCSP  DCSP writer.writerow(['int', 'int', 'int']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '']) DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP field1 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field2 = (field1 + int((0.025 * np.random.normal(0, 100, 1)))) DCNL DCSP  DCSP  DCSP  DCSP field3 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (testNumber == 3): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3', 'field4']) DCNL DCSP  DCSP  DCSP writer.writerow(['int', 'int', 'int', 'int']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '', '']) DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP field2 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field3 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = (field2 + field3) DCNL DCSP  DCSP  DCSP  DCSP field4 = int(np.random.random_integers(0, 100, 1)) DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3, field4]) DCNL DCSP  DCSP elif ((testNumber == 4) or (testNumber == 5)): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '']) DCNL DCSP  DCSP  DCSP if (testNumber == 5): DCNL DCSP  DCSP  DCSP  DCSP categories = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP categories = ['a', 'b', 'c', 'd'] DCNL DCSP  DCSP  DCSP numRecsSaved = 0 DCNL DCSP  DCSP  DCSP firstFieldInd = 0 DCNL DCSP  DCSP  DCSP done = False DCNL DCSP  DCSP  DCSP while (not done): DCNL DCSP  DCSP  DCSP  DCSP while (not done): DCNL DCSP  DCSP  DCSP  DCSP  DCSP field1 = categories[firstFieldInd] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for category in categories: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field2 = category DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP numRecsSaved += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (numRecsSaved == numRecords): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP firstFieldInd += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (firstFieldInd == len(categories)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP firstFieldInd = 0 DCNL DCSP  DCSP elif (testNumber == 6): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '']) DCNL DCSP  DCSP  DCSP choises = [['a', [0.9, 0.05, 0.05]], ['b', [0.05, 0.9, 0.05]], ['c', [0.05, 0.05, 0.9]]] DCNL DCSP  DCSP  DCSP cat2 = ['d', 'e', 'f'] DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP ind1 = int(np.random.random_integers(0, 2, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = choises[ind1][0] DCNL DCSP  DCSP  DCSP  DCSP ind2 = np.searchsorted(np.cumsum(choises[ind1][1]), np.random.random()) DCNL DCSP  DCSP  DCSP  DCSP field2 = cat2[ind2] DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (testNumber == 7): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '']) DCNL DCSP  DCSP  DCSP choises = [['a', [0.9, 0.05, 0.05]], ['b', [0.05, 0.9, 0.05]], ['c', [0.05, 0.05, 0.9]]] DCNL DCSP  DCSP  DCSP cat2 = ['d', 'e', 'f'] DCNL DCSP  DCSP  DCSP cat3 = ['g', 'h', 'i'] DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP ind1 = int(np.random.random_integers(0, 2, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = choises[ind1][0] DCNL DCSP  DCSP  DCSP  DCSP ind2 = np.searchsorted(np.cumsum(choises[ind1][1]), np.random.random()) DCNL DCSP  DCSP  DCSP  DCSP field2 = cat2[ind2] DCNL DCSP  DCSP  DCSP  DCSP ind3 = int(np.random.random_integers(0, 2, 1)) DCNL DCSP  DCSP  DCSP  DCSP field3 = cat3[ind3] DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (testNumber == 8): DCNL DCSP  DCSP  DCSP writer.writerow(['field1', 'field2', 'field3']) DCNL DCSP  DCSP  DCSP writer.writerow(['string', 'string', 'string']) DCNL DCSP  DCSP  DCSP writer.writerow(['', '', '']) DCNL DCSP  DCSP  DCSP choises = [['a', 'd', [0.9, 0.05, 0.05]], ['a', 'e', [0.05, 0.9, 0.05]], ['a', 'f', [0.05, 0.05, 0.9]], ['b', 'd', [0.9, 0.05, 0.05]], ['b', 'e', [0.05, 0.9, 0.05]], ['b', 'f', [0.05, 0.05, 0.9]], ['c', 'd', [0.9, 0.05, 0.05]], ['c', 'e', [0.05, 0.9, 0.05]], ['c', 'f', [0.05, 0.05, 0.9]]] DCNL DCSP  DCSP  DCSP cat3 = ['g', 'h', 'i'] DCNL DCSP  DCSP  DCSP for i in range(0, numRecords): DCNL DCSP  DCSP  DCSP  DCSP ind1 = int(np.random.random_integers(0, 8, 1)) DCNL DCSP  DCSP  DCSP  DCSP field1 = choises[ind1][0] DCNL DCSP  DCSP  DCSP  DCSP field2 = choises[ind1][1] DCNL DCSP  DCSP  DCSP  DCSP ind2 = np.searchsorted(np.cumsum(choises[ind1][2]), np.random.random()) DCNL DCSP  DCSP  DCSP  DCSP field3 = cat3[ind2] DCNL DCSP  DCSP  DCSP  DCSP writer.writerow([field1, field2, field3]) DCNL DCSP  DCSP  DCSP pass DCNL DCSP return\n", "intent": "generates requested number of records and saves in a csv file .\n", "question_id": 1195}, {"snippet": "def word_pairs(text): DCNL  DCSP last_word = None DCNL DCSP for word in words(text): DCNL DCSP  DCSP if (last_word is not None): DCNL DCSP  DCSP  DCSP (yield (last_word, word)) DCNL DCSP  DCSP last_word = word DCNL DCSP (yield (last_word, '<end>'))\n", "intent": "given some text .\n", "question_id": 1196}, {"snippet": "def module_to_dict(module, omittable=(lambda k: k.startswith('_'))): DCNL  DCSP return dict([(k, repr(v)) for (k, v) in module.__dict__.items() if (not omittable(k))])\n", "intent": "converts a module namespace to a python dictionary .\n", "question_id": 1197}, {"snippet": "def _fillInOnTimes(vector, durations): DCNL  DCSP nonzeros = numpy.array(vector).nonzero()[0] DCNL DCSP if (len(nonzeros) == 0): DCNL DCSP  DCSP return DCNL DCSP if (len(nonzeros) == 1): DCNL DCSP  DCSP durations[nonzeros[0]] = 1 DCNL DCSP  DCSP return DCNL DCSP prev = nonzeros[0] DCNL DCSP onTime = 1 DCNL DCSP onStartIdx = prev DCNL DCSP endIdx = nonzeros[(-1)] DCNL DCSP for idx in nonzeros[1:]: DCNL DCSP  DCSP if (idx != (prev + 1)): DCNL DCSP  DCSP  DCSP durations[onStartIdx:(onStartIdx + onTime)] = range(1, (onTime + 1)) DCNL DCSP  DCSP  DCSP onTime = 1 DCNL DCSP  DCSP  DCSP onStartIdx = idx DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP onTime += 1 DCNL DCSP  DCSP prev = idx DCNL DCSP durations[onStartIdx:(onStartIdx + onTime)] = range(1, (onTime + 1))\n", "intent": "helper function used by averageontimepertimestep .\n", "question_id": 1198}, {"snippet": "@require_POST DCNL @xframe_options_sameorigin DCNL def del_image_async(request, image_id): DCNL  DCSP user = request.user DCNL DCSP if (not user.is_authenticated()): DCNL DCSP  DCSP message = _('You DCSP are DCSP not DCSP logged DCSP in.') DCNL DCSP  DCSP return HttpResponseForbidden(json.dumps({'status': 'error', 'message': message})) DCNL DCSP try: DCNL DCSP  DCSP image = ImageAttachment.objects.get(pk=image_id) DCNL DCSP except ImageAttachment.DoesNotExist: DCNL DCSP  DCSP message = _('The DCSP requested DCSP image DCSP could DCSP not DCSP be DCSP found.') DCNL DCSP  DCSP return HttpResponseNotFound(json.dumps({'status': 'error', 'message': message})) DCNL DCSP if (not ((user == image.creator) or user.has_perm('upload.delete_imageattachment'))): DCNL DCSP  DCSP message = _('You DCSP do DCSP not DCSP have DCSP permission DCSP to DCSP do DCSP that.') DCNL DCSP  DCSP return HttpResponseForbidden(json.dumps({'status': 'error', 'message': message})) DCNL DCSP image.file.delete() DCNL DCSP if image.thumbnail: DCNL DCSP  DCSP image.thumbnail.delete() DCNL DCSP image.delete() DCNL DCSP return HttpResponse(json.dumps({'status': 'success'}))\n", "intent": "delete an image given its object id .\n", "question_id": 1199}, {"snippet": "def rl_op(left, right): DCNL  DCSP if (len(right) > 0): DCNL DCSP  DCSP rl_gate = right[0] DCNL DCSP  DCSP rl_gate_is_unitary = is_scalar_matrix((Dagger(rl_gate), rl_gate), _get_min_qubits(rl_gate), True) DCNL DCSP if ((len(right) > 0) and rl_gate_is_unitary): DCNL DCSP  DCSP new_right = right[1:len(right)] DCNL DCSP  DCSP new_left = ((Dagger(rl_gate),) + left) DCNL DCSP  DCSP return (new_left, new_right) DCNL DCSP return None\n", "intent": "perform a rl operation .\n", "question_id": 1200}, {"snippet": "def makedirs(name, mode=511): DCNL  DCSP from errno import EEXIST DCNL DCSP (head, tail) = path.split(name) DCNL DCSP if (not tail): DCNL DCSP  DCSP (head, tail) = path.split(head) DCNL DCSP if (head and tail and (not path.exists(head))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP makedirs(head, mode) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != EEXIST): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (tail == curdir): DCNL DCSP  DCSP  DCSP return DCNL DCSP mkdir(name, mode)\n", "intent": "makedirs super-mkdir; create a leaf directory and all intermediate ones .\n", "question_id": 1201}, {"snippet": "def _make_sync_method(name): DCNL  DCSP def sync_wrapper(self, *args, **kwds): DCNL DCSP  DCSP method = getattr(self, name) DCNL DCSP  DCSP future = method(*args, **kwds) DCNL DCSP  DCSP return future.get_result() DCNL DCSP return sync_wrapper\n", "intent": "helper to synthesize a synchronous method from an async method name .\n", "question_id": 1202}, {"snippet": "def pillar_pcre(tgt, delimiter=DEFAULT_TARGET_DELIM): DCNL  DCSP matcher = salt.minion.Matcher({'pillar': __pillar__}, __salt__) DCNL DCSP try: DCNL DCSP  DCSP return matcher.pillar_pcre_match(tgt, delimiter=delimiter) DCNL DCSP except Exception as exc: DCNL DCSP  DCSP log.exception(exc) DCNL DCSP  DCSP return False\n", "intent": "return true if the minion matches the given pillar_pcre target .\n", "question_id": 1203}, {"snippet": "def _pl(x): DCNL  DCSP len_x = (x if isinstance(x, (integer_types, np.generic)) else len(x)) DCNL DCSP return ('' if (len_x == 1) else 's')\n", "intent": "determine if plural should be used .\n", "question_id": 1204}, {"snippet": "def test_table_info_stats(table_types): DCNL  DCSP a = np.array([1, 2, 1, 2], dtype='int32') DCNL DCSP b = np.array([1, 2, 1, 2], dtype='float32') DCNL DCSP c = np.array(['a', 'c', 'e', 'f'], dtype='|S1') DCNL DCSP d = time.Time([1, 2, 1, 2], format='mjd') DCNL DCSP t = table_types.Table([a, b, c, d], names=['a', 'b', 'c', 'd']) DCNL DCSP masked = ('masked=True DCSP ' if t.masked else '') DCNL DCSP out = StringIO() DCNL DCSP t.info('stats', out=out) DCNL DCSP table_header_line = '<{0} DCSP {1}length=4>'.format(t.__class__.__name__, masked) DCNL DCSP exp = [table_header_line, 'name DCSP mean DCSP std DCSP min DCSP max', '---- DCSP ---- DCSP --- DCSP --- DCSP ---', ' DCSP  DCSP  DCSP a DCSP  DCSP 1.5 DCSP 0.5 DCSP  DCSP  DCSP 1 DCSP  DCSP  DCSP 2', ' DCSP  DCSP  DCSP b DCSP  DCSP 1.5 DCSP 0.5 DCSP 1.0 DCSP 2.0', ' DCSP  DCSP  DCSP c DCSP  DCSP  DCSP -- DCSP  DCSP -- DCSP  DCSP -- DCSP  DCSP --', ' DCSP  DCSP  DCSP d DCSP  DCSP  DCSP -- DCSP  DCSP -- DCSP 1.0 DCSP 2.0'] DCNL DCSP assert (out.getvalue().splitlines() == exp) DCNL DCSP tinfo = t.info(['attributes', 'stats'], out=None) DCNL DCSP assert (tinfo.colnames == ['name', 'dtype', 'shape', 'unit', 'format', 'description', 'class', 'mean', 'std', 'min', 'max', 'n_bad', 'length']) DCNL DCSP assert np.all((tinfo['mean'] == ['1.5', '1.5', '--', '--'])) DCNL DCSP assert np.all((tinfo['std'] == ['0.5', '0.5', '--', '--'])) DCNL DCSP assert np.all((tinfo['min'] == ['1', '1.0', '--', '1.0'])) DCNL DCSP assert np.all((tinfo['max'] == ['2', '2.0', '--', '2.0'])) DCNL DCSP out = StringIO() DCNL DCSP t.info('stats', out=out) DCNL DCSP exp = [table_header_line, 'name DCSP mean DCSP std DCSP min DCSP max', '---- DCSP ---- DCSP --- DCSP --- DCSP ---', ' DCSP  DCSP  DCSP a DCSP  DCSP 1.5 DCSP 0.5 DCSP  DCSP  DCSP 1 DCSP  DCSP  DCSP 2', ' DCSP  DCSP  DCSP b DCSP  DCSP 1.5 DCSP 0.5 DCSP 1.0 DCSP 2.0', ' DCSP  DCSP  DCSP c DCSP  DCSP  DCSP -- DCSP  DCSP -- DCSP  DCSP -- DCSP  DCSP --', ' DCSP  DCSP  DCSP d DCSP  DCSP  DCSP -- DCSP  DCSP -- DCSP 1.0 DCSP 2.0'] DCNL DCSP assert (out.getvalue().splitlines() == exp) DCNL DCSP custom = data_info_factory(names=['sum', 'first'], funcs=[np.sum, (lambda col: col[0])]) DCNL DCSP out = StringIO() DCNL DCSP tinfo = t.info(['attributes', custom], out=None) DCNL DCSP assert (tinfo.colnames == ['name', 'dtype', 'shape', 'unit', 'format', 'description', 'class', 'sum', 'first', 'n_bad', 'length']) DCNL DCSP assert np.all((tinfo['name'] == ['a', 'b', 'c', 'd'])) DCNL DCSP assert np.all((tinfo['dtype'] == ['int32', 'float32', dtype_info_name('S1'), 'object'])) DCNL DCSP assert np.all((tinfo['sum'] == ['6', '6.0', '--', '--'])) DCNL DCSP assert np.all((tinfo['first'] == ['1', '1.0', ('a' if six.PY2 else \"b'a'\"), '1.0']))\n", "intent": "test the info() method of printing a summary of table column statistics .\n", "question_id": 1205}, {"snippet": "def wait_for_video_player_ready(context, wait_time=MAX_WAIT_TIME): DCNL  DCSP class ContextWithMixin(BrowserActionMixins, ): DCNL DCSP  DCSP def __init__(self): DCNL DCSP  DCSP  DCSP self.browser = context.browser DCNL DCSP context_wm = ContextWithMixin() DCNL DCSP context_wm.browser_wait_for_js_object_exists('$') DCNL DCSP context_wm.browser_wait_for_js_object_exists('$(\"video\")') DCNL DCSP context.browser.execute_script('$(\"video\").trigger(\"loadedmetadata\");') DCNL DCSP try: DCNL DCSP  DCSP context_wm.browser_wait_for_js_condition('window._kalite_debug.video_player_initialized', max_wait_time=wait_time) DCNL DCSP except KALiteTimeout as e: DCNL DCSP  DCSP raise TimeoutException(str(e))\n", "intent": "if youre on the \"learn\" page with video content .\n", "question_id": 1206}, {"snippet": "def clone_dir(src, dest): DCNL  DCSP for x in os.listdir(src): DCNL DCSP  DCSP dpath = os.path.join(dest, x) DCNL DCSP  DCSP spath = os.path.join(src, x) DCNL DCSP  DCSP if os.path.isdir(spath): DCNL DCSP  DCSP  DCSP os.mkdir(dpath) DCNL DCSP  DCSP  DCSP clone_dir(spath, dpath) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hardlink_file(spath, dpath) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP shutil.copy2(spath, dpath)\n", "intent": "clone a directory using hard links for the files .\n", "question_id": 1207}, {"snippet": "def action_event_finish(context, values): DCNL  DCSP return IMPL.action_event_finish(context, values)\n", "intent": "finish an event on an instance action .\n", "question_id": 1208}, {"snippet": "def user_is_article_course_staff(user, article): DCNL  DCSP wiki_slug = article_course_wiki_root_slug(article) DCNL DCSP if (wiki_slug is None): DCNL DCSP  DCSP return False DCNL DCSP modstore = modulestore.django.modulestore() DCNL DCSP return _has_wiki_staff_access(user, wiki_slug, modstore)\n", "intent": "the root of a course wiki is /<course_number> .\n", "question_id": 1209}, {"snippet": "def is_deriv_k(fa, fd, DE): DCNL  DCSP (dfa, dfd) = ((fd * ((fd * derivation(fa, DE)) - (fa * derivation(fd, DE)))), ((fd ** 2) * fa)) DCNL DCSP (dfa, dfd) = dfa.cancel(dfd, include=True) DCNL DCSP if ((len(DE.L_K) + len(DE.E_K)) != (len(DE.D) - 1)): DCNL DCSP  DCSP if ([i for i in DE.cases if (i == 'tan')] or (set([i for i in DE.cases if (i == 'primitive')]) - set(DE.L_K))): DCNL DCSP  DCSP  DCSP raise NotImplementedError('Real DCSP version DCSP of DCSP the DCSP structure DCSP theorems DCSP with DCSP hypertangent DCSP support DCSP is DCSP not DCSP yet DCSP implemented.') DCNL DCSP  DCSP raise NotImplementedError('Nonelementary DCSP extensions DCSP not DCSP supported DCSP in DCSP the DCSP structure DCSP theorems.') DCNL DCSP E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.E_K] DCNL DCSP L_part = [DE.D[i].as_expr() for i in DE.L_K] DCNL DCSP lhs = Matrix([(E_part + L_part)]) DCNL DCSP rhs = Matrix([(dfa.as_expr() / dfd.as_expr())]) DCNL DCSP (A, u) = constant_system(lhs, rhs, DE) DCNL DCSP if ((not all((derivation(i, DE, basic=True).is_zero for i in u))) or (not A)): DCNL DCSP  DCSP return None DCNL DCSP elif (not all((i.is_Rational for i in u))): DCNL DCSP  DCSP raise NotImplementedError('Cannot DCSP work DCSP with DCSP non-rational DCSP coefficients DCSP in DCSP this DCSP case.') DCNL DCSP else: DCNL DCSP  DCSP terms = (DE.E_args + [DE.T[i] for i in DE.L_K]) DCNL DCSP  DCSP ans = list(zip(terms, u)) DCNL DCSP  DCSP result = Add(*[Mul(i, j) for (i, j) in ans]) DCNL DCSP  DCSP argterms = ([DE.T[i] for i in DE.E_K] + DE.L_args) DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP ld = [] DCNL DCSP  DCSP for (i, j) in zip(argterms, u): DCNL DCSP  DCSP  DCSP (i, d) = i.as_numer_denom() DCNL DCSP  DCSP  DCSP (icoeff, iterms) = sqf_list(i) DCNL DCSP  DCSP  DCSP l.append(Mul(*([Pow(icoeff, j)] + [Pow(b, (e * j)) for (b, e) in iterms]))) DCNL DCSP  DCSP  DCSP (dcoeff, dterms) = sqf_list(d) DCNL DCSP  DCSP  DCSP ld.append(Mul(*([Pow(dcoeff, j)] + [Pow(b, (e * j)) for (b, e) in dterms]))) DCNL DCSP  DCSP const = cancel((((fa.as_expr() / fd.as_expr()) / Mul(*l)) * Mul(*ld))) DCNL DCSP  DCSP return (ans, result, const)\n", "intent": "checks if df/f is the derivative of an element of k(t) .\n", "question_id": 1210}, {"snippet": "def validate_user_access_to_subscribers(user_profile, stream): DCNL  DCSP validate_user_access_to_subscribers_helper(user_profile, {'realm__domain': stream.realm.domain, 'realm_id': stream.realm_id, 'invite_only': stream.invite_only}, (lambda : subscribed_to_stream(user_profile, stream)))\n", "intent": "validates whether the user can view the subscribers of a stream .\n", "question_id": 1211}, {"snippet": "def get_duty_officers(at_time=None): DCNL  DCSP duty_officers = [] DCNL DCSP if (not at_time): DCNL DCSP  DCSP at_time = timezone.now() DCNL DCSP current_shifts = Shift.objects.filter(deleted=False, start__lt=at_time, end__gt=at_time) DCNL DCSP if current_shifts: DCNL DCSP  DCSP duty_officers = [shift.user for shift in current_shifts] DCNL DCSP  DCSP return duty_officers DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP u = UserProfile.objects.get(fallback_alert_user=True) DCNL DCSP  DCSP  DCSP return [u.user] DCNL DCSP  DCSP except UserProfile.DoesNotExist: DCNL DCSP  DCSP  DCSP return []\n", "intent": "returns a list of duty officers for a given time or now if none given .\n", "question_id": 1212}, {"snippet": "def greedy_branching(G, attr='weight', default=1, kind='max'): DCNL  DCSP if (kind not in KINDS): DCNL DCSP  DCSP raise nx.NetworkXException('Unknown DCSP value DCSP for DCSP `kind`.') DCNL DCSP if (kind == 'min'): DCNL DCSP  DCSP reverse = False DCNL DCSP else: DCNL DCSP  DCSP reverse = True DCNL DCSP if (attr is None): DCNL DCSP  DCSP attr = random_string() DCNL DCSP edges = [(u, v, data.get(attr, default)) for (u, v, data) in G.edges(data=True)] DCNL DCSP try: DCNL DCSP  DCSP edges.sort(key=itemgetter(2, 0, 1), reverse=reverse) DCNL DCSP except TypeError: DCNL DCSP  DCSP edges.sort(key=itemgetter(2), reverse=reverse) DCNL DCSP B = nx.DiGraph() DCNL DCSP B.add_nodes_from(G) DCNL DCSP uf = nx.utils.UnionFind() DCNL DCSP for (i, (u, v, w)) in enumerate(edges): DCNL DCSP  DCSP if (uf[u] == uf[v]): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (B.in_degree(v) == 1): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP data = {} DCNL DCSP  DCSP  DCSP if (attr is not None): DCNL DCSP  DCSP  DCSP  DCSP data[attr] = w DCNL DCSP  DCSP  DCSP B.add_edge(u, v, **data) DCNL DCSP  DCSP  DCSP uf.union(u, v) DCNL DCSP return B\n", "intent": "returns a branching obtained through a greedy algorithm .\n", "question_id": 1213}, {"snippet": "def _create_siv_cipher(factory, **kwargs): DCNL  DCSP try: DCNL DCSP  DCSP key = kwargs.pop('key') DCNL DCSP except KeyError as e: DCNL DCSP  DCSP raise TypeError(('Missing DCSP parameter: DCSP ' + str(e))) DCNL DCSP nonce = kwargs.pop('nonce', None) DCNL DCSP return SivMode(factory, key, nonce, kwargs)\n", "intent": "create a new block cipher .\n", "question_id": 1214}, {"snippet": "def new(key, nonce=None): DCNL  DCSP if (nonce is None): DCNL DCSP  DCSP nonce = get_random_bytes(8) DCNL DCSP return Salsa20Cipher(key, nonce)\n", "intent": "create a new salsa20 cipher .\n", "question_id": 1215}, {"snippet": "def _aggr_last(inList): DCNL  DCSP for elem in reversed(inList): DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP return elem DCNL DCSP return None\n", "intent": "returns last non-none element in the list .\n", "question_id": 1216}, {"snippet": "def gis_download_kml(record_id, filename, session_id_name, session_id, user_id=None): DCNL  DCSP if user_id: DCNL DCSP  DCSP auth.s3_impersonate(user_id) DCNL DCSP result = gis.download_kml(record_id, filename, session_id_name, session_id) DCNL DCSP db.commit() DCNL DCSP return result\n", "intent": "download a kml file - will normally be done asynchronously if there is a worker alive .\n", "question_id": 1217}, {"snippet": "def futrig(e, **kwargs): DCNL  DCSP from sympy.simplify.fu import hyper_as_trig DCNL DCSP from sympy.simplify.simplify import bottom_up DCNL DCSP e = sympify(e) DCNL DCSP if (not isinstance(e, Basic)): DCNL DCSP  DCSP return e DCNL DCSP if (not e.args): DCNL DCSP  DCSP return e DCNL DCSP old = e DCNL DCSP e = bottom_up(e, (lambda x: _futrig(x, **kwargs))) DCNL DCSP if (kwargs.pop('hyper', True) and e.has(HyperbolicFunction)): DCNL DCSP  DCSP (e, f) = hyper_as_trig(e) DCNL DCSP  DCSP e = f(_futrig(e)) DCNL DCSP if ((e != old) and e.is_Mul and e.args[0].is_Rational): DCNL DCSP  DCSP e = Mul(*e.as_coeff_Mul()) DCNL DCSP return e\n", "intent": "return simplified e using fu-like transformations .\n", "question_id": 1218}, {"snippet": "def finger(hash_type=None): DCNL  DCSP if (hash_type is None): DCNL DCSP  DCSP hash_type = __opts__['hash_type'] DCNL DCSP return salt.utils.pem_finger(os.path.join(__opts__['pki_dir'], 'minion.pub'), sum_type=hash_type)\n", "intent": "return the minions public key fingerprint hash_type the hash algorithm used to calculate the fingerprint cli example: .\n", "question_id": 1219}, {"snippet": "def extract_arguments(text): DCNL  DCSP regexp = re.compile('\\\\/\\\\w*(@\\\\w*)*\\\\s*([\\\\s\\\\S]*)', re.IGNORECASE) DCNL DCSP result = regexp.match(text) DCNL DCSP return (result.group(2) if is_command(text) else None)\n", "intent": "returns the argument after the command .\n", "question_id": 1220}, {"snippet": "def register_services(hass): DCNL  DCSP descriptions = load_yaml_config_file(path.join(path.dirname(__file__), 'services.yaml')) DCNL DCSP hass.services.register(DOMAIN, SERVICE_SYNC, _sync_service, descriptions.get(SERVICE_SYNC), schema=HARMONY_SYNC_SCHEMA)\n", "intent": "register all services for harmony devices .\n", "question_id": 1221}, {"snippet": "def start(name, call=None): DCNL  DCSP if (call != 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP instance DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -a DCSP or DCSP --action.') DCNL DCSP log.info('Starting DCSP machine: DCSP %s', name) DCNL DCSP vb_start_vm(name) DCNL DCSP machine = vb_get_machine(name) DCNL DCSP del machine['name'] DCNL DCSP return treat_machine_dict(machine)\n", "intent": "start a machine .\n", "question_id": 1222}, {"snippet": "def _dmp_ff_trivial_gcd(f, g, u, K): DCNL  DCSP zero_f = dmp_zero_p(f, u) DCNL DCSP zero_g = dmp_zero_p(g, u) DCNL DCSP if (zero_f and zero_g): DCNL DCSP  DCSP return tuple(dmp_zeros(3, u, K)) DCNL DCSP elif zero_f: DCNL DCSP  DCSP return (dmp_ground_monic(g, u, K), dmp_zero(u), dmp_ground(dmp_ground_LC(g, u, K), u)) DCNL DCSP elif zero_g: DCNL DCSP  DCSP return (dmp_ground_monic(f, u, K), dmp_ground(dmp_ground_LC(f, u, K), u), dmp_zero(u)) DCNL DCSP elif query('USE_SIMPLIFY_GCD'): DCNL DCSP  DCSP return _dmp_simplify_gcd(f, g, u, K) DCNL DCSP else: DCNL DCSP  DCSP return None\n", "intent": "handle trivial cases in gcd algorithm over a field .\n", "question_id": 1223}, {"snippet": "def get_qiime_scripts_dir(): DCNL  DCSP script_fp = which('print_qiime_config.py') DCNL DCSP if (script_fp is None): DCNL DCSP  DCSP raise ScriptsDirError('Could DCSP not DCSP find DCSP the DCSP directory DCSP containing DCSP QIIME DCSP scripts. DCSP QIIME DCSP scripts DCSP must DCSP be DCSP accessible DCSP via DCSP the DCSP PATH DCSP environment DCSP variable, DCSP and DCSP they DCSP must DCSP be DCSP executable. DCSP Please DCSP ensure DCSP that DCSP you DCSP have DCSP a DCSP valid DCSP QIIME DCSP installation DCSP (see DCSP the DCSP QIIME DCSP Installation DCSP Guide: DCSP http://qiime.org/install/install.html).') DCNL DCSP return dirname(script_fp)\n", "intent": "return the directory containing qiime scripts .\n", "question_id": 1224}, {"snippet": "@export_as_api DCNL @ExecutionContext.enforce_phase(EXECUTION_PHASE.BEFORE_TRADING, EXECUTION_PHASE.HANDLE_BAR, EXECUTION_PHASE.SCHEDULED) DCNL def get_order(order_id): DCNL  DCSP return get_simu_exchange().get_order(order_id)\n", "intent": "get a specified order by the unique order_id .\n", "question_id": 1225}, {"snippet": "def ode_1st_exact(eq, func, order, match): DCNL  DCSP x = func.args[0] DCNL DCSP f = func.func DCNL DCSP r = match DCNL DCSP e = r[r['e']] DCNL DCSP d = r[r['d']] DCNL DCSP global y DCNL DCSP y = r['y'] DCNL DCSP C1 = get_numbered_constants(eq, num=1) DCNL DCSP sol = (Integral(d, x) + Integral((e - Integral(d, x).diff(y)), y)) DCNL DCSP return Eq(sol, C1)\n", "intent": "solves 1st order exact ordinary differential equations .\n", "question_id": 1226}, {"snippet": "def restart(name): DCNL  DCSP return reboot(name)\n", "intent": "this is a compatibility function which simply calls nspawn .\n", "question_id": 1227}, {"snippet": "def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP sensor = ImapSensor(config.get(CONF_NAME, None), config.get(CONF_USERNAME), config.get(CONF_PASSWORD), config.get(CONF_SERVER), config.get(CONF_PORT)) DCNL DCSP if sensor.connection: DCNL DCSP  DCSP add_devices([sensor]) DCNL DCSP else: DCNL DCSP  DCSP return False\n", "intent": "setup the imap platform .\n", "question_id": 1228}, {"snippet": "def check_cli(module, cli): DCNL  DCSP name = module.params['pn_name'] DCNL DCSP global VROUTER_EXISTS, VROUTER_NAME_EXISTS DCNL DCSP location = (cli + ' DCSP switch-setup-show DCSP format DCSP switch-name') DCNL DCSP location = shlex.split(location) DCNL DCSP out = module.run_command(location)[1] DCNL DCSP location = out.split()[1] DCNL DCSP check_vrouter = (cli + (' DCSP vrouter-show DCSP location DCSP %s DCSP ' % location)) DCNL DCSP check_vrouter += 'format DCSP name DCSP no-show-headers' DCNL DCSP check_vrouter = shlex.split(check_vrouter) DCNL DCSP out = module.run_command(check_vrouter)[1] DCNL DCSP if out: DCNL DCSP  DCSP VROUTER_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_EXISTS = False DCNL DCSP show = (cli + ' DCSP vrouter-show DCSP format DCSP name DCSP no-show-headers DCSP ') DCNL DCSP show = shlex.split(show) DCNL DCSP out = module.run_command(show)[1] DCNL DCSP out = out.split() DCNL DCSP if (name in out): DCNL DCSP  DCSP VROUTER_NAME_EXISTS = True DCNL DCSP else: DCNL DCSP  DCSP VROUTER_NAME_EXISTS = False\n", "intent": "this method checks for idempotency using the vlan-show command .\n", "question_id": 1229}, {"snippet": "def cell_to_rowcol(cell): DCNL  DCSP m = _re_cell_ex.match(cell) DCNL DCSP if (not m): DCNL DCSP  DCSP raise Exception(('Ill-formed DCSP single_cell DCSP reference: DCSP %s' % cell)) DCNL DCSP (col_abs, col, row_abs, row) = m.groups() DCNL DCSP row_abs = bool(row_abs) DCNL DCSP col_abs = bool(col_abs) DCNL DCSP row = (int(row) - 1) DCNL DCSP col = col_by_name(col.upper()) DCNL DCSP return (row, col, row_abs, col_abs)\n", "intent": "convert an excel cell reference string in a1 notation to numeric row/col notation .\n", "question_id": 1230}, {"snippet": "def previous_current_next(items): DCNL  DCSP extend = itertools.chain([None], items, [None]) DCNL DCSP (prev, cur, nex) = itertools.tee(extend, 3) DCNL DCSP next(cur) DCNL DCSP next(nex) DCNL DCSP next(nex) DCNL DCSP return zip(prev, cur, nex)\n", "intent": "from URL creates an iterator which returns  triples .\n", "question_id": 1231}, {"snippet": "def _reinstall_default_lookups(): DCNL  DCSP _install_lookups(dict(instance_state=_default_state_getter, instance_dict=_default_dict_getter, manager_of_class=_default_manager_getter)) DCNL DCSP _instrumentation_factory._extended = False\n", "intent": "restore simplified lookups .\n", "question_id": 1232}, {"snippet": "def _parse_sequence(sequence): DCNL  DCSP if ((not sequence) or (sequence[0] != '<') or (sequence[(-1)] != '>')): DCNL DCSP  DCSP return None DCNL DCSP words = sequence[1:(-1)].split('-') DCNL DCSP modifiers = 0 DCNL DCSP while (words and (words[0] in _modifier_names)): DCNL DCSP  DCSP modifiers |= (1 << _modifier_names[words[0]]) DCNL DCSP  DCSP del words[0] DCNL DCSP if (words and (words[0] in _type_names)): DCNL DCSP  DCSP type = _type_names[words[0]] DCNL DCSP  DCSP del words[0] DCNL DCSP else: DCNL DCSP  DCSP return None DCNL DCSP if (_binder_classes[type] is _SimpleBinder): DCNL DCSP  DCSP if (modifiers or words): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP detail = None DCNL DCSP else: DCNL DCSP  DCSP if (type in [_type_names[s] for s in ('KeyPress', 'KeyRelease')]): DCNL DCSP  DCSP  DCSP type_re = _keysym_re DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP type_re = _button_re DCNL DCSP  DCSP if (not words): DCNL DCSP  DCSP  DCSP detail = None DCNL DCSP  DCSP elif ((len(words) == 1) and type_re.match(words[0])): DCNL DCSP  DCSP  DCSP detail = words[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP return (modifiers, type, detail)\n", "intent": "get a string which should describe an event sequence .\n", "question_id": 1233}, {"snippet": "def get_feature(features, id, tags=('locus_tag', 'gene', 'old_locus_tag')): DCNL  DCSP for f in features: DCNL DCSP  DCSP for key in tags: DCNL DCSP  DCSP  DCSP for x in f.qualifiers.get(key, []): DCNL DCSP  DCSP  DCSP  DCSP if (x == id): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f DCNL DCSP raise KeyError(id)\n", "intent": "search list of seqfeature objects for an identifier under the given tags .\n", "question_id": 1234}, {"snippet": "def _is_svc(svc_path): DCNL  DCSP run_file = os.path.join(svc_path, 'run') DCNL DCSP if (os.path.exists(svc_path) and os.path.exists(run_file) and os.access(run_file, os.X_OK)): DCNL DCSP  DCSP return True DCNL DCSP return False\n", "intent": "return true if directory <svc_path> is really a service: file <svc_path>/run exists and is executable svc_path the  directory to check for compatibility .\n", "question_id": 1235}, {"snippet": "def pool_create(request, **kwargs): DCNL  DCSP body = {'pool': {'name': kwargs['name'], 'description': kwargs['description'], 'subnet_id': kwargs['subnet_id'], 'protocol': kwargs['protocol'], 'lb_method': kwargs['lb_method'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP pool = quantumclient(request).create_pool(body).get('pool') DCNL DCSP return Pool(pool)\n", "intent": "create a pool for specified protocol .\n", "question_id": 1236}, {"snippet": "def do_translate(parser, token): DCNL  DCSP class TranslateParser(TokenParser, ): DCNL DCSP  DCSP def top(self): DCNL DCSP  DCSP  DCSP value = self.value() DCNL DCSP  DCSP  DCSP if self.more(): DCNL DCSP  DCSP  DCSP  DCSP if (self.tag() == 'noop'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP noop = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError, \"only DCSP option DCSP for DCSP 'trans' DCSP is DCSP 'noop'\" DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP noop = False DCNL DCSP  DCSP  DCSP return (value, noop) DCNL DCSP (value, noop) = TranslateParser(token.contents).top() DCNL DCSP return TranslateNode(value, noop)\n", "intent": "this will mark a string for translation and will translate the string for the current language .\n", "question_id": 1237}, {"snippet": "def install_from_oracle_site(version=DEFAULT_VERSION): DCNL  DCSP prefix = '/opt' DCNL DCSP (release, build) = version.split('-') DCNL DCSP (major, update) = release.split('u') DCNL DCSP if (len(update) == 1): DCNL DCSP  DCSP update = ('0' + update) DCNL DCSP arch = _required_jdk_arch() DCNL DCSP self_extracting_archive = (major == '6') DCNL DCSP extension = ('bin' if self_extracting_archive else 'tar.gz') DCNL DCSP filename = ('jdk-%(release)s-linux-%(arch)s.%(extension)s' % locals()) DCNL DCSP download_path = posixpath.join('/tmp', filename) DCNL DCSP url = ('http://download.oracle.com/otn-pub/java/jdk/%(version)s/%(filename)s' % locals()) DCNL DCSP _download(url, download_path) DCNL DCSP install_dir = ('jdk1.%(major)s.0_%(update)s' % locals()) DCNL DCSP with cd(prefix): DCNL DCSP  DCSP if is_dir(install_dir): DCNL DCSP  DCSP  DCSP run_as_root(('rm DCSP -rf DCSP %s' % quote(install_dir))) DCNL DCSP if self_extracting_archive: DCNL DCSP  DCSP run(('chmod DCSP u+x DCSP %s' % quote(download_path))) DCNL DCSP  DCSP with cd('/tmp'): DCNL DCSP  DCSP  DCSP run_as_root(('rm DCSP -rf DCSP %s' % quote(install_dir))) DCNL DCSP  DCSP  DCSP run_as_root(('./%s' % filename)) DCNL DCSP  DCSP  DCSP run_as_root(('mv DCSP %s DCSP %s' % (quote(install_dir), quote(prefix)))) DCNL DCSP else: DCNL DCSP  DCSP with cd(prefix): DCNL DCSP  DCSP  DCSP run_as_root(('tar DCSP xzvf DCSP %s' % quote(download_path))) DCNL DCSP link_path = posixpath.join(prefix, 'jdk') DCNL DCSP if is_link(link_path): DCNL DCSP  DCSP run_as_root(('rm DCSP -f DCSP %s' % quote(link_path))) DCNL DCSP run_as_root(('ln DCSP -s DCSP %s DCSP %s' % (quote(install_dir), quote(link_path)))) DCNL DCSP run(('rm DCSP -f DCSP %s' % quote(download_path))) DCNL DCSP _create_profile_d_file(prefix)\n", "intent": "download tarball from oracle site and install jdk .\n", "question_id": 1238}, {"snippet": "def create_connection(parsed_url): DCNL  DCSP if (parsed_url.scheme == 'https'): DCNL DCSP  DCSP conn = httplib.HTTPSConnection(parsed_url.netloc) DCNL DCSP else: DCNL DCSP  DCSP conn = httplib.HTTPConnection(parsed_url.netloc) DCNL DCSP return conn\n", "intent": "helper function to create connection with httplib .\n", "question_id": 1239}, {"snippet": "def show_port(port, profile=None): DCNL  DCSP conn = _auth(profile) DCNL DCSP return conn.show_port(port)\n", "intent": "fetches information of a certain port cli example: .\n", "question_id": 1240}, {"snippet": "def __TimeZoneKeyNameWorkaround(name): DCNL  DCSP try: DCNL DCSP  DCSP return name[:name.index('\\x00')] DCNL DCSP except ValueError: DCNL DCSP  DCSP return name\n", "intent": "it may be a bug in vista .\n", "question_id": 1241}, {"snippet": "def is_valid_module(filename): DCNL  DCSP if (not filename.endswith('.py')): DCNL DCSP  DCSP return False DCNL DCSP if (filename == '__init__.py'): DCNL DCSP  DCSP return True DCNL DCSP for prefix in IGNORED_PREFIXES: DCNL DCSP  DCSP if filename.startswith(prefix): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True\n", "intent": "determines if a filename is a valid python module .\n", "question_id": 1242}, {"snippet": "def _txt2obj(backend, name): DCNL  DCSP name = name.encode('ascii') DCNL DCSP obj = backend._lib.OBJ_txt2obj(name, 1) DCNL DCSP backend.openssl_assert((obj != backend._ffi.NULL)) DCNL DCSP return obj\n", "intent": "converts a python string with an asn .\n", "question_id": 1243}, {"snippet": "@gen.engine DCNL def Grep(args, callback): DCNL  DCSP assert (len(args) >= 2) DCNL DCSP pattern = re.compile(args[0]) DCNL DCSP files = args[1:] DCNL DCSP bucket = store = None DCNL DCSP for f in files: DCNL DCSP  DCSP resolved = store_utils.ParseFullPath(f) DCNL DCSP  DCSP assert (resolved is not None), ('Cannot DCSP determine DCSP bucket DCSP from DCSP %s' % f) DCNL DCSP  DCSP (b, path) = resolved DCNL DCSP  DCSP assert ((bucket is None) or (bucket == b)), 'Input DCSP files DCSP must DCSP all DCSP be DCSP in DCSP the DCSP same DCSP bucket' DCNL DCSP  DCSP if (store is None): DCNL DCSP  DCSP  DCSP bucket = b DCNL DCSP  DCSP  DCSP store = ObjectStore.GetInstance(bucket) DCNL DCSP  DCSP contents = (yield gen.Task(store_utils.GetFileContents, store, path)) DCNL DCSP  DCSP for line in contents.split('\\n'): DCNL DCSP  DCSP  DCSP if pattern.search(line): DCNL DCSP  DCSP  DCSP  DCSP print ('%s:%s' % (f, line)) DCNL DCSP callback()\n", "intent": "grep a set of files .\n", "question_id": 1244}, {"snippet": "def guadd(a, b, c): DCNL  DCSP (x, y) = c.shape DCNL DCSP for i in range(x): DCNL DCSP  DCSP for j in range(y): DCNL DCSP  DCSP  DCSP c[(i, j)] = (a[(i, j)] + b[(i, j)])\n", "intent": "a generalized addition .\n", "question_id": 1245}, {"snippet": "def logm(A, disp=True): DCNL  DCSP A = _asarray_square(A) DCNL DCSP import scipy.linalg._matfuncs_inv_ssq DCNL DCSP F = scipy.linalg._matfuncs_inv_ssq._logm(A) DCNL DCSP F = _maybe_real(A, F) DCNL DCSP errtol = (1000 * eps) DCNL DCSP errest = (norm((expm(F) - A), 1) / norm(A, 1)) DCNL DCSP if disp: DCNL DCSP  DCSP if ((not isfinite(errest)) or (errest >= errtol)): DCNL DCSP  DCSP  DCSP print('logm DCSP result DCSP may DCSP be DCSP inaccurate, DCSP approximate DCSP err DCSP =', errest) DCNL DCSP  DCSP return F DCNL DCSP else: DCNL DCSP  DCSP return (F, errest)\n", "intent": "compute matrix logarithm .\n", "question_id": 1246}, {"snippet": "def get_text(xmlns, rich_node): DCNL  DCSP text_node = rich_node.find(QName(xmlns, 't').text) DCNL DCSP partial_text = (text_node.text or '') DCNL DCSP if (text_node.get(QName(NAMESPACES['xml'], 'space').text) != 'preserve'): DCNL DCSP  DCSP partial_text = partial_text.strip() DCNL DCSP return str(partial_text)\n", "intent": "read rich text .\n", "question_id": 1247}, {"snippet": "def addListsSetCraftProfile(craftSequence, defaultProfile, repository, fileNameHelp): DCNL  DCSP settings.addListsToRepository(fileNameHelp, repository) DCNL DCSP repository.craftSequenceLabel = settings.LabelDisplay().getFromName('Craft DCSP Sequence: DCSP ', repository) DCNL DCSP craftToolStrings = [] DCNL DCSP for craftTool in craftSequence[:(-1)]: DCNL DCSP  DCSP craftToolStrings.append((settings.getEachWordCapitalized(craftTool) + '->')) DCNL DCSP craftToolStrings.append(settings.getEachWordCapitalized(craftSequence[(-1)])) DCNL DCSP for craftToolStringIndex in xrange(0, len(craftToolStrings), 5): DCNL DCSP  DCSP craftLine = ' DCSP '.join(craftToolStrings[craftToolStringIndex:(craftToolStringIndex + 5)]) DCNL DCSP  DCSP settings.LabelDisplay().getFromName(craftLine, repository) DCNL DCSP settings.LabelDisplay().getFromName('', repository) DCNL DCSP repository.profileList = ProfileList().getFromName('Profile DCSP List:', repository) DCNL DCSP repository.profileListbox = ProfileListboxSetting().getFromListSetting(repository.profileList, 'Profile DCSP Selection:', repository, defaultProfile) DCNL DCSP repository.addListboxSelection = AddProfile().getFromProfileListboxSettingRepository(repository.profileListbox, repository) DCNL DCSP repository.deleteListboxSelection = DeleteProfile().getFromProfileListboxSettingRepository(repository.profileListbox, repository) DCNL DCSP directoryName = archive.getProfilesPath() DCNL DCSP archive.makeDirectory(directoryName) DCNL DCSP repository.windowPosition.value = '0+400'\n", "intent": "set the craft profile repository .\n", "question_id": 1248}, {"snippet": "def build_instance_groups(parsed_instance_groups): DCNL  DCSP instance_groups = [] DCNL DCSP for instance_group in parsed_instance_groups: DCNL DCSP  DCSP ig_config = {} DCNL DCSP  DCSP keys = instance_group.keys() DCNL DCSP  DCSP if ('Name' in keys): DCNL DCSP  DCSP  DCSP ig_config['Name'] = instance_group['Name'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ig_config['Name'] = instance_group['InstanceGroupType'] DCNL DCSP  DCSP ig_config['InstanceType'] = instance_group['InstanceType'] DCNL DCSP  DCSP ig_config['InstanceCount'] = instance_group['InstanceCount'] DCNL DCSP  DCSP ig_config['InstanceRole'] = instance_group['InstanceGroupType'].upper() DCNL DCSP  DCSP if ('BidPrice' in keys): DCNL DCSP  DCSP  DCSP ig_config['BidPrice'] = instance_group['BidPrice'] DCNL DCSP  DCSP  DCSP ig_config['Market'] = constants.SPOT DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ig_config['Market'] = constants.ON_DEMAND DCNL DCSP  DCSP if ('EbsConfiguration' in keys): DCNL DCSP  DCSP  DCSP ig_config['EbsConfiguration'] = instance_group['EbsConfiguration'] DCNL DCSP  DCSP if ('AutoScalingPolicy' in keys): DCNL DCSP  DCSP  DCSP ig_config['AutoScalingPolicy'] = instance_group['AutoScalingPolicy'] DCNL DCSP  DCSP instance_groups.append(ig_config) DCNL DCSP return instance_groups\n", "intent": "helper method that converts --instance-groups option value in create-cluster and add-instance-groups to amazon elastic mapreduce instancegroupconfig data type .\n", "question_id": 1249}, {"snippet": "def wait_for_xblock_initialization(page, xblock_css): DCNL  DCSP def _is_finished_loading(): DCNL DCSP  DCSP is_done = page.browser.execute_script(\"return DCSP $({!r}).data('initialized')\".format(xblock_css)) DCNL DCSP  DCSP return (is_done, is_done) DCNL DCSP return Promise(_is_finished_loading, 'Finished DCSP initializing DCSP the DCSP xblock.').fulfill()\n", "intent": "wait for the xblock with the given css to finish initializing .\n", "question_id": 1250}, {"snippet": "def _hc_cut(n_clusters, children, n_leaves): DCNL  DCSP if (n_clusters > n_leaves): DCNL DCSP  DCSP raise ValueError(('Cannot DCSP extract DCSP more DCSP clusters DCSP than DCSP samples: DCSP %s DCSP clusters DCSP where DCSP given DCSP for DCSP a DCSP tree DCSP with DCSP %s DCSP leaves.' % (n_clusters, n_leaves))) DCNL DCSP nodes = [(- (max(children[(-1)]) + 1))] DCNL DCSP for i in xrange((n_clusters - 1)): DCNL DCSP  DCSP these_children = children[((- nodes[0]) - n_leaves)] DCNL DCSP  DCSP heappush(nodes, (- these_children[0])) DCNL DCSP  DCSP heappushpop(nodes, (- these_children[1])) DCNL DCSP label = np.zeros(n_leaves, dtype=np.intp) DCNL DCSP for (i, node) in enumerate(nodes): DCNL DCSP  DCSP label[_hierarchical._hc_get_descendent((- node), children, n_leaves)] = i DCNL DCSP return label\n", "intent": "function cutting the ward tree for a given number of clusters .\n", "question_id": 1251}, {"snippet": "def _read_link(name): DCNL  DCSP alt_link_path = '/etc/alternatives/{0}'.format(name) DCNL DCSP return os.readlink(alt_link_path)\n", "intent": "read the link from /etc/alternatives throws an oserror if the link does not exist .\n", "question_id": 1252}, {"snippet": "def service_create(name, service_type, description=None, profile=None, **connection_args): DCNL  DCSP kstone = auth(profile, **connection_args) DCNL DCSP service = kstone.services.create(name, service_type, description=description) DCNL DCSP return service_get(service.id, profile=profile, **connection_args)\n", "intent": "add service to keystone service catalog cli examples: .\n", "question_id": 1253}, {"snippet": "def bootstrap_plot(series, fig=None, size=50, samples=500, **kwds): DCNL  DCSP import random DCNL DCSP import matplotlib.pyplot as plt DCNL DCSP data = list(series.values) DCNL DCSP samplings = [random.sample(data, size) for _ in range(samples)] DCNL DCSP means = np.array([np.mean(sampling) for sampling in samplings]) DCNL DCSP medians = np.array([np.median(sampling) for sampling in samplings]) DCNL DCSP midranges = np.array([((min(sampling) + max(sampling)) * 0.5) for sampling in samplings]) DCNL DCSP if (fig is None): DCNL DCSP  DCSP fig = plt.figure() DCNL DCSP x = lrange(samples) DCNL DCSP axes = [] DCNL DCSP ax1 = fig.add_subplot(2, 3, 1) DCNL DCSP ax1.set_xlabel('Sample') DCNL DCSP axes.append(ax1) DCNL DCSP ax1.plot(x, means, **kwds) DCNL DCSP ax2 = fig.add_subplot(2, 3, 2) DCNL DCSP ax2.set_xlabel('Sample') DCNL DCSP axes.append(ax2) DCNL DCSP ax2.plot(x, medians, **kwds) DCNL DCSP ax3 = fig.add_subplot(2, 3, 3) DCNL DCSP ax3.set_xlabel('Sample') DCNL DCSP axes.append(ax3) DCNL DCSP ax3.plot(x, midranges, **kwds) DCNL DCSP ax4 = fig.add_subplot(2, 3, 4) DCNL DCSP ax4.set_xlabel('Mean') DCNL DCSP axes.append(ax4) DCNL DCSP ax4.hist(means, **kwds) DCNL DCSP ax5 = fig.add_subplot(2, 3, 5) DCNL DCSP ax5.set_xlabel('Median') DCNL DCSP axes.append(ax5) DCNL DCSP ax5.hist(medians, **kwds) DCNL DCSP ax6 = fig.add_subplot(2, 3, 6) DCNL DCSP ax6.set_xlabel('Midrange') DCNL DCSP axes.append(ax6) DCNL DCSP ax6.hist(midranges, **kwds) DCNL DCSP for axis in axes: DCNL DCSP  DCSP plt.setp(axis.get_xticklabels(), fontsize=8) DCNL DCSP  DCSP plt.setp(axis.get_yticklabels(), fontsize=8) DCNL DCSP return fig\n", "intent": "bootstrap plot .\n", "question_id": 1254}, {"snippet": "def emboss(img, azi=45.0, ele=18.0, dep=2): DCNL  DCSP ele = (((ele * 2) * numpy.pi) / 360.0) DCNL DCSP azi = (((azi * 2) * numpy.pi) / 360.0) DCNL DCSP a = numpy.asarray(img).astype('float') DCNL DCSP grad = numpy.gradient(a) DCNL DCSP (grad_x, grad_y) = grad DCNL DCSP gd = numpy.cos(ele) DCNL DCSP dx = (gd * numpy.cos(azi)) DCNL DCSP dy = (gd * numpy.sin(azi)) DCNL DCSP dz = numpy.sin(ele) DCNL DCSP grad_x = ((grad_x * dep) / 100.0) DCNL DCSP grad_y = ((grad_y * dep) / 100.0) DCNL DCSP leng = numpy.sqrt((((grad_x ** 2) + (grad_y ** 2)) + 1.0)) DCNL DCSP uni_x = (grad_x / leng) DCNL DCSP uni_y = (grad_y / leng) DCNL DCSP uni_z = (1.0 / leng) DCNL DCSP a2 = (255 * (((dx * uni_x) + (dy * uni_y)) + (dz * uni_z))) DCNL DCSP a2 = a2.clip(0, 255) DCNL DCSP return Image.fromarray(a2.astype('uint8'))\n", "intent": "perform embossing of image img .\n", "question_id": 1255}, {"snippet": "def get_profile_user_fieldname(profile_model=None, user_model=None): DCNL  DCSP Profile = (profile_model or get_profile_model()) DCNL DCSP User = (user_model or get_user_model()) DCNL DCSP for field in Profile._meta.fields: DCNL DCSP  DCSP if (field.rel and (field.rel.to == User)): DCNL DCSP  DCSP  DCSP return field.name DCNL DCSP raise ImproperlyConfigured((u'Value DCSP for DCSP ACCOUNTS_PROFILE_MODEL DCSP does DCSP not DCSP contain DCSP a DCSP ForeignKey DCSP field DCSP for DCSP auth.User: DCSP %s' % Profile.__name__))\n", "intent": "returns the name of the first field on the profile model that points to the auth .\n", "question_id": 1256}, {"snippet": "@pytest.fixture(scope='function') DCNL def status(app): DCNL  DCSP return app._status\n", "intent": "compat for testing with previous @with_app decorator .\n", "question_id": 1257}, {"snippet": "def test_mapping(value): DCNL  DCSP return isinstance(value, MappingType)\n", "intent": "return true if the object is a mapping .\n", "question_id": 1258}, {"snippet": "def print_sample(ex_source, ex_reference, ex_prediction, src_dict, tgt_dict): DCNL  DCSP sample_output = u'\\n DCSP  DCSP  DCSP  DCSP Source DCSP Sentence: DCSP {source}\\n DCSP  DCSP  DCSP  DCSP Reference DCSP Translation: DCSP {reference}\\n DCSP  DCSP  DCSP  DCSP Predicted DCSP Translation: DCSP {prediction}\\n DCSP  DCSP  DCSP  DCSP '.format(source=' DCSP '.join([src_dict[k].decode('utf-8') for k in ex_source]), reference=' DCSP '.join([tgt_dict[k].decode('utf-8') for k in ex_reference]), prediction=' DCSP '.join([tgt_dict[k].decode('utf-8') for k in ex_prediction])) DCNL DCSP print sample_output.encode('utf-8')\n", "intent": "print some example predictions .\n", "question_id": 1259}, {"snippet": "def _Q(filter_, thing): DCNL  DCSP T = type(thing) DCNL DCSP if isinstance({}, T): DCNL DCSP  DCSP for (k, v) in compat.iteritems(thing): DCNL DCSP  DCSP  DCSP if (filter_ == k): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(v, type([])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield iter(v)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield v) DCNL DCSP  DCSP  DCSP if (type(v) in (type({}), type([]))): DCNL DCSP  DCSP  DCSP  DCSP (yield Q(filter_, v)) DCNL DCSP elif isinstance([], T): DCNL DCSP  DCSP for k in thing: DCNL DCSP  DCSP  DCSP (yield Q(filter_, k)) DCNL DCSP else: DCNL DCSP  DCSP pass\n", "intent": "underlying machinery for q function recursion .\n", "question_id": 1260}, {"snippet": "def _norm_version(version, build=''): DCNL  DCSP l = version.split('.') DCNL DCSP if build: DCNL DCSP  DCSP l.append(build) DCNL DCSP try: DCNL DCSP  DCSP ints = map(int, l) DCNL DCSP except ValueError: DCNL DCSP  DCSP strings = l DCNL DCSP else: DCNL DCSP  DCSP strings = list(map(str, ints)) DCNL DCSP version = '.'.join(strings[:3]) DCNL DCSP return version\n", "intent": "normalize the version and build strings and return a single version string using the format major .\n", "question_id": 1261}, {"snippet": "def check_table(table=None, family='ipv4'): DCNL  DCSP if (not table): DCNL DCSP  DCSP return 'Error: DCSP table DCSP needs DCSP to DCSP be DCSP specified' DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmd = '{0} DCSP list DCSP tables DCSP {1}'.format(_nftables_cmd(), nft_family) DCNL DCSP out = __salt__['cmd.run'](cmd, python_shell=False).find('table DCSP {0} DCSP {1}'.format(nft_family, table)) DCNL DCSP if (out != (-1)): DCNL DCSP  DCSP out = '' DCNL DCSP else: DCNL DCSP  DCSP return False DCNL DCSP if (not out): DCNL DCSP  DCSP return True DCNL DCSP return out\n", "intent": "check for the existence of a table cli example:: salt * nftables .\n", "question_id": 1262}, {"snippet": "def mismatch(mismatched, description, details): DCNL  DCSP return _Mismatch(mismatched=mismatched, _description=description, _details=details)\n", "intent": "create an immutable mismatch that also stores the mismatched object .\n", "question_id": 1263}, {"snippet": "def invert(image): DCNL  DCSP lut = [] DCNL DCSP for i in range(256): DCNL DCSP  DCSP lut.append((255 - i)) DCNL DCSP return _lut(image, lut)\n", "intent": "invert  the image .\n", "question_id": 1264}, {"snippet": "def org_facility_controller(): DCNL  DCSP db = current.db DCNL DCSP s3db = current.s3db DCNL DCSP s3 = current.response.s3 DCNL DCSP def prep(r): DCNL DCSP  DCSP s3db.gis_location_filter(r) DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP method = r.method DCNL DCSP  DCSP  DCSP  DCSP get_vars = r.get_vars DCNL DCSP  DCSP  DCSP  DCSP type_filter = get_vars.get('facility_type.name', None) DCNL DCSP  DCSP  DCSP  DCSP if type_filter: DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_names = [s3_unicode(name).lower().strip() for name in type_filter.split(',')] DCNL DCSP  DCSP  DCSP  DCSP  DCSP field = s3db.org_site_facility_type.facility_type_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.comment = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(type_names) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP list_fields = s3db.get_config('org_facility', 'list_fields') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP list_fields.remove('site_facility_type.facility_type_id') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((not method) or (method == 'create')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP type_table = s3db.org_facility_type DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = (type_table.name == type_filter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP row = db(query).select(type_table.id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP type_id = (row and row.id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if type_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.default = type_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP crud_form = s3db.get_config('org_facility', 'crud_form') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for e in crud_form.elements: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (e.selector == 'facility_type'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.options.label = '' DCNL DCSP  DCSP  DCSP  DCSP if r.id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP field = table.obsolete DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.readable = field.writable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((method == 'update') and (r.representation == 'popup') and (get_vars.get('profile') == 'org_organisation')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field = table.organisation_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.readable = False DCNL DCSP  DCSP  DCSP  DCSP elif (method == 'create'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP name = get_vars.get('name') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.default = name DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((r.representation == 'popup') and (get_vars.get('profile') == 'org_organisation')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP organisation_id = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for k in ('~.organisation_id', '(organisation)', '~.(organisation)'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (k in get_vars): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP organisation_id = get_vars[k] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (organisation_id is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field = table.organisation_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.default = organisation_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP field.readable = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cname = r.component_name DCNL DCSP  DCSP  DCSP  DCSP if (cname in ('inv_item', 'recv', 'send')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.inv_prep(r) DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.configure('inv_inv_item', create=False, deletable=False, editable=False, listadd=False) DCNL DCSP  DCSP  DCSP  DCSP elif (cname == 'human_resource'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP org_site_staff_config(r) DCNL DCSP  DCSP  DCSP  DCSP elif ((cname == 'req') and (r.method not in ('update', 'read'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.req_create_form_mods() DCNL DCSP  DCSP  DCSP  DCSP elif (cname == 'asset'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP record = r.record DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable = s3db.asset_asset DCNL DCSP  DCSP  DCSP  DCSP  DCSP field = atable.organisation_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.default = record.organisation_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.readable = field.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP field = atable.site_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.default = record.site_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP field.readable = field.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3db.configure('asset_asset', create_next=None) DCNL DCSP  DCSP elif (r.representation == 'geojson'): DCNL DCSP  DCSP  DCSP mtable = s3db.gis_marker DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP def postp(r, output): DCNL DCSP  DCSP record = r.record DCNL DCSP  DCSP if ((r.representation == 'plain') and record): DCNL DCSP  DCSP  DCSP T = current.T DCNL DCSP  DCSP  DCSP output = TABLE() DCNL DCSP  DCSP  DCSP append = output.append DCNL DCSP  DCSP  DCSP append(TR(TD(A(T('Edit'), _target='_blank', _id='edit-btn', _href=URL(args=[r.id, 'update']))))) DCNL DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % T('Name')))), TD(record.name))) DCNL DCSP  DCSP  DCSP site_id = record.site_id DCNL DCSP  DCSP  DCSP ttable = db.org_facility_type DCNL DCSP  DCSP  DCSP ltable = db.org_site_facility_type DCNL DCSP  DCSP  DCSP query = ((ltable.site_id == site_id) & (ltable.facility_type_id == ttable.id)) DCNL DCSP  DCSP  DCSP rows = db(query).select(ttable.name) DCNL DCSP  DCSP  DCSP if rows: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ltable.facility_type_id.label))), TD(', DCSP '.join([row.name for row in rows])))) DCNL DCSP  DCSP  DCSP ftable = r.table DCNL DCSP  DCSP  DCSP if record.comments: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.comments.label))), TD(ftable.comments.represent(record.comments)))) DCNL DCSP  DCSP  DCSP table = db.org_organisation DCNL DCSP  DCSP  DCSP org = db((table.id == record.organisation_id)).select(table.name, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if org: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.organisation_id.label))), TD(org.name))) DCNL DCSP  DCSP  DCSP if current.deployment_settings.has_module('req'): DCNL DCSP  DCSP  DCSP  DCSP rtable = s3db.req_req DCNL DCSP  DCSP  DCSP  DCSP query = (((rtable.site_id == site_id) & (rtable.fulfil_status != 2)) & rtable.priority.belongs((2, 3))) DCNL DCSP  DCSP  DCSP  DCSP reqs = db(query).select(rtable.id, rtable.req_ref, rtable.type) DCNL DCSP  DCSP  DCSP  DCSP if reqs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % T('Requests')))))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP req_types = {1: 'req_item', 3: 'req_skill', 8: '', 9: ''} DCNL DCSP  DCSP  DCSP  DCSP  DCSP vals = [A(req.req_ref, _href=URL(c='req', f='req', args=[req.id, req_types[req.type]])) for req in reqs] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for val in vals: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP append(TR(TD(val, _colspan=2))) DCNL DCSP  DCSP  DCSP gtable = s3db.gis_location DCNL DCSP  DCSP  DCSP stable = s3db.org_site DCNL DCSP  DCSP  DCSP query = ((gtable.id == stable.location_id) & (stable.id == site_id)) DCNL DCSP  DCSP  DCSP location = db(query).select(gtable.addr_street, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if location.addr_street: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % gtable.addr_street.label))), TD(location.addr_street))) DCNL DCSP  DCSP  DCSP opens = record.opening_times DCNL DCSP  DCSP  DCSP if opens: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.opening_times.label))), TD(opens))) DCNL DCSP  DCSP  DCSP contact = record.contact DCNL DCSP  DCSP  DCSP if contact: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.contact.label))), TD(contact))) DCNL DCSP  DCSP  DCSP phone1 = record.phone1 DCNL DCSP  DCSP  DCSP if phone1: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.phone1.label))), TD(phone1))) DCNL DCSP  DCSP  DCSP email = record.email DCNL DCSP  DCSP  DCSP if email: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.email.label))), TD(A(email, _href=('mailto:%s' % email))))) DCNL DCSP  DCSP  DCSP website = record.website DCNL DCSP  DCSP  DCSP if website: DCNL DCSP  DCSP  DCSP  DCSP append(TR(TD(B(('%s:' % ftable.website.label))), TD(A(website, _href=website)))) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = current.rest_controller('org', 'facility', rheader=org_rheader) DCNL DCSP return output\n", "intent": "facility controller .\n", "question_id": 1265}, {"snippet": "def limited_integrate(fa, fd, G, DE): DCNL  DCSP (fa, fd) = ((fa * Poly((1 / fd.LC()), DE.t)), fd.monic()) DCNL DCSP (A, B, h, N, g, V) = limited_integrate_reduce(fa, fd, G, DE) DCNL DCSP V = ([g] + V) DCNL DCSP g = A.gcd(B) DCNL DCSP (A, B, V) = (A.quo(g), B.quo(g), [via.cancel((vid * g), include=True) for (via, vid) in V]) DCNL DCSP (Q, M) = prde_linear_constraints(A, B, V, DE) DCNL DCSP (M, _) = constant_system(M, zeros(M.rows, 1), DE) DCNL DCSP l = M.nullspace() DCNL DCSP if ((M == Matrix()) or (len(l) > 1)): DCNL DCSP  DCSP raise NotImplementedError('param_rischDE() DCSP is DCSP required DCSP to DCSP solve DCSP this DCSP integral.') DCNL DCSP elif (len(l) == 0): DCNL DCSP  DCSP raise NonElementaryIntegralException DCNL DCSP elif (len(l) == 1): DCNL DCSP  DCSP if l[0][0].is_zero: DCNL DCSP  DCSP  DCSP raise NonElementaryIntegralException DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP l[0] *= (1 / l[0][0]) DCNL DCSP  DCSP  DCSP C = sum([(Poly(i, DE.t) * q) for (i, q) in zip(l[0], Q)]) DCNL DCSP  DCSP  DCSP (B, C, m, alpha, beta) = spde(A, B, C, N, DE) DCNL DCSP  DCSP  DCSP y = solve_poly_rde(B, C, m, DE) DCNL DCSP  DCSP  DCSP return ((((alpha * y) + beta), h), list(l[0][1:])) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError\n", "intent": "solves the limited integration problem:  f = dv + sum(ci*wi .\n", "question_id": 1266}, {"snippet": "def remove(predicate, seq): DCNL  DCSP return filterfalse(predicate, seq)\n", "intent": "return those items of sequence for which predicate is false .\n", "question_id": 1267}, {"snippet": "def rad(degrees): DCNL  DCSP return ((pi * degrees) / 180)\n", "intent": "convert degrees in radiants .\n", "question_id": 1268}, {"snippet": "@cleanup DCNL def test_determinism_markers(): DCNL  DCSP _determinism_check(u'm', format=u'pdf')\n", "intent": "test for reproducible pdf output: figure with different markers .\n", "question_id": 1269}, {"snippet": "def GetResourceLimits(logging_context, error_fh=sys.stderr): DCNL  DCSP resource_limits = DEFAULT_RESOURCE_LIMITS.copy() DCNL DCSP StatusUpdate('Getting DCSP current DCSP resource DCSP limits.', error_fh) DCNL DCSP resource_limits.update(_GetRemoteResourceLimits(logging_context)) DCNL DCSP logging.debug('Using DCSP resource DCSP limits: DCSP %s', resource_limits) DCNL DCSP return resource_limits\n", "intent": "gets the resource limits .\n", "question_id": 1270}, {"snippet": "def binary_predicate(func, *args): DCNL  DCSP argtypes = [GEOM_PTR, GEOM_PTR] DCNL DCSP if args: DCNL DCSP  DCSP argtypes += args DCNL DCSP func.argtypes = argtypes DCNL DCSP func.restype = c_char DCNL DCSP func.errcheck = check_predicate DCNL DCSP return func\n", "intent": "for geos binary predicate functions .\n", "question_id": 1271}, {"snippet": "def convert(values): DCNL  DCSP dtype = values.dtype DCNL DCSP if is_categorical_dtype(values): DCNL DCSP  DCSP return values DCNL DCSP elif is_object_dtype(dtype): DCNL DCSP  DCSP return values.ravel().tolist() DCNL DCSP if needs_i8_conversion(dtype): DCNL DCSP  DCSP values = values.view('i8') DCNL DCSP v = values.ravel() DCNL DCSP if (compressor == 'zlib'): DCNL DCSP  DCSP _check_zlib() DCNL DCSP  DCSP if (dtype == np.object_): DCNL DCSP  DCSP  DCSP return v.tolist() DCNL DCSP  DCSP v = v.tostring() DCNL DCSP  DCSP return ExtType(0, zlib.compress(v)) DCNL DCSP elif (compressor == 'blosc'): DCNL DCSP  DCSP _check_blosc() DCNL DCSP  DCSP if (dtype == np.object_): DCNL DCSP  DCSP  DCSP return v.tolist() DCNL DCSP  DCSP v = v.tostring() DCNL DCSP  DCSP return ExtType(0, blosc.compress(v, typesize=dtype.itemsize)) DCNL DCSP return ExtType(0, v.tostring())\n", "intent": "convert the numpy values to a list .\n", "question_id": 1272}, {"snippet": "def addSquareTwoToPixelDictionary(pixelDictionary, point, value, width): DCNL  DCSP point /= width DCNL DCSP x = int(round(point.real)) DCNL DCSP y = int(round(point.imag)) DCNL DCSP for xStep in xrange((x - 2), (x + 3)): DCNL DCSP  DCSP for yStep in xrange((y - 2), (y + 3)): DCNL DCSP  DCSP  DCSP pixelDictionary[(xStep, yStep)] = value\n", "intent": "add square with two pixels around the center to pixel dictionary .\n", "question_id": 1273}, {"snippet": "def first(items): DCNL  DCSP return items[0]\n", "intent": "returns first item from a list .\n", "question_id": 1274}, {"snippet": "def example_exc_handler(tries_remaining, exception, delay): DCNL  DCSP print >>sys.stderr, (\"Caught DCSP '%s', DCSP %d DCSP tries DCSP remaining, DCSP sleeping DCSP for DCSP %s DCSP seconds\" % (exception, tries_remaining, delay))\n", "intent": "example exception handler; prints a warning to stderr .\n", "question_id": 1275}, {"snippet": "def init(mpstate): DCNL  DCSP return ADSBModule(mpstate)\n", "intent": "initialise module .\n", "question_id": 1276}, {"snippet": "@decorator.decorator DCNL def audio_video_fx(f, clip, *a, **k): DCNL  DCSP if hasattr(clip, 'audio'): DCNL DCSP  DCSP newclip = clip.copy() DCNL DCSP  DCSP if (clip.audio is not None): DCNL DCSP  DCSP  DCSP newclip.audio = f(clip.audio, *a, **k) DCNL DCSP  DCSP return newclip DCNL DCSP else: DCNL DCSP  DCSP return f(clip, *a, **k)\n", "intent": "use an audio function on a video/audio clip this decorator tells that the function f  can be also used on a video clip .\n", "question_id": 1277}, {"snippet": "def get_file(file_path): DCNL  DCSP return (file_path in _db_content.get('files'))\n", "intent": "check if file exists in the db .\n", "question_id": 1278}, {"snippet": "@register.simple_tag DCNL def one_param(arg): DCNL  DCSP return ('one_param DCSP - DCSP Expected DCSP result: DCSP %s' % arg)\n", "intent": "expected one_param __doc__ .\n", "question_id": 1279}, {"snippet": "def _host_find(context, session, src_aggregate, dst): DCNL  DCSP uuid = session.call_xenapi('host.get_record', dst)['uuid'] DCNL DCSP for (compute_host, host_uuid) in src_aggregate.metadetails.iteritems(): DCNL DCSP  DCSP if (host_uuid == uuid): DCNL DCSP  DCSP  DCSP return compute_host DCNL DCSP raise exception.NoValidHost(reason=('Host DCSP %(host_uuid)s DCSP could DCSP not DCSP be DCSP found DCSP from DCSP aggregate DCSP metadata: DCSP %(metadata)s.' % {'host_uuid': uuid, 'metadata': src_aggregate.metadetails}))\n", "intent": "return the host from the xenapi host reference .\n", "question_id": 1280}, {"snippet": "def get_user_model_name(): DCNL  DCSP return getattr(settings, u'AUTH_USER_MODEL', u'auth.User')\n", "intent": "returns the app_label .\n", "question_id": 1281}, {"snippet": "@register_uncanonicalize DCNL @gof.local_optimizer([T.Alloc]) DCNL def local_alloc_dimshuffle(node): DCNL  DCSP if isinstance(node.op, T.Alloc): DCNL DCSP  DCSP input_ = node.inputs[0] DCNL DCSP  DCSP if (input_.owner and isinstance(input_.owner.op, DimShuffle)): DCNL DCSP  DCSP  DCSP new_order = input_.owner.op.new_order DCNL DCSP  DCSP  DCSP expected_new_order = ((('x',) * (input_.ndim - input_.owner.inputs[0].ndim)) + tuple(range(input_.owner.inputs[0].ndim))) DCNL DCSP  DCSP  DCSP if (new_order != expected_new_order): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return [T.alloc(input_.owner.inputs[0], *node.inputs[1:])] DCNL DCSP return False\n", "intent": "if a dimshuffle is inside an alloc and only adds dimension to the left .\n", "question_id": 1282}, {"snippet": "@requires_sklearn DCNL def test_ica_full_data_recovery(): DCNL  DCSP raw = read_raw_fif(raw_fname).crop(0.5, stop).load_data() DCNL DCSP events = read_events(event_name) DCNL DCSP picks = pick_types(raw.info, meg=True, stim=False, ecg=False, eog=False, exclude='bads')[:10] DCNL DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP epochs = Epochs(raw, events[:4], event_id, tmin, tmax, picks=picks, baseline=(None, 0), preload=True) DCNL DCSP evoked = epochs.average() DCNL DCSP n_channels = 5 DCNL DCSP data = raw._data[:n_channels].copy() DCNL DCSP data_epochs = epochs.get_data() DCNL DCSP data_evoked = evoked.data DCNL DCSP for method in ['fastica']: DCNL DCSP  DCSP stuff = [(2, n_channels, True), (2, (n_channels // 2), False)] DCNL DCSP  DCSP for (n_components, n_pca_components, ok) in stuff: DCNL DCSP  DCSP  DCSP ica = ICA(n_components=n_components, max_pca_components=n_pca_components, n_pca_components=n_pca_components, method=method, max_iter=1) DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP  DCSP  DCSP ica.fit(raw, picks=list(range(n_channels))) DCNL DCSP  DCSP  DCSP raw2 = ica.apply(raw.copy(), exclude=[]) DCNL DCSP  DCSP  DCSP if ok: DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(data[:n_channels], raw2._data[:n_channels], rtol=1e-10, atol=1e-15) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP diff = np.abs((data[:n_channels] - raw2._data[:n_channels])) DCNL DCSP  DCSP  DCSP  DCSP assert_true((np.max(diff) > 1e-14)) DCNL DCSP  DCSP  DCSP ica = ICA(n_components=n_components, max_pca_components=n_pca_components, n_pca_components=n_pca_components) DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(record=True): DCNL DCSP  DCSP  DCSP  DCSP ica.fit(epochs, picks=list(range(n_channels))) DCNL DCSP  DCSP  DCSP epochs2 = ica.apply(epochs.copy(), exclude=[]) DCNL DCSP  DCSP  DCSP data2 = epochs2.get_data()[:, :n_channels] DCNL DCSP  DCSP  DCSP if ok: DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(data_epochs[:, :n_channels], data2, rtol=1e-10, atol=1e-15) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP diff = np.abs((data_epochs[:, :n_channels] - data2)) DCNL DCSP  DCSP  DCSP  DCSP assert_true((np.max(diff) > 1e-14)) DCNL DCSP  DCSP  DCSP evoked2 = ica.apply(evoked.copy(), exclude=[]) DCNL DCSP  DCSP  DCSP data2 = evoked2.data[:n_channels] DCNL DCSP  DCSP  DCSP if ok: DCNL DCSP  DCSP  DCSP  DCSP assert_allclose(data_evoked[:n_channels], data2, rtol=1e-10, atol=1e-15) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP diff = np.abs((evoked.data[:n_channels] - data2)) DCNL DCSP  DCSP  DCSP  DCSP assert_true((np.max(diff) > 1e-14)) DCNL DCSP assert_raises(ValueError, ICA, method='pizza-decomposision')\n", "intent": "test recovery of full data when no source is rejected .\n", "question_id": 1283}, {"snippet": "def write_lastlines_file(lastlines_dirpath, path, data): DCNL  DCSP underscored = path.replace('/', '_') DCNL DCSP dest_path = os.path.join(lastlines_dirpath, underscored) DCNL DCSP open(dest_path, 'w').write(data) DCNL DCSP return dest_path\n", "intent": "write data to lastlines file for path .\n", "question_id": 1284}, {"snippet": "def congestionControl(Cause_presence=0): DCNL  DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=57) DCNL DCSP c = CongestionLevelAndSpareHalfOctets() DCNL DCSP packet = ((a / b) / c) DCNL DCSP if (Cause_presence is 1): DCNL DCSP  DCSP e = CauseHdr(ieiC=8, eightBitC=0) DCNL DCSP  DCSP packet = (packet / e) DCNL DCSP return packet\n", "intent": "congestion control section 9 .\n", "question_id": 1285}, {"snippet": "def net_connections(kind='inet'): DCNL  DCSP return _psplatform.net_connections(kind)\n", "intent": "return system-wide connections as a list of  namedtuples .\n", "question_id": 1286}, {"snippet": "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs): DCNL  DCSP dim = len(dataframe) DCNL DCSP fig = make_subplots(rows=dim, cols=dim, print_grid=False) DCNL DCSP trace_list = [] DCNL DCSP for listy in dataframe: DCNL DCSP  DCSP for listx in dataframe: DCNL DCSP  DCSP  DCSP if ((listx == listy) and (diag == 'histogram')): DCNL DCSP  DCSP  DCSP  DCSP trace = graph_objs.Histogram(x=listx, showlegend=False) DCNL DCSP  DCSP  DCSP elif ((listx == listy) and (diag == 'box')): DCNL DCSP  DCSP  DCSP  DCSP trace = graph_objs.Box(y=listx, name=None, showlegend=False) DCNL DCSP  DCSP  DCSP elif ('marker' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP kwargs['marker']['size'] = size DCNL DCSP  DCSP  DCSP  DCSP trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP trace_list.append(trace) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs) DCNL DCSP  DCSP  DCSP trace_list.append(trace) DCNL DCSP trace_index = 0 DCNL DCSP indices = range(1, (dim + 1)) DCNL DCSP for y_index in indices: DCNL DCSP  DCSP for x_index in indices: DCNL DCSP  DCSP  DCSP fig.append_trace(trace_list[trace_index], y_index, x_index) DCNL DCSP  DCSP  DCSP trace_index += 1 DCNL DCSP for j in range(dim): DCNL DCSP  DCSP xaxis_key = 'xaxis{}'.format(((((dim * dim) - dim) + 1) + j)) DCNL DCSP  DCSP fig['layout'][xaxis_key].update(title=headers[j]) DCNL DCSP for j in range(dim): DCNL DCSP  DCSP yaxis_key = 'yaxis{}'.format((1 + (dim * j))) DCNL DCSP  DCSP fig['layout'][yaxis_key].update(title=headers[j]) DCNL DCSP fig['layout'].update(height=height, width=width, title=title, showlegend=True) DCNL DCSP hide_tick_labels_from_box_subplots(fig) DCNL DCSP return fig\n", "intent": "refer to figurefactory .\n", "question_id": 1287}, {"snippet": "def stop(watch, is_group=True): DCNL  DCSP if (not misc.is_string_secure(watch)): DCNL DCSP  DCSP logging.error(('Watch DCSP string DCSP (%s) DCSP is DCSP a DCSP possible DCSP security DCSP violation' % watch)) DCNL DCSP  DCSP return False DCNL DCSP logging.info('Stopping DCSP watch DCSP {0}'.format(watch)) DCNL DCSP if is_group: DCNL DCSP  DCSP stop_command = [MONIT, 'stop', '-g', watch] DCNL DCSP else: DCNL DCSP  DCSP stop_command = [MONIT, 'stop', watch] DCNL DCSP if (not run_with_retry(stop_command)): DCNL DCSP  DCSP return False DCNL DCSP logging.info('Unmonitoring DCSP watch DCSP {0}'.format(watch)) DCNL DCSP if is_group: DCNL DCSP  DCSP unmonitor_command = [MONIT, 'unmonitor', '-g', watch] DCNL DCSP else: DCNL DCSP  DCSP unmonitor_command = [MONIT, 'unmonitor', watch] DCNL DCSP return run_with_retry(unmonitor_command)\n", "intent": "shut down the named programs monit is watching .\n", "question_id": 1288}, {"snippet": "def __virtual__(): DCNL  DCSP if HAS_CX_ORACLE: DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return (False, 'The DCSP oracle DCSP execution DCSP module DCSP not DCSP loaded: DCSP python DCSP oracle DCSP library DCSP not DCSP found.')\n", "intent": "load module only if cx_oracle installed .\n", "question_id": 1289}, {"snippet": "def addFaces(geometryOutput, faces): DCNL  DCSP if (geometryOutput.__class__ == list): DCNL DCSP  DCSP for element in geometryOutput: DCNL DCSP  DCSP  DCSP addFaces(element, faces) DCNL DCSP  DCSP return DCNL DCSP if (geometryOutput.__class__ != dict): DCNL DCSP  DCSP return DCNL DCSP for geometryOutputKey in geometryOutput.keys(): DCNL DCSP  DCSP geometryOutputValue = geometryOutput[geometryOutputKey] DCNL DCSP  DCSP if (geometryOutputKey == 'face'): DCNL DCSP  DCSP  DCSP for face in geometryOutputValue: DCNL DCSP  DCSP  DCSP  DCSP faces.append(face) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP addFaces(geometryOutputValue, faces)\n", "intent": "add the faces .\n", "question_id": 1290}, {"snippet": "def _massage_metakeys(dct, prfx): DCNL  DCSP lowprefix = prfx.lower() DCNL DCSP ret = {} DCNL DCSP for (k, v) in list(dct.items()): DCNL DCSP  DCSP if (not k.lower().startswith(lowprefix)): DCNL DCSP  DCSP  DCSP k = ('%s%s' % (prfx, k)) DCNL DCSP  DCSP ret[k] = v DCNL DCSP return ret\n", "intent": "returns a copy of the supplied dictionary .\n", "question_id": 1291}, {"snippet": "def _get_token(host, username, password): DCNL  DCSP url = 'http://{}/cgi-bin/luci/api/xqsystem/login'.format(host) DCNL DCSP data = {'username': username, 'password': password} DCNL DCSP try: DCNL DCSP  DCSP res = requests.post(url, data=data, timeout=5) DCNL DCSP except requests.exceptions.Timeout: DCNL DCSP  DCSP _LOGGER.exception('Connection DCSP to DCSP the DCSP router DCSP timed DCSP out') DCNL DCSP  DCSP return DCNL DCSP if (res.status_code == 200): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = res.json() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP _LOGGER.exception('Failed DCSP to DCSP parse DCSP response DCSP from DCSP mi DCSP router') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return result['token'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP error_message = ('Xiaomi DCSP token DCSP cannot DCSP be DCSP refreshed, DCSP response DCSP from DCSP ' + 'url: DCSP [%s] DCSP \\nwith DCSP parameter: DCSP [%s] DCSP \\nwas: DCSP [%s]') DCNL DCSP  DCSP  DCSP _LOGGER.exception(error_message, url, data, result) DCNL DCSP  DCSP  DCSP return DCNL DCSP else: DCNL DCSP  DCSP _LOGGER.error('Invalid DCSP response: DCSP [%s] DCSP at DCSP url: DCSP [%s] DCSP with DCSP data DCSP [%s]', res, url, data)\n", "intent": "get authentication token for the given host+username+password .\n", "question_id": 1292}, {"snippet": "def ParseJSONRequest(request): DCNL  DCSP content_type = request.headers.get('Content-Type', '') DCNL DCSP if (not any((content_type.startswith(x) for x in _CONTENT_TYPES))): DCNL DCSP  DCSP raise web.HTTPError(400, ('bad DCSP request DCSP content DCSP type: DCSP %s' % content_type)) DCNL DCSP json_dict = json.loads(request.body) DCNL DCSP return json_dict\n", "intent": "parse the json-encoded contents of the request body and return the python data object .\n", "question_id": 1293}, {"snippet": "def is_language_prefix_patterns_used(): DCNL  DCSP return any((isinstance(url_pattern, LocaleRegexURLResolver) for url_pattern in get_resolver(None).url_patterns))\n", "intent": "returns true if the localeregexurlresolver is used at root level of the urlpatterns .\n", "question_id": 1294}, {"snippet": "def get_num_logical_cpus_per_socket(run_function=run): DCNL  DCSP siblings = run_function('grep DCSP \"^siblings\" DCSP /proc/cpuinfo').stdout.rstrip() DCNL DCSP num_siblings = map(int, re.findall('^siblings\\\\s*:\\\\s*(\\\\d+)\\\\s*$', siblings, re.M)) DCNL DCSP if (len(num_siblings) == 0): DCNL DCSP  DCSP raise error.TestError('Unable DCSP to DCSP find DCSP siblings DCSP info DCSP in DCSP /proc/cpuinfo') DCNL DCSP if (min(num_siblings) != max(num_siblings)): DCNL DCSP  DCSP raise error.TestError(('Number DCSP of DCSP siblings DCSP differ DCSP %r' % num_siblings)) DCNL DCSP return num_siblings[0]\n", "intent": "get the number of cores  per cpu .\n", "question_id": 1295}, {"snippet": "def setEpisodeToWanted(show, s, e): DCNL  DCSP epObj = show.getEpisode(int(s), int(e)) DCNL DCSP if epObj: DCNL DCSP  DCSP with epObj.lock: DCNL DCSP  DCSP  DCSP if ((epObj.status != SKIPPED) or (epObj.airdate == date.fromordinal(1))): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP sickrage.srCore.srLogger.info((u'Setting DCSP episode DCSP %s DCSP S%02dE%02d DCSP to DCSP wanted' % (show.name, s, e))) DCNL DCSP  DCSP  DCSP epObj.status = WANTED DCNL DCSP  DCSP  DCSP epObj.saveToDB() DCNL DCSP  DCSP sickrage.srCore.SEARCHQUEUE.put(BacklogQueueItem(show, [epObj])) DCNL DCSP  DCSP sickrage.srCore.srLogger.info((u'Starting DCSP backlog DCSP search DCSP for DCSP %s DCSP S%02dE%02d DCSP because DCSP some DCSP episodes DCSP were DCSP set DCSP to DCSP wanted' % (show.name, s, e)))\n", "intent": "sets an episode to wanted .\n", "question_id": 1296}, {"snippet": "def import_module(name, deprecated=False): DCNL  DCSP with _ignore_deprecated_imports(deprecated): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return importlib.import_module(name) DCNL DCSP  DCSP except ImportError as msg: DCNL DCSP  DCSP  DCSP raise unittest.SkipTest(str(msg))\n", "intent": "import and return the module to be tested .\n", "question_id": 1297}, {"snippet": "def generate_image_url(image_ref): DCNL  DCSP return ('%s/images/%s' % (generate_glance_url(), image_ref))\n", "intent": "generate an image url from an image_ref .\n", "question_id": 1298}, {"snippet": "def alterWiddershinsSupportedPathByPoint(alongAway, overhangWiddershinsLeft, overhangWiddershinsRight, point): DCNL  DCSP if alongAway.getIsWiddershinsPointSupported(point): DCNL DCSP  DCSP return DCNL DCSP overhangWiddershins = overhangWiddershinsLeft DCNL DCSP if (overhangWiddershinsRight.getDistance() < overhangWiddershinsLeft.getDistance()): DCNL DCSP  DCSP overhangWiddershins = overhangWiddershinsRight DCNL DCSP overhangWiddershins.alterLoop()\n", "intent": "get widdershins path with overhangs filled in for point .\n", "question_id": 1299}, {"snippet": "def get_service(hass, config, discovery_info=None): DCNL  DCSP context_str = json.dumps({'hass': hass.config.as_dict(), 'custom': config[CONF_CONTEXT]}) DCNL DCSP context_b64 = base64.b64encode(context_str.encode('utf-8')) DCNL DCSP context = context_b64.decode('utf-8') DCNL DCSP import boto3 DCNL DCSP aws_config = config.copy() DCNL DCSP del aws_config[CONF_PLATFORM] DCNL DCSP del aws_config[CONF_NAME] DCNL DCSP del aws_config[CONF_CONTEXT] DCNL DCSP profile = aws_config.get(CONF_PROFILE_NAME) DCNL DCSP if (profile is not None): DCNL DCSP  DCSP boto3.setup_default_session(profile_name=profile) DCNL DCSP  DCSP del aws_config[CONF_PROFILE_NAME] DCNL DCSP lambda_client = boto3.client('lambda', **aws_config) DCNL DCSP return AWSLambda(lambda_client, context)\n", "intent": "get the aws lambda notification service .\n", "question_id": 1300}, {"snippet": "def list_worlds(): DCNL  DCSP print DCNL DCSP worlds = world.get_worlds() DCNL DCSP if (not worlds): DCNL DCSP  DCSP print 'No DCSP world DCSP saves DCSP found DCSP in DCSP the DCSP usual DCSP place' DCNL DCSP  DCSP return DCNL DCSP print 'Detected DCSP saves:' DCNL DCSP worldNameLen = max(([len(x) for x in worlds] + [len('World')])) DCNL DCSP formatString = (('%-' + str(worldNameLen)) + 's DCSP | DCSP %-8s DCSP | DCSP %-16s DCSP | DCSP %s DCSP ') DCNL DCSP print (formatString % ('World', 'Playtime', 'Modified', 'Path')) DCNL DCSP print (formatString % (('-' * worldNameLen), ('-' * 8), ('-' * 16), ('-' * 4))) DCNL DCSP for (name, info) in sorted(worlds.iteritems()): DCNL DCSP  DCSP if (isinstance(name, basestring) and name.startswith('World') and (len(name) == 6)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP world_n = int(name[(-1)]) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (info['LastPlayed'] > 0): DCNL DCSP  DCSP  DCSP timestamp = time.strftime('%Y-%m-%d DCSP %H:%M', time.localtime((info['LastPlayed'] / 1000))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP timestamp = '' DCNL DCSP  DCSP if (info['Time'] > 0): DCNL DCSP  DCSP  DCSP playtime = (info['Time'] / 20) DCNL DCSP  DCSP  DCSP playstamp = ('%d:%02d' % ((playtime / 3600), ((playtime / 60) % 60))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP playstamp = '' DCNL DCSP  DCSP path = info['path'] DCNL DCSP  DCSP print (formatString % (name, playstamp, timestamp, path)) DCNL DCSP found_corrupt = any([x.get('IsCorrupt') for x in worlds.values()]) DCNL DCSP if found_corrupt: DCNL DCSP  DCSP print '' DCNL DCSP  DCSP print 'An DCSP error DCSP has DCSP been DCSP detected DCSP in DCSP one DCSP or DCSP more DCSP of DCSP your DCSP worlds DCSP (see DCSP the DCSP above DCSP table).' DCNL DCSP  DCSP print 'This DCSP is DCSP usually DCSP due DCSP to DCSP a DCSP corrupt DCSP level.dat DCSP file. DCSP  DCSP Corrupt DCSP worlds DCSP need DCSP to DCSP be' DCNL DCSP  DCSP print 'repaired DCSP before DCSP Overviewer DCSP can DCSP render DCSP them.'\n", "intent": "prints out a brief summary of saves found in the default directory .\n", "question_id": 1301}, {"snippet": "def to_dict(obj, encoder): DCNL  DCSP return dict(obj)\n", "intent": "converts an arbitrary object c{obj} to a c{dict} .\n", "question_id": 1302}, {"snippet": "@_blocked_elementwise DCNL def sign_round_up(X): DCNL  DCSP Y = X.copy() DCNL DCSP Y[(Y == 0)] = 1 DCNL DCSP Y /= np.abs(Y) DCNL DCSP return Y\n", "intent": "this should do the right thing for both real and complex matrices .\n", "question_id": 1303}, {"snippet": "def safe_get_host(request): DCNL  DCSP if (isinstance(settings.ALLOWED_HOSTS, (list, tuple)) and ('*' not in settings.ALLOWED_HOSTS)): DCNL DCSP  DCSP return request.get_host() DCNL DCSP else: DCNL DCSP  DCSP return configuration_helpers.get_value('site_domain', settings.SITE_NAME)\n", "intent": "get the host name for this request .\n", "question_id": 1304}, {"snippet": "def get_qiime_hex_string_color(index): DCNL  DCSP assert (index >= 0), 'There DCSP are DCSP no DCSP negative DCSP indices DCSP for DCSP the DCSP QIIME DCSP colors' DCNL DCSP n_colors = len(data_color_order) DCNL DCSP if (index >= n_colors): DCNL DCSP  DCSP index = int((index - floor(((index / n_colors) * n_colors)))) DCNL DCSP return data_colors[data_color_order[index]].toHex()\n", "intent": "retrieve an hex color from the list of qiime colors input: index: index of the color to retrieve .\n", "question_id": 1305}, {"snippet": "def aggregate_scores(scores): DCNL  DCSP total_correct_graded = float_sum((score.earned for score in scores if score.graded)) DCNL DCSP total_possible_graded = float_sum((score.possible for score in scores if score.graded)) DCNL DCSP any_attempted_graded = any((score.attempted for score in scores if score.graded)) DCNL DCSP total_correct = float_sum((score.earned for score in scores)) DCNL DCSP total_possible = float_sum((score.possible for score in scores)) DCNL DCSP any_attempted = any((score.attempted for score in scores)) DCNL DCSP all_total = AggregatedScore(total_correct, total_possible, False, any_attempted) DCNL DCSP graded_total = AggregatedScore(total_correct_graded, total_possible_graded, True, any_attempted_graded) DCNL DCSP return (all_total, graded_total)\n", "intent": "scores: a list of scorebase objects returns: a tuple .\n", "question_id": 1306}, {"snippet": "def abs__file__(): DCNL  DCSP for m in sys.modules.values(): DCNL DCSP  DCSP if ((_is_jython and (not isinstance(m, ModuleType))) or hasattr(m, '__loader__')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP f = getattr(m, '__file__', None) DCNL DCSP  DCSP if (f is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP m.__file__ = os.path.abspath(f)\n", "intent": "set all module __file__ attribute to an absolute path .\n", "question_id": 1307}, {"snippet": "@staff_member_required DCNL def evennia_admin(request): DCNL  DCSP return render(request, 'evennia_admin.html', {'playerdb': PlayerDB})\n", "intent": "helpful evennia-specific admin page .\n", "question_id": 1308}, {"snippet": "def avail_images(): DCNL  DCSP conn = get_conn() DCNL DCSP return conn.image_list()\n", "intent": "return a dict of all available vm images on the cloud provider .\n", "question_id": 1309}, {"snippet": "def _extract_images(filename, num_images): DCNL  DCSP print('Extracting DCSP images DCSP from: DCSP ', filename) DCNL DCSP with gzip.open(filename) as bytestream: DCNL DCSP  DCSP bytestream.read(16) DCNL DCSP  DCSP buf = bytestream.read((((_IMAGE_SIZE * _IMAGE_SIZE) * num_images) * _NUM_CHANNELS)) DCNL DCSP  DCSP data = np.frombuffer(buf, dtype=np.uint8) DCNL DCSP  DCSP data = data.reshape(num_images, _IMAGE_SIZE, _IMAGE_SIZE, _NUM_CHANNELS) DCNL DCSP return data\n", "intent": "extract the images into a numpy array .\n", "question_id": 1310}, {"snippet": "def get_file_obj(fname, mode='r', encoding=None): DCNL  DCSP if _is_string_like(fname): DCNL DCSP  DCSP return _open(fname, mode, encoding) DCNL DCSP try: DCNL DCSP  DCSP if ('r' in mode): DCNL DCSP  DCSP  DCSP fname.read DCNL DCSP  DCSP if (('w' in mode) or ('a' in mode)): DCNL DCSP  DCSP  DCSP fname.write DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ValueError('fname DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP file-like DCSP object') DCNL DCSP return EmptyContextManager(fname)\n", "intent": "light wrapper to handle strings and let files  pass through .\n", "question_id": 1311}, {"snippet": "def make_insecure_stub(stub_class, host, port=None): DCNL  DCSP if (port is None): DCNL DCSP  DCSP target = host DCNL DCSP else: DCNL DCSP  DCSP target = ('%s:%d' % (host, port)) DCNL DCSP channel = grpc.insecure_channel(target) DCNL DCSP return stub_class(channel)\n", "intent": "makes an insecure stub for an rpc service .\n", "question_id": 1312}, {"snippet": "def test_cli_roles_override_decorator_roles(): DCNL  DCSP @roles('r1') DCNL DCSP def command(): DCNL DCSP  DCSP pass DCNL DCSP eq_effective_roles(command, ['r2'], cli_roles=['r2'], env={'roledefs': fake_roles})\n", "intent": "if cli roles are provided they replace roles defined in @roles .\n", "question_id": 1313}, {"snippet": "def CreateSummaryResults(): DCNL  DCSP errors = [] DCNL DCSP passes = [] DCNL DCSP current_path = os.path.join(_RESULTS_PATH, 'current') DCNL DCSP schemes = GetCurrentSchemes() DCNL DCSP test_path = os.path.join(current_path, options.conf) DCNL DCSP print 'Creating DCSP summary DCSP results.' DCNL DCSP for testname in _SUMMARY.keys(): DCNL DCSP  DCSP if testname.endswith('.js'): DCNL DCSP  DCSP  DCSP testname = testname[:(-3)] DCNL DCSP  DCSP temp_details = '' DCNL DCSP  DCSP filepath = (((test_path + '/') + testname) + '/Run DCSP 1/Automation DCSP Results.plist') DCNL DCSP  DCSP print filepath DCNL DCSP  DCSP xmldoc = ElementTree.parse(filepath) DCNL DCSP  DCSP dicts = xmldoc.findall('*/array/dict') DCNL DCSP  DCSP for tmpdict in dicts: DCNL DCSP  DCSP  DCSP error = {} DCNL DCSP  DCSP  DCSP tmppass = {} DCNL DCSP  DCSP  DCSP if ((tmpdict.find('string').text == 'Error') and (int(tmpdict.find('integer').text) == 4)): DCNL DCSP  DCSP  DCSP  DCSP error['testname'] = tmpdict[3].text DCNL DCSP  DCSP  DCSP  DCSP error['timestamp'] = tmpdict.find('date').text DCNL DCSP  DCSP  DCSP  DCSP error['status'] = tmpdict[1].text DCNL DCSP  DCSP  DCSP  DCSP errors.append(error) DCNL DCSP  DCSP  DCSP elif ((tmpdict.find('string').text == 'Pass') and (int(tmpdict.find('integer').text) == 4)): DCNL DCSP  DCSP  DCSP  DCSP tmppass['testname'] = tmpdict[3].text DCNL DCSP  DCSP  DCSP  DCSP tmppass['timestamp'] = tmpdict.find('date').text DCNL DCSP  DCSP  DCSP  DCSP tmppass['status'] = tmpdict[1].text DCNL DCSP  DCSP  DCSP  DCSP passes.append(tmppass) DCNL DCSP  DCSP  DCSP elif (tmpdict[1].text == 'Debug'): DCNL DCSP  DCSP  DCSP  DCSP temp_details += (tmpdict[3].text + '\\n') DCNL DCSP  DCSP _SUMMARY[testname]['details'] = temp_details DCNL DCSP  DCSP if (not options.regen): DCNL DCSP  DCSP  DCSP ProcessScreenshots(testname) DCNL DCSP  DCSP for image_name in GetImageNames(testname): DCNL DCSP  DCSP  DCSP if (IsImageEqual(testname, image_name) is False): DCNL DCSP  DCSP  DCSP  DCSP _SUMMARY[testname]['warnings'][image_name] = 'Warning: DCSP The DCSP screenshot DCSP does DCSP not DCSP match DCSP the DCSP Baseline. DCSP  DCSP Do DCSP you DCSP want DCSP to DCSP Accept DCSP the DCSP Current DCSP image DCSP as DCSP the DCSP new DCSP Baseline?' DCNL DCSP  DCSP  DCSP  DCSP _SUMMARY[testname]['alert'] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _SUMMARY[testname]['warnings'][image_name] = None DCNL DCSP fmt_args = {'errors': errors, 'passes': passes, 'summary': _SUMMARY, 'random_num': random.randint(1, sys.maxsize), 'schemes': schemes, 'scheme': options.conf} DCNL DCSP resources_path = os.path.dirname(('%s/testing' % _BASE_PATH)) DCNL DCSP template_path = os.path.join(resources_path, 'templates') DCNL DCSP _loader = template.Loader(template_path) DCNL DCSP summary_html = _loader.load('summary_results.test').generate(**fmt_args) DCNL DCSP f = open(('%s/index.html' % test_path), 'w') DCNL DCSP f.write(summary_html) DCNL DCSP f.close()\n", "intent": "process the resulting .\n", "question_id": 1314}, {"snippet": "def boto_volume_for_test(test, cluster_id): DCNL  DCSP region_name = u'some-test-region-1' DCNL DCSP s = Boto3Session(botocore_session=botocore_get_session(), region_name=region_name) DCNL DCSP ec2 = s.resource('ec2', region_name=region_name) DCNL DCSP stubber = Stubber(ec2.meta.client) DCNL DCSP stubber.activate() DCNL DCSP volume_id = u'vol-{}'.format(random_name(test)) DCNL DCSP v = ec2.Volume(id=volume_id) DCNL DCSP tags = [] DCNL DCSP if (cluster_id is not None): DCNL DCSP  DCSP tags.append(dict(Key=CLUSTER_ID_LABEL, Value=cluster_id)) DCNL DCSP v.meta.data = dict(Tags=tags) DCNL DCSP return v\n", "intent": "create an in-memory boto3 volume .\n", "question_id": 1315}, {"snippet": "def lch2lab(lch): DCNL  DCSP lch = _prepare_lab_array(lch) DCNL DCSP (c, h) = (lch[..., 1], lch[..., 2]) DCNL DCSP (lch[..., 1], lch[..., 2]) = ((c * np.cos(h)), (c * np.sin(h))) DCNL DCSP return lch\n", "intent": "cie-lch to cie-lab color space conversion .\n", "question_id": 1316}, {"snippet": "def convert_tmtheme_to_css(theme_file): DCNL  DCSP if (not theme_file): DCNL DCSP  DCSP return default_ccsl DCNL DCSP theme_as_dict = parse_file(theme_file) DCNL DCSP cssl = [] DCNL DCSP default_color = 'rgb(236,9,140)' DCNL DCSP for i in theme_as_dict.get('settings'): DCNL DCSP  DCSP s = i.get('settings', {}) DCNL DCSP  DCSP if ('caret' in s): DCNL DCSP  DCSP  DCSP default_color = convert_to_rgba_css(s['caret']) DCNL DCSP for item in theme_as_dict.get('settings'): DCNL DCSP  DCSP scope = item.get('scope', 'body') DCNL DCSP  DCSP props = item.get('settings', {}) DCNL DCSP  DCSP props_str = '' DCNL DCSP  DCSP if props: DCNL DCSP  DCSP  DCSP for (k, v) in props.items(): DCNL DCSP  DCSP  DCSP  DCSP k = k.replace('foreground', 'color') DCNL DCSP  DCSP  DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if any(((k == w) for w in ('background', 'color'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP props_str += ('%s: DCSP %s; DCSP ' % (k, (convert_to_rgba_css(v) or v))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (k == 'fontStyle'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('bold' in v): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP props_str += 'font-weight: DCSP bold; DCSP font-style: DCSP normal; DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif ('italic' in v): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP props_str += 'font-weight: DCSP normal; DCSP font-style: DCSP italic; DCSP ' DCNL DCSP  DCSP  DCSP if (not props.get('fontStyle')): DCNL DCSP  DCSP  DCSP  DCSP props_str += 'font-weight: DCSP normal; DCSP font-style: DCSP normal; DCSP ' DCNL DCSP  DCSP  DCSP if (not props.get('foreground')): DCNL DCSP  DCSP  DCSP  DCSP props_str += ('color: DCSP %s; DCSP ' % default_color) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP props_str += ('color: DCSP %s; DCSP font-weight: DCSP normal; DCSP font-style: DCSP normal; DCSP ' % default_color) DCNL DCSP  DCSP if (scope == 'keyword'): DCNL DCSP  DCSP  DCSP props_str += 'width: DCSP 100%; DCSP ' DCNL DCSP  DCSP mo = re.search(SCOPES_REGEX, scope) DCNL DCSP  DCSP tag = (mo.lastgroup.replace('__', '.').replace('_', '-') if mo else '') DCNL DCSP  DCSP if tag: DCNL DCSP  DCSP  DCSP cssl.append(('%s DCSP { DCSP %s}' % (tag, props_str))) DCNL DCSP return cssl\n", "intent": "return list of css lines ready to be pasted .\n", "question_id": 1317}, {"snippet": "def with_timeout(seconds, function, *args, **kwds): DCNL  DCSP timeout_value = kwds.pop('timeout_value', _NONE) DCNL DCSP timeout = Timeout.start_new(seconds) DCNL DCSP try: DCNL DCSP  DCSP return function(*args, **kwds) DCNL DCSP except Timeout: DCNL DCSP  DCSP if ((sys.exc_info()[1] is timeout) and (timeout_value is not _NONE)): DCNL DCSP  DCSP  DCSP return timeout_value DCNL DCSP  DCSP raise DCNL DCSP finally: DCNL DCSP  DCSP timeout.cancel()\n", "intent": "wrap a call to *function* with a timeout; if the called function fails to return before the timeout .\n", "question_id": 1318}, {"snippet": "def updating(name, jail=None, chroot=None, root=None, filedate=None, filename=None): DCNL  DCSP opts = '' DCNL DCSP if filedate: DCNL DCSP  DCSP opts += 'd DCSP {0}'.format(filedate) DCNL DCSP if filename: DCNL DCSP  DCSP opts += 'f DCSP {0}'.format(filename) DCNL DCSP cmd = _pkg(jail, chroot, root) DCNL DCSP cmd.append('updating') DCNL DCSP if opts: DCNL DCSP  DCSP cmd.append(('-' + opts)) DCNL DCSP cmd.append(name) DCNL DCSP return __salt__['cmd.run'](cmd, output_loglevel='trace', python_shell=False)\n", "intent": "displays updating entries of software packages cli example: .\n", "question_id": 1319}, {"snippet": "def recommend_for_user(user): DCNL  DCSP return recommend_for_brands(brandsfor.get(user, set()))\n", "intent": "get a users brands and recommend based on them .\n", "question_id": 1320}, {"snippet": "@memoized DCNL def sys_prefix_unfollowed(): DCNL  DCSP try: DCNL DCSP  DCSP frame = sys._current_frames().values()[0] DCNL DCSP  DCSP while frame.f_back: DCNL DCSP  DCSP  DCSP frame = frame.f_back DCNL DCSP  DCSP code = frame.f_code DCNL DCSP  DCSP filename = code.co_filename DCNL DCSP  DCSP unfollowed = dirname(dirname(filename)) DCNL DCSP except: DCNL DCSP  DCSP return sys.prefix DCNL DCSP return unfollowed\n", "intent": "since conda is installed into non-root environments as a symlink only and because sys .\n", "question_id": 1321}, {"snippet": "def setTracebackClearing(clear=True): DCNL  DCSP global clear_tracebacks DCNL DCSP clear_tracebacks = clear\n", "intent": "enable or disable traceback clearing .\n", "question_id": 1322}, {"snippet": "def node_boundary(G, nbunch1, nbunch2=None): DCNL  DCSP nset1 = {n for n in nbunch1 if (n in G)} DCNL DCSP bdy = (set(chain.from_iterable((G[v] for v in nset1))) - nset1) DCNL DCSP if (nbunch2 is not None): DCNL DCSP  DCSP bdy &= set(nbunch2) DCNL DCSP return bdy\n", "intent": "returns the node boundary of nbunch1 .\n", "question_id": 1323}, {"snippet": "def dict_match(d, key, default=None): DCNL  DCSP if ((key in d) and ('[' not in key)): DCNL DCSP  DCSP return d[key] DCNL DCSP else: DCNL DCSP  DCSP for (pattern, value) in iteritems(d): DCNL DCSP  DCSP  DCSP if fnmatchcase(key, pattern): DCNL DCSP  DCSP  DCSP  DCSP return value DCNL DCSP return default\n", "intent": "like __getitem__ but works as if the keys() are all filename patterns .\n", "question_id": 1324}, {"snippet": "def _maybe_strip_national_prefix_carrier_code(number, metadata): DCNL  DCSP carrier_code = U_EMPTY_STRING DCNL DCSP possible_national_prefix = metadata.national_prefix_for_parsing DCNL DCSP if ((len(number) == 0) or (possible_national_prefix is None) or (len(possible_national_prefix) == 0)): DCNL DCSP  DCSP return (U_EMPTY_STRING, number, False) DCNL DCSP prefix_pattern = re.compile(possible_national_prefix) DCNL DCSP prefix_match = prefix_pattern.match(number) DCNL DCSP if prefix_match: DCNL DCSP  DCSP national_number_pattern = re.compile((metadata.general_desc.national_number_pattern or U_EMPTY_STRING)) DCNL DCSP  DCSP is_viable_original_number = fullmatch(national_number_pattern, number) DCNL DCSP  DCSP num_groups = len(prefix_match.groups()) DCNL DCSP  DCSP transform_rule = metadata.national_prefix_transform_rule DCNL DCSP  DCSP if ((transform_rule is None) or (len(transform_rule) == 0) or (prefix_match.groups()[(num_groups - 1)] is None)): DCNL DCSP  DCSP  DCSP national_number_match = fullmatch(national_number_pattern, number[prefix_match.end():]) DCNL DCSP  DCSP  DCSP if (is_viable_original_number and (not national_number_match)): DCNL DCSP  DCSP  DCSP  DCSP return (U_EMPTY_STRING, number, False) DCNL DCSP  DCSP  DCSP if ((num_groups > 0) and (prefix_match.groups(num_groups) is not None)): DCNL DCSP  DCSP  DCSP  DCSP carrier_code = prefix_match.group(1) DCNL DCSP  DCSP  DCSP return (carrier_code, number[prefix_match.end():], True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP transformed_number = re.sub(prefix_pattern, transform_rule, number, count=1) DCNL DCSP  DCSP  DCSP national_number_match = fullmatch(national_number_pattern, transformed_number) DCNL DCSP  DCSP  DCSP if (is_viable_original_number and (not national_number_match)): DCNL DCSP  DCSP  DCSP  DCSP return ('', number, False) DCNL DCSP  DCSP  DCSP if (num_groups > 1): DCNL DCSP  DCSP  DCSP  DCSP carrier_code = prefix_match.group(1) DCNL DCSP  DCSP  DCSP return (carrier_code, transformed_number, True) DCNL DCSP else: DCNL DCSP  DCSP return (carrier_code, number, False)\n", "intent": "strips any national prefix  present in a number .\n", "question_id": 1325}, {"snippet": "def smooth_with_function_and_mask(image, function, mask): DCNL  DCSP bleed_over = function(mask.astype(float)) DCNL DCSP masked_image = np.zeros(image.shape, image.dtype) DCNL DCSP masked_image[mask] = image[mask] DCNL DCSP smoothed_image = function(masked_image) DCNL DCSP output_image = (smoothed_image / (bleed_over + np.finfo(float).eps)) DCNL DCSP return output_image\n", "intent": "smooth an image with a linear function .\n", "question_id": 1326}, {"snippet": "@statfunc DCNL def geweke(x, first=0.1, last=0.5, intervals=20): DCNL  DCSP if (np.ndim(x) > 1): DCNL DCSP  DCSP return [geweke(y, first, last, intervals) for y in np.transpose(x)] DCNL DCSP for interval in (first, last): DCNL DCSP  DCSP if ((interval <= 0) or (interval >= 1)): DCNL DCSP  DCSP  DCSP raise ValueError('Invalid DCSP intervals DCSP for DCSP Geweke DCSP convergence DCSP analysis', (first, last)) DCNL DCSP if ((first + last) >= 1): DCNL DCSP  DCSP raise ValueError('Invalid DCSP intervals DCSP for DCSP Geweke DCSP convergence DCSP analysis', (first, last)) DCNL DCSP zscores = [] DCNL DCSP end = (len(x) - 1) DCNL DCSP last_start_idx = ((1 - last) * end) DCNL DCSP start_indices = np.arange(0, int(last_start_idx), step=int((last_start_idx / (intervals - 1)))) DCNL DCSP for start in start_indices: DCNL DCSP  DCSP first_slice = x[start:(start + int((first * (end - start))))] DCNL DCSP  DCSP last_slice = x[int((end - (last * (end - start)))):] DCNL DCSP  DCSP z = (first_slice.mean() - last_slice.mean()) DCNL DCSP  DCSP z /= np.sqrt((first_slice.var() + last_slice.var())) DCNL DCSP  DCSP zscores.append([start, z]) DCNL DCSP if (intervals is None): DCNL DCSP  DCSP return np.array(zscores[0]) DCNL DCSP else: DCNL DCSP  DCSP return np.array(zscores)\n", "intent": "return z-scores for convergence diagnostics .\n", "question_id": 1327}, {"snippet": "@requires_ftp DCNL @requires_good_network DCNL def test_fetch_file_ftp(): DCNL  DCSP _test_fetch('ftp://speedtest.tele2.net/1KB.zip')\n", "intent": "test file downloading over ftp .\n", "question_id": 1328}, {"snippet": "def _mostfunc(lhs, func, X=None): DCNL  DCSP fterms = [tmp for tmp in lhs.atoms(func) if ((not X) or (X.is_Symbol and (X in tmp.free_symbols)) or ((not X.is_Symbol) and tmp.has(X)))] DCNL DCSP if (len(fterms) == 1): DCNL DCSP  DCSP return fterms[0] DCNL DCSP elif fterms: DCNL DCSP  DCSP return max(list(ordered(fterms)), key=(lambda x: x.count(func))) DCNL DCSP return None\n", "intent": "returns the term in lhs which contains the most of the func-type things e .\n", "question_id": 1329}, {"snippet": "def parse_sorted_query(model_cls, parts, prefixes={}, query_cls=query.AndQuery): DCNL  DCSP query_parts = [] DCNL DCSP sort_parts = [] DCNL DCSP for part in parts: DCNL DCSP  DCSP if (part.endswith((u'+', u'-')) and (u':' not in part)): DCNL DCSP  DCSP  DCSP sort_parts.append(part) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query_parts.append(part) DCNL DCSP q = query_from_strings(query_cls, model_cls, prefixes, query_parts) DCNL DCSP s = sort_from_strings(model_cls, sort_parts) DCNL DCSP return (q, s)\n", "intent": "given a list of strings .\n", "question_id": 1330}, {"snippet": "def test_no_exception(exception_app): DCNL  DCSP (request, response) = sanic_endpoint_test(exception_app) DCNL DCSP assert (response.status == 200) DCNL DCSP assert (response.text == 'OK')\n", "intent": "test that a route works without an exception .\n", "question_id": 1331}, {"snippet": "def _get_block_summary_totals(course_data): DCNL  DCSP block_summary_counts = {} DCNL DCSP unique_course_counts = {} DCNL DCSP for course in course_data: DCNL DCSP  DCSP block_counts = course.get(BLOCK_COUNTS_KEY) DCNL DCSP  DCSP for (count_label, value) in block_counts.items(): DCNL DCSP  DCSP  DCSP unique = 0 DCNL DCSP  DCSP  DCSP if (value > 0): DCNL DCSP  DCSP  DCSP  DCSP unique = 1 DCNL DCSP  DCSP  DCSP if (count_label in block_summary_counts): DCNL DCSP  DCSP  DCSP  DCSP block_summary_counts[count_label] += value DCNL DCSP  DCSP  DCSP  DCSP unique_course_counts[count_label] += unique DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP block_summary_counts[count_label] = value DCNL DCSP  DCSP  DCSP  DCSP unique_course_counts[count_label] = unique DCNL DCSP return (block_summary_counts, unique_course_counts)\n", "intent": "totals the xblock types included in the course data and returns those counts by type arguments: course_data : a list of course_data objects returns: dict: containing the total number of blocks by type <block_type>: <count> .\n", "question_id": 1332}, {"snippet": "def generate_bell(n): DCNL  DCSP n = as_int(n) DCNL DCSP if (n < 1): DCNL DCSP  DCSP raise ValueError('n DCSP must DCSP be DCSP a DCSP positive DCSP integer') DCNL DCSP if (n == 1): DCNL DCSP  DCSP (yield (0,)) DCNL DCSP elif (n == 2): DCNL DCSP  DCSP (yield (0, 1)) DCNL DCSP  DCSP (yield (1, 0)) DCNL DCSP elif (n == 3): DCNL DCSP  DCSP for li in [(0, 1, 2), (0, 2, 1), (2, 0, 1), (2, 1, 0), (1, 2, 0), (1, 0, 2)]: DCNL DCSP  DCSP  DCSP (yield li) DCNL DCSP else: DCNL DCSP  DCSP m = (n - 1) DCNL DCSP  DCSP op = ([0] + ([(-1)] * m)) DCNL DCSP  DCSP l = list(range(n)) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP (yield tuple(l)) DCNL DCSP  DCSP  DCSP big = (None, (-1)) DCNL DCSP  DCSP  DCSP for i in range(n): DCNL DCSP  DCSP  DCSP  DCSP if (op[i] and (l[i] > big[1])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP big = (i, l[i]) DCNL DCSP  DCSP  DCSP (i, _) = big DCNL DCSP  DCSP  DCSP if (i is None): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP j = (i + op[i]) DCNL DCSP  DCSP  DCSP (l[i], l[j]) = (l[j], l[i]) DCNL DCSP  DCSP  DCSP (op[i], op[j]) = (op[j], op[i]) DCNL DCSP  DCSP  DCSP if ((j == 0) or (j == m) or (l[(j + op[j])] > l[j])): DCNL DCSP  DCSP  DCSP  DCSP op[j] = 0 DCNL DCSP  DCSP  DCSP for i in range(j): DCNL DCSP  DCSP  DCSP  DCSP if (l[i] > l[j]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP op[i] = 1 DCNL DCSP  DCSP  DCSP for i in range((j + 1), n): DCNL DCSP  DCSP  DCSP  DCSP if (l[i] > l[j]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP op[i] = (-1)\n", "intent": "return permutations of [0 .\n", "question_id": 1333}, {"snippet": "def test_install_exit_status_code_when_no_requirements(script): DCNL  DCSP result = script.pip('install', expect_error=True) DCNL DCSP assert ('You DCSP must DCSP give DCSP at DCSP least DCSP one DCSP requirement DCSP to DCSP install' in result.stderr) DCNL DCSP assert (result.returncode == ERROR)\n", "intent": "test install exit status code when no requirements specified .\n", "question_id": 1334}, {"snippet": "def treeio_login_required(f): DCNL  DCSP def wrap(request, *args, **kwargs): DCNL DCSP  DCSP 'Wrap' DCNL DCSP  DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP  DCSP user = request.user.profile DCNL DCSP  DCSP  DCSP user_modules = user.get_perspective().get_modules() DCNL DCSP  DCSP  DCSP all_modules = Module.objects.all() DCNL DCSP  DCSP  DCSP active = None DCNL DCSP  DCSP  DCSP for module in all_modules: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP import_name = ((module.name + '.') + settings.HARDTREE_MODULE_IDENTIFIER) DCNL DCSP  DCSP  DCSP  DCSP  DCSP hmodule = __import__(import_name, fromlist=[str(module.name)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP urls = hmodule.URL_PATTERNS DCNL DCSP  DCSP  DCSP  DCSP  DCSP for regexp in urls: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if re.match(regexp, request.path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP active = module DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP if active: DCNL DCSP  DCSP  DCSP  DCSP if (active in user_modules): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if user.has_permission(active): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return f(request, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (request.path[:3] == '/m/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect('/m/user/denied') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect('/user/denied') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (request.path[:3] == '/m/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect('/m/user/denied') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect('/user/denied') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return f(request, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (request.path[:3] == '/m/'): DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect('/m/accounts/login') DCNL DCSP  DCSP  DCSP if (('response_format' in kwargs) and (kwargs['response_format'] == 'rss')): DCNL DCSP  DCSP  DCSP  DCSP if (('secret' in request.GET) and verify_secret_key(request)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f(request, *args, **kwargs) DCNL DCSP  DCSP  DCSP return HttpResponseRedirect('/accounts/login') DCNL DCSP wrap.__doc__ = f.__doc__ DCNL DCSP wrap.__name__ = f.__name__ DCNL DCSP return wrap\n", "intent": "check that the user has write access to the treeio .\n", "question_id": 1335}, {"snippet": "def isBPFSocket(obj): DCNL  DCSP return (isinstance(obj, L2bpfListenSocket) or isinstance(obj, L2bpfListenSocket) or isinstance(obj, L3bpfSocket))\n", "intent": "return true is obj is a bpf super socket .\n", "question_id": 1336}, {"snippet": "@public DCNL def make_report(e): DCNL  DCSP import platform as _platform DCNL DCSP from ajenti.plugins import manager DCNL DCSP from ajenti import platform, platform_unmapped, platform_string, installation_uid, version, debug DCNL DCSP logging.blackbox.stop() DCNL DCSP tb = traceback.format_exc(e) DCNL DCSP tb = '\\n'.join(((' DCSP  DCSP  DCSP  DCSP ' + x) for x in tb.splitlines())) DCNL DCSP log = logging.blackbox.buffer DCNL DCSP log = '\\n'.join(((' DCSP  DCSP  DCSP  DCSP ' + x) for x in log.splitlines())) DCNL DCSP catcher_url = None DCNL DCSP try: DCNL DCSP  DCSP report = catcher.collect(e) DCNL DCSP  DCSP html = catcher.formatters.HTMLFormatter().format(report, maxdepth=3) DCNL DCSP  DCSP catcher_url = catcher.uploaders.AjentiOrgUploader().upload(html) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP import gevent DCNL DCSP import greenlet DCNL DCSP import reconfigure DCNL DCSP import requests DCNL DCSP import psutil DCNL DCSP return ('Ajenti DCSP bug DCSP report\\n--------------------\\n\\n\\nInfo DCSP | DCSP Value\\n----- DCSP | DCSP -----\\nAjenti DCSP | DCSP %s\\nPlatform DCSP | DCSP %s DCSP / DCSP %s DCSP / DCSP %s\\nArchitecture DCSP | DCSP %s\\nPython DCSP | DCSP %s\\nInstallation DCSP | DCSP %s\\nDebug DCSP | DCSP %s\\nCatcher DCSP report DCSP | DCSP %s\\nLoaded DCSP plugins DCSP | DCSP %s\\n\\nLibrary DCSP | DCSP Version\\n------- DCSP | DCSP -------\\ngevent DCSP | DCSP %s\\ngreenlet DCSP | DCSP %s\\nreconfigure DCSP | DCSP %s\\nrequests DCSP | DCSP %s\\npsutil DCSP | DCSP %s\\n\\n\\n%s\\n\\nLog DCSP content:\\n\\n%s\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % (version, platform, platform_unmapped, platform_string.strip(), subprocess.check_output(['uname', '-mp']).strip(), '.'.join([str(x) for x in _platform.python_version_tuple()]), installation_uid, debug, (catcher_url or 'Failed DCSP to DCSP upload DCSP traceback'), ', DCSP '.join(sorted(manager.get_order())), gevent.__version__, greenlet.__version__, reconfigure.__version__, requests.__version__, psutil.__version__, tb, log))\n", "intent": "formats a bug report .\n", "question_id": 1337}, {"snippet": "@require_context DCNL @require_volume_exists DCNL def volume_glance_metadata_bulk_create(context, volume_id, metadata): DCNL  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP for (key, value) in metadata.items(): DCNL DCSP  DCSP  DCSP rows = session.query(models.VolumeGlanceMetadata).filter_by(volume_id=volume_id).filter_by(key=key).filter_by(deleted=False).all() DCNL DCSP  DCSP  DCSP if (len(rows) > 0): DCNL DCSP  DCSP  DCSP  DCSP raise exception.GlanceMetadataExists(key=key, volume_id=volume_id) DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = key DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = six.text_type(value) DCNL DCSP  DCSP  DCSP session.add(vol_glance_metadata)\n", "intent": "update the glance metadata for a volume by adding new key:value pairs .\n", "question_id": 1338}, {"snippet": "def redact_http_basic_auth(output): DCNL  DCSP url_re = '(https?)://.*@' DCNL DCSP redacted = '\\\\1://<redacted>@' DCNL DCSP if (sys.version_info >= (2, 7)): DCNL DCSP  DCSP return re.sub(url_re, redacted, output, flags=re.IGNORECASE) DCNL DCSP elif re.search(url_re, output.lower()): DCNL DCSP  DCSP return re.sub(url_re, redacted, output.lower()) DCNL DCSP return output\n", "intent": "remove http user and password .\n", "question_id": 1339}, {"snippet": "def wrap(text, width): DCNL  DCSP text = force_unicode(text) DCNL DCSP def _generator(): DCNL DCSP  DCSP it = iter(text.split(' DCSP ')) DCNL DCSP  DCSP word = it.next() DCNL DCSP  DCSP (yield word) DCNL DCSP  DCSP pos = ((len(word) - word.rfind('\\n')) - 1) DCNL DCSP  DCSP for word in it: DCNL DCSP  DCSP  DCSP if ('\\n' in word): DCNL DCSP  DCSP  DCSP  DCSP lines = word.split('\\n') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lines = (word,) DCNL DCSP  DCSP  DCSP pos += (len(lines[0]) + 1) DCNL DCSP  DCSP  DCSP if (pos > width): DCNL DCSP  DCSP  DCSP  DCSP (yield '\\n') DCNL DCSP  DCSP  DCSP  DCSP pos = len(lines[(-1)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (len(lines) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pos = len(lines[(-1)]) DCNL DCSP  DCSP  DCSP (yield word) DCNL DCSP return u''.join(_generator())\n", "intent": "a word-wrap function that preserves existing line breaks and most spaces in the text .\n", "question_id": 1340}, {"snippet": "def loadLocalVariables(filename): DCNL  DCSP f = file(filename, 'r') DCNL DCSP lines = [f.readline(), f.readline()] DCNL DCSP f.close() DCNL DCSP for line in lines: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return _parseLocalVariables(line) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return {}\n", "intent": "accepts a filename and attempts to load the emacs variable declarations from that file .\n", "question_id": 1341}, {"snippet": "def get_dasharray(obj, i=None): DCNL  DCSP if (obj.__dict__.get('_dashSeq', None) is not None): DCNL DCSP  DCSP return ','.join(map(str, obj._dashSeq)) DCNL DCSP else: DCNL DCSP  DCSP ls = obj.get_linestyle() DCNL DCSP  DCSP if (i is not None): DCNL DCSP  DCSP  DCSP ls = ls[i] DCNL DCSP  DCSP dasharray = LINESTYLES.get(ls, None) DCNL DCSP  DCSP if (dasharray is None): DCNL DCSP  DCSP  DCSP warnings.warn(\"dash DCSP style DCSP '{0}' DCSP not DCSP understood: DCSP defaulting DCSP to DCSP solid.\".format(ls)) DCNL DCSP  DCSP  DCSP dasharray = LINESTYLES['-'] DCNL DCSP  DCSP return dasharray\n", "intent": "get an svg dash array for the given matplotlib linestyle parameters obj : matplotlib object the matplotlib line or path object .\n", "question_id": 1342}, {"snippet": "def DeleteUser(username, token=None): DCNL  DCSP token = data_store.GetDefaultToken(token) DCNL DCSP user_urn = ('aff4:/users/%s' % username) DCNL DCSP try: DCNL DCSP  DCSP aff4.FACTORY.Open(user_urn, users.GRRUser, token=token) DCNL DCSP except aff4.InstantiationError: DCNL DCSP  DCSP EPrint(('User DCSP %s DCSP not DCSP found.' % username)) DCNL DCSP  DCSP return DCNL DCSP aff4.FACTORY.Delete(user_urn, token=token) DCNL DCSP EPrint(('User DCSP %s DCSP has DCSP been DCSP deleted.' % username)) DCNL DCSP events.Events.PublishEvent('Audit', events.AuditEvent(user=token.username, action='USER_DELETE', urn=user_urn), token=token)\n", "intent": "deletes an existing user .\n", "question_id": 1343}, {"snippet": "def _write_files(output_root, contents, generated_suffix_map=None): DCNL  DCSP _ensure_dir(output_root) DCNL DCSP to_delete = (set((file.basename() for file in output_root.files())) - set(contents.keys())) DCNL DCSP if generated_suffix_map: DCNL DCSP  DCSP for output_file in contents.keys(): DCNL DCSP  DCSP  DCSP for (suffix, generated_suffix) in generated_suffix_map.items(): DCNL DCSP  DCSP  DCSP  DCSP if output_file.endswith(suffix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP to_delete.discard(output_file.replace(suffix, generated_suffix)) DCNL DCSP for extra_file in to_delete: DCNL DCSP  DCSP (output_root / extra_file).remove_p() DCNL DCSP for (filename, file_content) in contents.iteritems(): DCNL DCSP  DCSP output_file = (output_root / filename) DCNL DCSP  DCSP not_file = (not output_file.isfile()) DCNL DCSP  DCSP write_file = (not_file or (output_file.read_md5() != hashlib.md5(file_content).digest())) DCNL DCSP  DCSP if write_file: DCNL DCSP  DCSP  DCSP LOG.debug('Writing DCSP %s', output_file) DCNL DCSP  DCSP  DCSP output_file.write_bytes(file_content) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.debug('%s DCSP unchanged, DCSP skipping', output_file)\n", "intent": "write file contents to output root .\n", "question_id": 1344}, {"snippet": "def checkbox_to_value(option, value_on=1, value_off=0): DCNL  DCSP if isinstance(option, list): DCNL DCSP  DCSP option = option[(-1)] DCNL DCSP if isinstance(option, (str, unicode)): DCNL DCSP  DCSP option = str(option).strip().lower() DCNL DCSP if (option in (True, 'on', 'true', '1', value_on)): DCNL DCSP  DCSP return value_on DCNL DCSP return value_off\n", "intent": "turns checkbox option on or true to value_on (1) any other value returns value_off (0) .\n", "question_id": 1345}, {"snippet": "def permission_check(check): DCNL  DCSP def decorator(cls): DCNL DCSP  DCSP cls.check_permission = staticmethod(check) DCNL DCSP  DCSP return cls DCNL DCSP return decorator\n", "intent": "class decorator for subclasses of publictask to sprinkle in re-usable permission checks:: @permission_check class mytask: def run_public: pass .\n", "question_id": 1346}, {"snippet": "def sm_flavor_create(context, values): DCNL  DCSP return IMPL.sm_flavor_create(context, values)\n", "intent": "create a new sm flavor entry .\n", "question_id": 1347}, {"snippet": "@register.filter DCNL def remaining(item_list, total): DCNL  DCSP list_length = len(item_list) DCNL DCSP expected_total = int(total) DCNL DCSP if (list_length != expected_total): DCNL DCSP  DCSP return range(0, (expected_total - list_length)) DCNL DCSP return ''\n", "intent": "returns a null list of remaining items derived from the total .\n", "question_id": 1348}, {"snippet": "@control_command() DCNL def pool_restart(state, modules=None, reload=False, reloader=None, **kwargs): DCNL  DCSP if state.app.conf.worker_pool_restarts: DCNL DCSP  DCSP state.consumer.controller.reload(modules, reload, reloader=reloader) DCNL DCSP  DCSP return ok(u'reload DCSP started') DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(u'Pool DCSP restarts DCSP not DCSP enabled')\n", "intent": "restart execution pool .\n", "question_id": 1349}, {"snippet": "def smStatus(): DCNL  DCSP a = TpPd(pd=8) DCNL DCSP b = MessageType(mesType=85) DCNL DCSP c = SmCause() DCNL DCSP packet = ((a / b) / c) DCNL DCSP return packet\n", "intent": "sm status section 9 .\n", "question_id": 1350}, {"snippet": "def dynamic_string_scriptler_param(registry, xml_parent, data): DCNL  DCSP dynamic_scriptler_param_common(registry, xml_parent, data, 'ScriptlerStringParameterDefinition')\n", "intent": "yaml: dynamic-string-scriptler dynamic parameter  requires the jenkins :jenkins-wiki:jenkins dynamic parameter plug-in <dynamic+parameter+plug-in> .\n", "question_id": 1351}, {"snippet": "def get_timezone_name(dt_or_tzinfo=None, width='long', uncommon=False, locale=LC_TIME): DCNL  DCSP if ((dt_or_tzinfo is None) or isinstance(dt_or_tzinfo, (int, long))): DCNL DCSP  DCSP dt = None DCNL DCSP  DCSP tzinfo = UTC DCNL DCSP elif isinstance(dt_or_tzinfo, (datetime, time)): DCNL DCSP  DCSP dt = dt_or_tzinfo DCNL DCSP  DCSP if (dt.tzinfo is not None): DCNL DCSP  DCSP  DCSP tzinfo = dt.tzinfo DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tzinfo = UTC DCNL DCSP else: DCNL DCSP  DCSP dt = None DCNL DCSP  DCSP tzinfo = dt_or_tzinfo DCNL DCSP locale = Locale.parse(locale) DCNL DCSP if hasattr(tzinfo, 'zone'): DCNL DCSP  DCSP zone = tzinfo.zone DCNL DCSP else: DCNL DCSP  DCSP zone = tzinfo.tzname(dt) DCNL DCSP zone = get_global('zone_aliases').get(zone, zone) DCNL DCSP info = locale.time_zones.get(zone, {}) DCNL DCSP if (width in info): DCNL DCSP  DCSP if (dt is None): DCNL DCSP  DCSP  DCSP field = 'generic' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dst = tzinfo.dst(dt) DCNL DCSP  DCSP  DCSP if (dst is None): DCNL DCSP  DCSP  DCSP  DCSP field = 'generic' DCNL DCSP  DCSP  DCSP elif (dst == 0): DCNL DCSP  DCSP  DCSP  DCSP field = 'standard' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP field = 'daylight' DCNL DCSP  DCSP if (field in info[width]): DCNL DCSP  DCSP  DCSP return info[width][field] DCNL DCSP metazone = get_global('meta_zones').get(zone) DCNL DCSP if metazone: DCNL DCSP  DCSP metazone_info = locale.meta_zones.get(metazone, {}) DCNL DCSP  DCSP if ((width in metazone_info) and (uncommon or metazone_info.get('common'))): DCNL DCSP  DCSP  DCSP if (dt is None): DCNL DCSP  DCSP  DCSP  DCSP field = 'generic' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP field = ((tzinfo.dst(dt) and 'daylight') or 'standard') DCNL DCSP  DCSP  DCSP if (field in metazone_info[width]): DCNL DCSP  DCSP  DCSP  DCSP return metazone_info[width][field] DCNL DCSP if (dt is not None): DCNL DCSP  DCSP return get_timezone_gmt(dt, width=width, locale=locale) DCNL DCSP return get_timezone_location(dt_or_tzinfo, locale=locale)\n", "intent": "return the localized display name for the given timezone .\n", "question_id": 1352}, {"snippet": "def _func(a, p, r, v): DCNL  DCSP f = ((((a[0] * math.log((r - 1.0))) + (a[1] * (math.log((r - 1.0)) ** 2))) + (a[2] * (math.log((r - 1.0)) ** 3))) + (a[3] * (math.log((r - 1.0)) ** 4))) DCNL DCSP if (r == 3): DCNL DCSP  DCSP f += ((-0.002) / (1.0 + (12.0 * (_phi(p) ** 2)))) DCNL DCSP  DCSP if (v <= 4.364): DCNL DCSP  DCSP  DCSP f += ((1.0 / 517.0) - (1.0 / (312.0 * (v, 1e+38)[np.isinf(v)]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f += (1.0 / (191.0 * (v, 1e+38)[np.isinf(v)])) DCNL DCSP return (- f)\n", "intent": "calculates f-hat for the coefficients in a .\n", "question_id": 1353}, {"snippet": "def get_output_error(cmd): DCNL  DCSP if (not isinstance(cmd, list)): DCNL DCSP  DCSP cmd = [cmd] DCNL DCSP logging.debug('Running: DCSP %s', ' DCSP '.join(map(quote, cmd))) DCNL DCSP try: DCNL DCSP  DCSP result = Popen(cmd, stdout=PIPE, stderr=PIPE) DCNL DCSP except IOError as e: DCNL DCSP  DCSP return ((-1), u(''), u(('Failed DCSP to DCSP run DCSP %r: DCSP %r' % (cmd, e)))) DCNL DCSP (so, se) = result.communicate() DCNL DCSP so = so.decode('utf8', 'replace') DCNL DCSP se = se.decode('utf8', 'replace') DCNL DCSP return (result.returncode, so, se)\n", "intent": "return the exit status .\n", "question_id": 1354}, {"snippet": "def from_scipy_sparse_matrix(A, parallel_edges=False, create_using=None, edge_attribute='weight'): DCNL  DCSP G = _prep_create_using(create_using) DCNL DCSP (n, m) = A.shape DCNL DCSP if (n != m): DCNL DCSP  DCSP raise nx.NetworkXError(('Adjacency DCSP matrix DCSP is DCSP not DCSP square. DCSP nx,ny=%s' % (A.shape,))) DCNL DCSP G.add_nodes_from(range(n)) DCNL DCSP triples = _generate_weighted_edges(A) DCNL DCSP if ((A.dtype.kind in ('i', 'u')) and G.is_multigraph() and parallel_edges): DCNL DCSP  DCSP chain = itertools.chain.from_iterable DCNL DCSP  DCSP triples = chain((((u, v, 1) for d in range(w)) for (u, v, w) in triples)) DCNL DCSP if (G.is_multigraph() and (not G.is_directed())): DCNL DCSP  DCSP triples = ((u, v, d) for (u, v, d) in triples if (u <= v)) DCNL DCSP G.add_weighted_edges_from(triples, weight=edge_attribute) DCNL DCSP return G\n", "intent": "creates a new graph from an adjacency matrix given as a scipy sparse matrix .\n", "question_id": 1355}, {"snippet": "def eta(lam): DCNL  DCSP if (lam > 0): DCNL DCSP  DCSP return mp.sqrt((2 * (lam - mp.log((lam + 1))))) DCNL DCSP elif (lam < 0): DCNL DCSP  DCSP return (- mp.sqrt((2 * (lam - mp.log((lam + 1)))))) DCNL DCSP else: DCNL DCSP  DCSP return 0\n", "intent": "function from dlmf 8 .\n", "question_id": 1356}, {"snippet": "def onGlobalDataDel(key): DCNL  DCSP DEBUG_MSG(('onDelGlobalData: DCSP %s' % key))\n", "intent": "kbengine method .\n", "question_id": 1357}, {"snippet": "def get_field_size(name): DCNL  DCSP m = field_size_re.search(name) DCNL DCSP return (int(m.group(1)) if m else None)\n", "intent": "extract the size number from a \"varchar\" type name .\n", "question_id": 1358}, {"snippet": "def index(): DCNL  DCSP send = request.vars.send DCNL DCSP if DEMO_MODE: DCNL DCSP  DCSP session.authorized = True DCNL DCSP  DCSP session.last_time = t0 DCNL DCSP if (not send): DCNL DCSP  DCSP send = URL('site') DCNL DCSP if session.authorized: DCNL DCSP  DCSP redirect(send) DCNL DCSP elif (failed_login_count() >= allowed_number_of_attempts): DCNL DCSP  DCSP time.sleep((2 ** allowed_number_of_attempts)) DCNL DCSP  DCSP raise HTTP(403) DCNL DCSP elif request.vars.password: DCNL DCSP  DCSP if verify_password(request.vars.password[:1024]): DCNL DCSP  DCSP  DCSP session.authorized = True DCNL DCSP  DCSP  DCSP login_record(True) DCNL DCSP  DCSP  DCSP if CHECK_VERSION: DCNL DCSP  DCSP  DCSP  DCSP session.check_version = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP session.check_version = False DCNL DCSP  DCSP  DCSP session.last_time = t0 DCNL DCSP  DCSP  DCSP if isinstance(send, list): DCNL DCSP  DCSP  DCSP  DCSP send = str(send[0]) DCNL DCSP  DCSP  DCSP redirect(send) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP times_denied = login_record(False) DCNL DCSP  DCSP  DCSP if (times_denied >= allowed_number_of_attempts): DCNL DCSP  DCSP  DCSP  DCSP response.flash = T('admin DCSP disabled DCSP because DCSP too DCSP many DCSP invalid DCSP login DCSP attempts') DCNL DCSP  DCSP  DCSP elif (times_denied == (allowed_number_of_attempts - 1)): DCNL DCSP  DCSP  DCSP  DCSP response.flash = T('You DCSP have DCSP one DCSP more DCSP login DCSP attempt DCSP before DCSP you DCSP are DCSP locked DCSP out') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP response.flash = T('invalid DCSP password.') DCNL DCSP return dict(send=send)\n", "intent": "index handler .\n", "question_id": 1359}, {"snippet": "@public DCNL def PolynomialRing(dom, *gens, **opts): DCNL  DCSP order = opts.get('order', GeneralizedPolynomialRing.default_order) DCNL DCSP if iterable(order): DCNL DCSP  DCSP order = build_product_order(order, gens) DCNL DCSP order = monomial_key(order) DCNL DCSP opts['order'] = order DCNL DCSP if order.is_global: DCNL DCSP  DCSP return GlobalPolynomialRing(dom, *gens, **opts) DCNL DCSP else: DCNL DCSP  DCSP return GeneralizedPolynomialRing(dom, *gens, **opts)\n", "intent": "create a generalized multivariate polynomial ring .\n", "question_id": 1360}, {"snippet": "def _mergetree(src, dst): DCNL  DCSP for item in os.listdir(src): DCNL DCSP  DCSP s = os.path.join(src, item) DCNL DCSP  DCSP d = os.path.join(dst, item) DCNL DCSP  DCSP if os.path.isdir(s): DCNL DCSP  DCSP  DCSP log.info('Copying DCSP folder DCSP {0} DCSP to DCSP {1}'.format(s, d)) DCNL DCSP  DCSP  DCSP if os.path.exists(d): DCNL DCSP  DCSP  DCSP  DCSP _mergetree(s, d) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP shutil.copytree(s, d) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.info('Copying DCSP file DCSP {0} DCSP to DCSP {1}'.format(s, d)) DCNL DCSP  DCSP  DCSP shutil.copy2(s, d)\n", "intent": "akin to shutils .\n", "question_id": 1361}, {"snippet": "def multiclass_hinge_loss(predictions, targets, delta=1): DCNL  DCSP num_cls = predictions.shape[1] DCNL DCSP if (targets.ndim == (predictions.ndim - 1)): DCNL DCSP  DCSP targets = theano.tensor.extra_ops.to_one_hot(targets, num_cls) DCNL DCSP elif (targets.ndim != predictions.ndim): DCNL DCSP  DCSP raise TypeError('rank DCSP mismatch DCSP between DCSP targets DCSP and DCSP predictions') DCNL DCSP corrects = predictions[targets.nonzero()] DCNL DCSP rest = theano.tensor.reshape(predictions[(1 - targets).nonzero()], ((-1), (num_cls - 1))) DCNL DCSP rest = theano.tensor.max(rest, axis=1) DCNL DCSP return theano.tensor.nnet.relu(((rest - corrects) + delta))\n", "intent": "computes the multi-class hinge loss between predictions and targets .\n", "question_id": 1362}, {"snippet": "def tamper(payload, **kwargs): DCNL  DCSP return (payload.replace(\"'\", '%00%27') if payload else payload)\n", "intent": "replaces apostrophe character with its illegal double unicode counterpart .\n", "question_id": 1363}, {"snippet": "def avail_sizes(kwargs=None, call=None): DCNL  DCSP if (call == 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP avail_sizes DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function, DCSP or DCSP with DCSP the DCSP --list-sizes DCSP option') DCNL DCSP zone = _get_specified_zone(kwargs, get_configured_provider()) DCNL DCSP result = {} DCNL DCSP for size_key in QINGCLOUD_SIZES[zone]: DCNL DCSP  DCSP result[size_key] = {} DCNL DCSP  DCSP for attribute_key in QINGCLOUD_SIZES[zone][size_key]: DCNL DCSP  DCSP  DCSP result[size_key][attribute_key] = QINGCLOUD_SIZES[zone][size_key][attribute_key] DCNL DCSP return result\n", "intent": "return a list of the instance sizes that are on the provider .\n", "question_id": 1364}, {"snippet": "def _get_module_name(path): DCNL  DCSP modulename = path DCNL DCSP try: DCNL DCSP  DCSP modulepath = re.match('(?P<modulepath>.*)\\\\.models.(?P<name>\\\\w+)$', path).group('modulepath') DCNL DCSP  DCSP module = Module.objects.get(name=modulepath) DCNL DCSP  DCSP modulename = _(module.title) DCNL DCSP except Module.DoesNotExist: DCNL DCSP  DCSP pass DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP return modulename\n", "intent": "returns real and translated module name for the given path .\n", "question_id": 1365}, {"snippet": "def inspect_image(name): DCNL  DCSP ret = _client_wrapper('inspect_image', name) DCNL DCSP for param in ('Size', 'VirtualSize'): DCNL DCSP  DCSP if (param in ret): DCNL DCSP  DCSP  DCSP ret['{0}_Human'.format(param)] = _size_fmt(ret[param]) DCNL DCSP return ret\n", "intent": "retrieves image information .\n", "question_id": 1366}, {"snippet": "def unique_rows(ar): DCNL  DCSP if (ar.ndim != 2): DCNL DCSP  DCSP raise ValueError(('unique_rows() DCSP only DCSP makes DCSP sense DCSP for DCSP 2D DCSP arrays, DCSP got DCSP %dd' % ar.ndim)) DCNL DCSP ar = np.ascontiguousarray(ar) DCNL DCSP ar_row_view = ar.view(('|S%d' % (ar.itemsize * ar.shape[1]))) DCNL DCSP (_, unique_row_indices) = np.unique(ar_row_view, return_index=True) DCNL DCSP ar_out = ar[unique_row_indices] DCNL DCSP return ar_out\n", "intent": "remove repeated rows from a 2d array .\n", "question_id": 1367}, {"snippet": "def __get_metadata(vm_): DCNL  DCSP md = config.get_cloud_config_value('metadata', vm_, __opts__, default='{}', search_global=False) DCNL DCSP try: DCNL DCSP  DCSP metadata = literal_eval(md) DCNL DCSP except Exception: DCNL DCSP  DCSP metadata = None DCNL DCSP if ((not metadata) or (not isinstance(metadata, dict))): DCNL DCSP  DCSP metadata = {'items': [{'key': 'salt-cloud-profile', 'value': vm_['profile']}]} DCNL DCSP else: DCNL DCSP  DCSP metadata['salt-cloud-profile'] = vm_['profile'] DCNL DCSP  DCSP items = [] DCNL DCSP  DCSP for (k, v) in six.iteritems(metadata): DCNL DCSP  DCSP  DCSP items.append({'key': k, 'value': v}) DCNL DCSP  DCSP metadata = {'items': items} DCNL DCSP return metadata\n", "intent": "get configured metadata and add salt-cloud-profile .\n", "question_id": 1368}, {"snippet": "def unauthenticated_userid(request): DCNL  DCSP return request.unauthenticated_userid\n", "intent": "a function that returns the value of the property :attr:pyramid .\n", "question_id": 1369}, {"snippet": "def find_sockfile(display=None): DCNL  DCSP display = (display or os.environ.get('DISPLAY') or ':0.0') DCNL DCSP if ('.' not in display): DCNL DCSP  DCSP display += '.0' DCNL DCSP cache_directory = get_cache_dir() DCNL DCSP return os.path.join(cache_directory, (SOCKBASE % display))\n", "intent": "finds the appropriate socket file .\n", "question_id": 1370}, {"snippet": "def libvlc_audio_output_device_list_get(p_instance, aout): DCNL  DCSP f = (_Cfunctions.get('libvlc_audio_output_device_list_get', None) or _Cfunction('libvlc_audio_output_device_list_get', ((1,), (1,)), None, ctypes.POINTER(AudioOutputDevice), Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, aout)\n", "intent": "gets a list of audio output devices for a given audio output .\n", "question_id": 1371}, {"snippet": "def runfile(filename, args=None, wdir=None, namespace=None, post_mortem=False): DCNL  DCSP try: DCNL DCSP  DCSP filename = filename.decode('utf-8') DCNL DCSP except (UnicodeError, TypeError, AttributeError): DCNL DCSP  DCSP pass DCNL DCSP global __umr__ DCNL DCSP if (os.environ.get('UMR_ENABLED', '').lower() == 'true'): DCNL DCSP  DCSP if (__umr__ is None): DCNL DCSP  DCSP  DCSP namelist = os.environ.get('UMR_NAMELIST', None) DCNL DCSP  DCSP  DCSP if (namelist is not None): DCNL DCSP  DCSP  DCSP  DCSP namelist = namelist.split(',') DCNL DCSP  DCSP  DCSP __umr__ = UserModuleReloader(namelist=namelist) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP verbose = (os.environ.get('UMR_VERBOSE', '').lower() == 'true') DCNL DCSP  DCSP  DCSP __umr__.run(verbose=verbose) DCNL DCSP if ((args is not None) and (not isinstance(args, basestring))): DCNL DCSP  DCSP raise TypeError('expected DCSP a DCSP character DCSP buffer DCSP object') DCNL DCSP if (namespace is None): DCNL DCSP  DCSP namespace = _get_globals() DCNL DCSP namespace['__file__'] = filename DCNL DCSP sys.argv = [filename] DCNL DCSP if (args is not None): DCNL DCSP  DCSP for arg in shlex.split(args): DCNL DCSP  DCSP  DCSP sys.argv.append(arg) DCNL DCSP if (wdir is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wdir = wdir.decode('utf-8') DCNL DCSP  DCSP except (UnicodeError, TypeError, AttributeError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP os.chdir(wdir) DCNL DCSP if post_mortem: DCNL DCSP  DCSP set_post_mortem() DCNL DCSP execfile(filename, namespace) DCNL DCSP clear_post_mortem() DCNL DCSP sys.argv = [''] DCNL DCSP namespace.pop('__file__')\n", "intent": "run filename args: command line arguments  wdir: working directory post_mortem: boolean .\n", "question_id": 1372}, {"snippet": "def detect(code): DCNL  DCSP return ((' DCSP ' not in code) and (('%20' in code) or (code.count('%') > 3)))\n", "intent": "detects if a scriptlet is urlencoded .\n", "question_id": 1373}, {"snippet": "def get_color_scheme(name): DCNL  DCSP name = name.lower() DCNL DCSP scheme = {} DCNL DCSP for key in COLOR_SCHEME_KEYS: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP scheme[key] = CONF.get('color_schemes', ((name + '/') + key)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP scheme[key] = CONF.get('color_schemes', ('spyder/' + key)) DCNL DCSP return scheme\n", "intent": "get a color scheme from config using its name .\n", "question_id": 1374}, {"snippet": "def gatherResults(deferredList): DCNL  DCSP d = DeferredList(deferredList, fireOnOneErrback=True) DCNL DCSP d.addCallback(_parseDListResult) DCNL DCSP return d\n", "intent": "returns list with result of given l{deferred}s .\n", "question_id": 1375}, {"snippet": "def mock_sign(version_id, reviewer=False): DCNL  DCSP version = Version.objects.get(pk=version_id) DCNL DCSP file_obj = version.all_files[0] DCNL DCSP if reviewer: DCNL DCSP  DCSP path = file_obj.signed_reviewer_file_path DCNL DCSP  DCSP storage = private_storage DCNL DCSP else: DCNL DCSP  DCSP path = file_obj.signed_file_path DCNL DCSP  DCSP storage = public_storage DCNL DCSP copy_stored_file(file_obj.file_path, path, src_storage=private_storage, dst_storage=storage) DCNL DCSP return path\n", "intent": "this is a mock for using in tests .\n", "question_id": 1376}, {"snippet": "def partial(f, k, w): DCNL  DCSP (w_plus, w_minus) = (w.copy(), w.copy()) DCNL DCSP w_plus[k] += 0.01 DCNL DCSP w_minus[k] += (-0.01) DCNL DCSP return ((f(w_plus) - f(w_minus)) / 0.02)\n", "intent": "return the partial derivative of the function f with respect to the kth variable .\n", "question_id": 1377}, {"snippet": "def unequal_vals_constraint(A, a, B, b): DCNL  DCSP return (a != b)\n", "intent": "a simple constraint: two neighbors must always have different values .\n", "question_id": 1378}, {"snippet": "def instance_info_cache_get(context, instance_uuid): DCNL  DCSP return IMPL.instance_info_cache_get(context, instance_uuid)\n", "intent": "gets an instance info cache from the table .\n", "question_id": 1379}, {"snippet": "def _MSBuildOnly(tool, name, setting_type): DCNL  DCSP def _Translate(value, msbuild_settings): DCNL DCSP  DCSP tool_settings = msbuild_settings.setdefault(tool.msbuild_name, {}) DCNL DCSP  DCSP tool_settings[name] = value DCNL DCSP _msbuild_validators[tool.msbuild_name][name] = setting_type.ValidateMSBuild DCNL DCSP _msvs_to_msbuild_converters[tool.msvs_name][name] = _Translate\n", "intent": "defines a setting that is only found in msbuild .\n", "question_id": 1380}, {"snippet": "def prepare_form_encoded_body(oauth_params, body): DCNL  DCSP return _append_params(oauth_params, body)\n", "intent": "prepare the form-encoded body .\n", "question_id": 1381}, {"snippet": "def test_wavelet_denoising_args(): DCNL  DCSP img = astro DCNL DCSP noisy = (img.copy() + (0.1 * np.random.randn(*img.shape))) DCNL DCSP for convert2ycbcr in [True, False]: DCNL DCSP  DCSP for multichannel in [True, False]: DCNL DCSP  DCSP  DCSP for sigma in [0.1, [0.1, 0.1, 0.1], None]: DCNL DCSP  DCSP  DCSP  DCSP if (((not multichannel) and (not convert2ycbcr)) or (isinstance(sigma, list) and (not multichannel))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP restoration.denoise_wavelet(noisy, sigma=sigma, convert2ycbcr=convert2ycbcr, multichannel=multichannel)\n", "intent": "some of the functions inside wavelet denoising throw an error the wrong arguments are passed .\n", "question_id": 1382}, {"snippet": "def user_required(handler): DCNL  DCSP def check_login(self, *args, **kwargs): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP handler DCSP has DCSP no DCSP login_url DCSP specified DCSP invoke DCSP a DCSP 403 DCSP error\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (self.request.query_string != ''): DCNL DCSP  DCSP  DCSP query_string = ('?' + self.request.query_string) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query_string = '' DCNL DCSP  DCSP continue_url = (self.request.path_url + query_string) DCNL DCSP  DCSP login_url = self.uri_for('login', **{'continue': continue_url}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth = self.auth.get_user_by_session() DCNL DCSP  DCSP  DCSP if (not auth): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.redirect(login_url, abort=True) DCNL DCSP  DCSP  DCSP  DCSP except (AttributeError, KeyError) as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.abort(403) DCNL DCSP  DCSP except AttributeError as e: DCNL DCSP  DCSP  DCSP logging.error(e) DCNL DCSP  DCSP  DCSP self.auth.unset_session() DCNL DCSP  DCSP  DCSP self.redirect(login_url) DCNL DCSP  DCSP return handler(self, *args, **kwargs) DCNL DCSP return check_login\n", "intent": "decorator for checking if theres a user associated with the current session .\n", "question_id": 1383}, {"snippet": "def wait_for_winexesvc(host, port, username, password, timeout=900): DCNL  DCSP start = time.time() DCNL DCSP log.debug('Attempting DCSP winexe DCSP connection DCSP to DCSP host DCSP {0} DCSP on DCSP port DCSP {1}'.format(host, port)) DCNL DCSP creds = \"-U DCSP '{0}%{1}' DCSP //{2}\".format(username, password, host) DCNL DCSP logging_creds = \"-U DCSP '{0}%XXX-REDACTED-XXX' DCSP //{1}\".format(username, host) DCNL DCSP try_count = 0 DCNL DCSP while True: DCNL DCSP  DCSP try_count += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ret_code = win_cmd('winexe DCSP {0} DCSP \"sc DCSP query DCSP winexesvc\"'.format(creds), logging_command=logging_creds) DCNL DCSP  DCSP  DCSP if (ret_code == 0): DCNL DCSP  DCSP  DCSP  DCSP log.debug('winexe DCSP connected...') DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP log.debug('Return DCSP code DCSP was DCSP {0}'.format(ret_code)) DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP except socket.error as exc: DCNL DCSP  DCSP  DCSP log.debug('Caught DCSP exception DCSP in DCSP wait_for_winexesvc: DCSP {0}'.format(exc)) DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP if ((time.time() - start) > timeout): DCNL DCSP  DCSP  DCSP  DCSP log.error('winexe DCSP connection DCSP timed DCSP out: DCSP {0}'.format(timeout)) DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP log.debug('Retrying DCSP winexe DCSP connection DCSP to DCSP host DCSP {0} DCSP on DCSP port DCSP {1} DCSP (try DCSP {2})'.format(host, port, try_count))\n", "intent": "wait until winexe connection can be established .\n", "question_id": 1384}, {"snippet": "def maybe(typ, val): DCNL  DCSP return (typ(val) if (val is not None) else val)\n", "intent": "call typ on value if val is defined .\n", "question_id": 1385}, {"snippet": "def hub_script(timeout=0): DCNL  DCSP parser = argparse.ArgumentParser(prog=(u'samp_hub DCSP ' + __version__)) DCNL DCSP parser.add_argument(u'-k', u'--secret', dest=u'secret', metavar=u'CODE', help=u'custom DCSP secret DCSP code.') DCNL DCSP parser.add_argument(u'-d', u'--addr', dest=u'addr', metavar=u'ADDR', help=u'listening DCSP address DCSP (or DCSP IP).') DCNL DCSP parser.add_argument(u'-p', u'--port', dest=u'port', metavar=u'PORT', type=int, help=u'listening DCSP port DCSP number.') DCNL DCSP parser.add_argument(u'-f', u'--lockfile', dest=u'lockfile', metavar=u'FILE', help=u'custom DCSP lockfile.') DCNL DCSP parser.add_argument(u'-w', u'--no-web-profile', dest=u'web_profile', action=u'store_false', help=u'run DCSP the DCSP Hub DCSP disabling DCSP the DCSP Web DCSP Profile.', default=True) DCNL DCSP parser.add_argument(u'-P', u'--pool-size', dest=u'pool_size', metavar=u'SIZE', type=int, help=u'the DCSP socket DCSP connections DCSP pool DCSP size.', default=20) DCNL DCSP timeout_group = parser.add_argument_group(u'Timeout DCSP group', u'Special DCSP options DCSP to DCSP setup DCSP hub DCSP and DCSP client DCSP timeouts.It DCSP contains DCSP a DCSP set DCSP of DCSP special DCSP options DCSP that DCSP allows DCSP to DCSP set DCSP up DCSP the DCSP Hub DCSP and DCSP clients DCSP inactivity DCSP timeouts, DCSP that DCSP is DCSP the DCSP Hub DCSP or DCSP client DCSP inactivity DCSP time DCSP interval DCSP after DCSP which DCSP the DCSP Hub DCSP shuts DCSP down DCSP or DCSP unregisters DCSP the DCSP client. DCSP Notification DCSP of DCSP samp.hub.disconnect DCSP MType DCSP is DCSP sent DCSP to DCSP the DCSP clients DCSP forcibly DCSP unregistered DCSP for DCSP timeout DCSP expiration.') DCNL DCSP timeout_group.add_argument(u'-t', u'--timeout', dest=u'timeout', metavar=u'SECONDS', help=u'set DCSP the DCSP Hub DCSP inactivity DCSP timeout DCSP in DCSP SECONDS. DCSP By DCSP default DCSP it DCSP is DCSP set DCSP to DCSP 0, DCSP that DCSP is DCSP the DCSP Hub DCSP never DCSP expires.', type=int, default=0) DCNL DCSP timeout_group.add_argument(u'-c', u'--client-timeout', dest=u'client_timeout', metavar=u'SECONDS', help=u'set DCSP the DCSP client DCSP inactivity DCSP timeout DCSP in DCSP SECONDS. DCSP By DCSP default DCSP it DCSP is DCSP set DCSP to DCSP 0, DCSP that DCSP is DCSP the DCSP client DCSP never DCSP expires.', type=int, default=0) DCNL DCSP parser.add_argument_group(timeout_group) DCNL DCSP log_group = parser.add_argument_group(u'Logging DCSP options', u'Additional DCSP options DCSP which DCSP allow DCSP to DCSP customize DCSP the DCSP logging DCSP output. DCSP By DCSP default DCSP the DCSP SAMP DCSP Hub DCSP uses DCSP the DCSP standard DCSP output DCSP and DCSP standard DCSP error DCSP devices DCSP to DCSP print DCSP out DCSP INFO DCSP level DCSP logging DCSP messages. DCSP Using DCSP the DCSP options DCSP here DCSP below DCSP it DCSP is DCSP possible DCSP to DCSP modify DCSP the DCSP logging DCSP level DCSP and DCSP also DCSP specify DCSP the DCSP output DCSP files DCSP where DCSP redirect DCSP the DCSP logging DCSP messages.') DCNL DCSP log_group.add_argument(u'-L', u'--log-level', dest=u'loglevel', metavar=u'LEVEL', help=u'set DCSP the DCSP Hub DCSP instance DCSP log DCSP level DCSP (OFF, DCSP ERROR, DCSP WARNING, DCSP INFO, DCSP DEBUG).', type=str, choices=[u'OFF', u'ERROR', u'WARNING', u'INFO', u'DEBUG'], default=u'INFO') DCNL DCSP log_group.add_argument(u'-O', u'--log-output', dest=u'logout', metavar=u'FILE', help=u'set DCSP the DCSP output DCSP file DCSP for DCSP the DCSP log DCSP messages.', default=u'') DCNL DCSP parser.add_argument_group(log_group) DCNL DCSP adv_group = parser.add_argument_group(u'Advanced DCSP group', u'Advanced DCSP options DCSP addressed DCSP to DCSP facilitate DCSP administrative DCSP tasks DCSP and DCSP allow DCSP new DCSP non-standard DCSP Hub DCSP behaviors. DCSP In DCSP particular DCSP the DCSP --label DCSP options DCSP is DCSP used DCSP to DCSP assign DCSP a DCSP value DCSP to DCSP hub.label DCSP token DCSP and DCSP is DCSP used DCSP to DCSP assign DCSP a DCSP name DCSP to DCSP the DCSP Hub DCSP instance. DCSP The DCSP very DCSP special DCSP --multi DCSP option DCSP allows DCSP to DCSP start DCSP a DCSP Hub DCSP in DCSP multi-instance DCSP mode. DCSP Multi-instance DCSP mode DCSP is DCSP a DCSP non-standard DCSP Hub DCSP behavior DCSP that DCSP enables DCSP multiple DCSP contemporaneous DCSP running DCSP Hubs. DCSP Multi-instance DCSP hubs DCSP place DCSP their DCSP non-standard DCSP lock-files DCSP within DCSP the DCSP <home DCSP directory>/.samp-1 DCSP directory DCSP naming DCSP them DCSP making DCSP use DCSP of DCSP the DCSP format: DCSP samp-hub-<PID>-<ID>, DCSP where DCSP PID DCSP is DCSP the DCSP Hub DCSP process DCSP ID DCSP while DCSP ID DCSP is DCSP an DCSP internal DCSP ID DCSP (integer).') DCNL DCSP adv_group.add_argument(u'-l', u'--label', dest=u'label', metavar=u'LABEL', help=u'assign DCSP a DCSP LABEL DCSP to DCSP the DCSP Hub.', default=u'') DCNL DCSP adv_group.add_argument(u'-m', u'--multi', dest=u'mode', help=u'run DCSP the DCSP Hub DCSP in DCSP multi-instance DCSP mode DCSP generating DCSP a DCSP custom DCSP lockfile DCSP with DCSP a DCSP random DCSP name.', action=u'store_const', const=u'multiple', default=u'single') DCNL DCSP parser.add_argument_group(adv_group) DCNL DCSP if SSL_SUPPORT: DCNL DCSP  DCSP ssl_group = parser.add_argument_group(u'SSL DCSP group', u'Additional DCSP options DCSP to DCSP launch DCSP the DCSP Hub DCSP instance DCSP using DCSP the DCSP Secure DCSP Sockets DCSP Layer DCSP (HTTPS). DCSP The DCSP --key-file DCSP and DCSP --cert-file DCSP parameters DCSP specify DCSP optional DCSP files DCSP which DCSP contain DCSP a DCSP certificate DCSP to DCSP be DCSP used DCSP to DCSP identify DCSP the DCSP local DCSP side DCSP of DCSP the DCSP connection. DCSP Often DCSP the DCSP private DCSP key DCSP is DCSP stored DCSP in DCSP the DCSP same DCSP file DCSP as DCSP the DCSP certificate; DCSP in DCSP this DCSP case, DCSP only DCSP the DCSP --cert-file DCSP parameter DCSP need DCSP be DCSP passed. DCSP If DCSP the DCSP private DCSP key DCSP is DCSP stored DCSP in DCSP a DCSP separate DCSP file, DCSP both DCSP parameters DCSP must DCSP be DCSP used. DCSP If DCSP the DCSP private DCSP key DCSP is DCSP stored DCSP in DCSP the DCSP certificate DCSP file, DCSP it DCSP should DCSP come DCSP before DCSP the DCSP first DCSP certificate DCSP in DCSP the DCSP certificate DCSP chain.') DCNL DCSP  DCSP ssl_group.add_argument(u'-s', u'--https', dest=u'https', action=u'store_true', help=u'run DCSP the DCSP Hub DCSP using DCSP the DCSP Secure DCSP Sockets DCSP Layer.', default=False) DCNL DCSP  DCSP ssl_group.add_argument(u'-C', u'--cert-file', dest=u'cert_file', metavar=u'FILE', help=u'set DCSP the DCSP certificate DCSP file.', default=None) DCNL DCSP  DCSP ssl_group.add_argument(u'-K', u'--key-file', dest=u'key_file', metavar=u'FILE', help=u'set DCSP the DCSP key DCSP file. DCSP By DCSP default DCSP this DCSP option DCSP is DCSP ignored, DCSP assuming DCSP that DCSP the DCSP private DCSP key DCSP is DCSP stored DCSP in DCSP the DCSP certificate DCSP file.', default=None) DCNL DCSP  DCSP ssl_group.add_argument(u'--cert-reqs', dest=u'cert_reqs', metavar=u'STRING', help=u'this DCSP option DCSP specifies DCSP whether DCSP a DCSP certificate DCSP is DCSP required DCSP from DCSP the DCSP client DCSP side DCSP of DCSP the DCSP connection, DCSP and DCSP whether DCSP it DCSP will DCSP be DCSP validated DCSP if DCSP provided. DCSP It DCSP must DCSP be DCSP one DCSP of DCSP the DCSP three DCSP values DCSP NONE DCSP (certificates DCSP ignored, DCSP default), DCSP OPTIONAL DCSP (not DCSP required, DCSP but DCSP validated DCSP if DCSP provided), DCSP or DCSP REQUIRED DCSP (required DCSP and DCSP validated). DCSP If DCSP the DCSP value DCSP of DCSP this DCSP option DCSP is DCSP not DCSP NONE, DCSP then DCSP the DCSP --ca-certs DCSP option DCSP must DCSP point DCSP to DCSP a DCSP file DCSP of DCSP CA DCSP certificates.', type=str, choices=[u'NONE', u'OPTIONAL', u'REQUIRED'], default=u'NONE') DCNL DCSP  DCSP ssl_group.add_argument(u'--ca-certs', dest=u'ca_certs', metavar=u'FILE', help=u'the DCSP --ca-certs DCSP file DCSP contains DCSP a DCSP set DCSP of DCSP concatenated DCSP \"certification DCSP authority\" DCSP certificates, DCSP which DCSP are DCSP used DCSP to DCSP validate DCSP certificates DCSP passed DCSP from DCSP the DCSP client DCSP end DCSP of DCSP the DCSP connection.', default=None) DCNL DCSP  DCSP ssl_group.add_argument(u'--ssl-version', dest=u'ssl_version', metavar=u'STRING', help=u\"the DCSP --ssl-version DCSP option DCSP specifies DCSP which DCSP version DCSP of DCSP the DCSP SSL DCSP protocol DCSP to DCSP use. DCSP Typically, DCSP the DCSP server DCSP chooses DCSP a DCSP particular DCSP protocol DCSP version, DCSP and DCSP the DCSP client DCSP must DCSP adapt DCSP to DCSP the DCSP server's DCSP choice. DCSP Most DCSP of DCSP the DCSP versions DCSP are DCSP not DCSP interoperable DCSP with DCSP the DCSP other DCSP versions. DCSP If DCSP not DCSP specified DCSP the DCSP default DCSP SSL DCSP version DCSP is DCSP taken DCSP from DCSP the DCSP default DCSP in DCSP the DCSP Python DCSP standard DCSP `ssl` DCSP library DCSP for DCSP the DCSP version DCSP of DCSP Python DCSP that DCSP is DCSP installed. DCSP Other DCSP SSL DCSP protocol DCSP versions DCSP are: DCSP SSLv2, DCSP SSLv3, DCSP SSLv23, DCSP TLSv1, DCSP TLSv1_1, DCSP TLSv1_2 DCSP but DCSP not DCSP all DCSP of DCSP them DCSP may DCSP be DCSP available DCSP on DCSP all DCSP versions DCSP of DCSP Python.\", type=str, choices=[u'SSLv23', u'SSLv2', u'SSLv3', u'TLSv1', u'TLSv1_1', u'TLSv1_2'], default=None) DCNL DCSP  DCSP parser.add_argument_group(ssl_group) DCNL DCSP options = parser.parse_args() DCNL DCSP try: DCNL DCSP  DCSP if SSL_SUPPORT: DCNL DCSP  DCSP  DCSP if (options.cert_reqs == u'OPTIONAL'): DCNL DCSP  DCSP  DCSP  DCSP options.cert_reqs = ssl.CERT_OPTIONAL DCNL DCSP  DCSP  DCSP elif (options.cert_reqs == u'REQUIRED'): DCNL DCSP  DCSP  DCSP  DCSP options.cert_reqs = ssl.CERT_REQUIRED DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP options.cert_reqs = ssl.CERT_NONE DCNL DCSP  DCSP  DCSP if (options.ssl_version is not None): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(ssl, (u'PROTOCOL_' + options.ssl_version)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP options.ssl_version = getattr(ssl, (u'PROTOCOL_' + options.ssl_version)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(u\"SSL DCSP protocol DCSP '{0}' DCSP not DCSP supported DCSP on DCSP this DCSP version DCSP of DCSP Python\".format(options.ssl_version)) DCNL DCSP  DCSP if (options.loglevel in (u'OFF', u'ERROR', u'WARNING', u'DEBUG', u'INFO')): DCNL DCSP  DCSP  DCSP log.setLevel(options.loglevel) DCNL DCSP  DCSP if (options.logout != u''): DCNL DCSP  DCSP  DCSP context = log.log_to_file(options.logout) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP class dummy_context(object, ): DCNL DCSP  DCSP  DCSP  DCSP def __enter__(self): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP def __exit__(self, exc_type, exc_value, traceback): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP context = dummy_context() DCNL DCSP  DCSP with context: DCNL DCSP  DCSP  DCSP args = copy.deepcopy(options.__dict__) DCNL DCSP  DCSP  DCSP del args[u'loglevel'] DCNL DCSP  DCSP  DCSP del args[u'logout'] DCNL DCSP  DCSP  DCSP hub = SAMPHubServer(**args) DCNL DCSP  DCSP  DCSP hub.start(False) DCNL DCSP  DCSP  DCSP if (not timeout): DCNL DCSP  DCSP  DCSP  DCSP while hub.is_running: DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(0.01) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(timeout) DCNL DCSP  DCSP  DCSP  DCSP hub.stop() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP hub.stop() DCNL DCSP  DCSP except NameError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP except IOError as e: DCNL DCSP  DCSP print(u'[SAMP] DCSP Error: DCSP I/O DCSP error({0}): DCSP {1}'.format(e.errno, e.strerror)) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except SystemExit: DCNL DCSP  DCSP pass\n", "intent": "this main function is executed by the samp_hub command line tool .\n", "question_id": 1386}, {"snippet": "def to_unicode(s, encoding=None): DCNL  DCSP if six.PY3: DCNL DCSP  DCSP return to_str(s, encoding) DCNL DCSP else: DCNL DCSP  DCSP if isinstance(s, str): DCNL DCSP  DCSP  DCSP return s.decode((encoding or __salt_system_encoding__)) DCNL DCSP  DCSP return unicode(s)\n", "intent": "given str or unicode .\n", "question_id": 1387}, {"snippet": "def update_intermediates(base, keys, bound, s, fn, args, instance, value): DCNL  DCSP for (f, k, fun, uid) in bound[s:]: DCNL DCSP  DCSP if (fun is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f.unbind_uid(k, uid) DCNL DCSP  DCSP except ReferenceError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP del bound[s:] DCNL DCSP f = getattr(*bound[(-1)][:2]) DCNL DCSP if (f is None): DCNL DCSP  DCSP fn(args, None, None) DCNL DCSP  DCSP return DCNL DCSP s += 1 DCNL DCSP append = bound.append DCNL DCSP for val in keys[s:(-1)]: DCNL DCSP  DCSP if isinstance(f, (EventDispatcher, Observable)): DCNL DCSP  DCSP  DCSP prop = f.property(val, True) DCNL DCSP  DCSP  DCSP if ((prop is not None) and getattr(prop, 'rebind', False)): DCNL DCSP  DCSP  DCSP  DCSP uid = f.fbind(val, update_intermediates, base, keys, bound, s, fn, args) DCNL DCSP  DCSP  DCSP  DCSP append([f.proxy_ref, val, update_intermediates, uid]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP append([f.proxy_ref, val, None, None]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP append([getattr(f, 'proxy_ref', f), val, None, None]) DCNL DCSP  DCSP f = getattr(f, val, None) DCNL DCSP  DCSP if (f is None): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP s += 1 DCNL DCSP if isinstance(f, (EventDispatcher, Observable)): DCNL DCSP  DCSP uid = f.fbind(keys[(-1)], fn, args) DCNL DCSP  DCSP if uid: DCNL DCSP  DCSP  DCSP append([f.proxy_ref, keys[(-1)], fn, uid]) DCNL DCSP fn(args, None, None)\n", "intent": "function that is called when an intermediate property is updated and rebind of that property is true .\n", "question_id": 1388}, {"snippet": "def node(): DCNL  DCSP return uname()[1]\n", "intent": "returns the computers network name  an empty string is returned if the value cannot be determined .\n", "question_id": 1389}, {"snippet": "def _qs_for(model_cls): DCNL  DCSP return model_cls.objects.filter(created__gte=date(2011, 1, 1)).extra(select={'day': 'extract( DCSP day DCSP from DCSP created DCSP )', 'month': 'extract( DCSP month DCSP from DCSP created DCSP )', 'year': 'extract( DCSP year DCSP from DCSP created DCSP )'}).values('year', 'month', 'day').annotate(count=Count('created'))\n", "intent": "return the monthly grouped queryset we need for model_cls .\n", "question_id": 1390}, {"snippet": "def log_to_stderr(level=None): DCNL  DCSP global _log_to_stderr DCNL DCSP import logging DCNL DCSP logger = get_logger() DCNL DCSP formatter = logging.Formatter(DEFAULT_LOGGING_FORMAT) DCNL DCSP handler = logging.StreamHandler() DCNL DCSP handler.setFormatter(formatter) DCNL DCSP logger.addHandler(handler) DCNL DCSP if (level is not None): DCNL DCSP  DCSP logger.setLevel(level) DCNL DCSP _log_to_stderr = True\n", "intent": "turn on logging and add a handler which prints to stderr .\n", "question_id": 1391}, {"snippet": "def supports_color(): DCNL  DCSP plat = sys.platform DCNL DCSP supported_platform = ((plat != 'Pocket DCSP PC') and ((plat != 'win32') or ('ANSICON' in os.environ))) DCNL DCSP is_a_tty = (hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()) DCNL DCSP if ((not supported_platform) or (not is_a_tty)): DCNL DCSP  DCSP return False DCNL DCSP return True\n", "intent": "returns true if the running systems terminal supports color .\n", "question_id": 1392}, {"snippet": "def get_request_promotions(request): DCNL  DCSP promotions = PagePromotion._default_manager.select_related().prefetch_related('content_object').filter(page_url=request.path).order_by('display_order') DCNL DCSP if ('q' in request.GET): DCNL DCSP  DCSP keyword_promotions = KeywordPromotion._default_manager.select_related().filter(keyword=request.GET['q']) DCNL DCSP  DCSP if keyword_promotions.exists(): DCNL DCSP  DCSP  DCSP promotions = list(chain(promotions, keyword_promotions)) DCNL DCSP return promotions\n", "intent": "return promotions relevant to this request .\n", "question_id": 1393}, {"snippet": "def project_embed(request, project_slug): DCNL  DCSP project = get_object_or_404(Project.objects.protected(request.user), slug=project_slug) DCNL DCSP version = project.versions.get(slug=LATEST) DCNL DCSP files = version.imported_files.order_by('path') DCNL DCSP return render_to_response('projects/project_embed.html', {'project': project, 'files': files, 'settings': {'GROK_API_HOST': settings.GROK_API_HOST, 'URI': request.build_absolute_uri(location='/').rstrip('/')}}, context_instance=RequestContext(request))\n", "intent": "have a content api placeholder .\n", "question_id": 1394}, {"snippet": "def test_paginated_url(): DCNL  DCSP url = urlparams(reverse('search'), q='bookmarks', page=2) DCNL DCSP request = RequestFactory().get(url) DCNL DCSP queryset = [{}, {}] DCNL DCSP paginated = paginate(request, queryset) DCNL DCSP eq_(paginated.url, (request.build_absolute_uri(request.path) + '?q=bookmarks'))\n", "intent": "avoid duplicating page param in pagination .\n", "question_id": 1395}, {"snippet": "def event(types_param, **kwargs): DCNL  DCSP def _event_hook(func): DCNL DCSP  DCSP hook = _get_hook(func, 'event') DCNL DCSP  DCSP if (hook is None): DCNL DCSP  DCSP  DCSP hook = _EventHook(func) DCNL DCSP  DCSP  DCSP _add_hook(func, hook) DCNL DCSP  DCSP hook.add_hook(types_param, kwargs) DCNL DCSP  DCSP return func DCNL DCSP if callable(types_param): DCNL DCSP  DCSP raise TypeError('@irc_raw() DCSP must DCSP be DCSP used DCSP as DCSP a DCSP function DCSP that DCSP returns DCSP a DCSP decorator') DCNL DCSP else: DCNL DCSP  DCSP return (lambda func: _event_hook(func))\n", "intent": "external event decorator .\n", "question_id": 1396}, {"snippet": "def _date_from_string(year, year_format, month, month_format, day='', day_format='', delim='__'): DCNL  DCSP format = delim.join((year_format, month_format, day_format)) DCNL DCSP datestr = delim.join((year, month, day)) DCNL DCSP try: DCNL DCSP  DCSP return datetime.datetime.strptime(datestr, format).date() DCNL DCSP except ValueError: DCNL DCSP  DCSP raise Http404((_(u\"Invalid DCSP date DCSP string DCSP '%(datestr)s' DCSP given DCSP format DCSP '%(format)s'\") % {'datestr': datestr, 'format': format}))\n", "intent": "helper: get a datetime .\n", "question_id": 1397}, {"snippet": "def main(filename, num_epochs, training_cost_xmin=200, test_accuracy_xmin=200, test_cost_xmin=0, training_accuracy_xmin=0, training_set_size=1000, lmbda=0.0): DCNL  DCSP run_network(filename, num_epochs, training_set_size, lmbda) DCNL DCSP make_plots(filename, num_epochs, test_accuracy_xmin, training_cost_xmin, test_accuracy_xmin, training_accuracy_xmin, training_set_size)\n", "intent": "filename is the name of the file where the results will be stored .\n", "question_id": 1398}, {"snippet": "def ansi(): DCNL  DCSP from .ansiext import AnsiExtension DCNL DCSP md = Markdown(output_format='ansi', extensions=[ExtraExtension(), AnsiExtension()]) DCNL DCSP md.stripTopLevelTags = False DCNL DCSP return md\n", "intent": "this makes a converter from markdown to ansi  format .\n", "question_id": 1399}, {"snippet": "def rst_to_html(in_rst, stderr): DCNL  DCSP if (not in_rst): DCNL DCSP  DCSP return (u'', 0) DCNL DCSP orig_sys_exit = sys.exit DCNL DCSP orig_sys_stderr = sys.stderr DCNL DCSP returncodes = [] DCNL DCSP try: DCNL DCSP  DCSP sys.exit = returncodes.append DCNL DCSP  DCSP sys.stderr = stderr DCNL DCSP  DCSP pp = publish_parts(in_rst, writer_name=u'html', settings_overrides=dict(exit_status_level=2, report_level=2), enable_exit_status=True) DCNL DCSP finally: DCNL DCSP  DCSP sys.exit = orig_sys_exit DCNL DCSP  DCSP sys.stderr = orig_sys_stderr DCNL DCSP return_value = u'' DCNL DCSP if ((u'title' in pp) and pp[u'title']): DCNL DCSP  DCSP return_value += u'<title>{0}</title>\\n<p DCSP style=\"font: DCSP 200% DCSP bold\">{0}</p>\\n'.format(pp[u'title']) DCNL DCSP return_value += pp[u'body'].strip() DCNL DCSP return (return_value, (returncodes.pop() if returncodes else 0))\n", "intent": "renders html from an rst fragment .\n", "question_id": 1400}, {"snippet": "def behave(cmdline, cwd='.', **kwargs): DCNL  DCSP assert isinstance(cmdline, six.string_types) DCNL DCSP return run(('behave DCSP ' + cmdline), cwd=cwd, **kwargs)\n", "intent": "run behave as subprocess command and return process/shell instance with results .\n", "question_id": 1401}, {"snippet": "def sls(name, mods=None, saltenv='base', **kwargs): DCNL  DCSP mods = ([item.strip() for item in mods.split(',')] if mods else []) DCNL DCSP grains = __salt__['dockerng.call'](name, 'grains.items') DCNL DCSP pillar = _gather_pillar(saltenv, {}, **grains) DCNL DCSP trans_tar = _prepare_trans_tar(name, mods=mods, saltenv=saltenv, pillar=pillar) DCNL DCSP trans_dest_path = _generate_tmp_path() DCNL DCSP mkdirp_trans_argv = ['mkdir', '-p', trans_dest_path] DCNL DCSP ret = __salt__['dockerng.run_all'](name, subprocess.list2cmdline(mkdirp_trans_argv)) DCNL DCSP if (ret['retcode'] != 0): DCNL DCSP  DCSP return {'result': False, 'comment': ret['stderr']} DCNL DCSP ret = None DCNL DCSP try: DCNL DCSP  DCSP trans_tar_sha256 = salt.utils.get_hash(trans_tar, 'sha256') DCNL DCSP  DCSP __salt__['dockerng.copy_to'](name, trans_tar, os.path.join(trans_dest_path, 'salt_state.tgz'), exec_driver='nsenter', overwrite=True) DCNL DCSP  DCSP ret = __salt__['dockerng.call'](name, 'state.pkg', os.path.join(trans_dest_path, 'salt_state.tgz'), trans_tar_sha256, 'sha256') DCNL DCSP finally: DCNL DCSP  DCSP rm_trans_argv = ['rm', '-rf', trans_dest_path] DCNL DCSP  DCSP __salt__['dockerng.run_all'](name, subprocess.list2cmdline(rm_trans_argv)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(trans_tar) DCNL DCSP  DCSP except (IOError, OSError) as exc: DCNL DCSP  DCSP  DCSP log.error(\"dockerng.sls: DCSP Unable DCSP to DCSP remove DCSP state DCSP tarball DCSP '{0}': DCSP {1}\".format(trans_tar, exc)) DCNL DCSP if (not isinstance(ret, dict)): DCNL DCSP  DCSP __context__['retcode'] = 1 DCNL DCSP elif (not salt.utils.check_state_result(ret)): DCNL DCSP  DCSP __context__['retcode'] = 2 DCNL DCSP else: DCNL DCSP  DCSP __context__['retcode'] = 0 DCNL DCSP return ret\n", "intent": "apply the highstate defined by the specified modules .\n", "question_id": 1402}, {"snippet": "def Define(d, flavor): DCNL  DCSP if (flavor == 'win'): DCNL DCSP  DCSP d = d.replace('#', ('\\\\%03o' % ord('#'))) DCNL DCSP return QuoteShellArgument(ninja_syntax.escape(('-D' + d)), flavor)\n", "intent": "takes a preprocessor define and returns a -d parameter thats ninja- and shell-escaped .\n", "question_id": 1403}, {"snippet": "def mp_from_ids(s3server, mp_id, mp_keyname, mp_bucketname): DCNL  DCSP if s3server['host']: DCNL DCSP  DCSP conn = boto.connect_s3(aws_access_key_id=s3server['access_key'], aws_secret_access_key=s3server['secret_key'], is_secure=s3server['is_secure'], host=s3server['host'], port=s3server['port'], calling_format=boto.s3.connection.OrdinaryCallingFormat(), path=s3server['conn_path']) DCNL DCSP else: DCNL DCSP  DCSP conn = S3Connection(s3server['access_key'], s3server['secret_key']) DCNL DCSP bucket = conn.lookup(mp_bucketname) DCNL DCSP mp = boto.s3.multipart.MultiPartUpload(bucket) DCNL DCSP mp.key_name = mp_keyname DCNL DCSP mp.id = mp_id DCNL DCSP return mp\n", "intent": "get the multipart upload from the bucket and multipart ids .\n", "question_id": 1404}, {"snippet": "def test_kronecker_delta_secondquant(): DCNL  DCSP D = KroneckerDelta DCNL DCSP (i, j, v, w) = symbols('i DCSP j DCSP v DCSP w', below_fermi=True, cls=Dummy) DCNL DCSP (a, b, t, u) = symbols('a DCSP b DCSP t DCSP u', above_fermi=True, cls=Dummy) DCNL DCSP (p, q, r, s) = symbols('p DCSP q DCSP r DCSP s', cls=Dummy) DCNL DCSP assert (D(i, a) == 0) DCNL DCSP assert (D(i, t) == 0) DCNL DCSP assert (D(i, j).is_above_fermi is False) DCNL DCSP assert (D(a, b).is_above_fermi is True) DCNL DCSP assert (D(p, q).is_above_fermi is True) DCNL DCSP assert (D(i, q).is_above_fermi is False) DCNL DCSP assert (D(q, i).is_above_fermi is False) DCNL DCSP assert (D(q, v).is_above_fermi is False) DCNL DCSP assert (D(a, q).is_above_fermi is True) DCNL DCSP assert (D(i, j).is_below_fermi is True) DCNL DCSP assert (D(a, b).is_below_fermi is False) DCNL DCSP assert (D(p, q).is_below_fermi is True) DCNL DCSP assert (D(p, j).is_below_fermi is True) DCNL DCSP assert (D(q, b).is_below_fermi is False) DCNL DCSP assert (D(i, j).is_only_above_fermi is False) DCNL DCSP assert (D(a, b).is_only_above_fermi is True) DCNL DCSP assert (D(p, q).is_only_above_fermi is False) DCNL DCSP assert (D(i, q).is_only_above_fermi is False) DCNL DCSP assert (D(q, i).is_only_above_fermi is False) DCNL DCSP assert (D(a, q).is_only_above_fermi is True) DCNL DCSP assert (D(i, j).is_only_below_fermi is True) DCNL DCSP assert (D(a, b).is_only_below_fermi is False) DCNL DCSP assert (D(p, q).is_only_below_fermi is False) DCNL DCSP assert (D(p, j).is_only_below_fermi is True) DCNL DCSP assert (D(q, b).is_only_below_fermi is False) DCNL DCSP assert (not D(i, q).indices_contain_equal_information) DCNL DCSP assert (not D(a, q).indices_contain_equal_information) DCNL DCSP assert D(p, q).indices_contain_equal_information DCNL DCSP assert D(a, b).indices_contain_equal_information DCNL DCSP assert D(i, j).indices_contain_equal_information DCNL DCSP assert (D(q, b).preferred_index == b) DCNL DCSP assert (D(q, b).killable_index == q) DCNL DCSP assert (D(q, t).preferred_index == t) DCNL DCSP assert (D(q, t).killable_index == q) DCNL DCSP assert (D(q, i).preferred_index == i) DCNL DCSP assert (D(q, i).killable_index == q) DCNL DCSP assert (D(q, v).preferred_index == v) DCNL DCSP assert (D(q, v).killable_index == q) DCNL DCSP assert (D(q, p).preferred_index == p) DCNL DCSP assert (D(q, p).killable_index == q) DCNL DCSP EV = evaluate_deltas DCNL DCSP assert (EV((D(a, q) * F(q))) == F(a)) DCNL DCSP assert (EV((D(i, q) * F(q))) == F(i)) DCNL DCSP assert (EV((D(a, q) * F(a))) == (D(a, q) * F(a))) DCNL DCSP assert (EV((D(i, q) * F(i))) == (D(i, q) * F(i))) DCNL DCSP assert (EV((D(a, b) * F(a))) == F(b)) DCNL DCSP assert (EV((D(a, b) * F(b))) == F(a)) DCNL DCSP assert (EV((D(i, j) * F(i))) == F(j)) DCNL DCSP assert (EV((D(i, j) * F(j))) == F(i)) DCNL DCSP assert (EV((D(p, q) * F(q))) == F(p)) DCNL DCSP assert (EV((D(p, q) * F(p))) == F(q)) DCNL DCSP assert (EV(((D(p, j) * D(p, i)) * F(i))) == F(j)) DCNL DCSP assert (EV(((D(p, j) * D(p, i)) * F(j))) == F(i)) DCNL DCSP assert ((EV((D(p, q) * D(p, i))) * F(i)) == (D(q, i) * F(i)))\n", "intent": "secondquant-specific methods .\n", "question_id": 1405}, {"snippet": "def overrides_a_method(class_node, name): DCNL  DCSP for ancestor in class_node.ancestors(): DCNL DCSP  DCSP if ((name in ancestor) and isinstance(ancestor[name], astroid.Function)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "return true if <name> is a method overridden from an ancestor .\n", "question_id": 1406}, {"snippet": "def decrypt_bigfile(infile, outfile, priv_key): DCNL  DCSP if (not isinstance(priv_key, key.PrivateKey)): DCNL DCSP  DCSP raise TypeError(('Private DCSP key DCSP required, DCSP but DCSP got DCSP %r' % priv_key)) DCNL DCSP for block in varblock.yield_varblocks(infile): DCNL DCSP  DCSP cleartext = pkcs1.decrypt(block, priv_key) DCNL DCSP  DCSP outfile.write(cleartext)\n", "intent": "decrypts an encrypted varblock file .\n", "question_id": 1407}, {"snippet": "def askcolor(color=None, **options): DCNL  DCSP global _chooser DCNL DCSP if (not _chooser): DCNL DCSP  DCSP _chooser = apply(Chooser, (), options) DCNL DCSP return _chooser.show(color, options)\n", "intent": "ask for a color .\n", "question_id": 1408}, {"snippet": "def test_ncr_wrong_nn_obj(): DCNL  DCSP nn = 'rnd' DCNL DCSP ncr = NeighbourhoodCleaningRule(return_indices=True, random_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, ncr.fit_sample, X, Y)\n", "intent": "test either if an error is raised with wrong nn object .\n", "question_id": 1409}, {"snippet": "def listen_tcp(portrange, host, factory): DCNL  DCSP assert (len(portrange) <= 2), ('invalid DCSP portrange: DCSP %s' % portrange) DCNL DCSP if (not hasattr(portrange, '__iter__')): DCNL DCSP  DCSP return reactor.listenTCP(portrange, factory, interface=host) DCNL DCSP if (not portrange): DCNL DCSP  DCSP return reactor.listenTCP(0, factory, interface=host) DCNL DCSP if (len(portrange) == 1): DCNL DCSP  DCSP return reactor.listenTCP(portrange[0], factory, interface=host) DCNL DCSP for x in range(portrange[0], (portrange[1] + 1)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return reactor.listenTCP(x, factory, interface=host) DCNL DCSP  DCSP except error.CannotListenError: DCNL DCSP  DCSP  DCSP if (x == portrange[1]): DCNL DCSP  DCSP  DCSP  DCSP raise\n", "intent": "like reactor .\n", "question_id": 1410}, {"snippet": "def _warn_if_activetcl_or_teapot_installed(tcl_root, tcltree): DCNL  DCSP from PyInstaller.lib.macholib import util DCNL DCSP if util.in_system_path(tcl_root): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP init_resource = [r[1] for r in tcltree if r[1].endswith('init.tcl')][0] DCNL DCSP except IndexError: DCNL DCSP  DCSP return DCNL DCSP mentions_activetcl = False DCNL DCSP mentions_teapot = False DCNL DCSP with open(init_resource, 'r') as init_file: DCNL DCSP  DCSP for line in init_file.readlines(): DCNL DCSP  DCSP  DCSP line = line.strip().lower() DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ('activetcl' in line): DCNL DCSP  DCSP  DCSP  DCSP mentions_activetcl = True DCNL DCSP  DCSP  DCSP if ('teapot' in line): DCNL DCSP  DCSP  DCSP  DCSP mentions_teapot = True DCNL DCSP  DCSP  DCSP if (mentions_activetcl and mentions_teapot): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (mentions_activetcl and mentions_teapot): DCNL DCSP  DCSP logger.warning(('\\nYou DCSP appear DCSP to DCSP be DCSP using DCSP an DCSP ActiveTcl DCSP build DCSP of DCSP Tcl/Tk, DCSP which DCSP PyInstaller DCSP has\\ndifficulty DCSP freezing. DCSP To DCSP fix DCSP this, DCSP comment DCSP out DCSP all DCSP references DCSP to DCSP \"teapot\" DCSP in:\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP %s\\n\\nSee DCSP https://github.com/pyinstaller/pyinstaller/issues/621 DCSP for DCSP more DCSP information.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % init_resource))\n", "intent": "if the current tcl installation is a teapot-distributed version of activetcl *and* the current platform is os x .\n", "question_id": 1411}, {"snippet": "def _dpower(xc, xe, yc, ye, p): DCNL  DCSP b = (len(str(abs(yc))) + ye) DCNL DCSP lxc = _dlog(xc, xe, ((p + b) + 1)) DCNL DCSP shift = (ye - b) DCNL DCSP if (shift >= 0): DCNL DCSP  DCSP pc = ((lxc * yc) * (10 ** shift)) DCNL DCSP else: DCNL DCSP  DCSP pc = _div_nearest((lxc * yc), (10 ** (- shift))) DCNL DCSP if (pc == 0): DCNL DCSP  DCSP if (((len(str(xc)) + xe) >= 1) == (yc > 0)): DCNL DCSP  DCSP  DCSP (coeff, exp) = (((10 ** (p - 1)) + 1), (1 - p)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (coeff, exp) = (((10 ** p) - 1), (- p)) DCNL DCSP else: DCNL DCSP  DCSP (coeff, exp) = _dexp(pc, (- (p + 1)), (p + 1)) DCNL DCSP  DCSP coeff = _div_nearest(coeff, 10) DCNL DCSP  DCSP exp += 1 DCNL DCSP return (coeff, exp)\n", "intent": "given integers xc .\n", "question_id": 1412}, {"snippet": "def elemwise_checker(op, expected_f, gap=None, test_dtypes=None, grad_test=True, name=None, gap_grad=None): DCNL  DCSP if (test_dtypes is None): DCNL DCSP  DCSP test_dtypes = sparse.all_dtypes DCNL DCSP class Tester(unittest.TestCase, ): DCNL DCSP  DCSP def setUp(self): DCNL DCSP  DCSP  DCSP super(Tester, self).setUp() DCNL DCSP  DCSP  DCSP self.op = op DCNL DCSP  DCSP  DCSP self.expected_f = expected_f DCNL DCSP  DCSP  DCSP self.gap = gap DCNL DCSP  DCSP  DCSP if (gap_grad is not None): DCNL DCSP  DCSP  DCSP  DCSP self.gap_grad = gap_grad DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.gap_grad = gap DCNL DCSP  DCSP  DCSP utt.seed_rng() DCNL DCSP  DCSP  DCSP assert (eval(self.__class__.__name__) is self.__class__) DCNL DCSP  DCSP def test_op(self): DCNL DCSP  DCSP  DCSP for format in sparse.sparse_formats: DCNL DCSP  DCSP  DCSP  DCSP for dtype in test_dtypes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((dtype == 'int8') or (dtype == 'uint8')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP if dtype.startswith('uint'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (self.gap and (len(self.gap) == 2) and (self.gap[0] < 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (self.gap[1] >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.gap = (0, self.gap[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('Gap DCSP not DCSP suitable DCSP for', dtype, self.__name__) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (variable, data) = sparse_random_inputs(format, shape=(4, 7), out_dtype=dtype, gap=self.gap) DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = theano.function(variable, self.op(*variable)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP tested = f(*data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = [m.toarray() for m in data] DCNL DCSP  DCSP  DCSP  DCSP  DCSP expected = self.expected_f(*data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (tested.format == format) DCNL DCSP  DCSP  DCSP  DCSP  DCSP tested = tested.toarray() DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP utt.assert_allclose(expected, tested) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AssertionError(self.__name__) DCNL DCSP  DCSP  DCSP  DCSP for dtype in ['int8', 'uint8']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (dtype in test_dtypes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if self.gap: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP domain = self.gap DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (dtype == 'uint8'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((len(domain) == 2) and (domain[0] < 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (domain[1] >= 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP domain = (0, domain[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('Gap DCSP not DCSP suitable DCSP for', dtype, self.__name__) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP domain = (0, 5) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (variable, data) = sparse_random_inputs(format, shape=(4, 7), out_dtype=dtype, gap=domain) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = theano.function(variable, self.op(*variable)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP old_value = (tensor.basic.float32_atol, tensor.basic.float32_rtol, tensor.basic.float64_atol, tensor.basic.float64_rtol) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tensor.basic.float32_atol = 0.0001 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tensor.basic.float32_rtol = 0.001 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tensor.basic.float64_atol = 0.001 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tensor.basic.float64_rtol = 0.0001 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tested = f(*data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (tensor.basic.float32_atol, tensor.basic.float32_rtol, tensor.basic.float64_atol, tensor.basic.float64_rtol) = old_value DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP data = [m.toarray().astype('float32') for m in data] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP expected = self.expected_f(*data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (tested.format == format) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tested = tested.toarray() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP utt.assert_allclose(tested, expected, rtol=0.01) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise AssertionError(self.__name__) DCNL DCSP  DCSP if grad_test: DCNL DCSP  DCSP  DCSP def test_grad(self): DCNL DCSP  DCSP  DCSP  DCSP for format in sparse.sparse_formats: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for dtype in sparse.float_dtypes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (variable, data) = sparse_random_inputs(format, shape=(4, 7), out_dtype=dtype, gap=self.gap_grad) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP verify_grad_sparse(self.op, data, structured=True) DCNL DCSP if (name is None): DCNL DCSP  DCSP name = (op.__name__.capitalize() + 'Tester') DCNL DCSP Tester.__name__ = name DCNL DCSP if hasattr(Tester, '__qualname__'): DCNL DCSP  DCSP Tester.__qualname__ = name DCNL DCSP assert ('Roundhalftoeven' not in Tester.__name__) DCNL DCSP return Tester\n", "intent": "return the appropriate test class for the elemwise on sparse .\n", "question_id": 1413}, {"snippet": "def general(): DCNL  DCSP return {'username': ['', 'admin', 'administrator'], 'password': ['', 'admin', 'administrator', 'password', '1234']}\n", "intent": "standard username/password combinations that could be applicable to any device .\n", "question_id": 1414}, {"snippet": "def trim_docstring(docstring): DCNL  DCSP if ((not docstring) or (not docstring.strip())): DCNL DCSP  DCSP return '' DCNL DCSP lines = docstring.expandtabs().splitlines() DCNL DCSP indent = min([(len(line) - len(line.lstrip())) for line in lines if line.lstrip()]) DCNL DCSP trimmed = ([lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]) DCNL DCSP return '\\n'.join(trimmed).strip()\n", "intent": "uniformly trims leading/trailing whitespace from docstrings .\n", "question_id": 1415}, {"snippet": "def runExperiment(args, model=None): DCNL  DCSP opt = _parseCommandLineOptions(args) DCNL DCSP model = _runExperimentImpl(opt, model) DCNL DCSP return model\n", "intent": "run a single opf experiment note: the caller is resposible for initializing python logging before calling this function (e .\n", "question_id": 1416}, {"snippet": "def describe_alias(FunctionName, Name, region=None, key=None, keyid=None, profile=None): DCNL  DCSP try: DCNL DCSP  DCSP alias = _find_alias(FunctionName, Name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP if alias: DCNL DCSP  DCSP  DCSP keys = ('AliasArn', 'Name', 'FunctionVersion', 'Description') DCNL DCSP  DCSP  DCSP return {'alias': dict([(k, alias.get(k)) for k in keys])} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'alias': None} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}\n", "intent": "given a function name and alias name describe the properties of the alias .\n", "question_id": 1417}, {"snippet": "def get_exe_prefixes(exe_filename): DCNL  DCSP prefixes = [('PURELIB/', ''), ('PLATLIB/pywin32_system32', ''), ('PLATLIB/', ''), ('SCRIPTS/', 'EGG-INFO/scripts/')] DCNL DCSP z = zipfile.ZipFile(exe_filename) DCNL DCSP try: DCNL DCSP  DCSP for info in z.infolist(): DCNL DCSP  DCSP  DCSP name = info.filename DCNL DCSP  DCSP  DCSP parts = name.split('/') DCNL DCSP  DCSP  DCSP if ((len(parts) == 3) and (parts[2] == 'PKG-INFO')): DCNL DCSP  DCSP  DCSP  DCSP if parts[1].endswith('.egg-info'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prefixes.insert(0, ('/'.join(parts[:2]), 'EGG-INFO/')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((len(parts) != 2) or (not name.endswith('.pth'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if name.endswith('-nspkg.pth'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (parts[0].upper() in ('PURELIB', 'PLATLIB')): DCNL DCSP  DCSP  DCSP  DCSP for pth in yield_lines(z.read(name)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pth = pth.strip().replace('\\\\', '/') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not pth.startswith('import')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prefixes.append((('%s/%s/' % (parts[0], pth)), '')) DCNL DCSP finally: DCNL DCSP  DCSP z.close() DCNL DCSP prefixes = [(x.lower(), y) for (x, y) in prefixes] DCNL DCSP prefixes.sort() DCNL DCSP prefixes.reverse() DCNL DCSP return prefixes\n", "intent": "get exe->egg path translations for a given .\n", "question_id": 1418}, {"snippet": "@pytest.fixture(scope='module', params=VC_BRANCH.keys()) DCNL def test_repo(request): DCNL  DCSP vc = request.param DCNL DCSP temp_dir = tempfile.mkdtemp() DCNL DCSP os.chdir(temp_dir) DCNL DCSP try: DCNL DCSP  DCSP sp.call([vc, 'init']) DCNL DCSP except FileNotFoundError: DCNL DCSP  DCSP pytest.skip('cannot DCSP find DCSP {} DCSP executable'.format(vc)) DCNL DCSP if (vc == 'git'): DCNL DCSP  DCSP with open('test-file', 'w'): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP sp.call(['git', 'add', 'test-file']) DCNL DCSP  DCSP sp.call(['git', 'commit', '-m', 'test DCSP commit']) DCNL DCSP return {'name': vc, 'dir': temp_dir}\n", "intent": "return a dict with vc and a temporary dir that is a repository for testing .\n", "question_id": 1419}, {"snippet": "def parse_stats(conf, json): DCNL  DCSP 'Ignore DCSP stats DCSP if DCSP coming DCSP from DCSP non-leading DCSP mesos DCSP master' DCNL DCSP elected_result = lookup_stat('master/elected', json, conf) DCNL DCSP if (elected_result == 1): DCNL DCSP  DCSP for (name, key) in get_stats_string(conf['version']).iteritems(): DCNL DCSP  DCSP  DCSP result = lookup_stat(name, json, conf) DCNL DCSP  DCSP  DCSP dispatch_stat(result, name, key, conf) DCNL DCSP else: DCNL DCSP  DCSP log_verbose(conf['verboseLogging'], 'This DCSP mesos DCSP master DCSP node DCSP is DCSP not DCSP elected DCSP leader DCSP so DCSP not DCSP writing DCSP data.') DCNL DCSP  DCSP return None\n", "intent": "parse stats response from mesos .\n", "question_id": 1420}, {"snippet": "def _get_iface_info(iface): DCNL  DCSP iface_info = interfaces() DCNL DCSP if (iface in iface_info.keys()): DCNL DCSP  DCSP return (iface_info, False) DCNL DCSP else: DCNL DCSP  DCSP error_msg = 'Interface DCSP \"{0}\" DCSP not DCSP in DCSP available DCSP interfaces: DCSP \"{1}\"'.format(iface, '\", DCSP \"'.join(iface_info.keys())) DCNL DCSP  DCSP log.error(error_msg) DCNL DCSP  DCSP return (None, error_msg)\n", "intent": "if iface is available .\n", "question_id": 1421}, {"snippet": "def set_scm(scm): DCNL  DCSP if (scm is not None): DCNL DCSP  DCSP if (not isinstance(scm, Scm)): DCNL DCSP  DCSP  DCSP raise ValueError(u'The DCSP scm DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP Scm, DCSP given DCSP {}'.format(scm)) DCNL DCSP  DCSP global _SCM DCNL DCSP  DCSP _SCM = scm\n", "intent": "sets the pants scm .\n", "question_id": 1422}, {"snippet": "def stop_after(space_number): DCNL  DCSP def _outer_wrapper(wrapped_function): DCNL DCSP  DCSP @wraps(wrapped_function) DCNL DCSP  DCSP def _wrapper(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (args[1].count(' DCSP ') == space_number): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP  DCSP print_info(err) DCNL DCSP  DCSP  DCSP return wrapped_function(self, *args, **kwargs) DCNL DCSP  DCSP return _wrapper DCNL DCSP return _outer_wrapper\n", "intent": "decorator that determine when to stop tab-completion decorator that tells command specific complete function  when to stop tab-completion .\n", "question_id": 1423}, {"snippet": "def nowdate(): DCNL  DCSP return now_datetime().strftime(DATE_FORMAT)\n", "intent": "return current date as yyyy-mm-dd .\n", "question_id": 1424}, {"snippet": "@Throttle(MIN_TIME_BETWEEN_UPDATES) DCNL def send_data(name, msg): DCNL  DCSP import dweepy DCNL DCSP try: DCNL DCSP  DCSP dweepy.dweet_for(name, msg) DCNL DCSP except dweepy.DweepyError: DCNL DCSP  DCSP _LOGGER.error(\"Error DCSP saving DCSP data DCSP '%s' DCSP to DCSP Dweet.io\", msg)\n", "intent": "send the collected data to dweet .\n", "question_id": 1425}, {"snippet": "def format_timedelta(datetime_or_timedelta, granularity='second', threshold=0.85): DCNL  DCSP return get_i18n().format_timedelta(datetime_or_timedelta, granularity, threshold)\n", "intent": "see :meth:i18n .\n", "question_id": 1426}, {"snippet": "def clean_up(): DCNL  DCSP for filename in ['test_file', 'Phylip/opuntia.phy', 'Phylip/hedgehog.phy']: DCNL DCSP  DCSP if os.path.isfile(filename): DCNL DCSP  DCSP  DCSP os.remove(filename)\n", "intent": "delete tests files (to be used as teardown() function in test fixtures) .\n", "question_id": 1427}, {"snippet": "def standardize_patterns(column_names, patterns): DCNL  DCSP try: DCNL DCSP  DCSP patterns = dict(((k, pattern_as_function(v)) for (k, v) in patterns.items() if v)) DCNL DCSP  DCSP if (not column_names): DCNL DCSP  DCSP  DCSP return patterns DCNL DCSP  DCSP p2 = {} DCNL DCSP  DCSP for k in patterns: DCNL DCSP  DCSP  DCSP if (k in column_names): DCNL DCSP  DCSP  DCSP  DCSP idx = column_names.index(k) DCNL DCSP  DCSP  DCSP  DCSP if (idx in patterns): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ColumnIdentifierError(('Column DCSP %s DCSP has DCSP index DCSP %i DCSP which DCSP already DCSP has DCSP a DCSP pattern.' % (k, idx))) DCNL DCSP  DCSP  DCSP  DCSP p2[idx] = patterns[k] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP p2[k] = patterns[k] DCNL DCSP  DCSP return p2 DCNL DCSP except AttributeError: DCNL DCSP  DCSP return dict(((i, pattern_as_function(x)) for (i, x) in enumerate(patterns)))\n", "intent": "given patterns in any of the permitted input forms .\n", "question_id": 1428}, {"snippet": "def login(request, user): DCNL  DCSP if (user is None): DCNL DCSP  DCSP user = request.user DCNL DCSP if (SESSION_KEY in request.session): DCNL DCSP  DCSP if (request.session[SESSION_KEY] != user.id): DCNL DCSP  DCSP  DCSP request.session.flush() DCNL DCSP else: DCNL DCSP  DCSP request.session.cycle_key() DCNL DCSP request.session[SESSION_KEY] = user.id DCNL DCSP request.session[BACKEND_SESSION_KEY] = user.backend DCNL DCSP if hasattr(request, 'user'): DCNL DCSP  DCSP request.user = user DCNL DCSP user_logged_in.send(sender=user.__class__, request=request, user=user)\n", "intent": "persist a user id and a backend in the request .\n", "question_id": 1429}, {"snippet": "def on_plugin_start(config): DCNL  DCSP pass\n", "intent": "called once after plugin is loaded .\n", "question_id": 1430}, {"snippet": "def to_json(journal): DCNL  DCSP tags = get_tags_count(journal) DCNL DCSP result = {u'tags': dict(((tag, count) for (count, tag) in tags)), u'entries': [e.to_dict() for e in journal.entries]} DCNL DCSP return json.dumps(result, indent=2)\n", "intent": "returns a json representation of the journal .\n", "question_id": 1431}, {"snippet": "@declared DCNL def get_object(ref): DCNL  DCSP if (not isinstance(ref, basestring)): DCNL DCSP  DCSP return ref DCNL DCSP name = ref DCNL DCSP if ('/' not in name): DCNL DCSP  DCSP return objs['hosts'].find_by_name(name) DCNL DCSP else: DCNL DCSP  DCSP elts = name.split('/', 1) DCNL DCSP  DCSP return objs['services'].find_srv_by_name_and_hostname(elts[0], elts[1])\n", "intent": "retrive object  from name .\n", "question_id": 1432}, {"snippet": "def textinfo_from_filename(path): DCNL  DCSP return TextInfo.init_from_filename(path)\n", "intent": "determine test info for the given path **using the filename only** .\n", "question_id": 1433}, {"snippet": "def _delete(context, namespace_name, resource_type_name, namespace_id, resource_type_id, session): DCNL  DCSP db_rec = _get(context, namespace_name, resource_type_name, namespace_id, resource_type_id, session) DCNL DCSP session.delete(db_rec) DCNL DCSP session.flush() DCNL DCSP return db_rec.to_dict()\n", "intent": "delete a resource type association or raise if not found .\n", "question_id": 1434}, {"snippet": "def tax_subtract(price, tax_percentage=21): DCNL  DCSP if (price is None): DCNL DCSP  DCSP return None DCNL DCSP result = (price / ((100 + tax_percentage) / D(100))) DCNL DCSP return result.quantize(D('0.01'), ROUND_HALF_UP)\n", "intent": "subtract the given tax_percentage from the given price .\n", "question_id": 1435}, {"snippet": "def _copy_r_to_cat(r, cat): DCNL  DCSP for key in r._attributes: DCNL DCSP  DCSP new_key = (u'validate_' + key) DCNL DCSP  DCSP cat[new_key] = r._attributes[key]\n", "intent": "copy validation result attributes to given vo catalog .\n", "question_id": 1436}, {"snippet": "def _cook_occurrences(period, occs, width, height): DCNL  DCSP last = {} DCNL DCSP for o in occs: DCNL DCSP  DCSP o.data = period.classify_occurrence(o) DCNL DCSP  DCSP if (not o.data): DCNL DCSP  DCSP  DCSP occs.remove(o) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP o.level = (-1) DCNL DCSP  DCSP o.max = 0 DCNL DCSP  DCSP if (not last): DCNL DCSP  DCSP  DCSP last[0] = o DCNL DCSP  DCSP  DCSP o.level = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for k in sorted(last.keys()): DCNL DCSP  DCSP  DCSP  DCSP if (last[k].end <= o.start): DCNL DCSP  DCSP  DCSP  DCSP  DCSP o.level = k DCNL DCSP  DCSP  DCSP  DCSP  DCSP last[k] = o DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (o.level == (-1)): DCNL DCSP  DCSP  DCSP  DCSP k = (k + 1) DCNL DCSP  DCSP  DCSP  DCSP last[k] = o DCNL DCSP  DCSP  DCSP  DCSP o.level = k DCNL DCSP for o in occs: DCNL DCSP  DCSP o.max = len([n for n in occs if (not ((n.end <= o.start) or (n.start >= o.end)))]) DCNL DCSP for o in occs: DCNL DCSP  DCSP o.cls = o.data['class'] DCNL DCSP  DCSP o.real_start = max(o.start, period.start) DCNL DCSP  DCSP o.real_end = min(o.end, period.end) DCNL DCSP  DCSP o.max = min(([n.max for n in occs if (not ((n.end <= o.start) or (n.start >= o.end)))] or [1])) DCNL DCSP  DCSP w = int((width / o.max)) DCNL DCSP  DCSP o.width = (w - 2) DCNL DCSP  DCSP o.left = (w * o.level) DCNL DCSP  DCSP o.top = int((height * (float((o.real_start - period.start).seconds) / (period.end - period.start).seconds))) DCNL DCSP  DCSP o.height = int((height * (float((o.real_end - o.real_start).seconds) / (period.end - period.start).seconds))) DCNL DCSP  DCSP o.height = min(o.height, (height - o.top)) DCNL DCSP return occs\n", "intent": "prepare occurrences to be displayed .\n", "question_id": 1437}, {"snippet": "def randomish_uid(): DCNL  DCSP with RID_COUNTER_LOCK: DCNL DCSP  DCSP global RID_COUNTER DCNL DCSP  DCSP RID_COUNTER += 1 DCNL DCSP  DCSP RID_COUNTER %= 4096 DCNL DCSP  DCSP return ('%3.3x%7.7x%x' % (random.randint(0, 4095), (time.time() // 16), RID_COUNTER))\n", "intent": "generate a weakly random unique id .\n", "question_id": 1438}, {"snippet": "def save_graph(graphdef, mestate): DCNL  DCSP if (graphdef.filename is None): DCNL DCSP  DCSP if ('HOME' in os.environ): DCNL DCSP  DCSP  DCSP dname = os.path.join(os.environ['HOME'], '.mavproxy') DCNL DCSP  DCSP  DCSP if os.path.exists(dname): DCNL DCSP  DCSP  DCSP  DCSP mp_util.mkdir_p(dname) DCNL DCSP  DCSP  DCSP  DCSP graphdef.filename = os.path.join(dname, 'mavgraphs.xml') DCNL DCSP  DCSP elif ('LOCALAPPDATA' in os.environ): DCNL DCSP  DCSP  DCSP dname = os.path.join(os.environ['LOCALAPPDATA'], 'MAVProxy') DCNL DCSP  DCSP  DCSP if os.path.exists(dname): DCNL DCSP  DCSP  DCSP  DCSP mp_util.mkdir_p(dname) DCNL DCSP  DCSP  DCSP  DCSP graphdef.filename = os.path.join(dname, 'mavgraphs.xml') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP graphdef.filename = 'mavgraphs.xml' DCNL DCSP if (graphdef.filename is None): DCNL DCSP  DCSP mestate.console.writeln('No DCSP file DCSP to DCSP save DCSP graph DCSP to', fg='red') DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP graphs = load_graph_xml(open(graphdef.filename).read(), graphdef.filename, load_all=True) DCNL DCSP except Exception: DCNL DCSP  DCSP graphs = [] DCNL DCSP found_name = False DCNL DCSP for i in range(len(graphs)): DCNL DCSP  DCSP if (graphs[i].name == graphdef.name): DCNL DCSP  DCSP  DCSP graphs[i] = graphdef DCNL DCSP  DCSP  DCSP found_name = True DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not found_name): DCNL DCSP  DCSP graphs.append(graphdef) DCNL DCSP mestate.console.writeln(('Saving DCSP %u DCSP graphs DCSP to DCSP %s' % (len(graphs), graphdef.filename))) DCNL DCSP f = open(graphdef.filename, 'w') DCNL DCSP f.write('<graphs>\\n\\n') DCNL DCSP for g in graphs: DCNL DCSP  DCSP f.write((\" DCSP <graph DCSP name='%s'>\\n\" % g.name.strip())) DCNL DCSP  DCSP if (g.description is None): DCNL DCSP  DCSP  DCSP g.description = '' DCNL DCSP  DCSP f.write((' DCSP  DCSP <description>%s</description>\\n' % g.description.strip())) DCNL DCSP  DCSP for e in g.expressions: DCNL DCSP  DCSP  DCSP f.write((' DCSP  DCSP <expression>%s</expression>\\n' % e.strip())) DCNL DCSP  DCSP f.write(' DCSP </graph>\\n\\n') DCNL DCSP f.write('</graphs>\\n') DCNL DCSP f.close()\n", "intent": "save a graph as xml .\n", "question_id": 1439}, {"snippet": "@register.filter DCNL def label_tag(field, suffix=None): DCNL  DCSP if (not hasattr(field, 'label_tag')): DCNL DCSP  DCSP return '' DCNL DCSP return field.label_tag(label_suffix=suffix)\n", "intent": "returns the label_tag for a field .\n", "question_id": 1440}, {"snippet": "def resolve_unhydrated_struct(address_family, address): DCNL  DCSP struct = address_family.addressables.get(address) DCNL DCSP if (not struct): DCNL DCSP  DCSP _raise_did_you_mean(address_family, address.target_name) DCNL DCSP dependencies = [] DCNL DCSP def maybe_append(outer_key, value): DCNL DCSP  DCSP if isinstance(value, six.string_types): DCNL DCSP  DCSP  DCSP if (outer_key != u'dependencies'): DCNL DCSP  DCSP  DCSP  DCSP dependencies.append(Address.parse(value, relative_to=address.spec_path)) DCNL DCSP  DCSP elif isinstance(value, Struct): DCNL DCSP  DCSP  DCSP collect_dependencies(value) DCNL DCSP def collect_dependencies(item): DCNL DCSP  DCSP for (key, value) in sorted(item._asdict().items(), key=_key_func): DCNL DCSP  DCSP  DCSP if (not AddressableDescriptor.is_addressable(item, key)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if isinstance(value, collections.MutableMapping): DCNL DCSP  DCSP  DCSP  DCSP for (_, v) in sorted(value.items(), key=_key_func): DCNL DCSP  DCSP  DCSP  DCSP  DCSP maybe_append(key, v) DCNL DCSP  DCSP  DCSP elif isinstance(value, collections.MutableSequence): DCNL DCSP  DCSP  DCSP  DCSP for v in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP maybe_append(key, v) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP maybe_append(key, value) DCNL DCSP collect_dependencies(struct) DCNL DCSP return UnhydratedStruct(address, struct, dependencies)\n", "intent": "given an address and its addressfamily .\n", "question_id": 1441}, {"snippet": "def _fit_slices(clf, x_chunk, y, slices, cv_splits): DCNL  DCSP from sklearn.base import clone DCNL DCSP n_epochs = len(x_chunk) DCNL DCSP estimators = list() DCNL DCSP values = np.unique([val for sl in slices for val in sl]) DCNL DCSP for t_slice in slices: DCNL DCSP  DCSP t_slice = np.array([np.where((ii == values))[0][0] for ii in t_slice]) DCNL DCSP  DCSP X = x_chunk[..., t_slice] DCNL DCSP  DCSP X = X.reshape(n_epochs, np.prod(X.shape[1:])) DCNL DCSP  DCSP estimators_ = list() DCNL DCSP  DCSP for (fold, (train, test)) in enumerate(cv_splits): DCNL DCSP  DCSP  DCSP clf_ = clone(clf) DCNL DCSP  DCSP  DCSP clf_.fit(X[train, :], y[train]) DCNL DCSP  DCSP  DCSP estimators_.append(clf_) DCNL DCSP  DCSP estimators.append(estimators_) DCNL DCSP return estimators\n", "intent": "aux function of generalizationacrosstime .\n", "question_id": 1442}, {"snippet": "def _init_atexit(): DCNL  DCSP import atexit DCNL DCSP import thread DCNL DCSP atexit.register(thread.do_terminate_threads)\n", "intent": "setup an at-exit job to be sure our workers are shutdown correctly before the interpreter quits .\n", "question_id": 1443}, {"snippet": "def extract_option_object(option): DCNL  DCSP @option DCNL DCSP def opt(): DCNL DCSP  DCSP pass DCNL DCSP return opt.__click_params__[0]\n", "intent": "convert a click .\n", "question_id": 1444}, {"snippet": "def parse_header_links(value): DCNL  DCSP links = [] DCNL DCSP replace_chars = ' DCSP \\'\"' DCNL DCSP for val in value.split(','): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (url, params) = val.split(';', 1) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP (url, params) = (val, '') DCNL DCSP  DCSP link = {} DCNL DCSP  DCSP link['url'] = url.strip('<> DCSP \\'\"') DCNL DCSP  DCSP for param in params.split(';'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (key, value) = param.split('=') DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP link[key.strip(replace_chars)] = value.strip(replace_chars) DCNL DCSP  DCSP links.append(link) DCNL DCSP return links\n", "intent": "return a dict of parsed link headers proxies .\n", "question_id": 1445}, {"snippet": "def local_elemwise_fusion_op(OP, max_input_fct=(lambda node: 32), maker=None): DCNL  DCSP if (maker is None): DCNL DCSP  DCSP def maker(node, scalar_op): DCNL DCSP  DCSP  DCSP return OP(scalar_op) DCNL DCSP def local_fuse(node): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP As DCSP part DCSP of DCSP specialization, DCSP we DCSP fuse DCSP two DCSP consecutive DCSP elemwise DCSP Ops DCSP of DCSP the\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP same DCSP shape.\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP For DCSP mixed DCSP dtype, DCSP we DCSP let DCSP the DCSP Composite DCSP op DCSP do DCSP the DCSP cast. DCSP It DCSP lets DCSP the DCSP C\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP compiler DCSP do DCSP the DCSP cast.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP number DCSP of DCSP dimensions DCSP is DCSP validated DCSP at DCSP call DCSP time DCSP by DCSP theano DCSP itself.\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (type(node.op) is not OP): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (len(node.outputs) > 1): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP inputs = [] DCNL DCSP  DCSP s_inputs = [] DCNL DCSP  DCSP s_g = [] DCNL DCSP  DCSP max_nb_input = max_input_fct(node) DCNL DCSP  DCSP new_nb_input = len(node.inputs) DCNL DCSP  DCSP fused = False DCNL DCSP  DCSP for i in node.inputs: DCNL DCSP  DCSP  DCSP do_fusion = False DCNL DCSP  DCSP  DCSP catch = False DCNL DCSP  DCSP  DCSP tmp_input = [] DCNL DCSP  DCSP  DCSP tmp_scalar = [] DCNL DCSP  DCSP  DCSP if (i.owner and isinstance(i.owner.op, OP) and (len(set([n for (n, idx) in i.clients])) == 1) and (i.owner.outputs[0].broadcastable == node.outputs[0].broadcastable)): DCNL DCSP  DCSP  DCSP  DCSP do_fusion = True DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tmp_s_input = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for ii in i.owner.inputs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ii in inputs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp_s_input.append(s_inputs[inputs.index(ii)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (ii in tmp_input): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp_s_input.append(tmp_scalar[tmp_input.index(ii)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp = scalar.get_scalar_type(ii.dtype).make_variable() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tv = gof.op.get_test_value(ii) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (tv.size > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp.tag.test_value = tv.flatten()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp.tag.test_value = tv DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp_s_input.append(tmp) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp_input.append(ii) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tmp_scalar.append(tmp_s_input[(-1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP s_op = i.owner.op.scalar_op(return_list=True, *tmp_s_input) DCNL DCSP  DCSP  DCSP  DCSP  DCSP i.owner.op.scalar_op.c_code(s_op[0].owner, 'test_presence_of_c_code', ['x' for x in i.owner.inputs], ['z' for z in i.owner.outputs], {}) DCNL DCSP  DCSP  DCSP  DCSP except MethodNotDefined: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catch = True DCNL DCSP  DCSP  DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catch = True DCNL DCSP  DCSP  DCSP  DCSP if catch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _logger.info(('%s DCSP does DCSP not DCSP implement DCSP the DCSP c_code DCSP function. DCSP As DCSP well DCSP as DCSP being DCSP potentially DCSP slow, DCSP this DCSP disables DCSP loop DCSP fusion DCSP of DCSP this DCSP op.' % str(i.owner.op.scalar_op))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP do_fusion = False DCNL DCSP  DCSP  DCSP new_nb_input_ = ((new_nb_input + len(tmp_input)) - 1) DCNL DCSP  DCSP  DCSP for x in tmp_input: DCNL DCSP  DCSP  DCSP  DCSP if (x in node.inputs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_nb_input_ -= 1 DCNL DCSP  DCSP  DCSP if (do_fusion and (new_nb_input_ <= max_nb_input)): DCNL DCSP  DCSP  DCSP  DCSP fused = True DCNL DCSP  DCSP  DCSP  DCSP new_nb_input = new_nb_input_ DCNL DCSP  DCSP  DCSP  DCSP inputs.extend(tmp_input) DCNL DCSP  DCSP  DCSP  DCSP s_inputs.extend(tmp_scalar) DCNL DCSP  DCSP  DCSP  DCSP s_g.extend(s_op) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (inputs.count(i) == node.inputs.count(i)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s = s_inputs[inputs.index(i)] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s = scalar.get_scalar_type(i.dtype).make_variable() DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (theano.config.compute_test_value != 'off'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP v = gof.op.get_test_value(i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (v.size > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s.tag.test_value = v.flatten()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP inputs.append(i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP s_inputs.append(s) DCNL DCSP  DCSP  DCSP  DCSP s_g.append(s) DCNL DCSP  DCSP if (not fused): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if ((new_nb_input != len(inputs)) or (len(s_inputs) != len(inputs))): DCNL DCSP  DCSP  DCSP raise Exception('Something DCSP has DCSP gone DCSP wrong DCSP with DCSP the DCSP elemwise\\nfusion DCSP optimization. DCSP We DCSP skip DCSP this DCSP optimization. DCSP You DCSP can DCSP ignore DCSP this DCSP message,\\nyour DCSP code DCSP will DCSP run DCSP correctly, DCSP but DCSP may DCSP be DCSP slower.') DCNL DCSP  DCSP s_new_out = node.op.scalar_op(return_list=True, *s_g) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s_new_out[0].owner.op.c_code(s_new_out[0].owner, 'test_presence_of_c_code', ['x' for x in s_g], ['z' for x in s_new_out], {}) DCNL DCSP  DCSP except MethodNotDefined: DCNL DCSP  DCSP  DCSP _logger.info(('%s DCSP does DCSP not DCSP implement DCSP the DCSP c_code DCSP function. DCSP As DCSP well DCSP as DCSP being DCSP potentially DCSP slow, DCSP this DCSP disables DCSP loop DCSP fusion DCSP of DCSP this DCSP op.' % str(s_new_out[0].owner.op))) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP _logger.info(('%s DCSP does DCSP not DCSP implement DCSP the DCSP c_code DCSP function. DCSP As DCSP well DCSP as DCSP being DCSP potentially DCSP slow, DCSP this DCSP disables DCSP loop DCSP fusion DCSP of DCSP this DCSP op.' % str(s_new_out[0].owner.op))) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP C = scalar.Composite(s_inputs, s_new_out) DCNL DCSP  DCSP n = maker(node, C)(*inputs).owner DCNL DCSP  DCSP assert (len(n.outputs) == 1) DCNL DCSP  DCSP assert (node.outputs[0].dtype == n.outputs[0].dtype) DCNL DCSP  DCSP if (len(n.inputs) > max_nb_input): DCNL DCSP  DCSP  DCSP _logger.info('loop DCSP fusion DCSP failed DCSP because DCSP Op DCSP would DCSP exceed DCSP kernel DCSP argument DCSP limit.') DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP ret = local_fuse(n) DCNL DCSP  DCSP  DCSP if ((ret is not False) and (ret is not None)): DCNL DCSP  DCSP  DCSP  DCSP assert (len(ret) == len(n.outputs)) DCNL DCSP  DCSP  DCSP  DCSP assert (len(ret) == 1) DCNL DCSP  DCSP  DCSP  DCSP n = ret[0].owner DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return n.outputs DCNL DCSP return local_fuse\n", "intent": "we parametrize it to make it work for elemwise and gpuelemwise op .\n", "question_id": 1446}, {"snippet": "@pytest.mark.cmd DCNL def test_cmd_contributors_mutually_exclusive(capfd): DCNL  DCSP with pytest.raises(CommandError) as e: DCNL DCSP  DCSP call_command('contributors', '--include-anonymous', '--mailmerge') DCNL DCSP assert ('argument DCSP --mailmerge: DCSP not DCSP allowed DCSP with DCSP argument DCSP --include-anonymous' in str(e)) DCNL DCSP with pytest.raises(CommandError) as e: DCNL DCSP  DCSP call_command('contributors', '--mailmerge', '--include-anonymous') DCNL DCSP assert ('argument DCSP --include-anonymous: DCSP not DCSP allowed DCSP with DCSP argument DCSP --mailmerge' in str(e))\n", "intent": "test mutually exclusive arguments are not accepted .\n", "question_id": 1447}, {"snippet": "def make_digest(app, global_conf, realm, authfunc, **kw): DCNL  DCSP from paste.util.import_string import eval_import DCNL DCSP import types DCNL DCSP authfunc = eval_import(authfunc) DCNL DCSP assert isinstance(authfunc, types.FunctionType), 'authfunc DCSP must DCSP resolve DCSP to DCSP a DCSP function' DCNL DCSP return AuthDigestHandler(app, realm, authfunc)\n", "intent": "grant access via digest authentication config looks like this:: [filter:grant] use = egg:paste#auth_digest realm=myrealm authfunc=somepackage .\n", "question_id": 1448}, {"snippet": "def _process_limits(*symbols): DCNL  DCSP limits = [] DCNL DCSP orientation = 1 DCNL DCSP for V in symbols: DCNL DCSP  DCSP if (isinstance(V, Symbol) or getattr(V, '_diff_wrt', False)): DCNL DCSP  DCSP  DCSP if isinstance(V, Idx): DCNL DCSP  DCSP  DCSP  DCSP if ((V.lower is None) or (V.upper is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP limits.append(Tuple(V)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP limits.append(Tuple(V, V.lower, V.upper)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP limits.append(Tuple(V)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif is_sequence(V, Tuple): DCNL DCSP  DCSP  DCSP V = sympify(flatten(V)) DCNL DCSP  DCSP  DCSP if (isinstance(V[0], (Symbol, Idx)) or getattr(V[0], '_diff_wrt', False)): DCNL DCSP  DCSP  DCSP  DCSP newsymbol = V[0] DCNL DCSP  DCSP  DCSP  DCSP if ((len(V) == 2) and isinstance(V[1], Interval)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP V[1:] = [V[1].start, V[1].end] DCNL DCSP  DCSP  DCSP  DCSP if (len(V) == 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((V[1] is None) and (V[2] is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nlim = [V[2]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ((V[1] is not None) and (V[2] is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP orientation *= (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nlim = [V[1]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ((V[1] is None) and (V[2] is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nlim = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nlim = V[1:] DCNL DCSP  DCSP  DCSP  DCSP  DCSP limits.append(Tuple(newsymbol, *nlim)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(V[0], Idx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((V[0].lower is not None) and (not bool((nlim[0] >= V[0].lower)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Summation DCSP exceeds DCSP Idx DCSP lower DCSP range.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((V[0].upper is not None) and (not bool((nlim[1] <= V[0].upper)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Summation DCSP exceeds DCSP Idx DCSP upper DCSP range.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif ((len(V) == 1) or ((len(V) == 2) and (V[1] is None))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP limits.append(Tuple(newsymbol)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif (len(V) == 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP limits.append(Tuple(newsymbol, V[1])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP raise ValueError(('Invalid DCSP limits DCSP given: DCSP %s' % str(symbols))) DCNL DCSP return (limits, orientation)\n", "intent": "process the list of symbols and convert them to canonical limits .\n", "question_id": 1449}, {"snippet": "def evalsc(command): DCNL  DCSP assert command.startswith('%') DCNL DCSP from spyder.utils import programs DCNL DCSP namespace = _get_globals() DCNL DCSP command = command[1:].strip() DCNL DCSP import re DCNL DCSP clear_match = re.match('^clear DCSP ([a-zA-Z0-9_, DCSP ]+)', command) DCNL DCSP cd_match = re.match('^cd DCSP \\\\\"?\\\\\\'?([a-zA-Z0-9_\\\\ DCSP \\\\:\\\\\\\\\\\\/\\\\.]+)', command) DCNL DCSP if cd_match: DCNL DCSP  DCSP os.chdir(eval(('r\"%s\"' % cd_match.groups()[0].strip()))) DCNL DCSP elif clear_match: DCNL DCSP  DCSP varnames = clear_match.groups()[0].replace(' DCSP ', '').split(',') DCNL DCSP  DCSP for varname in varnames: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP namespace.pop(varname) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP elif (command in ('cd', 'pwd')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _print(os.getcwdu()) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP _print(os.getcwd()) DCNL DCSP elif (command == 'ls'): DCNL DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP programs.run_shell_command('dir') DCNL DCSP  DCSP  DCSP _print('\\n') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP programs.run_shell_command('ls') DCNL DCSP  DCSP  DCSP _print('\\n') DCNL DCSP elif (command == 'scientific'): DCNL DCSP  DCSP from spyder.config import base DCNL DCSP  DCSP execfile(base.SCIENTIFIC_STARTUP, namespace) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementedError((\"Unsupported DCSP command: DCSP '%s'\" % command))\n", "intent": "evaluate special commands .\n", "question_id": 1450}, {"snippet": "def get_service(hass, config, discovery_info=None): DCNL  DCSP import syslog DCNL DCSP facility = getattr(syslog, SYSLOG_FACILITY[config.get(CONF_FACILITY)]) DCNL DCSP option = getattr(syslog, SYSLOG_OPTION[config.get(CONF_OPTION)]) DCNL DCSP priority = getattr(syslog, SYSLOG_PRIORITY[config.get(CONF_PRIORITY)]) DCNL DCSP return SyslogNotificationService(facility, option, priority)\n", "intent": "get the syslog notification service .\n", "question_id": 1451}, {"snippet": "def alias(*aliases): DCNL  DCSP def decorator(cls): DCNL DCSP  DCSP caller = sys._getframe(1) DCNL DCSP  DCSP globals_dict = caller.f_globals DCNL DCSP  DCSP for alias in aliases: DCNL DCSP  DCSP  DCSP globals_dict[alias] = cls DCNL DCSP  DCSP return cls DCNL DCSP return decorator\n", "intent": "decorating a class with @alias allows the class to be referenced by each of the names provided as arguments .\n", "question_id": 1452}, {"snippet": "def CalculateVariables(default_variables, params): DCNL  DCSP flavor = gyp.common.GetFlavor(params) DCNL DCSP if (flavor == 'mac'): DCNL DCSP  DCSP default_variables.setdefault('OS', 'mac') DCNL DCSP elif (flavor == 'win'): DCNL DCSP  DCSP default_variables.setdefault('OS', 'win') DCNL DCSP  DCSP import gyp.generator.msvs as msvs_generator DCNL DCSP  DCSP generator_additional_non_configuration_keys = getattr(msvs_generator, 'generator_additional_non_configuration_keys', []) DCNL DCSP  DCSP generator_additional_path_sections = getattr(msvs_generator, 'generator_additional_path_sections', []) DCNL DCSP  DCSP gyp.msvs_emulation.CalculateCommonVariables(default_variables, params) DCNL DCSP else: DCNL DCSP  DCSP operating_system = flavor DCNL DCSP  DCSP if (flavor == 'android'): DCNL DCSP  DCSP  DCSP operating_system = 'linux' DCNL DCSP  DCSP default_variables.setdefault('OS', operating_system)\n", "intent": "calculate additional variables for use in the build .\n", "question_id": 1453}, {"snippet": "def set_var(name, value): DCNL  DCSP return config(name, value)\n", "intent": "set traffic server configuration variable values .\n", "question_id": 1454}, {"snippet": "def checkout_with_ecommerce_service(user, course_key, course_mode, processor): DCNL  DCSP course_id = unicode(course_key) DCNL DCSP try: DCNL DCSP  DCSP api = ecommerce_api_client(user) DCNL DCSP  DCSP result = api.baskets.post({'products': [{'sku': course_mode.sku}], 'checkout': True, 'payment_processor_name': processor}) DCNL DCSP  DCSP return result.get('payment_data') DCNL DCSP except SlumberBaseException: DCNL DCSP  DCSP params = {'username': user.username, 'mode': course_mode.slug, 'course_id': course_id} DCNL DCSP  DCSP log.exception('Failed DCSP to DCSP create DCSP order DCSP for DCSP %(username)s DCSP %(mode)s DCSP mode DCSP of DCSP %(course_id)s', params) DCNL DCSP  DCSP raise DCNL DCSP finally: DCNL DCSP  DCSP audit_log('checkout_requested', course_id=course_id, mode=course_mode.slug, processor_name=processor, user_id=user.id)\n", "intent": "create a new basket and trigger immediate checkout .\n", "question_id": 1455}, {"snippet": "def get_vmware_hosts(check_esx_path, vcenter, user, password): DCNL  DCSP list_host_cmd = [check_esx_path, '-D', vcenter, '-u', user, '-p', password, '-l', 'runtime', '-s', 'listhost'] DCNL DCSP print 'Got DCSP host DCSP list' DCNL DCSP print ' DCSP '.join(list_host_cmd) DCNL DCSP p = Popen(list_host_cmd, stdout=PIPE, stderr=PIPE) DCNL DCSP output = p.communicate() DCNL DCSP print 'Exit DCSP status', p.returncode DCNL DCSP if (p.returncode == 2): DCNL DCSP  DCSP print 'Error: DCSP check_esx3.pl DCSP returnes DCSP an DCSP error:', output DCNL DCSP  DCSP raise SystemExit(2) DCNL DCSP parts = output[0].split(':') DCNL DCSP hsts_raw = parts[1].split('|')[0] DCNL DCSP hsts_raw_lst = hsts_raw.split(',') DCNL DCSP hosts = [] DCNL DCSP for hst_raw in hsts_raw_lst: DCNL DCSP  DCSP hst_raw = hst_raw.strip() DCNL DCSP  DCSP elts = hst_raw.split('(') DCNL DCSP  DCSP hst = elts[0] DCNL DCSP  DCSP hosts.append(hst) DCNL DCSP return hosts\n", "intent": "get a list of all hosts from a vcenter .\n", "question_id": 1456}, {"snippet": "def getNumpyRandomGenerator(seed=None): DCNL  DCSP if (seed is None): DCNL DCSP  DCSP seed = int(((time.time() % 10000) * 10)) DCNL DCSP print 'Numpy DCSP seed DCSP set DCSP to:', seed, 'called DCSP by', DCNL DCSP callStack = traceback.extract_stack(limit=3) DCNL DCSP print callStack[0][2], 'line', callStack[0][1], '->', callStack[1][2] DCNL DCSP return numpy.random.RandomState(seed)\n", "intent": "return a numpy random number generator with the given seed .\n", "question_id": 1457}, {"snippet": "def gen_conv_code_unroll_batch_kern(d, unroll_bsize=1, unroll_ksize=1): DCNL  DCSP assert ((unroll_bsize > 0) and (unroll_ksize > 0)) DCNL DCSP if (('unroll_bsize' in d) or ('unroll_ksize' in d) or ('unroll_iter' in d) or ('unroll_biter' in d) or ('unroll_kiter' in d)): DCNL DCSP  DCSP raise Exception(\"We DCSP can't DCSP use DCSP this DCSP dictionnary DCSP as DCSP we DCSP will DCSP overwrite DCSP some DCSP of DCSP its DCSP containt\") DCNL DCSP d = d.copy() DCNL DCSP d['unroll_bsize'] = unroll_bsize DCNL DCSP d['unroll_ksize'] = unroll_ksize DCNL DCSP def my_dup(st, size): DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP for i in xrange(size): DCNL DCSP  DCSP  DCSP d['unroll_iter'] = i DCNL DCSP  DCSP  DCSP s += (st % d) DCNL DCSP  DCSP return (s + '\\n') DCNL DCSP def my_dup2(st): DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP iter = 0 DCNL DCSP  DCSP for i in xrange(unroll_bsize): DCNL DCSP  DCSP  DCSP d['unroll_biter'] = i DCNL DCSP  DCSP  DCSP for j in xrange(unroll_ksize): DCNL DCSP  DCSP  DCSP  DCSP d['unroll_kiter'] = j DCNL DCSP  DCSP  DCSP  DCSP d['unroll_iter'] = iter DCNL DCSP  DCSP  DCSP  DCSP iter += 1 DCNL DCSP  DCSP  DCSP  DCSP s += (st % d) DCNL DCSP  DCSP return (s + '\\n') DCNL DCSP ret = ('\\nconst DCSP int DCSP mode=%(mode)s;\\nint DCSP typenum=0, DCSP typenum_f=0;\\nPyArrayObject DCSP *ain1=NULL, DCSP *ain2=NULL, DCSP *filtersflipped_arr=NULL, DCSP *img2d_arr=NULL, DCSP *z_arr=NULL;;\\nconst DCSP %(type)s DCSP fill_value DCSP = DCSP 0;\\n\\nint DCSP type_im=PyArray_TYPE(%(img2d)s);\\nint DCSP type_ker=PyArray_TYPE(%(filtersflipped)s);\\n\\nnpy_intp DCSP dim_zz[2]={%(self_outshp0)s,%(self_outshp1)s};\\nnpy_intp DCSP dim_im[2]={%(self_imshp1)s,%(self_imshp2)s};\\nconst DCSP npy_intp DCSP dim_ker0=%(self_kshp0)s;\\nconst DCSP npy_intp DCSP dim_ker1=%(self_kshp1)s;\\n\\nPyArray_Dims DCSP img2d_shape;\\nnpy_intp DCSP img2d_dim[4]={1,1,0,0};\\nimg2d_shape.ptr=img2d_dim;\\nimg2d_shape.len=4;\\n\\nPyArray_Dims DCSP kerns_shape;\\nnpy_intp DCSP kerns_dim[4]={1,1,0,0};\\nkerns_shape.ptr=kerns_dim;\\nkerns_shape.len=4;\\nPyObject DCSP *img2d=NULL, DCSP *contig, DCSP *filtersflipped=NULL;\\n\\nif(PyArray_NDIM(%(img2d)s)==2){\\n DCSP  DCSP img2d_dim[3]=PyArray_DIMS(%(img2d)s)[1];\\n DCSP  DCSP img2d_dim[2]=PyArray_DIMS(%(img2d)s)[0];\\n}else DCSP if(PyArray_NDIM(%(img2d)s)==3){\\n DCSP  DCSP img2d_dim[3]=PyArray_DIMS(%(img2d)s)[2];\\n DCSP  DCSP img2d_dim[2]=PyArray_DIMS(%(img2d)s)[1];\\n DCSP  DCSP img2d_dim[0]=PyArray_DIMS(%(img2d)s)[0];\\n}else DCSP if(PyArray_NDIM(%(img2d)s)==4){\\n DCSP  DCSP img2d_dim[3]=PyArray_DIMS(%(img2d)s)[3];\\n DCSP  DCSP img2d_dim[2]=PyArray_DIMS(%(img2d)s)[2];\\n DCSP  DCSP img2d_dim[1]=PyArray_DIMS(%(img2d)s)[1];\\n DCSP  DCSP img2d_dim[0]=PyArray_DIMS(%(img2d)s)[0];\\n}else DCSP {\\n DCSP  DCSP  DCSP  DCSP std::stringstream DCSP temp;\\n DCSP  DCSP  DCSP  DCSP temp DCSP << DCSP \"nddim=\"<<PyArray_NDIM(%(img2d)s);\\n DCSP  DCSP  DCSP  DCSP std::string DCSP param DCSP = DCSP temp.str();\\n DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_ValueError,\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (\"img DCSP don\\'t DCSP have DCSP a DCSP good DCSP shape. DCSP \" DCSP + DCSP param).c_str());\\n DCSP  DCSP  DCSP  DCSP %(fail)s;\\n}\\n\\nif(PyArray_NDIM(%(filtersflipped)s)==3){\\n DCSP  DCSP kerns_dim[3]=PyArray_DIMS(%(filtersflipped)s)[2];\\n DCSP  DCSP kerns_dim[2]=PyArray_DIMS(%(filtersflipped)s)[1];\\n DCSP  DCSP kerns_dim[0]=PyArray_DIMS(%(filtersflipped)s)[0];\\n}else DCSP if(PyArray_NDIM(%(filtersflipped)s)==4){\\n DCSP  DCSP kerns_dim[3]=PyArray_DIMS(%(filtersflipped)s)[3];\\n DCSP  DCSP kerns_dim[2]=PyArray_DIMS(%(filtersflipped)s)[2];\\n DCSP  DCSP kerns_dim[1]=PyArray_DIMS(%(filtersflipped)s)[1];\\n DCSP  DCSP kerns_dim[0]=PyArray_DIMS(%(filtersflipped)s)[0];\\n}else{\\n DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_ValueError, DCSP \"kernel DCSP don\\'t DCSP have DCSP a DCSP good DCSP shape\");\\n DCSP  DCSP  DCSP  DCSP %(fail)s;\\n}\\n\\n%(assert_size)s\\n\\nimg2d DCSP = DCSP PyArray_Newshape(%(img2d)s,&img2d_shape, DCSP NPY_CORDER);\\nimg2d_arr DCSP = DCSP (PyArrayObject*)img2d;\\nif DCSP ((PyArray_STRIDES(img2d_arr)[3] DCSP != DCSP (npy_intp)sizeof(%(type)s))\\n DCSP  DCSP  DCSP  DCSP  DCSP || DCSP (PyArray_STRIDES(img2d_arr)[2] DCSP != DCSP PyArray_DIMS(img2d_arr)[3]*(npy_intp)sizeof(%(type)s))){\\n DCSP  DCSP  DCSP  DCSP contig DCSP = DCSP (PyObject*)(PyArray_GETCONTIGUOUS((PyArrayObject*)img2d));\\n DCSP  DCSP  DCSP  DCSP Py_DECREF(img2d);\\n DCSP  DCSP  DCSP  DCSP img2d DCSP = DCSP contig;\\n DCSP  DCSP  DCSP  DCSP img2d_arr DCSP = DCSP (PyArrayObject*)img2d;\\n DCSP  DCSP  DCSP  DCSP if DCSP (!PyArray_ISCONTIGUOUS(img2d_arr)){\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_ValueError, DCSP \"img2d DCSP isn\\'t DCSP contiguous\");\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(fail)s;\\n DCSP  DCSP  DCSP  DCSP }\\n}\\n\\nfiltersflipped DCSP = DCSP PyArray_Newshape(%(filtersflipped)s,&kerns_shape, DCSP NPY_CORDER);\\nfiltersflipped_arr DCSP = DCSP (PyArrayObject*)filtersflipped;\\nif DCSP ((PyArray_STRIDES(filtersflipped_arr)[3] DCSP != DCSP (npy_intp)sizeof(%(type)s))\\n DCSP  DCSP  DCSP  DCSP  DCSP || DCSP (PyArray_STRIDES(filtersflipped_arr)[2] DCSP != DCSP PyArray_DIMS(filtersflipped_arr)[3]*(npy_intp)sizeof(%(type)s))){\\n DCSP  DCSP  DCSP  DCSP contig DCSP = DCSP (PyObject*)(PyArray_GETCONTIGUOUS((PyArrayObject*)filtersflipped));\\n DCSP  DCSP  DCSP  DCSP Py_DECREF(filtersflipped);\\n DCSP  DCSP  DCSP  DCSP filtersflipped DCSP = DCSP contig;\\n DCSP  DCSP  DCSP  DCSP filtersflipped_arr DCSP = DCSP (PyArrayObject*)filtersflipped;\\n DCSP  DCSP  DCSP  DCSP if DCSP (!PyArray_ISCONTIGUOUS(filtersflipped_arr)){\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_ValueError, DCSP \"filtersflipped DCSP isn\\'t DCSP contiguous\");\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(fail)s;\\n DCSP  DCSP  DCSP  DCSP }\\n}\\n\\nif(mode DCSP != DCSP VALID DCSP && DCSP mode DCSP != DCSP FULL){\\n DCSP  DCSP PyErr_SetString(PyExc_ValueError, DCSP \"invalid DCSP mode, DCSP only DCSP full DCSP and DCSP valid DCSP are DCSP supported\"); DCSP %(fail)s;\\n}\\ntypenum DCSP = DCSP PyArray_ObjectType((PyObject*)%(img2d)s, DCSP 0);\\ntypenum_f DCSP = DCSP PyArray_ObjectType((PyObject*)%(filtersflipped)s, DCSP 0);\\nif DCSP (typenum DCSP < DCSP 0) DCSP {PyErr_SetString(PyExc_ValueError, DCSP \"Invalid DCSP type\"); DCSP %(fail)s;}\\nif DCSP (typenum DCSP != DCSP typenum_f) DCSP {PyErr_SetString(PyExc_ValueError, DCSP \"Input DCSP types DCSP must DCSP match\"); DCSP %(fail)s;}\\n\\nif DCSP (!img2d)\\n{\\n DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_AssertionError, DCSP \"!img2d\");\\n DCSP  DCSP  DCSP  DCSP %(fail)s;\\n}\\nif DCSP (!filtersflipped)\\n{\\n DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_AssertionError, DCSP \"!filtersflipped\");\\n DCSP  DCSP  DCSP  DCSP %(fail)s;\\n}\\n\\nif DCSP ((!%(z)s)\\n DCSP  DCSP || DCSP *PyArray_DIMS(%(z)s)!=4\\n DCSP  DCSP ||(PyArray_DIMS(%(z)s)[0] DCSP != DCSP %(self_bsize)s)\\n DCSP  DCSP ||(PyArray_DIMS(%(z)s)[1] DCSP != DCSP %(self_nkern)s)\\n DCSP  DCSP ||(PyArray_DIMS(%(z)s)[2] DCSP != DCSP dim_zz[0])\\n DCSP  DCSP ||(PyArray_DIMS(%(z)s)[3] DCSP != DCSP dim_zz[1])\\n DCSP  DCSP ||!PyArray_ISCONTIGUOUS(%(z)s)\\n DCSP  DCSP )\\n{\\n DCSP  DCSP {Py_XDECREF(%(z)s);}\\n DCSP  DCSP npy_intp DCSP dims[4] DCSP = DCSP {0,0,0,0};\\n DCSP  DCSP dims[0]=%(self_bsize)s;\\n DCSP  DCSP dims[1]=%(self_nkern)s;\\n DCSP  DCSP dims[2]=dim_zz[0];\\n DCSP  DCSP dims[3]=dim_zz[1];\\n DCSP  DCSP %(z)s DCSP = DCSP (PyArrayObject*) DCSP PyArray_ZEROS(4, DCSP dims, DCSP typenum,0);\\n}else{\\n DCSP  DCSP //PyArray_FILLWBYTE((PyObject*)%(z)s,0);\\n}\\nz_arr DCSP = DCSP (PyArrayObject*) DCSP %(z)s;\\n\\nint DCSP Os[2];\\nOs[0]=%(self_outshp0)s;\\nOs[1]=%(self_outshp1)s;\\n\\n//assertions\\nif DCSP (!PyArray_ISCONTIGUOUS(%(z)s))\\n{\\n DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_AssertionError, DCSP \"Output DCSP (%(z)s) DCSP not DCSP contiguous\");\\n DCSP  DCSP  DCSP  DCSP %(fail)s;\\n}\\n\\nfor(int DCSP b=0;b< DCSP %(self_bsize)s DCSP ;b+=%(unroll_bsize)s){\\n DCSP  DCSP for(int DCSP n_kern=0;n_kern<%(self_nkern)s;n_kern+=%(unroll_ksize)s){\\n\\n' % d) DCNL DCSP ret += my_dup2('%(type)s DCSP * DCSP __restrict__ DCSP out%(unroll_iter)s=(%(type)s DCSP *)(PyArray_GETPTR2(z_arr,b+%(unroll_biter)s,n_kern+%(unroll_kiter)s));') DCNL DCSP ret += my_dup('for DCSP (int DCSP i DCSP = DCSP 0; DCSP i DCSP < DCSP dim_zz[0]*dim_zz[1]; DCSP ++i) DCSP out%(unroll_iter)s[i] DCSP = DCSP 0;', (unroll_bsize * unroll_ksize)) DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP for(int DCSP stack_size=0;stack_size<%(self_imshp0)s;stack_size++){\\n' % d) DCNL DCSP ret += my_dup('const DCSP %(type)s DCSP * DCSP __restrict__ DCSP in%(unroll_iter)d=(%(type)s DCSP *)(PyArray_GETPTR2(img2d_arr,b+%(unroll_iter)s,stack_size));', unroll_bsize) DCNL DCSP ret += my_dup('const DCSP %(type)s DCSP * DCSP __restrict__ DCSP hvals%(unroll_iter)s=(%(type)s DCSP *)(PyArray_GETPTR2(filtersflipped_arr,n_kern+%(unroll_iter)s,stack_size));', unroll_ksize) DCNL DCSP ret += ('\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP new_m;\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP iter_m=0; DCSP iter_m DCSP < DCSP Os[0]; DCSP iter_m++) DCSP {\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP Reposition DCSP index DCSP into DCSP input DCSP image DCSP based DCSP on DCSP requested DCSP output DCSP size\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP pos_m DCSP = DCSP iter_m*%(self_dx)s;//The DCSP position DCSP of DCSP the DCSP patch DCSP in DCSP the DCSP image\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP (mode DCSP == DCSP FULL) DCSP new_m DCSP = DCSP pos_m DCSP ;\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else DCSP new_m DCSP = DCSP (pos_m+dim_ker0-1);\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP iter_n=0; DCSP iter_n DCSP < DCSP Os[1]; DCSP iter_n++) DCSP { DCSP  DCSP // DCSP loop DCSP over DCSP columns\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP pos_n=iter_n*%(self_dy)s;\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % d) DCNL DCSP ret += my_dup('%(type)s DCSP sum%(unroll_iter)s=0;', (unroll_bsize * unroll_ksize)) DCNL DCSP ret += ('\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP Sum DCSP over DCSP kernel, DCSP if DCSP index DCSP into DCSP image DCSP is DCSP out DCSP of DCSP bounds\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP fill DCSP with DCSP the DCSP value\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP j=0; DCSP j DCSP < DCSP dim_ker0; DCSP j++) DCSP {\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP ind0 DCSP = DCSP (new_m-j);\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if(mode==FULL){\\n' % d) DCNL DCSP ret += my_dup('const DCSP %(type)s DCSP * DCSP idx_hvals%(unroll_iter)s=&hvals%(unroll_iter)s[j*dim_ker1];', unroll_ksize) DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if(ind0 DCSP < DCSP 0 DCSP || DCSP ind0 DCSP >= DCSP dim_im[0]){\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if(fill_value!=0)\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP k=0; DCSP k DCSP < DCSP dim_ker1; DCSP k++) DCSP {\\n' % d) DCNL DCSP ret += my_dup2('sum%(unroll_iter)s DCSP += DCSP idx_hvals%(unroll_kiter)s[k] DCSP * DCSP fill_value;') DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }else{\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP //do DCSP the DCSP part DCSP where DCSP kernel DCSP is DCSP to DCSP the DCSP right DCSP of DCSP the DCSP img\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP k=0,max_k=max((int)(pos_n-dim_im[1])+1,0);\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if(fill_value!=0){\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for(k=0;k<max_k;k++){\\n' % d) DCNL DCSP ret += my_dup2('sum%(unroll_iter)s DCSP += DCSP idx_hvals%(unroll_kiter)s[k] DCSP * DCSP fill_value;') DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }else DCSP {k=max_k;}\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP //do DCSP the DCSP part DCSP where DCSP the DCSP kernel DCSP is DCSP on DCSP the DCSP img\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP max_k=min(pos_n+1,(int)dim_ker1);\\n' % d) DCNL DCSP ret += my_dup('const DCSP %(type)s DCSP * DCSP idx_in%(unroll_iter)s=&in%(unroll_iter)s[ind0*dim_im[1]];', unroll_bsize) DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP ind1=pos_n-k; DCSP k<max_k; DCSP k++,ind1--) DCSP {\\n\\n' % d) DCNL DCSP ret += my_dup2('sum%(unroll_iter)s+= DCSP idx_hvals%(unroll_kiter)s[k] DCSP * DCSP idx_in%(unroll_biter)s[ind1];') DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP //do DCSP the DCSP part DCSP to DCSP the DCSP left DCSP of DCSP the DCSP img\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if(fill_value!=0)\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for(;k<dim_ker1;k++){\\n' % d) DCNL DCSP ret += my_dup2('sum%(unroll_iter)s DCSP += DCSP idx_hvals%(unroll_kiter)s[k] DCSP * DCSP fill_value;') DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }else{//valid DCSP mode\\n' % d) DCNL DCSP ret += my_dup('const DCSP %(type)s* DCSP idx_in%(unroll_iter)s=&in%(unroll_iter)s[ind0*dim_im[1]];', unroll_bsize) DCNL DCSP ret += my_dup('const DCSP %(type)s* DCSP idx_hvals%(unroll_iter)s=&hvals%(unroll_iter)s[j*dim_ker1];', unroll_ksize) DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP new_n DCSP = DCSP (pos_n+dim_ker1-1);\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP k=0,last=new_n; DCSP k DCSP < DCSP dim_ker1; DCSP k++,last--) DCSP {\\n' % d) DCNL DCSP ret += my_dup2('sum%(unroll_iter)s+=idx_hvals%(unroll_kiter)s[k]*idx_in%(unroll_biter)s[last];') DCNL DCSP ret += ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }//for DCSP j\\n' % d) DCNL DCSP ret += my_dup('out%(unroll_iter)s[iter_m*dim_zz[1]+iter_n] DCSP %(affectation)s DCSP sum%(unroll_iter)s;', (unroll_bsize * unroll_ksize)) DCNL DCSP ret += '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }//for DCSP n\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }//for DCSP m\\n DCSP  DCSP  DCSP  DCSP }//for DCSP stack_size\\n DCSP  DCSP }//for DCSP n_kern\\n}//for DCSP b\\nPy_XDECREF(img2d);\\nPy_XDECREF(filtersflipped);\\n' DCNL DCSP return ret\n", "intent": "c_code for convop that unroll the batch size loop .\n", "question_id": 1458}, {"snippet": "def onlyOnce(fn): DCNL  DCSP def wrap(*args, **kwargs): DCNL DCSP  DCSP if hasattr(fn, 'called'): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP fn.called = 1 DCNL DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP util.mergeFunctionMetadata(fn, wrap) DCNL DCSP return wrap\n", "intent": "set up fn to only run once within an interpreter instance .\n", "question_id": 1459}, {"snippet": "def wait(name, ignore_already_stopped=False, fail_on_exit_status=False): DCNL  DCSP try: DCNL DCSP  DCSP pre = state(name) DCNL DCSP except CommandExecutionError: DCNL DCSP  DCSP return {'result': ignore_already_stopped, 'comment': \"Container DCSP '{0}' DCSP absent\".format(name)} DCNL DCSP already_stopped = (pre == 'stopped') DCNL DCSP response = _client_wrapper('wait', name) DCNL DCSP _clear_context() DCNL DCSP try: DCNL DCSP  DCSP post = state(name) DCNL DCSP except CommandExecutionError: DCNL DCSP  DCSP post = None DCNL DCSP if already_stopped: DCNL DCSP  DCSP success = ignore_already_stopped DCNL DCSP elif (post == 'stopped'): DCNL DCSP  DCSP success = True DCNL DCSP else: DCNL DCSP  DCSP success = False DCNL DCSP result = {'result': success, 'state': {'old': pre, 'new': post}, 'exit_status': response} DCNL DCSP if already_stopped: DCNL DCSP  DCSP result['comment'] = \"Container DCSP '{0}' DCSP already DCSP stopped\".format(name) DCNL DCSP if (fail_on_exit_status and result['result']): DCNL DCSP  DCSP result['result'] = (result['exit_status'] == 0) DCNL DCSP return result\n", "intent": "wait for the container to exit gracefully .\n", "question_id": 1460}, {"snippet": "def processElse(xmlElement): DCNL  DCSP evaluate.processCondition(xmlElement)\n", "intent": "process the else statement .\n", "question_id": 1461}, {"snippet": "def list_pkgs(versions_as_list=False, **kwargs): DCNL  DCSP versions_as_list = salt.utils.is_true(versions_as_list) DCNL DCSP if salt.utils.is_true(kwargs.get('removed')): DCNL DCSP  DCSP return {} DCNL DCSP if ('pkg.list_pkgs' in __context__): DCNL DCSP  DCSP if versions_as_list: DCNL DCSP  DCSP  DCSP return __context__['pkg.list_pkgs'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = copy.deepcopy(__context__['pkg.list_pkgs']) DCNL DCSP  DCSP  DCSP __salt__['pkg_resource.stringify'](ret) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP ret = {} DCNL DCSP cmd = '/usr/bin/pkginfo DCSP -x' DCNL DCSP lines = __salt__['cmd.run'](cmd).splitlines() DCNL DCSP for (index, line) in enumerate(lines): DCNL DCSP  DCSP if ((index % 2) == 0): DCNL DCSP  DCSP  DCSP name = line.split()[0].strip() DCNL DCSP  DCSP if ((index % 2) == 1): DCNL DCSP  DCSP  DCSP version_num = line.split()[1].strip() DCNL DCSP  DCSP  DCSP __salt__['pkg_resource.add_pkg'](ret, name, version_num) DCNL DCSP __salt__['pkg_resource.sort_pkglist'](ret) DCNL DCSP __context__['pkg.list_pkgs'] = copy.deepcopy(ret) DCNL DCSP if (not versions_as_list): DCNL DCSP  DCSP __salt__['pkg_resource.stringify'](ret) DCNL DCSP return ret\n", "intent": "list the packages currently installed as a dict:: {<package_name>: <version>} cli example: .\n", "question_id": 1462}, {"snippet": "def bytes_chr(i): DCNL  DCSP raise Exception('Should DCSP be DCSP overriden')\n", "intent": "returns a byte string  of length 1 whose ordinal value is i .\n", "question_id": 1463}, {"snippet": "@FileSystem.in_directory(current_directory, 'django', 'grocery') DCNL def test_django_admin_media_serving_on_django_13(): DCNL  DCSP os.environ['PYTHONPATH'] = ('%s:%s' % (FileSystem.join(lib_directory, 'Django-1.3'), OLD_PYTHONPATH)) DCNL DCSP (status, out) = commands.getstatusoutput('python DCSP manage.py DCSP harvest DCSP --verbosity=2 DCSP ./features/') DCNL DCSP assert_equals(status, 0, out) DCNL DCSP lines = out.splitlines() DCNL DCSP assert (u\"Preparing DCSP to DCSP serve DCSP django's DCSP admin DCSP site DCSP static DCSP files...\" in lines) DCNL DCSP assert (u'Running DCSP on DCSP port DCSP 7000 DCSP ... DCSP OK' in lines) DCNL DCSP assert (u'Fetching DCSP admin DCSP media DCSP ... DCSP OK' in lines) DCNL DCSP assert (u'Fetching DCSP static DCSP files DCSP ... DCSP OK' in lines) DCNL DCSP assert (u'Fetching DCSP CSS DCSP files: DCSP ... DCSP OK' in lines) DCNL DCSP assert (u'Fetching DCSP javascript DCSP files: DCSP ... DCSP OK' in lines) DCNL DCSP assert (u\"Django's DCSP builtin DCSP server DCSP is DCSP running DCSP at DCSP 0.0.0.0:7000\" in lines)\n", "intent": "lettuce should serve admin static files properly on django 1 .\n", "question_id": 1464}, {"snippet": "def restart_apppool(name): DCNL  DCSP pscmd = list() DCNL DCSP pscmd.append(\"Restart-WebAppPool DCSP '{0}'\".format(name)) DCNL DCSP cmd_ret = _srvmgr(str().join(pscmd)) DCNL DCSP return (cmd_ret['retcode'] == 0)\n", "intent": "restart an iis application pool .\n", "question_id": 1465}, {"snippet": "def p_direct_declarator_6(t): DCNL  DCSP pass\n", "intent": "direct_declarator : direct_declarator lparen rparen .\n", "question_id": 1466}, {"snippet": "def auth(request): DCNL  DCSP def get_user(): DCNL DCSP  DCSP if hasattr(request, 'user'): DCNL DCSP  DCSP  DCSP return request.user DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP from django.contrib.auth.models import AnonymousUser DCNL DCSP  DCSP  DCSP return AnonymousUser() DCNL DCSP return {'user': SimpleLazyObject(get_user), 'messages': messages.get_messages(request), 'perms': lazy((lambda : PermWrapper(get_user())), PermWrapper)()}\n", "intent": "returns context variables required by apps that use djangos authentication system .\n", "question_id": 1467}, {"snippet": "def test_non_broadcasting_parameters(): DCNL  DCSP a = 3 DCNL DCSP b = np.array([[1, 2, 3], [4, 5, 6]]) DCNL DCSP c = np.array([[1, 2, 3, 4], [1, 2, 3, 4]]) DCNL DCSP class TestModel(Model, ): DCNL DCSP  DCSP p1 = Parameter() DCNL DCSP  DCSP p2 = Parameter() DCNL DCSP  DCSP p3 = Parameter() DCNL DCSP  DCSP def evaluate(self, *args): DCNL DCSP  DCSP  DCSP return DCNL DCSP for args in itertools.permutations((a, b, c)): DCNL DCSP  DCSP with pytest.raises(InputParameterError): DCNL DCSP  DCSP  DCSP TestModel(*args)\n", "intent": "tests that in a model with 3 parameters that do not all mutually broadcast .\n", "question_id": 1468}, {"snippet": "def _sd_version(): DCNL  DCSP return salt.utils.systemd.version(__context__)\n", "intent": "returns __context__ .\n", "question_id": 1469}, {"snippet": "def ext_pillar(minion_id, pillar, profile=None): DCNL  DCSP if (profile is None): DCNL DCSP  DCSP profile = {} DCNL DCSP ret = {'credentials_result': False, 'credentials': None, 'credentials_metadata': None} DCNL DCSP profile_data = copy.deepcopy(profile) DCNL DCSP if profile_data.get('disabled', False): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP token_version = profile_data.get('token_version', 1) DCNL DCSP try: DCNL DCSP  DCSP url = profile_data['url'] DCNL DCSP  DCSP auth_key = profile_data['auth_key'] DCNL DCSP  DCSP auth_context = profile_data['auth_context'] DCNL DCSP  DCSP role = auth_context['from'] DCNL DCSP except (KeyError, TypeError): DCNL DCSP  DCSP msg = 'profile DCSP has DCSP undefined DCSP url, DCSP auth_key DCSP or DCSP auth_context' DCNL DCSP  DCSP log.debug(msg) DCNL DCSP  DCSP return ret DCNL DCSP region = profile_data.get('region', 'us-east-1') DCNL DCSP token_duration = profile_data.get('token_duration', 60) DCNL DCSP retries = profile_data.get('retries', 5) DCNL DCSP token_cache_file = profile_data.get('token_cache_file') DCNL DCSP backoff = profile_data.get('backoff', 1) DCNL DCSP client = confidant.client.ConfidantClient(url, auth_key, auth_context, token_lifetime=token_duration, token_version=token_version, token_cache_file=token_cache_file, region=region, retries=retries, backoff=backoff) DCNL DCSP try: DCNL DCSP  DCSP data = client.get_service(role, decrypt_blind=True) DCNL DCSP except confidant.client.TokenCreationError: DCNL DCSP  DCSP return ret DCNL DCSP if (not data['result']): DCNL DCSP  DCSP return ret DCNL DCSP ret = confidant.formatter.combined_credential_pair_format(data) DCNL DCSP ret['credentials_result'] = True DCNL DCSP return ret\n", "intent": "read pillar data from confidant via its api .\n", "question_id": 1470}, {"snippet": "def set_lights_xy(hass, lights, x_val, y_val, brightness): DCNL  DCSP for light in lights: DCNL DCSP  DCSP if is_on(hass, light): DCNL DCSP  DCSP  DCSP turn_on(hass, light, xy_color=[x_val, y_val], brightness=brightness, transition=30)\n", "intent": "set color of array of lights .\n", "question_id": 1471}, {"snippet": "def sendEmail(SUBJECT, BODY, TO, FROM, SENDER, PASSWORD, SMTP_SERVER): DCNL  DCSP for body_charset in ('US-ASCII', 'ISO-8859-1', 'UTF-8'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP BODY.encode(body_charset) DCNL DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP msg = MIMEText(BODY.encode(body_charset), 'html', body_charset) DCNL DCSP msg['From'] = SENDER DCNL DCSP msg['To'] = TO DCNL DCSP msg['Subject'] = SUBJECT DCNL DCSP SMTP_PORT = 587 DCNL DCSP session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT) DCNL DCSP session.starttls() DCNL DCSP session.login(FROM, PASSWORD) DCNL DCSP session.sendmail(SENDER, TO, msg.as_string()) DCNL DCSP session.quit()\n", "intent": "sends an html email .\n", "question_id": 1472}, {"snippet": "def with_metaclass(meta, *bases): DCNL  DCSP return meta('NewBase', bases, {})\n", "intent": "create a base class with a metaclass .\n", "question_id": 1473}, {"snippet": "def get_f_option(opts): DCNL  DCSP for (opt, arg) in opts: DCNL DCSP  DCSP if (opt == '-f'): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP else: DCNL DCSP  DCSP return None\n", "intent": "return value of the -f option .\n", "question_id": 1474}, {"snippet": "def spawn(argv, master_read=_read, stdin_read=_read): DCNL  DCSP if (type(argv) == type('')): DCNL DCSP  DCSP argv = (argv,) DCNL DCSP (pid, master_fd) = fork() DCNL DCSP if (pid == CHILD): DCNL DCSP  DCSP os.execlp(argv[0], *argv) DCNL DCSP try: DCNL DCSP  DCSP mode = tty.tcgetattr(STDIN_FILENO) DCNL DCSP  DCSP tty.setraw(STDIN_FILENO) DCNL DCSP  DCSP restore = 1 DCNL DCSP except tty.error: DCNL DCSP  DCSP restore = 0 DCNL DCSP try: DCNL DCSP  DCSP _copy(master_fd, master_read, stdin_read) DCNL DCSP except OSError: DCNL DCSP  DCSP if restore: DCNL DCSP  DCSP  DCSP tty.tcsetattr(STDIN_FILENO, tty.TCSAFLUSH, mode) DCNL DCSP os.close(master_fd) DCNL DCSP return os.waitpid(pid, 0)[1]\n", "intent": "create a spawned process .\n", "question_id": 1475}, {"snippet": "def constructor_import(loader, node): DCNL  DCSP value = loader.construct_scalar(node) DCNL DCSP if ('.' not in value): DCNL DCSP  DCSP raise yaml.YAMLError(\"import DCSP tag DCSP suffix DCSP contains DCSP no DCSP '.'\") DCNL DCSP return try_to_import(value)\n", "intent": "callback used by pyyaml when a \"!import <str>\" tag is encountered .\n", "question_id": 1476}, {"snippet": "def vocabulary_create(context, data_dict): DCNL  DCSP model = context['model'] DCNL DCSP schema = (context.get('schema') or ckan.logic.schema.default_create_vocabulary_schema()) DCNL DCSP _check_access('vocabulary_create', context, data_dict) DCNL DCSP (data, errors) = _validate(data_dict, schema, context) DCNL DCSP if errors: DCNL DCSP  DCSP model.Session.rollback() DCNL DCSP  DCSP raise ValidationError(errors) DCNL DCSP vocabulary = model_save.vocabulary_dict_save(data, context) DCNL DCSP if (not context.get('defer_commit')): DCNL DCSP  DCSP model.repo.commit() DCNL DCSP log.debug(('Created DCSP Vocabulary DCSP %s' % vocabulary.name)) DCNL DCSP return model_dictize.vocabulary_dictize(vocabulary, context)\n", "intent": "create a new tag vocabulary .\n", "question_id": 1477}, {"snippet": "def instance_get_all_by_host_and_not_type(context, host, type_id=None): DCNL  DCSP return IMPL.instance_get_all_by_host_and_not_type(context, host, type_id)\n", "intent": "get all instances belonging to a host with a different type_id .\n", "question_id": 1478}, {"snippet": "def managed(flag=True, using=None): DCNL  DCSP if (using is None): DCNL DCSP  DCSP using = DEFAULT_DB_ALIAS DCNL DCSP connection = connections[using] DCNL DCSP connection.managed(flag)\n", "intent": "puts the transaction manager into a manual state: managed transactions have to be committed explicitly by the user .\n", "question_id": 1479}, {"snippet": "def eval_location(pymodule, offset): DCNL  DCSP return eval_location2(pymodule, offset)[1]\n", "intent": "find the pyname at the offset .\n", "question_id": 1480}, {"snippet": "def plainpager(text): DCNL  DCSP sys.stdout.write(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding)))\n", "intent": "simply print unformatted text .\n", "question_id": 1481}, {"snippet": "def error(request): DCNL  DCSP messages = get_messages(request) DCNL DCSP return render_to_response('error.html', {'version': version, 'messages': messages}, RequestContext(request))\n", "intent": "error view .\n", "question_id": 1482}, {"snippet": "def copymod(dct, without=None, **kwargs): DCNL  DCSP if (without is None): DCNL DCSP  DCSP without = [] DCNL DCSP rval = copy(dct) DCNL DCSP for a in without: DCNL DCSP  DCSP if (a in rval): DCNL DCSP  DCSP  DCSP del rval[a] DCNL DCSP for (kw, val) in iteritems(kwargs): DCNL DCSP  DCSP rval[kw] = val DCNL DCSP return rval\n", "intent": "return dct but with the keys named by args removed .\n", "question_id": 1483}, {"snippet": "def simultaneous_ci(q_crit, var, groupnobs, pairindices=None): DCNL  DCSP ng = len(groupnobs) DCNL DCSP if (pairindices is None): DCNL DCSP  DCSP pairindices = np.triu_indices(ng, 1) DCNL DCSP gvar = (var / groupnobs) DCNL DCSP d12 = np.sqrt((gvar[pairindices[0]] + gvar[pairindices[1]])) DCNL DCSP d = np.zeros((ng, ng)) DCNL DCSP d[pairindices] = d12 DCNL DCSP d = (d + d.conj().T) DCNL DCSP sum1 = np.sum(d12) DCNL DCSP sum2 = np.sum(d, axis=0) DCNL DCSP if (ng > 2): DCNL DCSP  DCSP w = ((((ng - 1.0) * sum2) - sum1) / ((ng - 1.0) * (ng - 2.0))) DCNL DCSP else: DCNL DCSP  DCSP w = ((sum1 * np.ones((2, 1))) / 2.0) DCNL DCSP return ((q_crit / np.sqrt(2)) * w)\n", "intent": "compute simultaneous confidence intervals for comparison of means .\n", "question_id": 1484}, {"snippet": "def parse_unified_diff_output(lines): DCNL  DCSP adds = [] DCNL DCSP removes = [] DCNL DCSP for line in lines: DCNL DCSP  DCSP if ((len(line) > 2) and ((line[:3] == '+++') or (line[:3] == '---'))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((len(line) > 1) and (line[:2] == '@@')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((len(line) > 0) and (line[0] == '+')): DCNL DCSP  DCSP  DCSP added_line = line[1:].lstrip().rstrip() DCNL DCSP  DCSP  DCSP if (len(added_line) == 0): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP adds = (adds + [added_line]) DCNL DCSP  DCSP elif ((len(line) > 0) and (line[0] == '-')): DCNL DCSP  DCSP  DCSP removed_line = line[1:].lstrip().rstrip() DCNL DCSP  DCSP  DCSP if (len(removed_line) == 0): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP removes = (removes + [removed_line]) DCNL DCSP return (adds, removes)\n", "intent": "parses the unified diff output of two files returns a pair of adds and removes .\n", "question_id": 1485}, {"snippet": "def check_increasing(x, y): DCNL  DCSP (rho, _) = spearmanr(x, y) DCNL DCSP increasing_bool = (rho >= 0) DCNL DCSP if (rho not in [(-1.0), 1.0]): DCNL DCSP  DCSP F = (0.5 * math.log(((1.0 + rho) / (1.0 - rho)))) DCNL DCSP  DCSP F_se = (1 / math.sqrt((len(x) - 3))) DCNL DCSP  DCSP rho_0 = math.tanh((F - (1.96 * F_se))) DCNL DCSP  DCSP rho_1 = math.tanh((F + (1.96 * F_se))) DCNL DCSP  DCSP if (np.sign(rho_0) != np.sign(rho_1)): DCNL DCSP  DCSP  DCSP warnings.warn('Confidence DCSP interval DCSP of DCSP the DCSP Spearman DCSP correlation DCSP coefficient DCSP spans DCSP zero. DCSP Determination DCSP of DCSP ``increasing`` DCSP may DCSP be DCSP suspect.') DCNL DCSP return increasing_bool\n", "intent": "determine whether y is monotonically correlated with x .\n", "question_id": 1486}, {"snippet": "def dot(v, w): DCNL  DCSP return sum(((v_i * w_i) for (v_i, w_i) in zip(v, w)))\n", "intent": "v_1 * w_1 + .\n", "question_id": 1487}, {"snippet": "def get_setting_name_and_refid(node): DCNL  DCSP (entry_type, info, refid) = node['entries'][0][:3] DCNL DCSP return (info.replace('; DCSP setting', ''), refid)\n", "intent": "extract setting name from directive index node .\n", "question_id": 1488}, {"snippet": "def load(session, tables=[], directory=None, drop_tables=False, verbose=False, safe=True, recursive=True, langs=None): DCNL  DCSP (print_start, print_status, print_done) = _get_verbose_prints(verbose) DCNL DCSP if (directory is None): DCNL DCSP  DCSP directory = get_default_csv_dir() DCNL DCSP table_names = _get_table_names(metadata, tables) DCNL DCSP table_objs = [metadata.tables[name] for name in table_names] DCNL DCSP if recursive: DCNL DCSP  DCSP table_objs.extend(find_dependent_tables(table_objs)) DCNL DCSP table_objs = sqlalchemy.sql.util.sort_tables(table_objs) DCNL DCSP engine = session.get_bind() DCNL DCSP oracle = (engine.dialect.name == 'oracle') DCNL DCSP if oracle: DCNL DCSP  DCSP rewrite_long_table_names() DCNL DCSP if ((not safe) and (engine.dialect.name == 'sqlite')): DCNL DCSP  DCSP session.execute('PRAGMA DCSP synchronous=OFF') DCNL DCSP  DCSP session.execute('PRAGMA DCSP journal_mode=OFF') DCNL DCSP if drop_tables: DCNL DCSP  DCSP print_start('Dropping DCSP tables') DCNL DCSP  DCSP for (n, table) in enumerate(reversed(table_objs)): DCNL DCSP  DCSP  DCSP table.drop(bind=engine, checkfirst=True) DCNL DCSP  DCSP  DCSP for column in table.c: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP drop = column.type.drop DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP drop(bind=engine, checkfirst=True) DCNL DCSP  DCSP  DCSP print_status(('%s/%s' % (n, len(table_objs)))) DCNL DCSP  DCSP print_done() DCNL DCSP print_start('Creating DCSP tables') DCNL DCSP for (n, table) in enumerate(table_objs): DCNL DCSP  DCSP table.create() DCNL DCSP  DCSP print_status(('%s/%s' % (n, len(table_objs)))) DCNL DCSP print_done() DCNL DCSP for table_obj in table_objs: DCNL DCSP  DCSP if oracle: DCNL DCSP  DCSP  DCSP table_name = table_obj._original_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP table_name = table_obj.name DCNL DCSP  DCSP insert_stmt = table_obj.insert() DCNL DCSP  DCSP print_start(table_name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP csvpath = ('%s/%s.csv' % (directory, table_name)) DCNL DCSP  DCSP  DCSP csvfile = open(csvpath, 'r') DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP print_done('missing?') DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP csvsize = sum((1 for line in csvfile)) DCNL DCSP  DCSP csvfile.seek(0) DCNL DCSP  DCSP reader = csv.reader(csvfile, lineterminator='\\n') DCNL DCSP  DCSP column_names = [six.text_type(column) for column in next(reader)] DCNL DCSP  DCSP if ((not safe) and (engine.dialect.name == 'postgresql')): DCNL DCSP  DCSP  DCSP not_null_cols = [c for c in column_names if (not table_obj.c[c].nullable)] DCNL DCSP  DCSP  DCSP if not_null_cols: DCNL DCSP  DCSP  DCSP  DCSP force_not_null = ('FORCE DCSP NOT DCSP NULL DCSP ' + ','.join((('\"%s\"' % c) for c in not_null_cols))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP force_not_null = '' DCNL DCSP  DCSP  DCSP raw_conn = engine.raw_connection() DCNL DCSP  DCSP  DCSP command = 'COPY DCSP %(table_name)s DCSP (%(columns)s) DCSP FROM DCSP STDIN DCSP CSV DCSP HEADER DCSP %(force_not_null)s' DCNL DCSP  DCSP  DCSP csvfile.seek(0) DCNL DCSP  DCSP  DCSP raw_conn.cursor().copy_expert((command % dict(table_name=table_name, columns=','.join((('\"%s\"' % c) for c in column_names)), force_not_null=force_not_null)), csvfile) DCNL DCSP  DCSP  DCSP raw_conn.commit() DCNL DCSP  DCSP  DCSP print_done() DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP deferred_rows = [] DCNL DCSP  DCSP seen_ids = set() DCNL DCSP  DCSP self_ref_columns = [] DCNL DCSP  DCSP for column in table_obj.c: DCNL DCSP  DCSP  DCSP if any((x.references(table_obj) for x in column.foreign_keys)): DCNL DCSP  DCSP  DCSP  DCSP self_ref_columns.append(column) DCNL DCSP  DCSP new_rows = [] DCNL DCSP  DCSP def insert_and_commit(): DCNL DCSP  DCSP  DCSP if (not new_rows): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP session.execute(insert_stmt, new_rows) DCNL DCSP  DCSP  DCSP session.commit() DCNL DCSP  DCSP  DCSP new_rows[:] = [] DCNL DCSP  DCSP  DCSP progress = ('%d%%' % ((100 * csvpos) // csvsize)) DCNL DCSP  DCSP  DCSP print_status(progress) DCNL DCSP  DCSP csvpos = 0 DCNL DCSP  DCSP for csvs in reader: DCNL DCSP  DCSP  DCSP csvpos += 1 DCNL DCSP  DCSP  DCSP row_data = {} DCNL DCSP  DCSP  DCSP for (column_name, value) in zip(column_names, csvs): DCNL DCSP  DCSP  DCSP  DCSP column = table_obj.c[column_name] DCNL DCSP  DCSP  DCSP  DCSP if (column.nullable and (value == '')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(column.type, sqlalchemy.types.Boolean): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (value == '0'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value = True DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(value, bytes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = value.decode('utf-8') DCNL DCSP  DCSP  DCSP  DCSP row_data[str(column_name)] = value DCNL DCSP  DCSP  DCSP if self_ref_columns: DCNL DCSP  DCSP  DCSP  DCSP foreign_ids = set((row_data[x.name] for x in self_ref_columns)) DCNL DCSP  DCSP  DCSP  DCSP foreign_ids.discard(None) DCNL DCSP  DCSP  DCSP  DCSP if (not foreign_ids): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen_ids.add(row_data['id']) DCNL DCSP  DCSP  DCSP  DCSP elif foreign_ids.issubset(seen_ids): DCNL DCSP  DCSP  DCSP  DCSP  DCSP insert_and_commit() DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen_ids.add(row_data['id']) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP deferred_rows.append((row_data, foreign_ids)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP new_rows.append(row_data) DCNL DCSP  DCSP  DCSP if (len(new_rows) >= 1000): DCNL DCSP  DCSP  DCSP  DCSP insert_and_commit() DCNL DCSP  DCSP insert_and_commit() DCNL DCSP  DCSP for (row_data, foreign_ids) in deferred_rows: DCNL DCSP  DCSP  DCSP if (not foreign_ids.issubset(seen_ids)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Too DCSP many DCSP levels DCSP of DCSP self-reference! DCSP  DCSP Row DCSP was: DCSP ' + str(row_data))) DCNL DCSP  DCSP  DCSP session.execute(insert_stmt.values(**row_data)) DCNL DCSP  DCSP  DCSP seen_ids.add(row_data['id']) DCNL DCSP  DCSP session.commit() DCNL DCSP  DCSP print_done() DCNL DCSP print_start('Translations') DCNL DCSP transl = translations.Translations(csv_directory=directory) DCNL DCSP new_row_count = 0 DCNL DCSP for (translation_class, rows) in transl.get_load_data(langs): DCNL DCSP  DCSP table_obj = translation_class.__table__ DCNL DCSP  DCSP if (table_obj in table_objs): DCNL DCSP  DCSP  DCSP insert_stmt = table_obj.insert() DCNL DCSP  DCSP  DCSP session.execute(insert_stmt, rows) DCNL DCSP  DCSP  DCSP session.commit() DCNL DCSP  DCSP  DCSP new_row_count += len(rows) DCNL DCSP  DCSP  DCSP print_status(str(new_row_count)) DCNL DCSP if (engine.dialect.name == 'sqlite'): DCNL DCSP  DCSP session.execute('PRAGMA DCSP integrity_check') DCNL DCSP print_done()\n", "intent": "load data from csv files into the given database session .\n", "question_id": 1489}, {"snippet": "def _nose_tools_trivial_transform(): DCNL  DCSP stub = _BUILDER.string_build('__all__ DCSP = DCSP []') DCNL DCSP all_entries = ['ok_', 'eq_'] DCNL DCSP for (pep8_name, method) in _nose_tools_functions(): DCNL DCSP  DCSP all_entries.append(pep8_name) DCNL DCSP  DCSP stub[pep8_name] = method DCNL DCSP all_assign = stub['__all__'].parent DCNL DCSP all_object = astroid.List(all_entries) DCNL DCSP all_object.parent = all_assign DCNL DCSP all_assign.value = all_object DCNL DCSP return stub\n", "intent": "custom transform for the nose .\n", "question_id": 1490}, {"snippet": "def indent_text(text, indent): DCNL  DCSP regex = re.compile('(\\\\\\\\*)(\"\"\"|\\'\\'\\')') DCNL DCSP res = [] DCNL DCSP in_quote = None DCNL DCSP for line in text.splitlines(): DCNL DCSP  DCSP if in_quote: DCNL DCSP  DCSP  DCSP res.append(line) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res.append((indent + line)) DCNL DCSP  DCSP while line: DCNL DCSP  DCSP  DCSP match = regex.search(line) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP if ((len(match.group(1)) % 2) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not in_quote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in_quote = match.group(2)[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (in_quote == match.group(2)[0]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in_quote = None DCNL DCSP  DCSP  DCSP  DCSP line = line[match.end():] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return '\\n'.join(res)\n", "intent": "indent given lines of python code avoiding indenting multiline quoted content .\n", "question_id": 1491}, {"snippet": "def _sparse_argmax_nnz_row(csr_mat): DCNL  DCSP n_rows = csr_mat.shape[0] DCNL DCSP idx = np.empty(n_rows, dtype=np.int) DCNL DCSP for k in range(n_rows): DCNL DCSP  DCSP row = csr_mat[k].tocoo() DCNL DCSP  DCSP idx[k] = row.col[np.argmax(row.data)] DCNL DCSP return idx\n", "intent": "return index of the maximum non-zero index in each row .\n", "question_id": 1492}, {"snippet": "def notify_owner(func): DCNL  DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP old = self._saved_copy() DCNL DCSP  DCSP result = func(self, *args, **kwargs) DCNL DCSP  DCSP self._notify_owners(old) DCNL DCSP  DCSP return result DCNL DCSP wrapper.__doc__ = ('Container DCSP method DCSP ``%s`` DCSP instrumented DCSP to DCSP notify DCSP property DCSP owners' % func.__name__) DCNL DCSP return wrapper\n", "intent": "a decorator for mutating methods of property container classes that notifies owners of the property container about mutating changes .\n", "question_id": 1493}, {"snippet": "def system_specific_scripts(system=None): DCNL  DCSP if is_windows(system): DCNL DCSP  DCSP return ['.bat', '.vbs'] DCNL DCSP elif is_osx(system): DCNL DCSP  DCSP return ['.command', '.sh'] DCNL DCSP else: DCNL DCSP  DCSP return ['.sh']\n", "intent": "all scripting types for that platform .\n", "question_id": 1494}, {"snippet": "def get_entry_ids(entry): DCNL  DCSP ids = {} DCNL DCSP for lazy in [False, True]: DCNL DCSP  DCSP if entry.get(u'trakt_movie_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'trakt'] = entry[u'trakt_movie_id'] DCNL DCSP  DCSP elif entry.get(u'trakt_show_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'trakt'] = entry[u'trakt_show_id'] DCNL DCSP  DCSP elif entry.get(u'trakt_episode_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'trakt'] = entry[u'trakt_episode_id'] DCNL DCSP  DCSP if entry.get(u'tmdb_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'tmdb'] = entry[u'tmdb_id'] DCNL DCSP  DCSP if entry.get(u'tvdb_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'tvdb'] = entry[u'tvdb_id'] DCNL DCSP  DCSP if entry.get(u'imdb_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'imdb'] = entry[u'imdb_id'] DCNL DCSP  DCSP if entry.get(u'tvrage_id', eval_lazy=lazy): DCNL DCSP  DCSP  DCSP ids[u'tvrage'] = entry[u'tvrage_id'] DCNL DCSP  DCSP if ids: DCNL DCSP  DCSP  DCSP break DCNL DCSP return ids\n", "intent": "creates a trakt ids dict from id fields on an entry .\n", "question_id": 1495}, {"snippet": "def import_book(stream, format=None, **kwargs): DCNL  DCSP return Databook().load(stream, format, **kwargs)\n", "intent": "return dataset of given stream .\n", "question_id": 1496}, {"snippet": "def get_real_func(obj): DCNL  DCSP while hasattr(obj, '__wrapped__'): DCNL DCSP  DCSP obj = obj.__wrapped__ DCNL DCSP if isinstance(obj, functools.partial): DCNL DCSP  DCSP obj = obj.func DCNL DCSP return obj\n", "intent": "gets the real function object of the  wrapped object by functools .\n", "question_id": 1497}, {"snippet": "def continued_indentation(logical_line, tokens, indent_level, indent_char, noqa): DCNL  DCSP first_row = tokens[0][2][0] DCNL DCSP nrows = ((1 + tokens[(-1)][2][0]) - first_row) DCNL DCSP if (noqa or (nrows == 1)): DCNL DCSP  DCSP return DCNL DCSP indent_next = logical_line.endswith(u':') DCNL DCSP row = depth = 0 DCNL DCSP valid_hangs = ((DEFAULT_INDENT_SIZE,) if (indent_char != u' DCTB ') else (DEFAULT_INDENT_SIZE, (2 * DEFAULT_INDENT_SIZE))) DCNL DCSP parens = ([0] * nrows) DCNL DCSP rel_indent = ([0] * nrows) DCNL DCSP open_rows = [[0]] DCNL DCSP hangs = [None] DCNL DCSP indent_chances = {} DCNL DCSP last_indent = tokens[0][2] DCNL DCSP indent = [last_indent[1]] DCNL DCSP last_token_multiline = None DCNL DCSP line = None DCNL DCSP last_line = u'' DCNL DCSP last_line_begins_with_multiline = False DCNL DCSP for (token_type, text, start, end, line) in tokens: DCNL DCSP  DCSP newline = (row < (start[0] - first_row)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP row = (start[0] - first_row) DCNL DCSP  DCSP  DCSP newline = ((not last_token_multiline) and (token_type not in (tokenize.NL, tokenize.NEWLINE))) DCNL DCSP  DCSP  DCSP last_line_begins_with_multiline = last_token_multiline DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP last_indent = start DCNL DCSP  DCSP  DCSP rel_indent[row] = (pep8.expand_indent(line) - indent_level) DCNL DCSP  DCSP  DCSP close_bracket = ((token_type == tokenize.OP) and (text in u']})')) DCNL DCSP  DCSP  DCSP for open_row in reversed(open_rows[depth]): DCNL DCSP  DCSP  DCSP  DCSP hang = (rel_indent[row] - rel_indent[open_row]) DCNL DCSP  DCSP  DCSP  DCSP hanging_indent = (hang in valid_hangs) DCNL DCSP  DCSP  DCSP  DCSP if hanging_indent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if hangs[depth]: DCNL DCSP  DCSP  DCSP  DCSP hanging_indent = (hang == hangs[depth]) DCNL DCSP  DCSP  DCSP visual_indent = ((not close_bracket) and (hang > 0) and indent_chances.get(start[1])) DCNL DCSP  DCSP  DCSP if (close_bracket and indent[depth]): DCNL DCSP  DCSP  DCSP  DCSP if (start[1] != indent[depth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, u'E124 DCSP {0}'.format(indent[depth]))) DCNL DCSP  DCSP  DCSP elif (close_bracket and (not hang)): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (indent[depth] and (start[1] < indent[depth])): DCNL DCSP  DCSP  DCSP  DCSP (yield (start, u'E128 DCSP {0}'.format(indent[depth]))) DCNL DCSP  DCSP  DCSP elif (hanging_indent or (indent_next and (rel_indent[row] == (2 * DEFAULT_INDENT_SIZE)))): DCNL DCSP  DCSP  DCSP  DCSP if close_bracket: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, u'E123 DCSP {0}'.format((indent_level + rel_indent[open_row])))) DCNL DCSP  DCSP  DCSP  DCSP hangs[depth] = hang DCNL DCSP  DCSP  DCSP elif (visual_indent is True): DCNL DCSP  DCSP  DCSP  DCSP indent[depth] = start[1] DCNL DCSP  DCSP  DCSP elif (visual_indent in (text, unicode)): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP one_indented = ((indent_level + rel_indent[open_row]) + DEFAULT_INDENT_SIZE) DCNL DCSP  DCSP  DCSP  DCSP if (hang <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = (u'E122', one_indented) DCNL DCSP  DCSP  DCSP  DCSP elif indent[depth]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = (u'E127', indent[depth]) DCNL DCSP  DCSP  DCSP  DCSP elif (hang > DEFAULT_INDENT_SIZE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = (u'E126', one_indented) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hangs[depth] = hang DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = (u'E121', one_indented) DCNL DCSP  DCSP  DCSP  DCSP (yield (start, u'{0} DCSP {1}'.format(*error))) DCNL DCSP  DCSP if (parens[row] and (token_type not in (tokenize.NL, tokenize.COMMENT)) and (not indent[depth])): DCNL DCSP  DCSP  DCSP indent[depth] = start[1] DCNL DCSP  DCSP  DCSP indent_chances[start[1]] = True DCNL DCSP  DCSP elif ((token_type in (tokenize.STRING, tokenize.COMMENT)) or (text in (u'u', u'ur', u'b', u'br'))): DCNL DCSP  DCSP  DCSP indent_chances[start[1]] = unicode DCNL DCSP  DCSP elif ((not indent_chances) and (not row) and (not depth) and (text == u'if')): DCNL DCSP  DCSP  DCSP indent_chances[(end[1] + 1)] = True DCNL DCSP  DCSP elif ((text == u':') and line[end[1]:].isspace()): DCNL DCSP  DCSP  DCSP open_rows[depth].append(row) DCNL DCSP  DCSP if (token_type == tokenize.OP): DCNL DCSP  DCSP  DCSP if (text in u'([{'): DCNL DCSP  DCSP  DCSP  DCSP depth += 1 DCNL DCSP  DCSP  DCSP  DCSP indent.append(0) DCNL DCSP  DCSP  DCSP  DCSP hangs.append(None) DCNL DCSP  DCSP  DCSP  DCSP if (len(open_rows) == depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP open_rows.append([]) DCNL DCSP  DCSP  DCSP  DCSP open_rows[depth].append(row) DCNL DCSP  DCSP  DCSP  DCSP parens[row] += 1 DCNL DCSP  DCSP  DCSP elif ((text in u')]}') and (depth > 0)): DCNL DCSP  DCSP  DCSP  DCSP prev_indent = (indent.pop() or last_indent[1]) DCNL DCSP  DCSP  DCSP  DCSP hangs.pop() DCNL DCSP  DCSP  DCSP  DCSP for d in range(depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (indent[d] > prev_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP indent[d] = 0 DCNL DCSP  DCSP  DCSP  DCSP for ind in list(indent_chances): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ind >= prev_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP del indent_chances[ind] DCNL DCSP  DCSP  DCSP  DCSP del open_rows[(depth + 1):] DCNL DCSP  DCSP  DCSP  DCSP depth -= 1 DCNL DCSP  DCSP  DCSP  DCSP if depth: DCNL DCSP  DCSP  DCSP  DCSP  DCSP indent_chances[indent[depth]] = True DCNL DCSP  DCSP  DCSP  DCSP for idx in range(row, (-1), (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parens[idx]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parens[idx] -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP assert (len(indent) == (depth + 1)) DCNL DCSP  DCSP  DCSP if ((start[1] not in indent_chances) and (not last_line.rstrip().endswith(u','))): DCNL DCSP  DCSP  DCSP  DCSP indent_chances[start[1]] = text DCNL DCSP  DCSP last_token_multiline = (start[0] != end[0]) DCNL DCSP  DCSP if last_token_multiline: DCNL DCSP  DCSP  DCSP rel_indent[(end[0] - first_row)] = rel_indent[row] DCNL DCSP  DCSP last_line = line DCNL DCSP if (indent_next and (not last_line_begins_with_multiline) and (pep8.expand_indent(line) == (indent_level + DEFAULT_INDENT_SIZE))): DCNL DCSP  DCSP pos = (start[0], (indent[0] + 4)) DCNL DCSP  DCSP (yield (pos, u'E125 DCSP {0}'.format((indent_level + (2 * DEFAULT_INDENT_SIZE)))))\n", "intent": "override pep8s function to provide indentation information .\n", "question_id": 1498}, {"snippet": "def delete_snapshot(kwargs=None, call=None): DCNL  DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP delete_snapshot DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if ((not kwargs) or ('name' not in kwargs)): DCNL DCSP  DCSP log.error('A DCSP name DCSP must DCSP be DCSP specified DCSP when DCSP deleting DCSP a DCSP snapshot.') DCNL DCSP  DCSP return False DCNL DCSP name = kwargs['name'] DCNL DCSP conn = get_conn() DCNL DCSP __utils__['cloud.fire_event']('event', 'delete DCSP snapshot', 'salt/cloud/snapshot/deleting', args={'name': name}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP try: DCNL DCSP  DCSP result = conn.destroy_volume_snapshot(conn.ex_get_snapshot(name)) DCNL DCSP except ResourceNotFoundError as exc: DCNL DCSP  DCSP log.error('Snapshot DCSP {0} DCSP could DCSP not DCSP be DCSP found.\\nThe DCSP following DCSP exception DCSP was DCSP thrown DCSP by DCSP libcloud:\\n{1}'.format(name, exc), exc_info_on_loglevel=logging.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP __utils__['cloud.fire_event']('event', 'deleted DCSP snapshot', 'salt/cloud/snapshot/deleted', args={'name': name}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP return result\n", "intent": "permanently delete a disk snapshot .\n", "question_id": 1499}, {"snippet": "@inspect_command() DCNL def stats(state, **kwargs): DCNL  DCSP return state.consumer.controller.stats()\n", "intent": "request worker statistics/information .\n", "question_id": 1500}, {"snippet": "def imsave(fname, arr, vmin=None, vmax=None, cmap=None, format=None, origin=None, dpi=100): DCNL  DCSP from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas DCNL DCSP from matplotlib.figure import Figure DCNL DCSP if ((format == u'png') or (format is None) or (isinstance(fname, six.string_types) and fname.lower().endswith(u'.png'))): DCNL DCSP  DCSP image = AxesImage(None, cmap=cmap, origin=origin) DCNL DCSP  DCSP image.set_data(arr) DCNL DCSP  DCSP image.set_clim(vmin, vmax) DCNL DCSP  DCSP image.write_png(fname) DCNL DCSP else: DCNL DCSP  DCSP fig = Figure(dpi=dpi, frameon=False) DCNL DCSP  DCSP FigureCanvas(fig) DCNL DCSP  DCSP fig.figimage(arr, cmap=cmap, vmin=vmin, vmax=vmax, origin=origin, resize=True) DCNL DCSP  DCSP fig.savefig(fname, dpi=dpi, format=format, transparent=True)\n", "intent": "save an array as in image file .\n", "question_id": 1501}, {"snippet": "def addmodify_repo(module, repodata, old_repos, zypper_version, warnings): DCNL  DCSP repo = repodata['url'] DCNL DCSP cmd = _get_cmd('addrepo', '--check') DCNL DCSP if repodata['name']: DCNL DCSP  DCSP cmd.extend(['--name', repodata['name']]) DCNL DCSP if repodata['priority']: DCNL DCSP  DCSP if (zypper_version >= LooseVersion('1.12.25')): DCNL DCSP  DCSP  DCSP cmd.extend(['--priority', str(repodata['priority'])]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP warnings.append('Setting DCSP priority DCSP only DCSP available DCSP for DCSP zypper DCSP >= DCSP 1.12.25. DCSP Ignoring DCSP priority DCSP argument.') DCNL DCSP if (repodata['enabled'] == '0'): DCNL DCSP  DCSP cmd.append('--disable') DCNL DCSP if (zypper_version >= LooseVersion('1.6.2')): DCNL DCSP  DCSP if (repodata['gpgcheck'] == '1'): DCNL DCSP  DCSP  DCSP cmd.append('--gpgcheck') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd.append('--no-gpgcheck') DCNL DCSP else: DCNL DCSP  DCSP warnings.append('Enabling/disabling DCSP gpgcheck DCSP only DCSP available DCSP for DCSP zypper DCSP >= DCSP 1.6.2. DCSP Using DCSP zypper DCSP default DCSP value.') DCNL DCSP if (repodata['autorefresh'] == '1'): DCNL DCSP  DCSP cmd.append('--refresh') DCNL DCSP cmd.append(repo) DCNL DCSP if (not repo.endswith('.repo')): DCNL DCSP  DCSP cmd.append(repodata['alias']) DCNL DCSP if (old_repos is not None): DCNL DCSP  DCSP for oldrepo in old_repos: DCNL DCSP  DCSP  DCSP remove_repo(module, oldrepo['url']) DCNL DCSP (rc, stdout, stderr) = module.run_command(cmd, check_rc=False) DCNL DCSP return (rc, stdout, stderr)\n", "intent": "adds the repo .\n", "question_id": 1502}, {"snippet": "def test_commented_csv(): DCNL  DCSP t = ascii.read(['#a,b', '1,2', '#3,4'], format='csv') DCNL DCSP assert (t.colnames == ['#a', 'b']) DCNL DCSP assert (len(t) == 2) DCNL DCSP assert (t['#a'][1] == '#3')\n", "intent": "check that csv reader does not have ignore lines with the # comment character which is defined for most basic readers .\n", "question_id": 1503}, {"snippet": "def render_to_ajax(template_name, context=None, context_instance=None): DCNL  DCSP if (context is None): DCNL DCSP  DCSP context = {} DCNL DCSP response_format = 'html' DCNL DCSP if ('response_format_tags' not in context): DCNL DCSP  DCSP context['response_format_tags'] = 'ajax' DCNL DCSP context = preprocess_context_ajax(context) DCNL DCSP content = render_to_string(template_name, context, context_instance, response_format) DCNL DCSP content = convert_to_ajax(content, context_instance) DCNL DCSP context['content'] = json.dumps(content) DCNL DCSP notifications = [] DCNL DCSP if (context_instance and ('request' in context_instance)): DCNL DCSP  DCSP request = context_instance['request'] DCNL DCSP  DCSP maxmsgs = 5 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for message in list(messages.get_messages(request))[:maxmsgs]: DCNL DCSP  DCSP  DCSP  DCSP msgtext = unicode(message) DCNL DCSP  DCSP  DCSP  DCSP if ('updaterecord:' in msgtext[:13]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP update_id = int(msgtext.split(':', 1)[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP update = UpdateRecord.objects.get(pk=update_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message = {'message': update.get_full_message(), 'tags': message.tags} DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if update.author: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((update.record_type == 'manual') or (update.record_type == 'share')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message['image'] = update.author.get_contact().get_picture() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message['title'] = unicode(update.author) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for obj in update.about.all(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP message['message'] = ('(%s) DCSP %s:<br DCSP />%s' % (obj.get_human_type(), unicode(obj), message['message'])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP notifications.append(message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP notifications.append({'message': unicode(message), 'tags': message.tags}) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP context['notifications'] = json.dumps(notifications) DCNL DCSP rendered_string = render_to_string('ajax_base', context, context_instance, response_format='json') DCNL DCSP return rendered_string\n", "intent": "render request into json object to be handled by ajax on the server-side .\n", "question_id": 1504}, {"snippet": "def _utf8(s): DCNL  DCSP if (not isinstance(s, bytes)): DCNL DCSP  DCSP s = s.encode('utf8') DCNL DCSP return s\n", "intent": "ensure utf8 bytes .\n", "question_id": 1505}, {"snippet": "@login_required DCNL def map_remove(request, mapid, template='maps/map_remove.html'): DCNL  DCSP map_obj = _resolve_map(request, mapid, 'base.delete_resourcebase', _PERMISSION_MSG_VIEW) DCNL DCSP if (request.method == 'GET'): DCNL DCSP  DCSP return render_to_response(template, RequestContext(request, {'map': map_obj})) DCNL DCSP elif (request.method == 'POST'): DCNL DCSP  DCSP if getattr(settings, 'SLACK_ENABLED', False): DCNL DCSP  DCSP  DCSP slack_message = None DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from geonode.contrib.slack.utils import build_slack_message_map DCNL DCSP  DCSP  DCSP  DCSP slack_message = build_slack_message_map('map_delete', map_obj) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print 'Could DCSP not DCSP build DCSP slack DCSP message DCSP for DCSP delete DCSP map.' DCNL DCSP  DCSP  DCSP delete_map.delay(object_id=map_obj.id) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from geonode.contrib.slack.utils import send_slack_messages DCNL DCSP  DCSP  DCSP  DCSP send_slack_messages(slack_message) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print 'Could DCSP not DCSP send DCSP slack DCSP message DCSP for DCSP delete DCSP map.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delete_map.delay(object_id=map_obj.id) DCNL DCSP  DCSP return HttpResponseRedirect(reverse('maps_browse'))\n", "intent": "delete a map .\n", "question_id": 1506}, {"snippet": "def libvlc_media_list_lock(p_ml): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_list_lock', None) or _Cfunction('libvlc_media_list_lock', ((1,),), None, None, MediaList)) DCNL DCSP return f(p_ml)\n", "intent": "get lock on media list items .\n", "question_id": 1507}, {"snippet": "def test_user_columns_flag(script, data, virtualenv): DCNL  DCSP virtualenv.system_site_packages = True DCNL DCSP script.pip('install', '-f', data.find_links, '--no-index', 'simple==1.0') DCNL DCSP script.pip('install', '-f', data.find_links, '--no-index', '--user', 'simple2==2.0') DCNL DCSP result = script.pip('list', '--user', '--format=columns') DCNL DCSP assert ('Package' in result.stdout) DCNL DCSP assert ('Version' in result.stdout) DCNL DCSP assert ('simple2 DCSP (2.0)' not in result.stdout) DCNL DCSP assert ('simple2 DCSP 2.0' in result.stdout), str(result)\n", "intent": "test the behavior of --user --format=columns flags in the list command .\n", "question_id": 1508}, {"snippet": "def test_scharr_v_horizontal(): DCNL  DCSP (i, j) = np.mgrid[(-5):6, (-5):6] DCNL DCSP image = (i >= 0).astype(float) DCNL DCSP result = filters.scharr_v(image) DCNL DCSP assert_allclose(result, 0)\n", "intent": "vertical scharr on a horizontal edge should be zero .\n", "question_id": 1509}, {"snippet": "def mktemp(suffix='', prefix=template, dir=None): DCNL  DCSP if (dir is None): DCNL DCSP  DCSP dir = gettempdir() DCNL DCSP names = _get_candidate_names() DCNL DCSP for seq in range(TMP_MAX): DCNL DCSP  DCSP name = next(names) DCNL DCSP  DCSP file = _os.path.join(dir, ((prefix + name) + suffix)) DCNL DCSP  DCSP if (not _exists(file)): DCNL DCSP  DCSP  DCSP return file DCNL DCSP raise FileExistsError(_errno.EEXIST, 'No DCSP usable DCSP temporary DCSP filename DCSP found')\n", "intent": "user-callable function to return a unique temporary file name .\n", "question_id": 1510}, {"snippet": "def ceil(x): DCNL  DCSP return Ceil()(x)\n", "intent": "elementwise ceil function .\n", "question_id": 1511}, {"snippet": "def find_parameters(instance, fields=None): DCNL  DCSP if (fields is None): DCNL DCSP  DCSP fields = NODES[('%s-widget' % instance.data['type'])].FIELDS.keys() DCNL DCSP params = [] DCNL DCSP for field in fields: DCNL DCSP  DCSP data = instance.data['properties'][field] DCNL DCSP  DCSP if ((field == 'sla') and (not instance.sla_enabled)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(data, list): DCNL DCSP  DCSP  DCSP params.extend(find_json_parameters(data)) DCNL DCSP  DCSP elif isinstance(data, basestring): DCNL DCSP  DCSP  DCSP for match in Template.pattern.finditer(data): DCNL DCSP  DCSP  DCSP  DCSP name = match.group('braced') DCNL DCSP  DCSP  DCSP  DCSP if (name is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP params.append(name) DCNL DCSP return params\n", "intent": "find parameters in the given fields .\n", "question_id": 1512}, {"snippet": "def _shell_command(command): DCNL  DCSP repo_dir = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP command_subprocess = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=repo_dir, universal_newlines=True) DCNL DCSP return command_subprocess.communicate()[0]\n", "intent": "return the first result of a shell command .\n", "question_id": 1513}, {"snippet": "def comprehensive_logger(logger=None, logging=True, maxlength=250, nowait=False): DCNL  DCSP def default_logger(msg): DCNL DCSP  DCSP print msg DCNL DCSP if (logger == None): DCNL DCSP  DCSP logger = default_logger DCNL DCSP def get_args(*args, **kwargs): DCNL DCSP  DCSP all_args = [] DCNL DCSP  DCSP for (i, arg) in enumerate(args): DCNL DCSP  DCSP  DCSP itm = ((('pos' + str(i)) + ': DCSP ') + str(arg)[:maxlength]) DCNL DCSP  DCSP  DCSP all_args.append(itm) DCNL DCSP  DCSP for (k, v) in kwargs.iteritems(): DCNL DCSP  DCSP  DCSP itm = ((str(k) + ': DCSP ') + str(v)[:maxlength]) DCNL DCSP  DCSP  DCSP all_args.append(itm) DCNL DCSP  DCSP return all_args DCNL DCSP def decorater(func): DCNL DCSP  DCSP @wraps(func) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP if (logging and (logger != None)): DCNL DCSP  DCSP  DCSP  DCSP logger(((((func.__module__ + '.') + func.__name__) + ' DCSP received: DCSP ') + ', DCSP '.join(get_args(*args, **kwargs)))) DCNL DCSP  DCSP  DCSP if nowait: DCNL DCSP  DCSP  DCSP  DCSP func(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP logger((((func.__module__ + '.') + func.__name__) + ' DCSP -nowait')) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start = time.time() DCNL DCSP  DCSP  DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP end = time.time() DCNL DCSP  DCSP  DCSP  DCSP if (logging and (logger != None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger((((((((func.__module__ + '.') + func.__name__) + ' DCSP [') + str((end - start))) + '] DCSP ') + ' DCSP returns: DCSP ') + str(result)[:maxlength])) DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return wrapper DCNL DCSP return decorater\n", "intent": "decorator to log the inputs and outputs of functions .\n", "question_id": 1514}, {"snippet": "def do_title(s): DCNL  DCSP return soft_unicode(s).title()\n", "intent": "return a titlecased version of the value .\n", "question_id": 1515}, {"snippet": "def pr_realm(entity): DCNL  DCSP if (not entity): DCNL DCSP  DCSP return [] DCNL DCSP s3db = current.s3db DCNL DCSP atable = s3db.pr_affiliation DCNL DCSP rtable = s3db.pr_role DCNL DCSP query = (((((atable.deleted != True) & (atable.role_id == rtable.id)) & (atable.pe_id == entity)) & (rtable.deleted != True)) & (rtable.role_type == OU)) DCNL DCSP rows = current.db(query).select(rtable.pe_id) DCNL DCSP realm = [row.pe_id for row in rows] DCNL DCSP return realm\n", "intent": "get the default realm  of an entity .\n", "question_id": 1516}, {"snippet": "def CDLCONCEALBABYSWALL(barDs, count): DCNL  DCSP return call_talib_with_ohlc(barDs, count, talib.CDLCONCEALBABYSWALL)\n", "intent": "concealing baby swallow .\n", "question_id": 1517}, {"snippet": "def _normalize_key(session, key_info): DCNL  DCSP if (not key_info.get('uids')): DCNL DCSP  DCSP key_info['uids'] = [{'name': '', 'email': '', 'comment': ''}] DCNL DCSP if (key_info.get('vcards') is None): DCNL DCSP  DCSP key_info['vcards'] = {} DCNL DCSP for uid in key_info['uids']: DCNL DCSP  DCSP uid['name'] = uid.get('name', _('Anonymous')) DCNL DCSP  DCSP uid['email'] = e = uid.get('email', '') DCNL DCSP  DCSP uid['comment'] = uid.get('comment', '') DCNL DCSP  DCSP if (e and (e not in key_info['vcards'])): DCNL DCSP  DCSP  DCSP vcard = session.config.vcards.get_vcard(e) DCNL DCSP  DCSP  DCSP if vcard: DCNL DCSP  DCSP  DCSP  DCSP ai = AddressInfo(e, uid['name'], vcard=vcard) DCNL DCSP  DCSP  DCSP  DCSP key_info['vcards'][e] = ai DCNL DCSP for (key, default) in [('on_keychain', False), ('keysize', '0'), ('keytype_name', 'unknown'), ('created', '1970-01-01 DCSP 00:00:00'), ('fingerprint', 'FINGERPRINT_IS_MISSING'), ('validity', '')]: DCNL DCSP  DCSP if (key not in key_info): DCNL DCSP  DCSP  DCSP key_info[key] = default\n", "intent": "make sure expected attributes are on all keys .\n", "question_id": 1518}, {"snippet": "def rec_join(key, r1, r2, jointype=u'inner', defaults=None, r1postfix=u'1', r2postfix=u'2'): DCNL  DCSP if cbook.is_string_like(key): DCNL DCSP  DCSP key = (key,) DCNL DCSP for name in key: DCNL DCSP  DCSP if (name not in r1.dtype.names): DCNL DCSP  DCSP  DCSP raise ValueError((u'r1 DCSP does DCSP not DCSP have DCSP key DCSP field DCSP %s' % name)) DCNL DCSP  DCSP if (name not in r2.dtype.names): DCNL DCSP  DCSP  DCSP raise ValueError((u'r2 DCSP does DCSP not DCSP have DCSP key DCSP field DCSP %s' % name)) DCNL DCSP def makekey(row): DCNL DCSP  DCSP return tuple([row[name] for name in key]) DCNL DCSP r1d = {makekey(row): i for (i, row) in enumerate(r1)} DCNL DCSP r2d = {makekey(row): i for (i, row) in enumerate(r2)} DCNL DCSP r1keys = set(r1d) DCNL DCSP r2keys = set(r2d) DCNL DCSP common_keys = (r1keys & r2keys) DCNL DCSP r1ind = np.array([r1d[k] for k in common_keys]) DCNL DCSP r2ind = np.array([r2d[k] for k in common_keys]) DCNL DCSP common_len = len(common_keys) DCNL DCSP left_len = right_len = 0 DCNL DCSP if ((jointype == u'outer') or (jointype == u'leftouter')): DCNL DCSP  DCSP left_keys = r1keys.difference(r2keys) DCNL DCSP  DCSP left_ind = np.array([r1d[k] for k in left_keys]) DCNL DCSP  DCSP left_len = len(left_ind) DCNL DCSP if (jointype == u'outer'): DCNL DCSP  DCSP right_keys = r2keys.difference(r1keys) DCNL DCSP  DCSP right_ind = np.array([r2d[k] for k in right_keys]) DCNL DCSP  DCSP right_len = len(right_ind) DCNL DCSP def key_desc(name): DCNL DCSP  DCSP u'\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP name DCSP is DCSP a DCSP string DCSP key, DCSP use DCSP the DCSP larger DCSP size DCSP of DCSP r1 DCSP or DCSP r2 DCSP before\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP merging\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP dt1 = r1.dtype[name] DCNL DCSP  DCSP if (dt1.type != np.string_): DCNL DCSP  DCSP  DCSP return (name, dt1.descr[0][1]) DCNL DCSP  DCSP dt2 = r2.dtype[name] DCNL DCSP  DCSP if (dt1 != dt2): DCNL DCSP  DCSP  DCSP msg = u\"The DCSP '{0}' DCSP fields DCSP in DCSP arrays DCSP 'r1' DCSP and DCSP 'r2' DCSP must DCSP have DCSP the DCSP same\" DCNL DCSP  DCSP  DCSP msg += u' DCSP dtype.' DCNL DCSP  DCSP  DCSP raise ValueError(msg.format(name)) DCNL DCSP  DCSP if (dt1.num > dt2.num): DCNL DCSP  DCSP  DCSP return (name, dt1.descr[0][1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (name, dt2.descr[0][1]) DCNL DCSP keydesc = [key_desc(name) for name in key] DCNL DCSP def mapped_r1field(name): DCNL DCSP  DCSP u'\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP column DCSP name DCSP in DCSP *newrec* DCSP that DCSP corresponds DCSP to DCSP the DCSP column DCSP in DCSP *r1*.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if ((name in key) or (name not in r2.dtype.names)): DCNL DCSP  DCSP  DCSP return name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (name + r1postfix) DCNL DCSP def mapped_r2field(name): DCNL DCSP  DCSP u'\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP column DCSP name DCSP in DCSP *newrec* DCSP that DCSP corresponds DCSP to DCSP the DCSP column DCSP in DCSP *r2*.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if ((name in key) or (name not in r1.dtype.names)): DCNL DCSP  DCSP  DCSP return name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (name + r2postfix) DCNL DCSP r1desc = [(mapped_r1field(desc[0]), desc[1]) for desc in r1.dtype.descr if (desc[0] not in key)] DCNL DCSP r2desc = [(mapped_r2field(desc[0]), desc[1]) for desc in r2.dtype.descr if (desc[0] not in key)] DCNL DCSP all_dtypes = ((keydesc + r1desc) + r2desc) DCNL DCSP if six.PY2: DCNL DCSP  DCSP all_dtypes = [(name.encode(u'utf-8'), dt) for (name, dt) in all_dtypes] DCNL DCSP newdtype = np.dtype(all_dtypes) DCNL DCSP newrec = np.recarray((((common_len + left_len) + right_len),), dtype=newdtype) DCNL DCSP if (defaults is not None): DCNL DCSP  DCSP for thiskey in defaults: DCNL DCSP  DCSP  DCSP if (thiskey not in newdtype.names): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn((u'rec_join DCSP defaults DCSP key=\"%s\" DCSP not DCSP in DCSP new DCSP dtype DCSP names DCSP \"%s\"' % (thiskey, newdtype.names))) DCNL DCSP for name in newdtype.names: DCNL DCSP  DCSP dt = newdtype[name] DCNL DCSP  DCSP if (dt.kind in (u'f', u'i')): DCNL DCSP  DCSP  DCSP newrec[name] = 0 DCNL DCSP if ((jointype != u'inner') and (defaults is not None)): DCNL DCSP  DCSP newrec_fields = list(newrec.dtype.fields) DCNL DCSP  DCSP for (k, v) in six.iteritems(defaults): DCNL DCSP  DCSP  DCSP if (k in newrec_fields): DCNL DCSP  DCSP  DCSP  DCSP newrec[k] = v DCNL DCSP for field in r1.dtype.names: DCNL DCSP  DCSP newfield = mapped_r1field(field) DCNL DCSP  DCSP if common_len: DCNL DCSP  DCSP  DCSP newrec[newfield][:common_len] = r1[field][r1ind] DCNL DCSP  DCSP if (((jointype == u'outer') or (jointype == u'leftouter')) and left_len): DCNL DCSP  DCSP  DCSP newrec[newfield][common_len:(common_len + left_len)] = r1[field][left_ind] DCNL DCSP for field in r2.dtype.names: DCNL DCSP  DCSP newfield = mapped_r2field(field) DCNL DCSP  DCSP if ((field not in key) and common_len): DCNL DCSP  DCSP  DCSP newrec[newfield][:common_len] = r2[field][r2ind] DCNL DCSP  DCSP if ((jointype == u'outer') and right_len): DCNL DCSP  DCSP  DCSP newrec[newfield][(- right_len):] = r2[field][right_ind] DCNL DCSP newrec.sort(order=key) DCNL DCSP return newrec\n", "intent": "join record arrays *r1* and *r2* on *key*; *key* is a tuple of field names -- if *key* is a string it is assumed to be a single attribute name .\n", "question_id": 1519}, {"snippet": "def check_response(method): DCNL  DCSP @functools.wraps(method) DCNL DCSP def wrapped(self, *args, **kwargs): DCNL DCSP  DCSP response = method(self, *args, **kwargs) DCNL DCSP  DCSP status = response.status_code DCNL DCSP  DCSP if (status >= 400): DCNL DCSP  DCSP  DCSP if (response.status_code == 429): DCNL DCSP  DCSP  DCSP  DCSP self.handle_429(resp, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP return method(self, *args, **kwargs).json() DCNL DCSP  DCSP  DCSP msg_args = (response, response.text, response.headers) DCNL DCSP  DCSP  DCSP msg = ('Bad DCSP api DCSP response: DCSP %r DCSP %r DCSP %r' % msg_args) DCNL DCSP  DCSP  DCSP raise BadAPIResponse(response, msg) DCNL DCSP  DCSP return response.json() DCNL DCSP return wrapped\n", "intent": "decorated functions will run .\n", "question_id": 1520}, {"snippet": "def get_installed_version(dist_name): DCNL  DCSP req = pkg_resources.Requirement.parse(dist_name) DCNL DCSP working_set = pkg_resources.WorkingSet() DCNL DCSP dist = working_set.find(req) DCNL DCSP return (dist.version if dist else None)\n", "intent": "get the installed version of dist_name avoiding pkg_resources cache .\n", "question_id": 1521}, {"snippet": "def get_cache(module): DCNL  DCSP cache = None DCNL DCSP try: DCNL DCSP  DCSP cache = apt.Cache() DCNL DCSP except SystemError: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP if ('/var/lib/apt/lists/' in str(e).lower()): DCNL DCSP  DCSP  DCSP retries = 0 DCNL DCSP  DCSP  DCSP while (retries < 2): DCNL DCSP  DCSP  DCSP  DCSP (rc, so, se) = module.run_command(['apt-get', 'update', '-q']) DCNL DCSP  DCSP  DCSP  DCSP retries += 1 DCNL DCSP  DCSP  DCSP  DCSP if (rc == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (rc != 0): DCNL DCSP  DCSP  DCSP  DCSP module.fail_json(msg=('Updating DCSP the DCSP cache DCSP to DCSP correct DCSP corrupt DCSP package DCSP lists DCSP failed:\\n%s\\n%s' % (str(e), (str(so) + str(se))))) DCNL DCSP  DCSP  DCSP cache = apt.Cache() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP module.fail_json(msg=str(e)) DCNL DCSP return cache\n", "intent": "attempt to get the cache object and update till it works .\n", "question_id": 1522}, {"snippet": "def _retrieve_users(): DCNL  DCSP return __salt__['users.config']()\n", "intent": "retrieves configured users .\n", "question_id": 1523}, {"snippet": "def missing(name): DCNL  DCSP return (name not in get_all())\n", "intent": "the inverse of s6 .\n", "question_id": 1524}, {"snippet": "def bootstrap(request): DCNL  DCSP all_bootstraps = [(app, app.get_bootstrap_file()) for app in appmanager.DESKTOP_APPS if request.user.has_hue_permission(action='access', app=app.name)] DCNL DCSP concatenated = [('\\n/* DCSP %s DCSP */\\n%s' % (app.name, b.read())) for (app, b) in all_bootstraps if (b is not None)] DCNL DCSP return HttpResponse(concatenated, content_type='text/javascript')\n", "intent": "concatenates bootstrap .\n", "question_id": 1525}, {"snippet": "def send_product_alerts(product): DCNL  DCSP stockrecords = product.stockrecords.all() DCNL DCSP num_stockrecords = len(stockrecords) DCNL DCSP if (not num_stockrecords): DCNL DCSP  DCSP return DCNL DCSP logger.info(\"Sending DCSP alerts DCSP for DCSP '%s'\", product) DCNL DCSP alerts = ProductAlert.objects.filter(product_id__in=(product.id, product.parent_id), status=ProductAlert.ACTIVE) DCNL DCSP num_alerts = alerts.count() DCNL DCSP if (num_stockrecords == 1): DCNL DCSP  DCSP num_in_stock = stockrecords[0].num_in_stock DCNL DCSP  DCSP hurry_mode = ((num_in_stock is not None) and (num_alerts < num_in_stock)) DCNL DCSP else: DCNL DCSP  DCSP result = stockrecords.aggregate(max_in_stock=Max('num_in_stock')) DCNL DCSP  DCSP hurry_mode = ((result['max_in_stock'] is not None) and (num_alerts < result['max_in_stock'])) DCNL DCSP message_tpl = loader.get_template('customer/alerts/message.html') DCNL DCSP email_subject_tpl = loader.get_template('customer/alerts/emails/alert_subject.txt') DCNL DCSP email_body_tpl = loader.get_template('customer/alerts/emails/alert_body.txt') DCNL DCSP emails = [] DCNL DCSP num_notifications = 0 DCNL DCSP selector = Selector() DCNL DCSP for alert in alerts: DCNL DCSP  DCSP strategy = selector.strategy(user=alert.user) DCNL DCSP  DCSP data = strategy.fetch_for_product(product) DCNL DCSP  DCSP if (not data.availability.is_available_to_buy): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ctx = Context({'alert': alert, 'site': Site.objects.get_current(), 'hurry': hurry_mode}) DCNL DCSP  DCSP if alert.user: DCNL DCSP  DCSP  DCSP num_notifications += 1 DCNL DCSP  DCSP  DCSP services.notify_user(alert.user, message_tpl.render(ctx)) DCNL DCSP  DCSP emails.append(mail.EmailMessage(email_subject_tpl.render(ctx).strip(), email_body_tpl.render(ctx), settings.OSCAR_FROM_EMAIL, [alert.get_email_address()])) DCNL DCSP  DCSP alert.close() DCNL DCSP if emails: DCNL DCSP  DCSP connection = mail.get_connection() DCNL DCSP  DCSP connection.open() DCNL DCSP  DCSP connection.send_messages(emails) DCNL DCSP  DCSP connection.close() DCNL DCSP logger.info('Sent DCSP %d DCSP notifications DCSP and DCSP %d DCSP emails', num_notifications, len(emails))\n", "intent": "check for notifications for this product and send email to users if the product is back in stock .\n", "question_id": 1526}, {"snippet": "def _SpaceRequiredBetween(left, right): DCNL  DCSP lval = left.value DCNL DCSP rval = right.value DCNL DCSP if (left.is_pseudo_paren and _IsIdNumberStringToken(right) and left.previous_token and _IsIdNumberStringToken(left.previous_token)): DCNL DCSP  DCSP return True DCNL DCSP if (left.is_pseudo_paren or right.is_pseudo_paren): DCNL DCSP  DCSP if left.OpensScope(): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP if (left.is_continuation or right.is_continuation): DCNL DCSP  DCSP return False DCNL DCSP if (right.name in pytree_utils.NONSEMANTIC_TOKENS): DCNL DCSP  DCSP return False DCNL DCSP if (_IsIdNumberStringToken(left) and _IsIdNumberStringToken(right)): DCNL DCSP  DCSP return True DCNL DCSP if ((lval == ',') and (rval == ':')): DCNL DCSP  DCSP return True DCNL DCSP if (rval in ':,'): DCNL DCSP  DCSP return False DCNL DCSP if ((lval == ',') and (rval in ']})')): DCNL DCSP  DCSP return style.Get('SPACE_BETWEEN_ENDING_COMMA_AND_CLOSING_BRACKET') DCNL DCSP if (lval == ','): DCNL DCSP  DCSP return True DCNL DCSP if ((lval == 'from') and (rval == '.')): DCNL DCSP  DCSP return True DCNL DCSP if ((lval == '.') and (rval == 'import')): DCNL DCSP  DCSP return True DCNL DCSP if ((right.is_keyword or right.is_name) and (left.is_keyword or left.is_name)): DCNL DCSP  DCSP return True DCNL DCSP if left.is_string: DCNL DCSP  DCSP if ((rval == '=') and (format_token.Subtype.DEFAULT_OR_NAMED_ASSIGN_ARG_LIST in right.subtypes)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (rval not in '[)]}.'): DCNL DCSP  DCSP  DCSP return True DCNL DCSP if (left.is_binary_op and (lval != '**') and _IsUnaryOperator(right)): DCNL DCSP  DCSP return True DCNL DCSP if (_IsUnaryOperator(left) and _IsUnaryOperator(right)): DCNL DCSP  DCSP return False DCNL DCSP if (left.is_binary_op or right.is_binary_op): DCNL DCSP  DCSP if ((lval == '**') or (rval == '**')): DCNL DCSP  DCSP  DCSP return style.Get('SPACES_AROUND_POWER_OPERATOR') DCNL DCSP  DCSP return True DCNL DCSP if (_IsUnaryOperator(left) and (lval != 'not') and (right.is_name or right.is_number or (rval == '('))): DCNL DCSP  DCSP return False DCNL DCSP if ((format_token.Subtype.SUBSCRIPT_COLON in left.subtypes) or (format_token.Subtype.SUBSCRIPT_COLON in right.subtypes)): DCNL DCSP  DCSP return False DCNL DCSP if ((format_token.Subtype.DEFAULT_OR_NAMED_ASSIGN in left.subtypes) or (format_token.Subtype.DEFAULT_OR_NAMED_ASSIGN in right.subtypes)): DCNL DCSP  DCSP return ((lval == ':') or style.Get('SPACES_AROUND_DEFAULT_OR_NAMED_ASSIGN')) DCNL DCSP if ((format_token.Subtype.VARARGS_LIST in left.subtypes) or (format_token.Subtype.VARARGS_LIST in right.subtypes)): DCNL DCSP  DCSP return False DCNL DCSP if ((format_token.Subtype.VARARGS_STAR in left.subtypes) or (format_token.Subtype.KWARGS_STAR_STAR in left.subtypes)): DCNL DCSP  DCSP return False DCNL DCSP if ((lval == '@') and (format_token.Subtype.DECORATOR in left.subtypes)): DCNL DCSP  DCSP return False DCNL DCSP if ((lval == '.') or (rval == '.')): DCNL DCSP  DCSP return False DCNL DCSP if (((lval == '(') and (rval == ')')) or ((lval == '[') and (rval == ']')) or ((lval == '{') and (rval == '}'))): DCNL DCSP  DCSP return False DCNL DCSP if ((lval in pytree_utils.OPENING_BRACKETS) and (rval in pytree_utils.OPENING_BRACKETS)): DCNL DCSP  DCSP return False DCNL DCSP if ((lval in pytree_utils.CLOSING_BRACKETS) and (rval in pytree_utils.CLOSING_BRACKETS)): DCNL DCSP  DCSP return False DCNL DCSP if ((lval in pytree_utils.CLOSING_BRACKETS) and (rval in '([')): DCNL DCSP  DCSP return False DCNL DCSP if ((lval in pytree_utils.OPENING_BRACKETS) and _IsIdNumberStringToken(right)): DCNL DCSP  DCSP return False DCNL DCSP if (left.is_name and (rval in '([')): DCNL DCSP  DCSP return False DCNL DCSP if (rval in pytree_utils.CLOSING_BRACKETS): DCNL DCSP  DCSP return False DCNL DCSP if ((lval == 'print') and (rval == '(')): DCNL DCSP  DCSP return False DCNL DCSP if ((lval in pytree_utils.OPENING_BRACKETS) and _IsUnaryOperator(right)): DCNL DCSP  DCSP return False DCNL DCSP if ((lval in pytree_utils.OPENING_BRACKETS) and ((format_token.Subtype.VARARGS_STAR in right.subtypes) or (format_token.Subtype.KWARGS_STAR_STAR in right.subtypes))): DCNL DCSP  DCSP return False DCNL DCSP if (rval == ';'): DCNL DCSP  DCSP return False DCNL DCSP if ((lval == '(') and (rval == 'await')): DCNL DCSP  DCSP return False DCNL DCSP return True\n", "intent": "return true if a space is required between the left and right token .\n", "question_id": 1527}, {"snippet": "def test_imap_folder_sync_enabled(db, default_account): DCNL  DCSP create_foldersyncstatuses(db, default_account) DCNL DCSP assert all([fs.sync_enabled for fs in default_account.foldersyncstatuses]) DCNL DCSP default_account.disable_sync('testing') DCNL DCSP db.session.commit() DCNL DCSP assert all([(not fs.sync_enabled) for fs in default_account.foldersyncstatuses])\n", "intent": "test that the imap folders sync_enabled property mirrors the account level sync_enabled property .\n", "question_id": 1528}, {"snippet": "def date_range(start, end): DCNL  DCSP if (getattr(start, 'date', None) is not None): DCNL DCSP  DCSP start = start.date() DCNL DCSP if (getattr(end, 'date', None) is not None): DCNL DCSP  DCSP end = end.date() DCNL DCSP days = ((end - start).days + 1) DCNL DCSP return ((start + datetime.timedelta(days=d)) for d in xrange(days))\n", "intent": "return an iterator providing the dates between start and end .\n", "question_id": 1529}, {"snippet": "def to_galaxy_parameters(tool, as_dict): DCNL  DCSP inputs = tool.inputs DCNL DCSP galaxy_request = {} DCNL DCSP def from_simple_value(input, param_dict_value, cwl_type=None): DCNL DCSP  DCSP if (cwl_type == 'json'): DCNL DCSP  DCSP  DCSP return json.dumps(param_dict_value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return param_dict_value DCNL DCSP for (input_name, input) in inputs.iteritems(): DCNL DCSP  DCSP as_dict_value = as_dict.get(input_name, NOT_PRESENT) DCNL DCSP  DCSP galaxy_input_type = input.type DCNL DCSP  DCSP if (galaxy_input_type == 'repeat'): DCNL DCSP  DCSP  DCSP if (input_name not in as_dict): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP only_input = input.inputs.values()[0] DCNL DCSP  DCSP  DCSP for (index, value) in enumerate(as_dict_value): DCNL DCSP  DCSP  DCSP  DCSP key = ('%s_repeat_0|%s' % (input_name, only_input.name)) DCNL DCSP  DCSP  DCSP  DCSP galaxy_value = from_simple_value(only_input, value) DCNL DCSP  DCSP  DCSP  DCSP galaxy_request[key] = galaxy_value DCNL DCSP  DCSP elif (galaxy_input_type == 'conditional'): DCNL DCSP  DCSP  DCSP case_strings = input.case_strings DCNL DCSP  DCSP  DCSP if (((as_dict_value is NOT_PRESENT) or (as_dict_value is None)) and ('null' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'null' DCNL DCSP  DCSP  DCSP elif ((as_dict_value is NOT_PRESENT) or (as_dict_value is None)): DCNL DCSP  DCSP  DCSP  DCSP raise RequestParameterInvalidException(('Cannot DCSP translate DCSP CWL DCSP datatype DCSP - DCSP value DCSP [%s] DCSP of DCSP type DCSP [%s] DCSP with DCSP case_strings DCSP [%s]. DCSP Non-null DCSP property DCSP must DCSP be DCSP set.' % (as_dict_value, type(as_dict_value), case_strings))) DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, bool) and ('boolean' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'boolean' DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, int) and ('integer' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'integer' DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, int) and ('long' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'long' DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, (int, float)) and ('float' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'float' DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, (int, float)) and ('double' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'double' DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, string_types) and ('string' in case_strings)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'string' DCNL DCSP  DCSP  DCSP elif (isinstance(as_dict_value, dict) and ('src' in as_dict_value) and ('id' in as_dict_value)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'File' DCNL DCSP  DCSP  DCSP elif (('json' in case_strings) and (as_dict_value is not None)): DCNL DCSP  DCSP  DCSP  DCSP cwl_type = 'json' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise RequestParameterInvalidException(('Cannot DCSP translate DCSP CWL DCSP datatype DCSP - DCSP value DCSP [%s] DCSP of DCSP type DCSP [%s] DCSP with DCSP case_strings DCSP [%s].' % (as_dict_value, type(as_dict_value), case_strings))) DCNL DCSP  DCSP  DCSP galaxy_request[('%s|_cwl__type_' % input_name)] = cwl_type DCNL DCSP  DCSP  DCSP if (cwl_type != 'null'): DCNL DCSP  DCSP  DCSP  DCSP current_case_index = input.get_current_case(cwl_type) DCNL DCSP  DCSP  DCSP  DCSP current_case_inputs = input.cases[current_case_index].inputs DCNL DCSP  DCSP  DCSP  DCSP current_case_input = current_case_inputs['_cwl__value_'] DCNL DCSP  DCSP  DCSP  DCSP galaxy_value = from_simple_value(current_case_input, as_dict_value, cwl_type) DCNL DCSP  DCSP  DCSP  DCSP galaxy_request[('%s|_cwl__value_' % input_name)] = galaxy_value DCNL DCSP  DCSP elif (as_dict_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP galaxy_value = from_simple_value(input, as_dict_value) DCNL DCSP  DCSP  DCSP galaxy_request[input_name] = galaxy_value DCNL DCSP log.info(('Converted DCSP galaxy_request DCSP is DCSP %s' % galaxy_request)) DCNL DCSP return galaxy_request\n", "intent": "tool is galaxys representation of the tool and as_dict is a galaxified representation of the input json .\n", "question_id": 1530}, {"snippet": "def _get_repo_options(**kwargs): DCNL  DCSP fromrepo = kwargs.get('fromrepo', '') DCNL DCSP repo = kwargs.get('repo', '') DCNL DCSP disablerepo = kwargs.get('disablerepo', '') DCNL DCSP enablerepo = kwargs.get('enablerepo', '') DCNL DCSP if (repo and (not fromrepo)): DCNL DCSP  DCSP fromrepo = repo DCNL DCSP ret = [] DCNL DCSP if fromrepo: DCNL DCSP  DCSP log.info(\"Restricting DCSP to DCSP repo DCSP '%s'\", fromrepo) DCNL DCSP  DCSP ret.extend(['--disablerepo=*', ('--enablerepo=' + fromrepo)]) DCNL DCSP else: DCNL DCSP  DCSP if disablerepo: DCNL DCSP  DCSP  DCSP targets = ([disablerepo] if (not isinstance(disablerepo, list)) else disablerepo) DCNL DCSP  DCSP  DCSP log.info('Disabling DCSP repo(s): DCSP %s', ', DCSP '.join(targets)) DCNL DCSP  DCSP  DCSP ret.extend(['--disablerepo={0}'.format(x) for x in targets]) DCNL DCSP  DCSP if enablerepo: DCNL DCSP  DCSP  DCSP targets = ([enablerepo] if (not isinstance(enablerepo, list)) else enablerepo) DCNL DCSP  DCSP  DCSP log.info('Enabling DCSP repo(s): DCSP %s', ', DCSP '.join(targets)) DCNL DCSP  DCSP  DCSP ret.extend(['--enablerepo={0}'.format(x) for x in targets]) DCNL DCSP return ret\n", "intent": "returns a list of --enablerepo and --disablerepo options to be used in the yum command .\n", "question_id": 1531}, {"snippet": "def agent_build_create(context, values): DCNL  DCSP return IMPL.agent_build_create(context, values)\n", "intent": "create a new agent build entry .\n", "question_id": 1532}, {"snippet": "def create_repository_admin_role(app, repository): DCNL  DCSP sa_session = app.model.context.current DCNL DCSP name = get_repository_admin_role_name(str(repository.name), str(repository.user.username)) DCNL DCSP description = 'A DCSP user DCSP or DCSP group DCSP member DCSP with DCSP this DCSP role DCSP can DCSP administer DCSP this DCSP repository.' DCNL DCSP role = app.model.Role(name=name, description=description, type=app.model.Role.types.SYSTEM) DCNL DCSP sa_session.add(role) DCNL DCSP sa_session.flush() DCNL DCSP app.model.UserRoleAssociation(repository.user, role) DCNL DCSP rra = app.model.RepositoryRoleAssociation(repository, role) DCNL DCSP sa_session.add(rra) DCNL DCSP sa_session.flush() DCNL DCSP return role\n", "intent": "create a new role with name-spaced name based on the repository name and its owners public user name .\n", "question_id": 1533}, {"snippet": "def logout_required(redirect): DCNL  DCSP def redirect_func(user): DCNL DCSP  DCSP return user.is_authenticated() DCNL DCSP if hasattr(redirect, '__call__'): DCNL DCSP  DCSP return user_access_decorator(redirect_func, redirect_field=None, redirect_url_func=(lambda : reverse('home')))(redirect) DCNL DCSP else: DCNL DCSP  DCSP return user_access_decorator(redirect_func, redirect_field=None, redirect_url_func=(lambda : redirect))\n", "intent": "requires that the user *not* be logged in .\n", "question_id": 1534}, {"snippet": "def getNewRepository(): DCNL  DCSP return SpeedRepository()\n", "intent": "get new repository .\n", "question_id": 1535}, {"snippet": "def _parse_vmconfig(config, instances): DCNL  DCSP vmconfig = None DCNL DCSP if isinstance(config, salt.utils.odict.OrderedDict): DCNL DCSP  DCSP vmconfig = OrderedDict() DCNL DCSP  DCSP for prop in config.keys(): DCNL DCSP  DCSP  DCSP if (prop not in instances): DCNL DCSP  DCSP  DCSP  DCSP vmconfig[prop] = config[prop] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(config[prop], salt.utils.odict.OrderedDict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP vmconfig[prop] = [] DCNL DCSP  DCSP  DCSP  DCSP for instance in config[prop]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP instance_config = config[prop][instance] DCNL DCSP  DCSP  DCSP  DCSP  DCSP instance_config[instances[prop]] = instance DCNL DCSP  DCSP  DCSP  DCSP  DCSP vmconfig[prop].append(instance_config) DCNL DCSP else: DCNL DCSP  DCSP log.error('smartos.vm_present::parse_vmconfig DCSP - DCSP failed DCSP to DCSP parse') DCNL DCSP return vmconfig\n", "intent": "parse vm_present vm config .\n", "question_id": 1536}, {"snippet": "def makeTerm(node, title='Node', term='xterm', display=None, cmd='bash'): DCNL  DCSP title = ('\"%s: DCSP %s\"' % (title, node.name)) DCNL DCSP if (not node.inNamespace): DCNL DCSP  DCSP title += ' DCSP (root)' DCNL DCSP cmds = {'xterm': ['xterm', '-title', title, '-display'], 'gterm': ['gnome-terminal', '--title', title, '--display']} DCNL DCSP if (term not in cmds): DCNL DCSP  DCSP error(('invalid DCSP terminal DCSP type: DCSP %s' % term)) DCNL DCSP  DCSP return DCNL DCSP (display, tunnel) = tunnelX11(node, display) DCNL DCSP if (display is None): DCNL DCSP  DCSP return [] DCNL DCSP term = node.popen((cmds[term] + [display, '-e', ('env DCSP TERM=ansi DCSP %s' % cmd)])) DCNL DCSP return ([tunnel, term] if tunnel else [term])\n", "intent": "create an x11 tunnel to the node and start up a terminal .\n", "question_id": 1537}, {"snippet": "@memoize(100) DCNL def get_backend_cls(backend=None, loader=None): DCNL  DCSP backend = (backend or 'disabled') DCNL DCSP loader = (loader or current_app.loader) DCNL DCSP aliases = dict(BACKEND_ALIASES, **loader.override_backends) DCNL DCSP try: DCNL DCSP  DCSP return get_cls_by_name(backend, aliases) DCNL DCSP except ValueError as exc: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP result DCSP backend: DCSP %r. DCSP  DCSP Did DCSP you DCSP spell DCSP it DCSP correctly? DCSP  DCSP (%s)' % (backend, exc)))\n", "intent": "get backend class by name/alias .\n", "question_id": 1538}, {"snippet": "def rid(): DCNL  DCSP return (struct.unpack('@Q', os.urandom(8))[0] & _WAMP_ID_MASK)\n", "intent": "generate a new random integer id from range **[0 .\n", "question_id": 1539}, {"snippet": "def logistic_regression_path(X, y, pos_class=None, Cs=10, fit_intercept=True, max_iter=100, tol=0.0001, verbose=0, solver='lbfgs', coef=None, class_weight=None, dual=False, penalty='l2', intercept_scaling=1.0, multi_class='ovr', random_state=None, check_input=True, max_squared_sum=None, sample_weight=None): DCNL  DCSP if isinstance(Cs, numbers.Integral): DCNL DCSP  DCSP Cs = np.logspace((-4), 4, Cs) DCNL DCSP _check_solver_option(solver, multi_class, penalty, dual) DCNL DCSP if check_input: DCNL DCSP  DCSP X = check_array(X, accept_sparse='csr', dtype=np.float64) DCNL DCSP  DCSP y = check_array(y, ensure_2d=False, dtype=None) DCNL DCSP  DCSP check_consistent_length(X, y) DCNL DCSP (_, n_features) = X.shape DCNL DCSP classes = np.unique(y) DCNL DCSP random_state = check_random_state(random_state) DCNL DCSP if ((pos_class is None) and (multi_class != 'multinomial')): DCNL DCSP  DCSP if (classes.size > 2): DCNL DCSP  DCSP  DCSP raise ValueError('To DCSP fit DCSP OvR, DCSP use DCSP the DCSP pos_class DCSP argument') DCNL DCSP  DCSP pos_class = classes[1] DCNL DCSP if (sample_weight is not None): DCNL DCSP  DCSP sample_weight = np.array(sample_weight, dtype=np.float64, order='C') DCNL DCSP  DCSP check_consistent_length(y, sample_weight) DCNL DCSP else: DCNL DCSP  DCSP sample_weight = np.ones(X.shape[0]) DCNL DCSP le = LabelEncoder() DCNL DCSP if (isinstance(class_weight, dict) or (multi_class == 'multinomial')): DCNL DCSP  DCSP class_weight_ = compute_class_weight(class_weight, classes, y) DCNL DCSP  DCSP sample_weight *= class_weight_[le.fit_transform(y)] DCNL DCSP if (multi_class == 'ovr'): DCNL DCSP  DCSP w0 = np.zeros((n_features + int(fit_intercept))) DCNL DCSP  DCSP mask_classes = np.array([(-1), 1]) DCNL DCSP  DCSP mask = (y == pos_class) DCNL DCSP  DCSP y_bin = np.ones(y.shape, dtype=np.float64) DCNL DCSP  DCSP y_bin[(~ mask)] = (-1.0) DCNL DCSP  DCSP if (class_weight == 'balanced'): DCNL DCSP  DCSP  DCSP class_weight_ = compute_class_weight(class_weight, mask_classes, y_bin) DCNL DCSP  DCSP  DCSP sample_weight *= class_weight_[le.fit_transform(y_bin)] DCNL DCSP else: DCNL DCSP  DCSP if (solver != 'sag'): DCNL DCSP  DCSP  DCSP lbin = LabelBinarizer() DCNL DCSP  DCSP  DCSP Y_multi = lbin.fit_transform(y) DCNL DCSP  DCSP  DCSP if (Y_multi.shape[1] == 1): DCNL DCSP  DCSP  DCSP  DCSP Y_multi = np.hstack([(1 - Y_multi), Y_multi]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP le = LabelEncoder() DCNL DCSP  DCSP  DCSP Y_multi = le.fit_transform(y) DCNL DCSP  DCSP w0 = np.zeros((classes.size, (n_features + int(fit_intercept))), order='F') DCNL DCSP if (coef is not None): DCNL DCSP  DCSP if (multi_class == 'ovr'): DCNL DCSP  DCSP  DCSP if (coef.size not in (n_features, w0.size)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Initialization DCSP coef DCSP is DCSP of DCSP shape DCSP %d, DCSP expected DCSP shape DCSP %d DCSP or DCSP %d' % (coef.size, n_features, w0.size))) DCNL DCSP  DCSP  DCSP w0[:coef.size] = coef DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP n_classes = classes.size DCNL DCSP  DCSP  DCSP if (n_classes == 2): DCNL DCSP  DCSP  DCSP  DCSP n_classes = 1 DCNL DCSP  DCSP  DCSP if ((coef.shape[0] != n_classes) or (coef.shape[1] not in (n_features, (n_features + 1)))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Initialization DCSP coef DCSP is DCSP of DCSP shape DCSP (%d, DCSP %d), DCSP expected DCSP shape DCSP (%d, DCSP %d) DCSP or DCSP (%d, DCSP %d)' % (coef.shape[0], coef.shape[1], classes.size, n_features, classes.size, (n_features + 1)))) DCNL DCSP  DCSP  DCSP w0[:, :coef.shape[1]] = coef DCNL DCSP if (multi_class == 'multinomial'): DCNL DCSP  DCSP if (solver in ['lbfgs', 'newton-cg']): DCNL DCSP  DCSP  DCSP w0 = w0.ravel() DCNL DCSP  DCSP target = Y_multi DCNL DCSP  DCSP if (solver == 'lbfgs'): DCNL DCSP  DCSP  DCSP func = (lambda x, *args: _multinomial_loss_grad(x, *args)[0:2]) DCNL DCSP  DCSP elif (solver == 'newton-cg'): DCNL DCSP  DCSP  DCSP func = (lambda x, *args: _multinomial_loss(x, *args)[0]) DCNL DCSP  DCSP  DCSP grad = (lambda x, *args: _multinomial_loss_grad(x, *args)[1]) DCNL DCSP  DCSP  DCSP hess = _multinomial_grad_hess DCNL DCSP  DCSP warm_start_sag = {'coef': w0.T} DCNL DCSP else: DCNL DCSP  DCSP target = y_bin DCNL DCSP  DCSP if (solver == 'lbfgs'): DCNL DCSP  DCSP  DCSP func = _logistic_loss_and_grad DCNL DCSP  DCSP elif (solver == 'newton-cg'): DCNL DCSP  DCSP  DCSP func = _logistic_loss DCNL DCSP  DCSP  DCSP grad = (lambda x, *args: _logistic_loss_and_grad(x, *args)[1]) DCNL DCSP  DCSP  DCSP hess = _logistic_grad_hess DCNL DCSP  DCSP warm_start_sag = {'coef': np.expand_dims(w0, axis=1)} DCNL DCSP coefs = list() DCNL DCSP n_iter = np.zeros(len(Cs), dtype=np.int32) DCNL DCSP for (i, C) in enumerate(Cs): DCNL DCSP  DCSP if (solver == 'lbfgs'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (w0, loss, info) = optimize.fmin_l_bfgs_b(func, w0, fprime=None, args=(X, target, (1.0 / C), sample_weight), iprint=((verbose > 0) - 1), pgtol=tol, maxiter=max_iter) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP (w0, loss, info) = optimize.fmin_l_bfgs_b(func, w0, fprime=None, args=(X, target, (1.0 / C), sample_weight), iprint=((verbose > 0) - 1), pgtol=tol) DCNL DCSP  DCSP  DCSP if ((info['warnflag'] == 1) and (verbose > 0)): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn('lbfgs DCSP failed DCSP to DCSP converge. DCSP Increase DCSP the DCSP number DCSP of DCSP iterations.') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP n_iter_i = (info['nit'] - 1) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP n_iter_i = (info['funcalls'] - 1) DCNL DCSP  DCSP elif (solver == 'newton-cg'): DCNL DCSP  DCSP  DCSP args = (X, target, (1.0 / C), sample_weight) DCNL DCSP  DCSP  DCSP (w0, n_iter_i) = newton_cg(hess, func, grad, w0, args=args, maxiter=max_iter, tol=tol) DCNL DCSP  DCSP elif (solver == 'liblinear'): DCNL DCSP  DCSP  DCSP (coef_, intercept_, n_iter_i) = _fit_liblinear(X, target, C, fit_intercept, intercept_scaling, None, penalty, dual, verbose, max_iter, tol, random_state, sample_weight=sample_weight) DCNL DCSP  DCSP  DCSP if fit_intercept: DCNL DCSP  DCSP  DCSP  DCSP w0 = np.concatenate([coef_.ravel(), intercept_]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP w0 = coef_.ravel() DCNL DCSP  DCSP elif (solver == 'sag'): DCNL DCSP  DCSP  DCSP if (multi_class == 'multinomial'): DCNL DCSP  DCSP  DCSP  DCSP target = target.astype(np.float64) DCNL DCSP  DCSP  DCSP  DCSP loss = 'multinomial' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP loss = 'log' DCNL DCSP  DCSP  DCSP (w0, n_iter_i, warm_start_sag) = sag_solver(X, target, sample_weight, loss, (1.0 / C), max_iter, tol, verbose, random_state, False, max_squared_sum, warm_start_sag) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError((\"solver DCSP must DCSP be DCSP one DCSP of DCSP {'liblinear', DCSP 'lbfgs', DCSP 'newton-cg', DCSP 'sag'}, DCSP got DCSP '%s' DCSP instead\" % solver)) DCNL DCSP  DCSP if (multi_class == 'multinomial'): DCNL DCSP  DCSP  DCSP multi_w0 = np.reshape(w0, (classes.size, (-1))) DCNL DCSP  DCSP  DCSP if (classes.size == 2): DCNL DCSP  DCSP  DCSP  DCSP multi_w0 = multi_w0[1][np.newaxis, :] DCNL DCSP  DCSP  DCSP coefs.append(multi_w0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP coefs.append(w0.copy()) DCNL DCSP  DCSP n_iter[i] = n_iter_i DCNL DCSP return (coefs, np.array(Cs), n_iter)\n", "intent": "compute a logistic regression model for a list of regularization parameters .\n", "question_id": 1540}, {"snippet": "@cleanup DCNL def test_determinism_all(): DCNL  DCSP _determinism_check(format=u'ps')\n", "intent": "test for reproducible ps output .\n", "question_id": 1541}, {"snippet": "def removeListFromDictionary(dictionary, keys): DCNL  DCSP for key in keys: DCNL DCSP  DCSP removeElementFromDictionary(dictionary, key)\n", "intent": "remove list from the dictionary .\n", "question_id": 1542}, {"snippet": "def log_ormcache_stats(sig=None, frame=None): DCNL  DCSP from odoo.modules.registry import Registry DCNL DCSP import threading DCNL DCSP me = threading.currentThread() DCNL DCSP me_dbname = me.dbname DCNL DCSP entries = defaultdict(int) DCNL DCSP for (dbname, reg) in Registry.registries.iteritems(): DCNL DCSP  DCSP for key in reg.cache.iterkeys(): DCNL DCSP  DCSP  DCSP entries[((dbname,) + key[:2])] += 1 DCNL DCSP for (key, count) in sorted(entries.items()): DCNL DCSP  DCSP (dbname, model_name, method) = key DCNL DCSP  DCSP me.dbname = dbname DCNL DCSP  DCSP stat = STAT[key] DCNL DCSP  DCSP _logger.info('%6d DCSP entries, DCSP %6d DCSP hit, DCSP %6d DCSP miss, DCSP %6d DCSP err, DCSP %4.1f%% DCSP ratio, DCSP for DCSP %s.%s', count, stat.hit, stat.miss, stat.err, stat.ratio, model_name, method.__name__) DCNL DCSP me.dbname = me_dbname\n", "intent": "log statistics of ormcache usage by database .\n", "question_id": 1543}, {"snippet": "def _yield_clusters(max_days_ago=None, now=None, **runner_kwargs): DCNL  DCSP if (now is None): DCNL DCSP  DCSP now = datetime.utcnow() DCNL DCSP emr_conn = EMRJobRunner(**runner_kwargs).make_emr_conn() DCNL DCSP created_after = None DCNL DCSP if (max_days_ago is not None): DCNL DCSP  DCSP created_after = (now - timedelta(days=max_days_ago)) DCNL DCSP for cluster_summary in _yield_all_clusters(emr_conn, created_after=created_after, _delay=_DELAY): DCNL DCSP  DCSP cluster_id = cluster_summary.id DCNL DCSP  DCSP sleep(_DELAY) DCNL DCSP  DCSP cluster = _patched_describe_cluster(emr_conn, cluster_id) DCNL DCSP  DCSP cluster.steps = _list_all_steps(emr_conn, cluster_id, _delay=_DELAY) DCNL DCSP  DCSP cluster.bootstrapactions = list(_yield_all_bootstrap_actions(emr_conn, cluster_id, _delay=_DELAY)) DCNL DCSP  DCSP (yield cluster)\n", "intent": "get relevant cluster information from emr .\n", "question_id": 1544}, {"snippet": "def execfile(filename, globals, locals=None): DCNL  DCSP if (locals is None): DCNL DCSP  DCSP locals = globals DCNL DCSP with open(filename, 'rbU') as fin: DCNL DCSP  DCSP source = fin.read() DCNL DCSP code = compile(source, filename, 'exec') DCNL DCSP exec code in globals, locals\n", "intent": "execute a python script in the given namespaces .\n", "question_id": 1545}, {"snippet": "def fix_location_header(request, response): DCNL  DCSP if (('Location' in response) and request.get_host()): DCNL DCSP  DCSP response['Location'] = request.build_absolute_uri(response['Location']) DCNL DCSP return response\n", "intent": "ensures that we always use an absolute uri in any location header in the response .\n", "question_id": 1546}, {"snippet": "@curry DCNL def lossless_float_to_int(funcname, func, argname, arg): DCNL  DCSP if (not isinstance(arg, float)): DCNL DCSP  DCSP return arg DCNL DCSP arg_as_int = int(arg) DCNL DCSP if (arg == arg_as_int): DCNL DCSP  DCSP warnings.warn('{f} DCSP expected DCSP an DCSP int DCSP for DCSP argument DCSP {name!r}, DCSP but DCSP got DCSP float DCSP {arg}. DCSP Coercing DCSP to DCSP int.'.format(f=funcname, name=argname, arg=arg)) DCNL DCSP  DCSP return arg_as_int DCNL DCSP raise TypeError(arg)\n", "intent": "a preprocessor that coerces integral floats to ints .\n", "question_id": 1547}, {"snippet": "def kernel_modules(attrs=None, where=None): DCNL  DCSP if (__grains__['os_family'] in ['RedHat', 'Debian']): DCNL DCSP  DCSP return _osquery_cmd(table='kernel_modules', attrs=attrs, where=where) DCNL DCSP return {'result': False, 'comment': 'Only DCSP available DCSP on DCSP Red DCSP Hat DCSP or DCSP Debian DCSP based DCSP systems.'}\n", "intent": "return kernel_modules information from osquery cli example: .\n", "question_id": 1548}, {"snippet": "def center(s, width): DCNL  DCSP n = (width - len(s)) DCNL DCSP if (n <= 0): DCNL DCSP  DCSP return s DCNL DCSP half = (n / 2) DCNL DCSP if ((n % 2) and (width % 2)): DCNL DCSP  DCSP half = (half + 1) DCNL DCSP return (((' DCSP ' * half) + s) + (' DCSP ' * (n - half)))\n", "intent": "center -> string return a center version of s .\n", "question_id": 1549}, {"snippet": "def _redefines_import(node): DCNL  DCSP current = node DCNL DCSP while (current and (not isinstance(current.parent, astroid.ExceptHandler))): DCNL DCSP  DCSP current = current.parent DCNL DCSP if ((not current) or (not is_import_error(current.parent))): DCNL DCSP  DCSP return False DCNL DCSP try_block = current.parent.parent DCNL DCSP for import_node in try_block.nodes_of_class((astroid.From, astroid.Import)): DCNL DCSP  DCSP for (name, alias) in import_node.names: DCNL DCSP  DCSP  DCSP if alias: DCNL DCSP  DCSP  DCSP  DCSP if (alias == node.name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP elif (name == node.name): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "detect that the given node  is inside an exception handler and redefines an import from the tryexcept body .\n", "question_id": 1550}, {"snippet": "def dhcp_options_absent(name=None, dhcp_options_id=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP r = __salt__['boto_vpc.get_resource_id']('dhcp_options', name=name, region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if ('error' in r): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP delete DCSP DHCP DCSP options: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP _id = r.get('id') DCNL DCSP if (not _id): DCNL DCSP  DCSP ret['comment'] = 'DHCP DCSP options DCSP {0} DCSP do DCSP not DCSP exist.'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'DHCP DCSP options DCSP {0} DCSP are DCSP set DCSP to DCSP be DCSP deleted.'.format(name) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP r = __salt__['boto_vpc.delete_dhcp_options'](dhcp_options_id=r['id'], region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if (not r.get('deleted')): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP delete DCSP DHCP DCSP options: DCSP {0}'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP ret['changes']['old'] = {'dhcp_options': _id} DCNL DCSP ret['changes']['new'] = {'dhcp_options': None} DCNL DCSP ret['comment'] = 'DHCP DCSP options DCSP {0} DCSP deleted.'.format(name) DCNL DCSP return ret\n", "intent": "ensure a set of dhcp options with the given settings exist .\n", "question_id": 1551}, {"snippet": "def find_best_blas_type(arrays=(), dtype=None): DCNL  DCSP dtype = _np.dtype(dtype) DCNL DCSP prefer_fortran = False DCNL DCSP if arrays: DCNL DCSP  DCSP dtypes = [ar.dtype for ar in arrays] DCNL DCSP  DCSP dtype = _np.find_common_type(dtypes, ()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP index = dtypes.index(dtype) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP index = 0 DCNL DCSP  DCSP if arrays[index].flags['FORTRAN']: DCNL DCSP  DCSP  DCSP prefer_fortran = True DCNL DCSP prefix = _type_conv.get(dtype.char, 'd') DCNL DCSP if (dtype.char == 'G'): DCNL DCSP  DCSP dtype = _np.dtype('D') DCNL DCSP elif (dtype.char not in 'fdFD'): DCNL DCSP  DCSP dtype = _np.dtype('d') DCNL DCSP return (prefix, dtype, prefer_fortran)\n", "intent": "find best-matching blas/lapack type .\n", "question_id": 1552}, {"snippet": "def save_load(jid, load, minions=None): DCNL  DCSP conn = _get_conn(ret=None) DCNL DCSP cur = conn.cursor() DCNL DCSP sql = 'INSERT DCSP INTO DCSP jids DCSP (jid, DCSP load) DCSP VALUES DCSP (?, DCSP ?)' DCNL DCSP cur.execute(sql, (jid, json.dumps(load))) DCNL DCSP _close_conn(conn)\n", "intent": "save the load to the specified jid id .\n", "question_id": 1553}, {"snippet": "def create_order_source(prices_include_tax, line_data, tax_rates): DCNL  DCSP lines = [Line.from_text(x) for x in line_data] DCNL DCSP shop = get_shop(prices_include_tax, currency=u'USD') DCNL DCSP tax_classes = create_assigned_tax_classes(tax_rates) DCNL DCSP products = create_products(shop, lines, tax_classes) DCNL DCSP services = create_services(shop, lines, tax_classes) DCNL DCSP source = OrderSource(shop) DCNL DCSP fill_order_source(source, lines, products, services) DCNL DCSP return source\n", "intent": "get order source with some testing data .\n", "question_id": 1554}, {"snippet": "def libvlc_media_player_event_manager(p_mi): DCNL  DCSP f = (_Cfunctions.get('libvlc_media_player_event_manager', None) or _Cfunction('libvlc_media_player_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)\n", "intent": "get the event manager from which the media player send event .\n", "question_id": 1555}, {"snippet": "def urlencode_params(params): DCNL  DCSP params = [(key, normalize_for_urlencode(val)) for (key, val) in params] DCNL DCSP return requests.utils.unquote_unreserved(urlencode(params))\n", "intent": "url encodes the parameters .\n", "question_id": 1556}, {"snippet": "def create_user_contributions(user_id, created_exploration_ids, edited_exploration_ids): DCNL  DCSP user_contributions = get_user_contributions(user_id, strict=False) DCNL DCSP if user_contributions: DCNL DCSP  DCSP raise Exception(('User DCSP contributions DCSP model DCSP for DCSP user DCSP %s DCSP already DCSP exists.' % user_id)) DCNL DCSP else: DCNL DCSP  DCSP user_contributions = UserContributions(user_id, created_exploration_ids, edited_exploration_ids) DCNL DCSP  DCSP _save_user_contributions(user_contributions) DCNL DCSP return user_contributions\n", "intent": "creates a new usercontributionsmodel and returns the domain object .\n", "question_id": 1557}, {"snippet": "@depends(HAS_ESX_CLI) DCNL def enable_firewall_ruleset(host, username, password, ruleset_enable, ruleset_name, protocol=None, port=None, esxi_hosts=None): DCNL  DCSP cmd = 'network DCSP firewall DCSP ruleset DCSP set DCSP --enabled DCSP {0} DCSP --ruleset-id={1}'.format(ruleset_enable, ruleset_name) DCNL DCSP ret = {} DCNL DCSP if esxi_hosts: DCNL DCSP  DCSP if (not isinstance(esxi_hosts, list)): DCNL DCSP  DCSP  DCSP raise CommandExecutionError(\"'esxi_hosts' DCSP must DCSP be DCSP a DCSP list.\") DCNL DCSP  DCSP for esxi_host in esxi_hosts: DCNL DCSP  DCSP  DCSP response = salt.utils.vmware.esxcli(host, username, password, cmd, protocol=protocol, port=port, esxi_host=esxi_host) DCNL DCSP  DCSP  DCSP ret.update({esxi_host: response}) DCNL DCSP else: DCNL DCSP  DCSP response = salt.utils.vmware.esxcli(host, username, password, cmd, protocol=protocol, port=port) DCNL DCSP  DCSP ret.update({host: response}) DCNL DCSP return ret\n", "intent": "enable or disable an esxi firewall rule set .\n", "question_id": 1558}, {"snippet": "def test_cons_replacing(): DCNL  DCSP cons = HyCons('foo', 'bar') DCNL DCSP cons[0] = 'car' DCNL DCSP assert (cons == HyCons('car', 'bar')) DCNL DCSP cons[1:] = 'cdr' DCNL DCSP assert (cons == HyCons('car', 'cdr')) DCNL DCSP try: DCNL DCSP  DCSP cons[:] = 'foo' DCNL DCSP  DCSP assert (True is False) DCNL DCSP except IndexError: DCNL DCSP  DCSP pass\n", "intent": "check that assigning to a cons works as expected .\n", "question_id": 1559}, {"snippet": "def get_ctx_rev(app, tool_shed_url, name, owner, changeset_revision): DCNL  DCSP tool_shed_url = common_util.get_tool_shed_url_from_tool_shed_registry(app, tool_shed_url) DCNL DCSP params = dict(name=name, owner=owner, changeset_revision=changeset_revision) DCNL DCSP pathspec = ['repository', 'get_ctx_rev'] DCNL DCSP ctx_rev = util.url_get(tool_shed_url, password_mgr=app.tool_shed_registry.url_auth(tool_shed_url), pathspec=pathspec, params=params) DCNL DCSP return ctx_rev\n", "intent": "send a request to the tool shed to retrieve the ctx_rev for a repository defined by the combination of a name .\n", "question_id": 1560}, {"snippet": "def load_configuration(arg_list, log_printer, arg_parser=None): DCNL  DCSP cli_sections = parse_cli(arg_list=arg_list, arg_parser=arg_parser) DCNL DCSP check_conflicts(cli_sections) DCNL DCSP if (bool(cli_sections['default'].get('find_config', 'False')) and (str(cli_sections['default'].get('config')) == '')): DCNL DCSP  DCSP cli_sections['default'].add_or_create_setting(Setting('config', re.escape(find_user_config(os.getcwd())))) DCNL DCSP targets = [] DCNL DCSP for item in list(cli_sections['default'].contents.pop('targets', '')): DCNL DCSP  DCSP targets.append(item.lower()) DCNL DCSP if bool(cli_sections['default'].get('no_config', 'False')): DCNL DCSP  DCSP sections = cli_sections DCNL DCSP else: DCNL DCSP  DCSP base_sections = load_config_file(Constants.system_coafile, log_printer) DCNL DCSP  DCSP user_sections = load_config_file(Constants.user_coafile, log_printer, silent=True) DCNL DCSP  DCSP default_config = str(base_sections['default'].get('config', '.coafile')) DCNL DCSP  DCSP user_config = str(user_sections['default'].get('config', default_config)) DCNL DCSP  DCSP config = os.path.abspath(str(cli_sections['default'].get('config', user_config))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP save = bool(cli_sections['default'].get('save', 'False')) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP save = True DCNL DCSP  DCSP coafile_sections = load_config_file(config, log_printer, silent=save) DCNL DCSP  DCSP sections = merge_section_dicts(base_sections, user_sections) DCNL DCSP  DCSP sections = merge_section_dicts(sections, coafile_sections) DCNL DCSP  DCSP sections = merge_section_dicts(sections, cli_sections) DCNL DCSP for section in sections: DCNL DCSP  DCSP if (section != 'default'): DCNL DCSP  DCSP  DCSP sections[section].defaults = sections['default'] DCNL DCSP str_log_level = str(sections['default'].get('log_level', '')).upper() DCNL DCSP log_printer.log_level = LOG_LEVEL.str_dict.get(str_log_level, LOG_LEVEL.INFO) DCNL DCSP return (sections, targets)\n", "intent": "parses the cli args and loads the config file accordingly .\n", "question_id": 1561}, {"snippet": "def absent(name, export=False, force=False): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP log.debug('zpool.absent::{0}::config::force DCSP = DCSP {1}'.format(name, force)) DCNL DCSP log.debug('zpool.absent::{0}::config::export DCSP = DCSP {1}'.format(name, export)) DCNL DCSP if __salt__['zpool.exists'](name): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP if export: DCNL DCSP  DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = __salt__['zpool.export'](name, force=force) DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = (ret['result'].get(name) == 'exported') DCNL DCSP  DCSP elif __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = __salt__['zpool.destroy'](name, force=force) DCNL DCSP  DCSP  DCSP ret['result'] = (ret['result'].get(name) == 'destroyed') DCNL DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP ret['changes'][name] = ('exported' if export else 'destroyed') DCNL DCSP  DCSP  DCSP ret['comment'] = 'storage DCSP pool DCSP {0} DCSP was DCSP {1}'.format(name, ret['changes'][name]) DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'storage DCSP pool DCSP {0} DCSP is DCSP absent'.format(name) DCNL DCSP return ret\n", "intent": "ensure storage pool is absent on the system name : string name of storage pool export : boolean export instread of destroy the zpool if present force : boolean force destroy or export .\n", "question_id": 1562}, {"snippet": "def fixSetGroupID(childPath): DCNL  DCSP if ((os.name == u'nt') or (os.name == u'ce')): DCNL DCSP  DCSP return DCNL DCSP parentPath = os.path.dirname(childPath) DCNL DCSP parentStat = os.stat(parentPath) DCNL DCSP parentMode = stat.S_IMODE(parentStat[stat.ST_MODE]) DCNL DCSP childPath = os.path.join(parentPath, os.path.basename(childPath)) DCNL DCSP if (parentMode & stat.S_ISGID): DCNL DCSP  DCSP parentGID = parentStat[stat.ST_GID] DCNL DCSP  DCSP childStat = os.stat(childPath) DCNL DCSP  DCSP childGID = childStat[stat.ST_GID] DCNL DCSP  DCSP if (childGID == parentGID): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP childPath_owner = childStat.st_uid DCNL DCSP  DCSP user_id = os.geteuid() DCNL DCSP  DCSP if ((user_id != 0) and (user_id != childPath_owner)): DCNL DCSP  DCSP  DCSP sickrage.srCore.srLogger.debug(((u'Not DCSP running DCSP as DCSP root DCSP or DCSP owner DCSP of DCSP ' + childPath) + u', DCSP not DCSP trying DCSP to DCSP set DCSP the DCSP set-group-ID')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.chown(childPath, (-1), parentGID) DCNL DCSP  DCSP  DCSP sickrage.srCore.srLogger.debug((u'Respecting DCSP the DCSP set-group-ID DCSP bit DCSP on DCSP the DCSP parent DCSP directory DCSP for DCSP %s' % childPath)) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP sickrage.srCore.srLogger.error((u'Failed DCSP to DCSP respect DCSP the DCSP set-group-ID DCSP bit DCSP on DCSP the DCSP parent DCSP directory DCSP for DCSP %s DCSP (setting DCSP group DCSP ID DCSP %i)' % (childPath, parentGID)))\n", "intent": "inherid sgid from parent .\n", "question_id": 1563}, {"snippet": "def dictfind(dictionary, element): DCNL  DCSP for (key, value) in iteritems(dictionary): DCNL DCSP  DCSP if (element is value): DCNL DCSP  DCSP  DCSP return key\n", "intent": "returns a key whose value in dictionary is element or .\n", "question_id": 1564}, {"snippet": "def store(registry, xml_parent, data): DCNL  DCSP namespace = 'org.jenkinsci.plugins.visualworks_store' DCNL DCSP scm = XML.SubElement(xml_parent, 'scm', {'class': '{0}.StoreSCM'.format(namespace)}) DCNL DCSP if ('script' in data): DCNL DCSP  DCSP XML.SubElement(scm, 'scriptName').text = data['script'] DCNL DCSP else: DCNL DCSP  DCSP raise JenkinsJobsException('Must DCSP specify DCSP a DCSP script DCSP name') DCNL DCSP if ('repository' in data): DCNL DCSP  DCSP XML.SubElement(scm, 'repositoryName').text = data['repository'] DCNL DCSP else: DCNL DCSP  DCSP raise JenkinsJobsException('Must DCSP specify DCSP a DCSP repository DCSP name') DCNL DCSP pundle_specs = data.get('pundles', []) DCNL DCSP if (not pundle_specs): DCNL DCSP  DCSP raise JenkinsJobsException('At DCSP least DCSP one DCSP pundle DCSP must DCSP be DCSP specified') DCNL DCSP valid_pundle_types = ['package', 'bundle'] DCNL DCSP pundles = XML.SubElement(scm, 'pundles') DCNL DCSP for pundle_spec in pundle_specs: DCNL DCSP  DCSP pundle = XML.SubElement(pundles, '{0}.PundleSpec'.format(namespace)) DCNL DCSP  DCSP pundle_type = next(iter(pundle_spec)) DCNL DCSP  DCSP pundle_name = pundle_spec[pundle_type] DCNL DCSP  DCSP if (pundle_type not in valid_pundle_types): DCNL DCSP  DCSP  DCSP raise JenkinsJobsException(('pundle DCSP type DCSP must DCSP be DCSP must DCSP be DCSP one DCSP of: DCSP ' + ', DCSP '.join(valid_pundle_types))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP XML.SubElement(pundle, 'name').text = pundle_name DCNL DCSP  DCSP  DCSP XML.SubElement(pundle, 'pundleType').text = pundle_type.upper() DCNL DCSP if ('version-regex' in data): DCNL DCSP  DCSP XML.SubElement(scm, 'versionRegex').text = data['version-regex'] DCNL DCSP if ('minimum-blessing' in data): DCNL DCSP  DCSP XML.SubElement(scm, 'minimumBlessingLevel').text = data['minimum-blessing'] DCNL DCSP if ('parcel-builder-file' in data): DCNL DCSP  DCSP XML.SubElement(scm, 'generateParcelBuilderInputFile').text = 'true' DCNL DCSP  DCSP XML.SubElement(scm, 'parcelBuilderInputFilename').text = data['parcel-builder-file'] DCNL DCSP else: DCNL DCSP  DCSP XML.SubElement(scm, 'generateParcelBuilderInputFile').text = 'false'\n", "intent": "yaml: store specifies the visualworks smalltalk store repository for this job .\n", "question_id": 1565}, {"snippet": "def available(name, jail=None): DCNL  DCSP return (name in get_all(jail))\n", "intent": "check that the given service is available .\n", "question_id": 1566}, {"snippet": "@register.inclusion_tag('inclusion.html') DCNL def inclusion_unlimited_args_kwargs(one, two='hi', *args, **kwargs): DCNL  DCSP sorted_kwarg = sorted(kwargs.items(), key=operator.itemgetter(0)) DCNL DCSP return {'result': ('inclusion_unlimited_args_kwargs DCSP - DCSP Expected DCSP result: DCSP %s DCSP / DCSP %s' % (', DCSP '.join((str(arg) for arg in ([one, two] + list(args)))), ', DCSP '.join((('%s=%s' % (k, v)) for (k, v) in sorted_kwarg))))}\n", "intent": "expected inclusion_unlimited_args_kwargs __doc__ .\n", "question_id": 1567}, {"snippet": "def list_users(): DCNL  DCSP return sorted([user.pw_name for user in pwd.getpwall()])\n", "intent": "return a list of all users cli example: .\n", "question_id": 1568}, {"snippet": "@contextfunction DCNL def rss_link(context, url=None): DCNL  DCSP request = context['request'] DCNL DCSP params = request.GET.copy() DCNL DCSP params.update({'secret': get_secret_key(request)}) DCNL DCSP if (not url): DCNL DCSP  DCSP url = request.path DCNL DCSP for ext in getattr(settings, 'HARDTREE_RESPONSE_FORMATS', {'html': 'text/html'}): DCNL DCSP  DCSP url = url.replace(('.' + ext), '') DCNL DCSP url += '.rss' DCNL DCSP try: DCNL DCSP  DCSP url += ('?' + urllib.urlencode(params)) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return Markup(url)\n", "intent": "generic rss link for this url .\n", "question_id": 1569}, {"snippet": "def _items(mappingorseq): DCNL  DCSP return (mappingorseq.iteritems() if hasattr(mappingorseq, 'iteritems') else mappingorseq)\n", "intent": "wrapper for efficient iteration over mappings represented by dicts or sequences:: .\n", "question_id": 1570}, {"snippet": "def event_return(events): DCNL  DCSP _options = _get_options() DCNL DCSP api_url = _options.get('api_url') DCNL DCSP channel = _options.get('channel') DCNL DCSP username = _options.get('username') DCNL DCSP hook = _options.get('hook') DCNL DCSP is_ok = True DCNL DCSP for event in events: DCNL DCSP  DCSP log.debug('Event: DCSP {0}'.format(str(event))) DCNL DCSP  DCSP log.debug('Event DCSP data: DCSP {0}'.format(str(event['data']))) DCNL DCSP  DCSP message = 'tag: DCSP {0}\\r\\n'.format(event['tag']) DCNL DCSP  DCSP for (key, value) in event['data'].iteritems(): DCNL DCSP  DCSP  DCSP message += '{0}: DCSP {1}\\r\\n'.format(key, value) DCNL DCSP  DCSP result = post_message(channel, message, username, api_url, hook) DCNL DCSP  DCSP if (not result): DCNL DCSP  DCSP  DCSP is_ok = False DCNL DCSP return is_ok\n", "intent": "send the events to a mattermost room .\n", "question_id": 1571}, {"snippet": "@frappe.whitelist() DCNL def get_default_address_template(): DCNL  DCSP return ((((((u'{{ DCSP address_line1 DCSP }}<br>{% DCSP if DCSP address_line2 DCSP %}{{ DCSP address_line2 DCSP }}<br>{% DCSP endif DCSP -%}{{ DCSP city DCSP }}<br>\\n{% DCSP if DCSP state DCSP %}{{ DCSP state DCSP }}<br>{% DCSP endif DCSP -%}\\n{% DCSP if DCSP pincode DCSP %}{{ DCSP pincode DCSP }}<br>{% DCSP endif DCSP -%}\\n{{ DCSP country DCSP }}<br>\\n{% DCSP if DCSP phone DCSP %}' + _(u'Phone')) + u': DCSP {{ DCSP phone DCSP }}<br>{% DCSP endif DCSP -%}\\n{% DCSP if DCSP fax DCSP %}') + _(u'Fax')) + u': DCSP {{ DCSP fax DCSP }}<br>{% DCSP endif DCSP -%}\\n{% DCSP if DCSP email_id DCSP %}') + _(u'Email')) + u': DCSP {{ DCSP email_id DCSP }}<br>{% DCSP endif DCSP -%}')\n", "intent": "get default address template .\n", "question_id": 1572}, {"snippet": "def _get_num_interval(config, num_pre, num_post): DCNL  DCSP post = (int(num_post) if num_post else 0) DCNL DCSP pre = (int(num_pre) if (num_pre is not None) else _get_last_snapshot(config)['id']) DCNL DCSP return (pre, post)\n", "intent": "returns numerical interval based on optionals num_pre .\n", "question_id": 1573}, {"snippet": "def make_region(*arg, **kw): DCNL  DCSP return CacheRegion(*arg, **kw)\n", "intent": "instantiate a new :class: .\n", "question_id": 1574}, {"snippet": "def composition(f, g): DCNL  DCSP def fg(arg): DCNL DCSP  DCSP return g(f(arg)) DCNL DCSP return fg\n", "intent": "return a composition of two functions .\n", "question_id": 1575}, {"snippet": "def domains_for_certname(config, certname): DCNL  DCSP def update_domains_for_name_match(candidate_lineage, rv): DCNL DCSP  DCSP 'Return DCSP domains DCSP if DCSP certname DCSP matches, DCSP else DCSP return DCSP rv\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP matching_domains = rv DCNL DCSP  DCSP if (candidate_lineage.lineagename == certname): DCNL DCSP  DCSP  DCSP matching_domains = candidate_lineage.names() DCNL DCSP  DCSP return matching_domains DCNL DCSP return _search_lineages(config, update_domains_for_name_match, None)\n", "intent": "find the domains in the cert with name certname .\n", "question_id": 1576}, {"snippet": "def buildHL0aTrainingSet(numOnes=5): DCNL  DCSP numPatterns = 23 DCNL DCSP p = getSimplePatterns(numOnes, numPatterns) DCNL DCSP s = [] DCNL DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP for _ in xrange(20): DCNL DCSP  DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP  DCSP s.append(p[0]) DCNL DCSP  DCSP s.append(p[1]) DCNL DCSP  DCSP s.append(p[2]) DCNL DCSP  DCSP s.append(p[rgen.randint(3, 23)]) DCNL DCSP return ([s], [[p[0], p[1], p[2]]])\n", "intent": "simple sequences for hl0 .\n", "question_id": 1577}, {"snippet": "def Normalize(filters, orders, exists): DCNL  DCSP eq_properties = set() DCNL DCSP inequality_properties = set() DCNL DCSP for f in filters: DCNL DCSP  DCSP if ((f.op() == datastore_pb.Query_Filter.IN) and (f.property_size() == 1)): DCNL DCSP  DCSP  DCSP f.set_op(datastore_pb.Query_Filter.EQUAL) DCNL DCSP  DCSP if (f.op() in EQUALITY_OPERATORS): DCNL DCSP  DCSP  DCSP eq_properties.add(f.property(0).name()) DCNL DCSP  DCSP elif (f.op() in INEQUALITY_OPERATORS): DCNL DCSP  DCSP  DCSP inequality_properties.add(f.property(0).name()) DCNL DCSP eq_properties -= inequality_properties DCNL DCSP remove_set = eq_properties.copy() DCNL DCSP new_orders = [] DCNL DCSP for o in orders: DCNL DCSP  DCSP if (o.property() not in remove_set): DCNL DCSP  DCSP  DCSP remove_set.add(o.property()) DCNL DCSP  DCSP  DCSP new_orders.append(o) DCNL DCSP orders = new_orders DCNL DCSP remove_set.update(inequality_properties) DCNL DCSP new_filters = [] DCNL DCSP for f in filters: DCNL DCSP  DCSP if (f.op() not in EXISTS_OPERATORS): DCNL DCSP  DCSP  DCSP new_filters.append(f) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP name = f.property(0).name() DCNL DCSP  DCSP if (name not in remove_set): DCNL DCSP  DCSP  DCSP remove_set.add(name) DCNL DCSP  DCSP  DCSP new_filters.append(f) DCNL DCSP for prop in exists: DCNL DCSP  DCSP if (prop not in remove_set): DCNL DCSP  DCSP  DCSP remove_set.add(prop) DCNL DCSP  DCSP  DCSP new_filter = datastore_pb.Query_Filter() DCNL DCSP  DCSP  DCSP new_filter.set_op(datastore_pb.Query_Filter.EXISTS) DCNL DCSP  DCSP  DCSP new_prop = new_filter.add_property() DCNL DCSP  DCSP  DCSP new_prop.set_name(prop) DCNL DCSP  DCSP  DCSP new_prop.set_multiple(False) DCNL DCSP  DCSP  DCSP new_prop.mutable_value() DCNL DCSP  DCSP  DCSP new_filters.append(new_filter) DCNL DCSP filters = new_filters DCNL DCSP if (datastore_types.KEY_SPECIAL_PROPERTY in eq_properties): DCNL DCSP  DCSP orders = [] DCNL DCSP new_orders = [] DCNL DCSP for o in orders: DCNL DCSP  DCSP if (o.property() == datastore_types.KEY_SPECIAL_PROPERTY): DCNL DCSP  DCSP  DCSP new_orders.append(o) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP new_orders.append(o) DCNL DCSP orders = new_orders DCNL DCSP return (filters, orders)\n", "intent": "normalizes filter and order query components .\n", "question_id": 1578}, {"snippet": "def remove_site(name): DCNL  DCSP pscmd = [] DCNL DCSP current_sites = list_sites() DCNL DCSP if (name not in current_sites): DCNL DCSP  DCSP _LOG.debug('Site DCSP already DCSP absent: DCSP %s', name) DCNL DCSP  DCSP return True DCNL DCSP pscmd.append(\"Remove-WebSite DCSP -Name DCSP '{0}'\".format(name)) DCNL DCSP cmd_ret = _srvmgr(str().join(pscmd)) DCNL DCSP if (cmd_ret['retcode'] == 0): DCNL DCSP  DCSP _LOG.debug('Site DCSP removed DCSP successfully: DCSP %s', name) DCNL DCSP  DCSP return True DCNL DCSP _LOG.error('Unable DCSP to DCSP remove DCSP site: DCSP %s', name) DCNL DCSP return False\n", "intent": "delete a website from iis .\n", "question_id": 1579}, {"snippet": "def get_jid(jid): DCNL  DCSP conn = _get_conn(ret=None) DCNL DCSP cur = conn.cursor() DCNL DCSP sql = 'SELECT DCSP id, DCSP full_ret DCSP FROM DCSP salt_returns DCSP WHERE DCSP jid DCSP = DCSP ?' DCNL DCSP cur.execute(sql, (jid,)) DCNL DCSP data = cur.fetchall() DCNL DCSP ret = {} DCNL DCSP if data: DCNL DCSP  DCSP for (minion, full_ret) in data: DCNL DCSP  DCSP  DCSP ret[minion] = json.loads(full_ret) DCNL DCSP _close_conn(conn) DCNL DCSP return ret\n", "intent": "return the information returned when the specified job id was executed .\n", "question_id": 1580}, {"snippet": "def test_tokenizer(): DCNL  DCSP raw = '<em>test<x></x></em>' DCNL DCSP eq_('<em>test&lt;x&gt;&lt;/x&gt;</em>', linkify(raw)) DCNL DCSP eq_(raw, linkify(raw, tokenizer=HTMLTokenizer))\n", "intent": "linkify doesnt always have to sanitize .\n", "question_id": 1581}, {"snippet": "def createUserObject(master, author, src=None): DCNL  DCSP if (not src): DCNL DCSP  DCSP log.msg('No DCSP vcs DCSP information DCSP found, DCSP unable DCSP to DCSP create DCSP User DCSP Object') DCNL DCSP  DCSP return defer.succeed(None) DCNL DCSP if (src in srcs): DCNL DCSP  DCSP usdict = dict(identifier=author, attr_type=src, attr_data=author) DCNL DCSP else: DCNL DCSP  DCSP log.msg(('Unrecognized DCSP source DCSP argument: DCSP %s' % src)) DCNL DCSP  DCSP return defer.succeed(None) DCNL DCSP return master.db.users.findUserByAttr(identifier=usdict['identifier'], attr_type=usdict['attr_type'], attr_data=usdict['attr_data'])\n", "intent": "take a change author and source and translate them into a user object .\n", "question_id": 1582}, {"snippet": "def _result_type_many(*arrays_and_dtypes): DCNL  DCSP try: DCNL DCSP  DCSP return np.result_type(*arrays_and_dtypes) DCNL DCSP except ValueError: DCNL DCSP  DCSP return reduce(np.result_type, arrays_and_dtypes)\n", "intent": "wrapper around numpy .\n", "question_id": 1583}, {"snippet": "def test_cache(): DCNL  DCSP cp = compilerop.CachingCompiler() DCNL DCSP ncache = len(linecache.cache) DCNL DCSP cp.cache('x=1') DCNL DCSP nt.assert_true((len(linecache.cache) > ncache))\n", "intent": "test the compiler correctly compiles and caches inputs .\n", "question_id": 1584}, {"snippet": "def create_gs_key(filename, rpc=None): DCNL  DCSP rpc = create_gs_key_async(filename, rpc) DCNL DCSP return rpc.get_result()\n", "intent": "create an encoded key for a google storage file .\n", "question_id": 1585}, {"snippet": "def add_stderr_logger(level=logging.DEBUG): DCNL  DCSP logger = logging.getLogger(__name__) DCNL DCSP handler = logging.StreamHandler() DCNL DCSP handler.setFormatter(logging.Formatter('%(asctime)s DCSP %(levelname)s DCSP %(message)s')) DCNL DCSP logger.addHandler(handler) DCNL DCSP logger.setLevel(level) DCNL DCSP logger.debug(('Added DCSP an DCSP stderr DCSP logging DCSP handler DCSP to DCSP logger: DCSP %s' % __name__)) DCNL DCSP return handler\n", "intent": "helper for quickly adding a streamhandler to the logger .\n", "question_id": 1586}, {"snippet": "def _sympify(a): DCNL  DCSP return sympify(a, strict=True)\n", "intent": "short version of sympify for internal usage for __add__ and __eq__ methods where it is ok to allow some things  in the expression .\n", "question_id": 1587}, {"snippet": "def plot_resources(results, palette='Viridis', **kwargs): DCNL  DCSP bp = import_required('bokeh.plotting', _BOKEH_MISSING_MSG) DCNL DCSP from bokeh import palettes DCNL DCSP from bokeh.models import LinearAxis, Range1d DCNL DCSP defaults = dict(title='Profile DCSP Results', tools='save,reset,resize,xwheel_zoom,xpan', plot_width=800, plot_height=300) DCNL DCSP defaults.update(((k, v) for (k, v) in kwargs.items() if (k in _get_figure_keywords()))) DCNL DCSP if results: DCNL DCSP  DCSP (t, mem, cpu) = zip(*results) DCNL DCSP  DCSP (left, right) = (min(t), max(t)) DCNL DCSP  DCSP t = [(i - left) for i in t] DCNL DCSP  DCSP p = bp.figure(y_range=(0, max(cpu)), x_range=(0, (right - left)), **defaults) DCNL DCSP else: DCNL DCSP  DCSP t = mem = cpu = [] DCNL DCSP  DCSP p = bp.figure(y_range=(0, 100), x_range=(0, 10), **defaults) DCNL DCSP colors = palettes.all_palettes[palette][6] DCNL DCSP p.line(t, cpu, color=colors[0], line_width=4, legend='% DCSP CPU') DCNL DCSP p.yaxis.axis_label = '% DCSP CPU' DCNL DCSP p.extra_y_ranges = {'memory': Range1d(start=(min(mem) if mem else 0), end=(max(mem) if mem else 100))} DCNL DCSP p.line(t, mem, color=colors[2], y_range_name='memory', line_width=4, legend='Memory') DCNL DCSP p.add_layout(LinearAxis(y_range_name='memory', axis_label='Memory DCSP (MB)'), 'right') DCNL DCSP p.xaxis.axis_label = 'Time DCSP (s)' DCNL DCSP return p\n", "intent": "plot resource usage in a bokeh plot .\n", "question_id": 1588}, {"snippet": "def mean_pool(bc01, pool_shape, pool_stride, image_shape): DCNL  DCSP mx = None DCNL DCSP (r, c) = image_shape DCNL DCSP (pr, pc) = pool_shape DCNL DCSP (rs, cs) = pool_stride DCNL DCSP def last_pool(im_shp, p_shp, p_strd): DCNL DCSP  DCSP rval = int(np.ceil((float((im_shp - p_shp)) / p_strd))) DCNL DCSP  DCSP assert (((p_strd * rval) + p_shp) >= im_shp) DCNL DCSP  DCSP assert (((p_strd * (rval - 1)) + p_shp) < im_shp) DCNL DCSP  DCSP return rval DCNL DCSP last_pool_r = (last_pool(image_shape[0], pool_shape[0], pool_stride[0]) * pool_stride[0]) DCNL DCSP required_r = (last_pool_r + pr) DCNL DCSP last_pool_c = (last_pool(image_shape[1], pool_shape[1], pool_stride[1]) * pool_stride[1]) DCNL DCSP required_c = (last_pool_c + pc) DCNL DCSP for bc01v in get_debug_values(bc01): DCNL DCSP  DCSP assert (not contains_inf(bc01v)) DCNL DCSP  DCSP assert (bc01v.shape[2] == image_shape[0]) DCNL DCSP  DCSP assert (bc01v.shape[3] == image_shape[1]) DCNL DCSP wide_infinity = T.alloc((- np.inf), bc01.shape[0], bc01.shape[1], required_r, required_c) DCNL DCSP name = bc01.name DCNL DCSP if (name is None): DCNL DCSP  DCSP name = 'anon_bc01' DCNL DCSP bc01 = T.set_subtensor(wide_infinity[:, :, 0:r, 0:c], bc01) DCNL DCSP bc01.name = ('infinite_padded_' + name) DCNL DCSP wide_infinity_count = T.alloc(0, bc01.shape[0], bc01.shape[1], required_r, required_c) DCNL DCSP bc01_count = T.set_subtensor(wide_infinity_count[:, :, 0:r, 0:c], 1) DCNL DCSP for row_within_pool in xrange(pool_shape[0]): DCNL DCSP  DCSP row_stop = ((last_pool_r + row_within_pool) + 1) DCNL DCSP  DCSP for col_within_pool in xrange(pool_shape[1]): DCNL DCSP  DCSP  DCSP col_stop = ((last_pool_c + col_within_pool) + 1) DCNL DCSP  DCSP  DCSP cur = bc01[:, :, row_within_pool:row_stop:rs, col_within_pool:col_stop:cs] DCNL DCSP  DCSP  DCSP cur.name = ((((('mean_pool_cur_' + bc01.name) + '_') + str(row_within_pool)) + '_') + str(col_within_pool)) DCNL DCSP  DCSP  DCSP cur_count = bc01_count[:, :, row_within_pool:row_stop:rs, col_within_pool:col_stop:cs] DCNL DCSP  DCSP  DCSP if (mx is None): DCNL DCSP  DCSP  DCSP  DCSP mx = cur DCNL DCSP  DCSP  DCSP  DCSP count = cur_count DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP mx = (mx + cur) DCNL DCSP  DCSP  DCSP  DCSP count = (count + cur_count) DCNL DCSP  DCSP  DCSP  DCSP mx.name = ((((('mean_pool_mx_' + bc01.name) + '_') + str(row_within_pool)) + '_') + str(col_within_pool)) DCNL DCSP mx /= count DCNL DCSP mx.name = (('mean_pool(' + name) + ')') DCNL DCSP for mxv in get_debug_values(mx): DCNL DCSP  DCSP assert isfinite(mxv) DCNL DCSP return mx\n", "intent": "does mean pooling  via a theano graph .\n", "question_id": 1589}, {"snippet": "def LoadSingleQueue(queue_info, open_fn=None): DCNL  DCSP builder = yaml_object.ObjectBuilder(QueueInfoExternal) DCNL DCSP handler = yaml_builder.BuilderHandler(builder) DCNL DCSP listener = yaml_listener.EventListener(handler) DCNL DCSP listener.Parse(queue_info) DCNL DCSP queue_info = handler.GetResults() DCNL DCSP if (len(queue_info) < 1): DCNL DCSP  DCSP raise MalformedQueueConfiguration('Empty DCSP queue DCSP configuration.') DCNL DCSP if (len(queue_info) > 1): DCNL DCSP  DCSP raise MalformedQueueConfiguration('Multiple DCSP queue: DCSP sections DCSP in DCSP configuration.') DCNL DCSP return queue_info[0]\n", "intent": "load a queue .\n", "question_id": 1590}, {"snippet": "def get_interface_type(interface): DCNL  DCSP if interface.upper().startswith('ET'): DCNL DCSP  DCSP return 'ethernet' DCNL DCSP elif interface.upper().startswith('VL'): DCNL DCSP  DCSP return 'svi' DCNL DCSP elif interface.upper().startswith('LO'): DCNL DCSP  DCSP return 'loopback' DCNL DCSP elif interface.upper().startswith('MG'): DCNL DCSP  DCSP return 'management' DCNL DCSP elif interface.upper().startswith('MA'): DCNL DCSP  DCSP return 'management' DCNL DCSP elif interface.upper().startswith('PO'): DCNL DCSP  DCSP return 'portchannel' DCNL DCSP else: DCNL DCSP  DCSP return 'unknown'\n", "intent": "gets the type of interface args: interface : full name of interface .\n", "question_id": 1591}, {"snippet": "def test_psi(): DCNL  DCSP sfreq = 50.0 DCNL DCSP n_signals = 3 DCNL DCSP n_epochs = 10 DCNL DCSP n_times = 500 DCNL DCSP rng = np.random.RandomState(42) DCNL DCSP data = rng.randn(n_epochs, n_signals, n_times) DCNL DCSP for i in range(n_epochs): DCNL DCSP  DCSP data[i, 1, 10:] = data[i, 0, :(-10)] DCNL DCSP  DCSP data[i, 2, :(-10)] = data[i, 0, 10:] DCNL DCSP (psi, freqs, times, n_epochs, n_tapers) = phase_slope_index(data, mode='fourier', sfreq=sfreq) DCNL DCSP assert_true((psi[(1, 0, 0)] < 0)) DCNL DCSP assert_true((psi[(2, 0, 0)] > 0)) DCNL DCSP indices = (np.array([0]), np.array([1])) DCNL DCSP (psi_2, freqs, times, n_epochs, n_tapers) = phase_slope_index(data, mode='fourier', sfreq=sfreq, indices=indices) DCNL DCSP assert_array_almost_equal(psi_2[(0, 0)], (- psi[(1, 0, 0)])) DCNL DCSP cwt_freqs = np.arange(5.0, 20, 0.5) DCNL DCSP (psi_cwt, freqs, times, n_epochs, n_tapers) = phase_slope_index(data, mode='cwt_morlet', sfreq=sfreq, cwt_frequencies=cwt_freqs, indices=indices) DCNL DCSP assert_true(np.all((psi_cwt > 0))) DCNL DCSP assert_true((psi_cwt.shape[(-1)] == n_times))\n", "intent": "test phase slope index  estimation .\n", "question_id": 1592}, {"snippet": "@depends(HAS_PYVMOMI) DCNL def get_service_policy(host, username, password, service_name, protocol=None, port=None, host_names=None): DCNL  DCSP service_instance = salt.utils.vmware.get_service_instance(host=host, username=username, password=password, protocol=protocol, port=port) DCNL DCSP valid_services = ['DCUI', 'TSM', 'SSH', 'ssh', 'lbtd', 'lsassd', 'lwiod', 'netlogond', 'ntpd', 'sfcbd-watchdog', 'snmpd', 'vprobed', 'vpxa', 'xorg'] DCNL DCSP host_names = _check_hosts(service_instance, host, host_names) DCNL DCSP ret = {} DCNL DCSP for host_name in host_names: DCNL DCSP  DCSP if (service_name not in valid_services): DCNL DCSP  DCSP  DCSP ret.update({host_name: {'Error': '{0} DCSP is DCSP not DCSP a DCSP valid DCSP service DCSP name.'.format(service_name)}}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP host_ref = _get_host_ref(service_instance, host, host_name=host_name) DCNL DCSP  DCSP services = host_ref.configManager.serviceSystem.serviceInfo.service DCNL DCSP  DCSP if ((service_name == 'SSH') or (service_name == 'ssh')): DCNL DCSP  DCSP  DCSP temp_service_name = 'TSM-SSH' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP temp_service_name = service_name DCNL DCSP  DCSP for service in services: DCNL DCSP  DCSP  DCSP if (service.key == temp_service_name): DCNL DCSP  DCSP  DCSP  DCSP ret.update({host_name: {service_name: service.policy}}) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = \"Could DCSP not DCSP find DCSP service DCSP '{0}' DCSP for DCSP host DCSP '{1}'.\".format(service_name, host_name) DCNL DCSP  DCSP  DCSP  DCSP ret.update({host_name: {'Error': msg}}) DCNL DCSP  DCSP if (ret.get(host_name) is None): DCNL DCSP  DCSP  DCSP msg = \"'vsphere.get_service_policy' DCSP failed DCSP for DCSP host DCSP {0}.\".format(host_name) DCNL DCSP  DCSP  DCSP log.debug(msg) DCNL DCSP  DCSP  DCSP ret.update({host_name: {'Error': msg}}) DCNL DCSP return ret\n", "intent": "get the service names policy for a given host or list of hosts .\n", "question_id": 1593}, {"snippet": "@pytest.fixture DCNL def message_mock(): DCNL  DCSP mmock = MessageMock() DCNL DCSP mmock.patch() DCNL DCSP (yield mmock) DCNL DCSP mmock.unpatch()\n", "intent": "fixture to get a messagemock .\n", "question_id": 1594}, {"snippet": "def get_ordered_locations(locations, **kwargs): DCNL  DCSP return locations\n", "intent": "order image location list .\n", "question_id": 1595}, {"snippet": "def add_label(name, kernel_config=None, platform=None, only_if_needed=None): DCNL  DCSP return models.Label.add_object(name=name, kernel_config=kernel_config, platform=platform, only_if_needed=only_if_needed).id\n", "intent": "add  label .\n", "question_id": 1596}, {"snippet": "def convert_to_response_dict(http_response, operation_model): DCNL  DCSP response_dict = {'headers': http_response.headers, 'status_code': http_response.status_code} DCNL DCSP if (response_dict['status_code'] >= 300): DCNL DCSP  DCSP response_dict['body'] = http_response.content DCNL DCSP elif operation_model.has_streaming_output: DCNL DCSP  DCSP response_dict['body'] = StreamingBody(http_response.raw, response_dict['headers'].get('content-length')) DCNL DCSP else: DCNL DCSP  DCSP response_dict['body'] = http_response.content DCNL DCSP return response_dict\n", "intent": "convert an http response object to a request dict .\n", "question_id": 1597}, {"snippet": "def construct_sort_part(model_cls, part): DCNL  DCSP assert part, 'part DCSP must DCSP be DCSP a DCSP field DCSP name DCSP and DCSP + DCSP or DCSP -' DCNL DCSP field = part[:(-1)] DCNL DCSP assert field, 'field DCSP is DCSP missing' DCNL DCSP direction = part[(-1)] DCNL DCSP assert (direction in ('+', '-')), 'part DCSP must DCSP end DCSP with DCSP + DCSP or DCSP -' DCNL DCSP is_ascending = (direction == '+') DCNL DCSP if (field in model_cls._sorts): DCNL DCSP  DCSP sort = model_cls._sorts[field](model_cls, is_ascending) DCNL DCSP elif (field in model_cls._fields): DCNL DCSP  DCSP sort = query.FixedFieldSort(field, is_ascending) DCNL DCSP else: DCNL DCSP  DCSP sort = query.SlowFieldSort(field, is_ascending) DCNL DCSP return sort\n", "intent": "create a sort from a single string criterion .\n", "question_id": 1598}, {"snippet": "def unlock_objects(bus, paths, callback=None): DCNL  DCSP service_obj = bus_get_object(bus, SS_PATH) DCNL DCSP service_iface = InterfaceWrapper(service_obj, SERVICE_IFACE) DCNL DCSP (unlocked_paths, prompt) = service_iface.Unlock(paths, signature='ao') DCNL DCSP unlocked_paths = list(unlocked_paths) DCNL DCSP if (len(prompt) > 1): DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP exec_prompt(bus, prompt, callback) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return exec_prompt_glib(bus, prompt)[0] DCNL DCSP elif callback: DCNL DCSP  DCSP callback(False, unlocked_paths)\n", "intent": "requests unlocking objects specified in paths .\n", "question_id": 1599}, {"snippet": "def Call(func_name, args=None, prefix=None): DCNL  DCSP node = Node(syms.power, [func_name, ArgList(args)]) DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP node.set_prefix(prefix) DCNL DCSP return node\n", "intent": "a function call .\n", "question_id": 1600}, {"snippet": "def _parse_route_template(template, default_sufix=''): DCNL  DCSP variables = {} DCNL DCSP reverse_template = pattern = '' DCNL DCSP args_count = last = 0 DCNL DCSP for match in _route_re.finditer(template): DCNL DCSP  DCSP part = template[last:match.start()] DCNL DCSP  DCSP name = match.group(1) DCNL DCSP  DCSP expr = (match.group(2) or default_sufix) DCNL DCSP  DCSP last = match.end() DCNL DCSP  DCSP if (not name): DCNL DCSP  DCSP  DCSP name = ('__%d__' % args_count) DCNL DCSP  DCSP  DCSP args_count += 1 DCNL DCSP  DCSP pattern += ('%s(?P<%s>%s)' % (re.escape(part), name, expr)) DCNL DCSP  DCSP reverse_template += ('%s%%(%s)s' % (part, name)) DCNL DCSP  DCSP variables[name] = re.compile(('^%s$' % expr)) DCNL DCSP part = template[last:] DCNL DCSP kwargs_count = (len(variables) - args_count) DCNL DCSP reverse_template += part DCNL DCSP regex = re.compile(('^%s%s$' % (pattern, re.escape(part)))) DCNL DCSP return (regex, reverse_template, args_count, kwargs_count, variables)\n", "intent": "lazy route template parser .\n", "question_id": 1601}, {"snippet": "def _interpolate(format): DCNL  DCSP from tokenize import tokenprog DCNL DCSP def matchorfail(text, pos): DCNL DCSP  DCSP match = tokenprog.match(text, pos) DCNL DCSP  DCSP if (match is None): DCNL DCSP  DCSP  DCSP raise _ItplError(text, pos) DCNL DCSP  DCSP return (match, match.end()) DCNL DCSP namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_' DCNL DCSP chunks = [] DCNL DCSP pos = 0 DCNL DCSP while 1: DCNL DCSP  DCSP dollar = format.find('$', pos) DCNL DCSP  DCSP if (dollar < 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP nextchar = format[(dollar + 1)] DCNL DCSP  DCSP if (nextchar == '{'): DCNL DCSP  DCSP  DCSP chunks.append((0, format[pos:dollar])) DCNL DCSP  DCSP  DCSP (pos, level) = ((dollar + 2), 1) DCNL DCSP  DCSP  DCSP while level: DCNL DCSP  DCSP  DCSP  DCSP (match, pos) = matchorfail(format, pos) DCNL DCSP  DCSP  DCSP  DCSP (tstart, tend) = match.regs[3] DCNL DCSP  DCSP  DCSP  DCSP token = format[tstart:tend] DCNL DCSP  DCSP  DCSP  DCSP if (token == '{'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP level = (level + 1) DCNL DCSP  DCSP  DCSP  DCSP elif (token == '}'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP level = (level - 1) DCNL DCSP  DCSP  DCSP chunks.append((1, format[(dollar + 2):(pos - 1)])) DCNL DCSP  DCSP elif (nextchar in namechars): DCNL DCSP  DCSP  DCSP chunks.append((0, format[pos:dollar])) DCNL DCSP  DCSP  DCSP (match, pos) = matchorfail(format, (dollar + 1)) DCNL DCSP  DCSP  DCSP while (pos < len(format)): DCNL DCSP  DCSP  DCSP  DCSP if ((format[pos] == '.') and ((pos + 1) < len(format)) and (format[(pos + 1)] in namechars)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (match, pos) = matchorfail(format, (pos + 1)) DCNL DCSP  DCSP  DCSP  DCSP elif (format[pos] in '(['): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (pos, level) = ((pos + 1), 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP while level: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (match, pos) = matchorfail(format, pos) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (tstart, tend) = match.regs[3] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP token = format[tstart:tend] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (token[0] in '(['): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP level = (level + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (token[0] in ')]'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP level = (level - 1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP chunks.append((1, format[(dollar + 1):pos])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP chunks.append((0, format[pos:(dollar + 1)])) DCNL DCSP  DCSP  DCSP pos = ((dollar + 1) + (nextchar == '$')) DCNL DCSP if (pos < len(format)): DCNL DCSP  DCSP chunks.append((0, format[pos:])) DCNL DCSP return chunks\n", "intent": "takes a format string and returns a list of 2-tuples of the form  where boolean says whether string should be evaled or not .\n", "question_id": 1602}, {"snippet": "def split_list(l, split): DCNL  DCSP m = sp.match(split) DCNL DCSP if (not m): DCNL DCSP  DCSP raise ValueError('split DCSP must DCSP be DCSP a DCSP string DCSP of DCSP the DCSP form DCSP a/b DCSP where DCSP a DCSP and DCSP b DCSP are DCSP ints') DCNL DCSP (i, t) = map(int, m.groups()) DCNL DCSP return l[(((i - 1) * len(l)) // t):((i * len(l)) // t)]\n", "intent": "splits a list into part a of b split should be a string of the form a/b .\n", "question_id": 1603}, {"snippet": "def _install_remote(): DCNL  DCSP download_config() DCNL DCSP read_config() DCNL DCSP rewrite_config() DCNL DCSP create_folders() DCNL DCSP check_dependencies() DCNL DCSP tools_nuget() DCNL DCSP tools_binskim() DCNL DCSP tools_binscope() DCNL DCSP tools_rpcclient() DCNL DCSP generate_secret() DCNL DCSP autostart()\n", "intent": "install the mobsf-utils on a windows-vm for static analysis .\n", "question_id": 1604}, {"snippet": "def make_xontribs_wiz(): DCNL  DCSP md = xontrib_metadata() DCNL DCSP pkgs = [md['packages'].get(d.get('package', None), {}) for d in md['xontribs']] DCNL DCSP w = _make_flat_wiz(make_xontrib, md['xontribs'], pkgs) DCNL DCSP return w\n", "intent": "makes a xontrib wizard .\n", "question_id": 1605}, {"snippet": "def get_versions(module=None): DCNL  DCSP def _ResultHook(rpc): DCNL DCSP  DCSP mapped_errors = [modules_service_pb.ModulesServiceError.INVALID_MODULE, modules_service_pb.ModulesServiceError.TRANSIENT_ERROR] DCNL DCSP  DCSP _CheckAsyncResult(rpc, mapped_errors, {}) DCNL DCSP  DCSP return list(rpc.response.version_list()) DCNL DCSP request = modules_service_pb.GetVersionsRequest() DCNL DCSP if module: DCNL DCSP  DCSP request.set_module(module) DCNL DCSP response = modules_service_pb.GetVersionsResponse() DCNL DCSP return _MakeAsyncCall('GetVersions', request, response, _ResultHook).get_result()\n", "intent": "returns a list of versions for a given module .\n", "question_id": 1606}, {"snippet": "def _attempt_to_acquire_lock(s3_fs, lock_uri, sync_wait_time, job_key, mins_to_expiration=None): DCNL  DCSP key = _lock_acquire_step_1(s3_fs, lock_uri, job_key, mins_to_expiration) DCNL DCSP if (key is None): DCNL DCSP  DCSP return False DCNL DCSP time.sleep(sync_wait_time) DCNL DCSP return _lock_acquire_step_2(key, job_key)\n", "intent": "returns true if this session successfully took ownership of the lock specified by lock_uri .\n", "question_id": 1607}, {"snippet": "@pytest.mark.cmd DCNL @pytest.mark.django_db DCNL def test_changed_languages_since_revision(capfd, project0_nongnu, tp0): DCNL  DCSP for store in tp0.stores.all(): DCNL DCSP  DCSP store.sync() DCNL DCSP rev = (tp0.stores.aggregate(rev=Min('last_sync_revision'))['rev'] - 1) DCNL DCSP call_command('changed_languages', ('--after-revision=%s' % rev)) DCNL DCSP (out, err) = capfd.readouterr() DCNL DCSP assert (out == u'language0,language1,templates\\n') DCNL DCSP revision = Revision.get() DCNL DCSP unit = tp0.stores.first().units.first() DCNL DCSP unit.target = 'NEW DCSP TARGET' DCNL DCSP unit.save() DCNL DCSP call_command('changed_languages', ('--after-revision=%s' % revision)) DCNL DCSP (out, err) = capfd.readouterr() DCNL DCSP assert (out == u'language0\\n')\n", "intent": "changed languages since a given revision .\n", "question_id": 1608}, {"snippet": "def FillUser(property): DCNL  DCSP if property.value().has_uservalue(): DCNL DCSP  DCSP uid = SynthesizeUserId(property.value().uservalue().email()) DCNL DCSP  DCSP if uid: DCNL DCSP  DCSP  DCSP property.mutable_value().mutable_uservalue().set_obfuscated_gaiaid(uid)\n", "intent": "fill in a synthetic user id for a user properties .\n", "question_id": 1609}, {"snippet": "def pdchAssignmentCommand(ChannelDescription_presence=0, CellChannelDescription_presence=0, MobileAllocation_presence=0, StartingTime_presence=0, FrequencyList_presence=0, ChannelDescription_presence1=0, FrequencyChannelSequence_presence=0, MobileAllocation_presence1=0, PacketChannelDescription_presence=0, DedicatedModeOrTBF_presence=0): DCNL  DCSP a = TpPd(pd=6) DCNL DCSP b = MessageType(mesType=35) DCNL DCSP c = ChannelDescription() DCNL DCSP packet = ((a / b) / c) DCNL DCSP if (ChannelDescription_presence is 1): DCNL DCSP  DCSP d = ChannelDescriptionHdr(ieiCD=98, eightBitCD=0) DCNL DCSP  DCSP packet = (packet / d) DCNL DCSP if (CellChannelDescription_presence is 1): DCNL DCSP  DCSP e = CellChannelDescriptionHdr(ieiCCD=5, eightBitCCD=0) DCNL DCSP  DCSP packet = (packet / e) DCNL DCSP if (MobileAllocation_presence is 1): DCNL DCSP  DCSP f = MobileAllocationHdr(ieiMA=114, eightBitMA=0) DCNL DCSP  DCSP packet = (packet / f) DCNL DCSP if (StartingTime_presence is 1): DCNL DCSP  DCSP g = StartingTimeHdr(ieiST=124, eightBitST=0) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP if (FrequencyList_presence is 1): DCNL DCSP  DCSP h = FrequencyListHdr(ieiFL=25, eightBitFL=0) DCNL DCSP  DCSP packet = (packet / h) DCNL DCSP if (ChannelDescription_presence1 is 1): DCNL DCSP  DCSP i = ChannelDescriptionHdr(ieiCD=28, eightBitCD=0) DCNL DCSP  DCSP packet = (packet / i) DCNL DCSP if (FrequencyChannelSequence_presence is 1): DCNL DCSP  DCSP j = FrequencyChannelSequenceHdr(ieiFCS=30, eightBitFCS=0) DCNL DCSP  DCSP packet = (packet / j) DCNL DCSP if (MobileAllocation_presence1 is 1): DCNL DCSP  DCSP k = MobileAllocationHdr(ieiMA=33, eightBitMA=0) DCNL DCSP  DCSP packet = (packet / k) DCNL DCSP if (PacketChannelDescription_presence is 1): DCNL DCSP  DCSP l = PacketChannelDescription(ieiPCD=34) DCNL DCSP  DCSP packet = (packet / l) DCNL DCSP if (DedicatedModeOrTBF_presence is 1): DCNL DCSP  DCSP m = DedicatedModeOrTBFHdr(ieiDMOT=35, eightBitDMOT=0) DCNL DCSP  DCSP packet = (packet / m) DCNL DCSP return packet\n", "intent": "pdch assignment command section 9 .\n", "question_id": 1610}, {"snippet": "def formList(): DCNL  DCSP tables = ['irs_ireport', 'rms_req', 'cr_shelter', 'pr_person', 'pr_image'] DCNL DCSP xml = TAG.forms() DCNL DCSP for tablename in tables: DCNL DCSP  DCSP xml.append(TAG.form(get_name(tablename), _url=(('http://' + request.env.http_host) + URL(f='create', args=tablename)))) DCNL DCSP response.headers['Content-Type'] = 'text/xml' DCNL DCSP response.view = 'xforms.xml' DCNL DCSP return xml\n", "intent": "generates a list of xforms based on database tables for odk collect URL @todo: deprecate .\n", "question_id": 1611}, {"snippet": "def knapsack_rep(weights, values, W): DCNL  DCSP k = ([0] * (W + 1)) DCNL DCSP for w in range(1, (W + 1)): DCNL DCSP  DCSP k[w] = max([((k[(w - i)] + values[i]) if (weights[i] <= w) else 0) for i in range(len(weights))]) DCNL DCSP return k[(-1)]\n", "intent": "knapsack with repetition .\n", "question_id": 1612}, {"snippet": "def test_maxfilter(): DCNL  DCSP check_usage(mne_maxfilter) DCNL DCSP with ArgvSetter(('-i', raw_fname, '--st', '--movecomp', '--linefreq', '60', '--trans', raw_fname)) as out: DCNL DCSP  DCSP with warnings.catch_warnings(record=True) as w: DCNL DCSP  DCSP  DCSP warnings.simplefilter('always') DCNL DCSP  DCSP  DCSP os.environ['_MNE_MAXFILTER_TEST'] = 'true' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP mne_maxfilter.run() DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP del os.environ['_MNE_MAXFILTER_TEST'] DCNL DCSP  DCSP assert_true((len(w) == 1)) DCNL DCSP  DCSP for check in ('maxfilter', '-trans', '-movecomp'): DCNL DCSP  DCSP  DCSP assert_true((check in out.stdout.getvalue()), check)\n", "intent": "test mne maxfilter .\n", "question_id": 1613}, {"snippet": "def detokenize(token_rules, words): DCNL  DCSP string = ' DCSP '.join(words) DCNL DCSP for subtoks in token_rules: DCNL DCSP  DCSP string = string.replace(subtoks.replace('<SEP>', ' DCSP '), subtoks) DCNL DCSP positions = [] DCNL DCSP i = 0 DCNL DCSP for chunk in string.split(): DCNL DCSP  DCSP subtoks = chunk.split('<SEP>') DCNL DCSP  DCSP positions.append(tuple(range(i, (i + len(subtoks))))) DCNL DCSP  DCSP i += len(subtoks) DCNL DCSP return positions\n", "intent": "to align with treebanks .\n", "question_id": 1614}, {"snippet": "def lazy_gettext(string, **variables): DCNL  DCSP return support.LazyProxy(gettext, string, **variables)\n", "intent": "a lazy version of :func:gettext .\n", "question_id": 1615}, {"snippet": "def push_mirrors(config, git_dir): DCNL  DCSP log = logging.getLogger('gitosis.mirror.push_mirrors') DCNL DCSP repository_dir = os.path.abspath(util.getRepositoryDir(config)) DCNL DCSP git_dir = os.path.abspath(git_dir) DCNL DCSP git_name = get_git_name(repository_dir, git_dir) DCNL DCSP log.info((\"Updating DCSP %s's DCSP mirrors.\" % git_name)) DCNL DCSP for remote in get_mirrors(config, git_name): DCNL DCSP  DCSP log.info(('Updating DCSP %s.' % remote)) DCNL DCSP  DCSP repository.mirror(git_dir, remote)\n", "intent": "apply a push with the mirror option to all mirrors defined in gitosis .\n", "question_id": 1616}, {"snippet": "def get_embargo_response(request, course_id, user): DCNL  DCSP redirect_url = redirect_if_blocked(course_id, user=user, ip_address=get_ip(request), url=request.path) DCNL DCSP if redirect_url: DCNL DCSP  DCSP return Response(status=status.HTTP_403_FORBIDDEN, data={'message': u\"Users DCSP from DCSP this DCSP location DCSP cannot DCSP access DCSP the DCSP course DCSP '{course_id}'.\".format(course_id=course_id), 'user_message_url': request.build_absolute_uri(redirect_url)})\n", "intent": "check whether any country access rules block the user from enrollment .\n", "question_id": 1617}, {"snippet": "def version_cmp(pkg1, pkg2, ignore_epoch=False): DCNL  DCSP normalize = (lambda x: (str(x).split(':', 1)[(-1)] if ignore_epoch else str(x))) DCNL DCSP pkg1 = normalize(pkg1) DCNL DCSP pkg2 = normalize(pkg2) DCNL DCSP if HAS_APTPKG: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP apt_pkg.init_system() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ret = apt_pkg.version_compare(pkg1, pkg2) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP ret = apt_pkg.version_compare(str(pkg1), str(pkg2)) DCNL DCSP  DCSP  DCSP return (1 if (ret > 0) else ((-1) if (ret < 0) else 0)) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP for (oper, ret) in (('lt', (-1)), ('eq', 0), ('gt', 1)): DCNL DCSP  DCSP  DCSP cmd = ['dpkg', '--compare-versions', pkg1, oper, pkg2] DCNL DCSP  DCSP  DCSP retcode = __salt__['cmd.retcode'](cmd, output_loglevel='trace', python_shell=False, ignore_retcode=True) DCNL DCSP  DCSP  DCSP if (retcode == 0): DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP except Exception as exc: DCNL DCSP  DCSP log.error(exc) DCNL DCSP return None\n", "intent": "do a cmp-style comparison on two packages .\n", "question_id": 1618}, {"snippet": "def rand(*size, **kwarg): DCNL  DCSP dtype = kwarg.pop('dtype', float) DCNL DCSP if kwarg: DCNL DCSP  DCSP raise TypeError(('rand() DCSP got DCSP unexpected DCSP keyword DCSP arguments DCSP %s' % ', DCSP '.join(kwarg.keys()))) DCNL DCSP return random_sample(size=size, dtype=dtype)\n", "intent": "returns an array of uniform random values over the interval [0 .\n", "question_id": 1619}, {"snippet": "def _evalf(func, points, derivatives=False, method='RK4'): DCNL  DCSP ann = func.annihilator DCNL DCSP a = ann.order DCNL DCSP R = ann.parent.base DCNL DCSP K = R.get_field() DCNL DCSP if (method == 'Euler'): DCNL DCSP  DCSP meth = _euler DCNL DCSP else: DCNL DCSP  DCSP meth = _rk4 DCNL DCSP dmf = [] DCNL DCSP for j in ann.listofpoly: DCNL DCSP  DCSP dmf.append(K.new(j.rep)) DCNL DCSP red = [((- dmf[i]) / dmf[a]) for i in range(a)] DCNL DCSP y0 = func.y0 DCNL DCSP if (len(y0) < a): DCNL DCSP  DCSP raise TypeError('Not DCSP Enough DCSP Initial DCSP Conditions') DCNL DCSP x0 = func.x0 DCNL DCSP sol = [meth(red, x0, points[0], y0, a)] DCNL DCSP for (i, j) in enumerate(points[1:]): DCNL DCSP  DCSP sol.append(meth(red, points[i], j, sol[(-1)], a)) DCNL DCSP if (not derivatives): DCNL DCSP  DCSP return [sympify(i[0]) for i in sol] DCNL DCSP else: DCNL DCSP  DCSP return sympify(sol)\n", "intent": "numerical methods for numerical integration along a given set of points in the complex plane .\n", "question_id": 1620}, {"snippet": "def get_complete_url(backend_name): DCNL  DCSP if (not any(provider.Registry.get_enabled_by_backend_name(backend_name))): DCNL DCSP  DCSP raise ValueError(('Provider DCSP with DCSP backend DCSP %s DCSP not DCSP enabled' % backend_name)) DCNL DCSP return _get_url('social:complete', backend_name)\n", "intent": "gets url for the endpoint that returns control to the auth pipeline .\n", "question_id": 1621}, {"snippet": "def handle_copy_source_param(params, **kwargs): DCNL  DCSP source = params.get('CopySource') DCNL DCSP if (source is None): DCNL DCSP  DCSP return DCNL DCSP if isinstance(source, six.string_types): DCNL DCSP  DCSP params['CopySource'] = _quote_source_header(source) DCNL DCSP elif isinstance(source, dict): DCNL DCSP  DCSP params['CopySource'] = _quote_source_header_from_dict(source)\n", "intent": "convert copysource param for copyobject/uploadpartcopy .\n", "question_id": 1622}, {"snippet": "def attach_userstory_statuses(queryset, as_field='userstory_statuses_attr'): DCNL  DCSP model = queryset.model DCNL DCSP sql = '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP json_agg(\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP row_to_json(projects_userstorystatus)\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ORDER DCSP BY DCSP projects_userstorystatus.order\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP projects_userstorystatus\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP projects_userstorystatus.project_id DCSP = DCSP {tbl}.id\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP sql = sql.format(tbl=model._meta.db_table) DCNL DCSP queryset = queryset.extra(select={as_field: sql}) DCNL DCSP return queryset\n", "intent": "attach a json userstory statuses representation to each object of the queryset .\n", "question_id": 1623}, {"snippet": "def create_object(typeclass=None, key=None, location=None, home=None, permissions=None, locks=None, aliases=None, tags=None, destination=None, report_to=None, nohome=False): DCNL  DCSP global _ObjectDB DCNL DCSP if (not _ObjectDB): DCNL DCSP  DCSP from evennia.objects.models import ObjectDB as _ObjectDB DCNL DCSP typeclass = (typeclass if typeclass else settings.BASE_OBJECT_TYPECLASS) DCNL DCSP if isinstance(typeclass, basestring): DCNL DCSP  DCSP typeclass = class_from_module(typeclass, settings.TYPECLASS_PATHS) DCNL DCSP location = dbid_to_obj(location, _ObjectDB) DCNL DCSP destination = dbid_to_obj(destination, _ObjectDB) DCNL DCSP home = dbid_to_obj(home, _ObjectDB) DCNL DCSP if (not home): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP home = (dbid_to_obj(settings.DEFAULT_HOME, _ObjectDB) if (not nohome) else None) DCNL DCSP  DCSP except _ObjectDB.DoesNotExist: DCNL DCSP  DCSP  DCSP raise _ObjectDB.DoesNotExist((\"settings.DEFAULT_HOME DCSP (= DCSP '%s') DCSP does DCSP not DCSP exist, DCSP or DCSP the DCSP setting DCSP is DCSP malformed.\" % settings.DEFAULT_HOME)) DCNL DCSP new_object = typeclass(db_key=key, db_location=location, db_destination=destination, db_home=home, db_typeclass_path=typeclass.path) DCNL DCSP new_object._createdict = {'key': key, 'location': location, 'destination': destination, 'home': home, 'typeclass': typeclass.path, 'permissions': permissions, 'locks': locks, 'aliases': aliases, 'tags': tags, 'destination': destination, 'report_to': report_to, 'nohome': nohome} DCNL DCSP new_object.save() DCNL DCSP return new_object\n", "intent": "create a new in-game object .\n", "question_id": 1624}, {"snippet": "def setup_wizard_visible_panes(shop): DCNL  DCSP return (len(load_setup_wizard_panes(shop)) > 0)\n", "intent": "check if shop wizard has visible panes that require merchant configuration .\n", "question_id": 1625}, {"snippet": "def question(): DCNL  DCSP def prep(r): DCNL DCSP  DCSP record = r.record DCNL DCSP  DCSP if (record and (r.component_name == 'question_l10n')): DCNL DCSP  DCSP  DCSP ttable = r.component.table DCNL DCSP  DCSP  DCSP if (r.method != 'update'): DCNL DCSP  DCSP  DCSP  DCSP ttable.question.default = record.question DCNL DCSP  DCSP  DCSP  DCSP ttable.options.default = record.options DCNL DCSP  DCSP  DCSP requires = ttable.language.requires DCNL DCSP  DCSP  DCSP if isinstance(requires, IS_ISO639_2_LANGUAGE_CODE): DCNL DCSP  DCSP  DCSP  DCSP all_options = dict(requires.language_codes()) DCNL DCSP  DCSP  DCSP  DCSP selectable = requires._select DCNL DCSP  DCSP  DCSP  DCSP if (not selectable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP selectable = all_options DCNL DCSP  DCSP  DCSP  DCSP selectable = dict(selectable) DCNL DCSP  DCSP  DCSP  DCSP query = ((ttable.question_id == r.id) & (ttable.deleted != True)) DCNL DCSP  DCSP  DCSP  DCSP if r.component_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP query &= (ttable.id != r.component_id) DCNL DCSP  DCSP  DCSP  DCSP rows = db(query).select(ttable.language) DCNL DCSP  DCSP  DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP  DCSP  DCSP selectable.pop(row.language, None) DCNL DCSP  DCSP  DCSP  DCSP if ((len(selectable) == 0) or (not any(((opt in all_options) for opt in selectable)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r.component.configure(insertable=False) DCNL DCSP  DCSP  DCSP  DCSP requires._select = selectable DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller(rheader=s3db.dc_rheader)\n", "intent": "manage data collection questions .\n", "question_id": 1626}, {"snippet": "def Dispatch(dispatch, userName=None, resultCLSID=None, typeinfo=None, UnicodeToString=None, clsctx=pythoncom.CLSCTX_SERVER): DCNL  DCSP assert (UnicodeToString is None), 'this DCSP is DCSP deprecated DCSP and DCSP will DCSP go DCSP away' DCNL DCSP (dispatch, userName) = dynamic._GetGoodDispatchAndUserName(dispatch, userName, clsctx) DCNL DCSP return __WrapDispatch(dispatch, userName, resultCLSID, typeinfo, clsctx=clsctx)\n", "intent": "creates a dispatch based com object .\n", "question_id": 1627}, {"snippet": "def ImportStateName(state): DCNL  DCSP return {STATE_READ: 'READ', STATE_GETTING: 'SENDING', STATE_GOT: 'SENT', STATE_NOT_SENT: 'NOT_SENT'}[state]\n", "intent": "converts a numeric state identifier to a string .\n", "question_id": 1628}, {"snippet": "def _project_cert_subject(project_id): DCNL  DCSP return (CONF.project_cert_subject % (project_id, timeutils.isotime()))\n", "intent": "helper to generate user cert subject .\n", "question_id": 1629}, {"snippet": "def get_split_user_partitions(user_partitions): DCNL  DCSP return [user_partition for user_partition in user_partitions if (user_partition.scheme.name == 'random')]\n", "intent": "helper method that filters a list of user_partitions and returns just the ones that are suitable for the split_test module .\n", "question_id": 1630}, {"snippet": "def report_on_config(args, graphtype=u'countgraph'): DCNL  DCSP check_conflicting_args(args, graphtype) DCNL DCSP if (graphtype not in khmer._buckets_per_byte): DCNL DCSP  DCSP raise ValueError((u'unknown DCSP graph DCSP type: DCSP ' + graphtype)) DCNL DCSP tablesize = calculate_graphsize(args, graphtype) DCNL DCSP maxmem = ((args.n_tables * tablesize) / khmer._buckets_per_byte[graphtype]) DCNL DCSP log_info(u'\\nPARAMETERS:') DCNL DCSP log_info(u' DCSP - DCSP kmer DCSP size DCSP = DCSP  DCSP  DCSP  DCSP  DCSP {ksize} DCSP  DCTB  DCTB (-k)', ksize=args.ksize) DCNL DCSP log_info(u' DCSP - DCSP n DCSP tables DCSP = DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {ntables} DCSP  DCTB  DCTB (-N)', ntables=args.n_tables) DCNL DCSP log_info(u' DCSP - DCSP max DCSP tablesize DCSP = DCSP {tsize:5.2g} DCSP  DCTB (-x)', tsize=tablesize) DCNL DCSP log_info(u'Estimated DCSP memory DCSP usage DCSP is DCSP {mem:.1f} DCSP Gb DCSP ({bytes:.2g} DCSP bytes DCSP = DCSP {ntables} DCSP bytes DCSP x DCSP {tsize:5.2g} DCSP entries DCSP / DCSP {div:d} DCSP entries DCSP per DCSP byte)', bytes=maxmem, mem=(maxmem / 1000000000.0), div=khmer._buckets_per_byte[graphtype], ntables=args.n_tables, tsize=tablesize) DCNL DCSP log_info((u'-' * 8)) DCNL DCSP if ((tablesize == DEFAULT_MAX_TABLESIZE) and (not getattr(args, u'loadgraph', None))): DCNL DCSP  DCSP log_warn(u'\\n** DCSP WARNING: DCSP tablesize DCSP is DCSP default!\\n** DCSP You DCSP probably DCSP want DCSP to DCSP increase DCSP this DCSP with DCSP -M/--max-memory-usage!\\n** DCSP Please DCSP read DCSP the DCSP docs!\\n')\n", "intent": "print out configuration .\n", "question_id": 1631}, {"snippet": "def dump_module_sessions(module): DCNL  DCSP global HOUSE DCNL DCSP if (not (module in HOUSE.keys())): DCNL DCSP  DCSP Error((\"Module DCSP '%s' DCSP not DCSP found.\" % module)) DCNL DCSP  DCSP return DCNL DCSP else: DCNL DCSP  DCSP mod = HOUSE[module] DCNL DCSP print (((((((color.B_YELLOW + '[') + color.B_RED) + '!') + color.B_YELLOW) + '] DCSP ') + color.B_WHITE) + module) DCNL DCSP for (cnt, obj) in enumerate(mod.keys()): DCNL DCSP  DCSP print (((((((color.B_GREEN + ' DCTB [') + color.B_YELLOW) + str(cnt)) + color.B_GREEN) + '] DCSP ') + color.B_WHITE) + str(obj))\n", "intent": "dump running sessions for a module .\n", "question_id": 1632}, {"snippet": "def check_segments(coll, positions, linelength, lineoffset, orientation): DCNL  DCSP segments = coll.get_segments() DCNL DCSP if ((orientation.lower() == u'horizontal') or (orientation.lower() == u'none') or (orientation is None)): DCNL DCSP  DCSP pos1 = 1 DCNL DCSP  DCSP pos2 = 0 DCNL DCSP elif (orientation.lower() == u'vertical'): DCNL DCSP  DCSP pos1 = 0 DCNL DCSP  DCSP pos2 = 1 DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(u\"orientation DCSP must DCSP be DCSP 'horizontal' DCSP or DCSP 'vertical'\") DCNL DCSP for (i, segment) in enumerate(segments): DCNL DCSP  DCSP assert_equal(segment[(0, pos1)], (lineoffset + (linelength / 2.0))) DCNL DCSP  DCSP assert_equal(segment[(1, pos1)], (lineoffset - (linelength / 2.0))) DCNL DCSP  DCSP assert_equal(segment[(0, pos2)], positions[i]) DCNL DCSP  DCSP assert_equal(segment[(1, pos2)], positions[i])\n", "intent": "check to make sure all values in the segment are correct .\n", "question_id": 1633}, {"snippet": "def __virtual__(): DCNL  DCSP supported = ['NetBSD', 'SunOS', 'DragonFly', 'Minix', 'Darwin', 'SmartOS'] DCNL DCSP if ((__grains__['os'] in supported) and _check_pkgin()): DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return (False, 'The DCSP pkgin DCSP execution DCSP module DCSP cannot DCSP be DCSP loaded: DCSP only DCSP available DCSP on DCSP {0} DCSP systems.'.format(', DCSP '.join(supported)))\n", "intent": "set the virtual pkg module if the os is supported by pkgin .\n", "question_id": 1634}, {"snippet": "def compute_sample_weight(class_weight, y, indices=None): DCNL  DCSP y = np.atleast_1d(y) DCNL DCSP if (y.ndim == 1): DCNL DCSP  DCSP y = np.reshape(y, ((-1), 1)) DCNL DCSP n_outputs = y.shape[1] DCNL DCSP if isinstance(class_weight, six.string_types): DCNL DCSP  DCSP if (class_weight not in ['balanced']): DCNL DCSP  DCSP  DCSP raise ValueError(('The DCSP only DCSP valid DCSP preset DCSP for DCSP class_weight DCSP is DCSP \"balanced\". DCSP Given DCSP \"%s\".' % class_weight)) DCNL DCSP elif ((indices is not None) and (not isinstance(class_weight, six.string_types))): DCNL DCSP  DCSP raise ValueError(('The DCSP only DCSP valid DCSP class_weight DCSP for DCSP subsampling DCSP is DCSP \"balanced\". DCSP Given DCSP \"%s\".' % class_weight)) DCNL DCSP elif (n_outputs > 1): DCNL DCSP  DCSP if ((not hasattr(class_weight, '__iter__')) or isinstance(class_weight, dict)): DCNL DCSP  DCSP  DCSP raise ValueError('For DCSP multi-output, DCSP class_weight DCSP should DCSP be DCSP a DCSP list DCSP of DCSP dicts, DCSP or DCSP a DCSP valid DCSP string.') DCNL DCSP  DCSP if (len(class_weight) != n_outputs): DCNL DCSP  DCSP  DCSP raise ValueError('For DCSP multi-output, DCSP number DCSP of DCSP elements DCSP in DCSP class_weight DCSP should DCSP match DCSP number DCSP of DCSP outputs.') DCNL DCSP expanded_class_weight = [] DCNL DCSP for k in range(n_outputs): DCNL DCSP  DCSP y_full = y[:, k] DCNL DCSP  DCSP classes_full = np.unique(y_full) DCNL DCSP  DCSP classes_missing = None DCNL DCSP  DCSP if ((class_weight == 'balanced') or (n_outputs == 1)): DCNL DCSP  DCSP  DCSP class_weight_k = class_weight DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP class_weight_k = class_weight[k] DCNL DCSP  DCSP if (indices is not None): DCNL DCSP  DCSP  DCSP y_subsample = y[(indices, k)] DCNL DCSP  DCSP  DCSP classes_subsample = np.unique(y_subsample) DCNL DCSP  DCSP  DCSP weight_k = np.choose(np.searchsorted(classes_subsample, classes_full), compute_class_weight(class_weight_k, classes_subsample, y_subsample), mode='clip') DCNL DCSP  DCSP  DCSP classes_missing = (set(classes_full) - set(classes_subsample)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP weight_k = compute_class_weight(class_weight_k, classes_full, y_full) DCNL DCSP  DCSP weight_k = weight_k[np.searchsorted(classes_full, y_full)] DCNL DCSP  DCSP if classes_missing: DCNL DCSP  DCSP  DCSP weight_k[in1d(y_full, list(classes_missing))] = 0.0 DCNL DCSP  DCSP expanded_class_weight.append(weight_k) DCNL DCSP expanded_class_weight = np.prod(expanded_class_weight, axis=0, dtype=np.float64) DCNL DCSP return expanded_class_weight\n", "intent": "estimate sample weights by class for unbalanced datasets .\n", "question_id": 1635}, {"snippet": "def __validate__(config): DCNL  DCSP if (not isinstance(config, dict)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP for item in config: DCNL DCSP  DCSP  DCSP if (not isinstance(config[item], dict)): DCNL DCSP  DCSP  DCSP  DCSP return (False, 'Configuration DCSP for DCSP journald DCSP beacon DCSP must DCSP be DCSP a DCSP dictionary DCSP of DCSP dictionaries.') DCNL DCSP return (True, 'Valid DCSP beacon DCSP configuration')\n", "intent": "validate the beacon configuration .\n", "question_id": 1636}, {"snippet": "@register.simple_tag(takes_context=True) DCNL def expand_fragment_header_link(context, header): DCNL  DCSP lines_of_context = context[u'lines_of_context'] DCNL DCSP offset = (context[u'first_line'] - header[u'line']) DCNL DCSP return render_to_string(u'reviews/expand_link.html', {u'tooltip': _(u'Expand DCSP to DCSP header'), u'text': format_html(u'<code>{0}</code>', header[u'text']), u'comment_id': context[u'comment'].id, u'expand_pos': ((lines_of_context[0] + offset), lines_of_context[1]), u'image_class': u'rb-icon-diff-expand-header'})\n", "intent": "render a diff comment fragment header expansion link .\n", "question_id": 1637}, {"snippet": "@FileSystem.in_directory(current_directory, 'django', 'dill') DCNL def test_model_existence_check(): DCNL  DCSP (status, out) = run_scenario('leaves', 'existence', 1) DCNL DCSP assert_equals(status, 0, out) DCNL DCSP (status, out) = run_scenario('leaves', 'existence', 2) DCNL DCSP assert_not_equals(status, 0) DCNL DCSP assert (\"Garden DCSP does DCSP not DCSP exist: DCSP {u'name': DCSP u'Botanic DCSP Gardens'}\" in out) DCNL DCSP gardens = '\\n'.join(['Rows DCSP in DCSP DB DCSP are:', 'id=1, DCSP name=Secret DCSP Garden, DCSP area=45, DCSP raining=False,', \"id=2, DCSP name=Octopus's DCSP Garden, DCSP area=120, DCSP raining=True,\", 'id=3, DCSP name=Covent DCSP Garden, DCSP area=200, DCSP raining=True,']) DCNL DCSP assert (gardens in out) DCNL DCSP assert ('AssertionError: DCSP 1 DCSP rows DCSP missing' in out) DCNL DCSP (status, out) = run_scenario('leaves', 'existence', 3) DCNL DCSP assert_not_equals(status, 0) DCNL DCSP assert (\"Garden DCSP does DCSP not DCSP exist: DCSP {u'name': DCSP u'Secret DCSP Garden', DCSP u'@howbig': DCSP u'huge'}\" in out) DCNL DCSP gardens = '\\n'.join(['Rows DCSP in DCSP DB DCSP are:', 'id=1, DCSP name=Secret DCSP Garden, DCSP area=45, DCSP raining=False, DCSP howbig=small,', \"id=2, DCSP name=Octopus's DCSP Garden, DCSP area=120, DCSP raining=True, DCSP howbig=medium,\", 'id=3, DCSP name=Covent DCSP Garden, DCSP area=200, DCSP raining=True, DCSP howbig=big,']) DCNL DCSP assert (gardens in out) DCNL DCSP assert ('AssertionError: DCSP 1 DCSP rows DCSP missing' in out) DCNL DCSP (status, out) = run_scenario('leaves', 'existence', 4) DCNL DCSP assert_not_equals(status, 0) DCNL DCSP assert ('Expected DCSP 2 DCSP geese, DCSP found DCSP 1' in out)\n", "intent": "model existence is checked through lettuce steps .\n", "question_id": 1638}, {"snippet": "def libvlc_video_get_track_description(p_mi): DCNL  DCSP f = (_Cfunctions.get('libvlc_video_get_track_description', None) or _Cfunction('libvlc_video_get_track_description', ((1,),), None, ctypes.POINTER(TrackDescription), MediaPlayer)) DCNL DCSP return f(p_mi)\n", "intent": "get the description of available video tracks .\n", "question_id": 1639}, {"snippet": "def file_hash(load, fnd): DCNL  DCSP if ('env' in load): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', \"Parameter DCSP 'env' DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen.\") DCNL DCSP  DCSP load.pop('env') DCNL DCSP if (not all(((x in load) for x in ('path', 'saltenv')))): DCNL DCSP  DCSP return '' DCNL DCSP saltenv = load['saltenv'] DCNL DCSP if (saltenv == 'base'): DCNL DCSP  DCSP saltenv = 'trunk' DCNL DCSP ret = {} DCNL DCSP relpath = fnd['rel'] DCNL DCSP path = fnd['path'] DCNL DCSP if ((not path) or (not os.path.isfile(path))): DCNL DCSP  DCSP return ret DCNL DCSP ret['hash_type'] = __opts__['hash_type'] DCNL DCSP cache_path = os.path.join(__opts__['cachedir'], 'svnfs/hash', saltenv, '{0}.hash.{1}'.format(relpath, __opts__['hash_type'])) DCNL DCSP if os.path.exists(cache_path): DCNL DCSP  DCSP with salt.utils.fopen(cache_path, 'rb') as fp_: DCNL DCSP  DCSP  DCSP (hsum, mtime) = fp_.read().split(':') DCNL DCSP  DCSP  DCSP if (os.path.getmtime(path) == mtime): DCNL DCSP  DCSP  DCSP  DCSP ret['hsum'] = hsum DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP ret['hsum'] = salt.utils.get_hash(path, __opts__['hash_type']) DCNL DCSP cache_dir = os.path.dirname(cache_path) DCNL DCSP if (not os.path.exists(cache_dir)): DCNL DCSP  DCSP os.makedirs(cache_dir) DCNL DCSP with salt.utils.fopen(cache_path, 'w') as fp_: DCNL DCSP  DCSP fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path))) DCNL DCSP return ret\n", "intent": "return a file hash .\n", "question_id": 1640}, {"snippet": "def continue_training(path): DCNL  DCSP with change_recursion_limit(config.recursion_limit): DCNL DCSP  DCSP with open(path, 'rb') as f: DCNL DCSP  DCSP  DCSP main_loop = load(f) DCNL DCSP main_loop.run()\n", "intent": "continues training using checkpoint .\n", "question_id": 1641}, {"snippet": "@mock_ec2 DCNL def test_dhcp_options_associate(): DCNL  DCSP conn = boto.connect_vpc(u'the_key', u'the_secret') DCNL DCSP dhcp_options = conn.create_dhcp_options(SAMPLE_DOMAIN_NAME, SAMPLE_NAME_SERVERS) DCNL DCSP vpc = conn.create_vpc(u'10.0.0.0/16') DCNL DCSP rval = conn.associate_dhcp_options(dhcp_options.id, vpc.id) DCNL DCSP rval.should.be.equal(True)\n", "intent": "associate dhcp option .\n", "question_id": 1642}, {"snippet": "def partition_by_cut(cut, rag): DCNL  DCSP nodes1 = [n for (i, n) in enumerate(rag.nodes()) if cut[i]] DCNL DCSP nodes2 = [n for (i, n) in enumerate(rag.nodes()) if (not cut[i])] DCNL DCSP sub1 = rag.subgraph(nodes1) DCNL DCSP sub2 = rag.subgraph(nodes2) DCNL DCSP return (sub1, sub2)\n", "intent": "compute resulting subgraphs from given bi-parition .\n", "question_id": 1643}, {"snippet": "@app.route('/scans/<int:scan_id>/urls/', methods=['GET']) DCNL @requires_auth DCNL def get_url_list(scan_id): DCNL  DCSP scan_info = get_scan_info_from_id(scan_id) DCNL DCSP if (scan_info is None): DCNL DCSP  DCSP abort(404, 'Scan DCSP not DCSP found') DCNL DCSP data = [str(u) for u in kb.kb.get_all_known_urls()] DCNL DCSP return jsonify({'items': data})\n", "intent": "a list with all the known urls by this scanner .\n", "question_id": 1644}, {"snippet": "@contextlib.contextmanager DCNL def try_target_cell(context, cell): DCNL  DCSP if cell: DCNL DCSP  DCSP with nova_context.target_cell(context, cell) as cell_context: DCNL DCSP  DCSP  DCSP (yield cell_context) DCNL DCSP else: DCNL DCSP  DCSP (yield context)\n", "intent": "if cell is not none call func with context .\n", "question_id": 1645}, {"snippet": "def get_num_groups(group_by, **filter_data): DCNL  DCSP query = models.TestView.objects.get_query_set_with_joins(filter_data) DCNL DCSP query = models.TestView.query_objects(filter_data, initial_query=query) DCNL DCSP return models.TestView.objects.get_num_groups(query, group_by)\n", "intent": "gets the count of unique groups with the given grouping fields .\n", "question_id": 1646}, {"snippet": "def _reloader_child(server, app, interval): DCNL  DCSP lockfile = os.environ.get('BOTTLE_LOCKFILE') DCNL DCSP bgcheck = FileCheckerThread(lockfile, interval) DCNL DCSP try: DCNL DCSP  DCSP bgcheck.start() DCNL DCSP  DCSP server.run(app) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass DCNL DCSP (bgcheck.status, status) = (5, bgcheck.status) DCNL DCSP bgcheck.join() DCNL DCSP if status: DCNL DCSP  DCSP sys.exit(status)\n", "intent": "start the server and check for modified files in a background thread .\n", "question_id": 1647}, {"snippet": "def bpic(trace, model=None): DCNL  DCSP model = modelcontext(model) DCNL DCSP mean_deviance = ((-2) * np.mean([model.logp(pt) for pt in trace])) DCNL DCSP free_rv_means = {rv.name: trace[rv.name].mean(axis=0) for rv in model.free_RVs} DCNL DCSP deviance_at_mean = ((-2) * model.logp(free_rv_means)) DCNL DCSP return ((3 * mean_deviance) - (2 * deviance_at_mean))\n", "intent": "calculates bayesian predictive information criterion n of the samples in trace from model read more theory here - in a paper by some of the leading authorities on model selection - dx .\n", "question_id": 1648}, {"snippet": "def getPage(url, contextFactory=None, *args, **kwargs): DCNL  DCSP return _makeGetterFactory(url, HTTPClientFactory, contextFactory=contextFactory, *args, **kwargs).deferred\n", "intent": "download a web page as a string .\n", "question_id": 1649}, {"snippet": "def smoothstep(edge0, edge1, x): DCNL  DCSP x = np.clip(((x - edge0) / (edge1 - edge0)), 0.0, 1.0) DCNL DCSP return ((x * x) * (3 - (2 * x)))\n", "intent": "performs smooth hermite interpolation between 0 and 1 when edge0 < x < edge1 .\n", "question_id": 1650}, {"snippet": "def is_owner_user(id, user): DCNL  DCSP conferences = get_memcached(get_key('conferences')) DCNL DCSP if (conferences[id]['info']['creator'] == user): DCNL DCSP  DCSP return True DCNL DCSP return False\n", "intent": "checks whether user is owner of conferences .\n", "question_id": 1651}, {"snippet": "def get_nodes(node, klass): DCNL  DCSP for child in node.children: DCNL DCSP  DCSP if isinstance(child, klass): DCNL DCSP  DCSP  DCSP (yield child) DCNL DCSP  DCSP for grandchild in get_nodes(child, klass): DCNL DCSP  DCSP  DCSP (yield grandchild)\n", "intent": "return an iterator on all children node of the given klass .\n", "question_id": 1652}, {"snippet": "def _format_return_data(retcode, stdout=None, stderr=None): DCNL  DCSP ret = {'retcode': retcode} DCNL DCSP if (stdout is not None): DCNL DCSP  DCSP ret['stdout'] = stdout DCNL DCSP if (stderr is not None): DCNL DCSP  DCSP ret['stderr'] = stderr DCNL DCSP return ret\n", "intent": "creates a dictionary from the parameters .\n", "question_id": 1653}, {"snippet": "def addClosedXMLTag(attributes, depth, localName, output, text=''): DCNL  DCSP depthStart = (' DCTB ' * depth) DCNL DCSP attributesString = getAttributesString(attributes) DCNL DCSP if (len(text) > 0): DCNL DCSP  DCSP output.write(('%s<%s%s DCSP >%s</%s>\\n' % (depthStart, localName, attributesString, text, localName))) DCNL DCSP else: DCNL DCSP  DCSP output.write(('%s<%s%s DCSP />\\n' % (depthStart, localName, attributesString)))\n", "intent": "add the closed xml tag .\n", "question_id": 1654}, {"snippet": "def contains_metastrings(s): DCNL  DCSP if ((s.find(_table_names_key) >= 0) or (s.find(_columns) >= 0) or (s.find(_data) >= 0) or (s.find(_rowid) >= 0)): DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 0\n", "intent": "verify that the given string does not contain any metadata strings that might interfere with dbtables database operation .\n", "question_id": 1655}, {"snippet": "def isSegmentAround(aroundSegmentsDictionary, aroundSegmentsDictionaryKey, segment): DCNL  DCSP if (aroundSegmentsDictionaryKey not in aroundSegmentsDictionary): DCNL DCSP  DCSP return False DCNL DCSP for aroundSegment in aroundSegmentsDictionary[aroundSegmentsDictionaryKey]: DCNL DCSP  DCSP endpoint = aroundSegment[0] DCNL DCSP  DCSP if isSegmentInX(segment, endpoint.point.real, endpoint.otherEndpoint.point.real): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "determine if there is another segment around .\n", "question_id": 1656}, {"snippet": "def generate_ticket(name, output=None, grain=None, key=None, overwrite=True): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP if (output == 'grain'): DCNL DCSP  DCSP if (grain and (not key)): DCNL DCSP  DCSP  DCSP if ((not overwrite) and (grain in __salt__['grains.ls']())): DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'No DCSP execution DCSP needed. DCSP Grain DCSP {0} DCSP already DCSP set'.format(grain) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP elif __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Ticket DCSP generation DCSP would DCSP be DCSP executed, DCSP storing DCSP result DCSP in DCSP grain: DCSP {0}'.format(grain) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif grain: DCNL DCSP  DCSP  DCSP if (grain in __salt__['grains.ls']()): DCNL DCSP  DCSP  DCSP  DCSP grain_value = __salt__['grains.get'](grain) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP grain_value = {} DCNL DCSP  DCSP  DCSP if ((not overwrite) and (key in grain_value)): DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'No DCSP execution DCSP needed. DCSP Grain DCSP {0}:{1} DCSP already DCSP set'.format(grain, key) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP elif __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Ticket DCSP generation DCSP would DCSP be DCSP executed, DCSP storing DCSP result DCSP in DCSP grain: DCSP {0}:{1}'.format(grain, key) DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = \"Error: DCSP output DCSP type DCSP 'grain' DCSP needs DCSP the DCSP grain DCSP parameter\\n\" DCNL DCSP  DCSP  DCSP return ret DCNL DCSP elif output: DCNL DCSP  DCSP if ((not overwrite) and os.path.isfile(output)): DCNL DCSP  DCSP  DCSP ret['comment'] = 'No DCSP execution DCSP needed. DCSP File DCSP {0} DCSP already DCSP set'.format(output) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Ticket DCSP generation DCSP would DCSP be DCSP executed, DCSP storing DCSP result DCSP in DCSP file: DCSP {0}'.format(output) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Ticket DCSP generation DCSP would DCSP be DCSP executed, DCSP not DCSP storing DCSP result' DCNL DCSP  DCSP return ret DCNL DCSP ticket = __salt__['icinga2.generate_ticket'](name).strip() DCNL DCSP if ticket: DCNL DCSP  DCSP ret['comment'] = str(ticket) DCNL DCSP if (output == 'grain'): DCNL DCSP  DCSP if (grain and (not key)): DCNL DCSP  DCSP  DCSP __salt__['grains.setval'](grain, ticket) DCNL DCSP  DCSP  DCSP ret['changes']['ticket'] = 'Executed. DCSP Output DCSP into DCSP grain: DCSP {0}'.format(grain) DCNL DCSP  DCSP elif grain: DCNL DCSP  DCSP  DCSP if (grain in __salt__['grains.ls']()): DCNL DCSP  DCSP  DCSP  DCSP grain_value = __salt__['grains.get'](grain) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP grain_value = {} DCNL DCSP  DCSP  DCSP grain_value[key] = ticket DCNL DCSP  DCSP  DCSP __salt__['grains.setval'](grain, grain_value) DCNL DCSP  DCSP  DCSP ret['changes']['ticket'] = 'Executed. DCSP Output DCSP into DCSP grain: DCSP {0}:{1}'.format(grain, key) DCNL DCSP elif output: DCNL DCSP  DCSP ret['changes']['ticket'] = 'Executed. DCSP Output DCSP into DCSP {0}'.format(output) DCNL DCSP  DCSP with salt.utils.fopen(output, 'w') as output_file: DCNL DCSP  DCSP  DCSP output_file.write(str(ticket)) DCNL DCSP else: DCNL DCSP  DCSP ret['changes']['ticket'] = 'Executed' DCNL DCSP return ret\n", "intent": "generate an icinga2 ticket on the master .\n", "question_id": 1657}, {"snippet": "def get(path, objectType, user=None): DCNL  DCSP ret = {'Path': path, 'ACLs': []} DCNL DCSP sidRet = _getUserSid(user) DCNL DCSP if (path and objectType): DCNL DCSP  DCSP dc = daclConstants() DCNL DCSP  DCSP objectTypeBit = dc.getObjectTypeBit(objectType) DCNL DCSP  DCSP path = dc.processPath(path, objectTypeBit) DCNL DCSP  DCSP tdacl = _get_dacl(path, objectTypeBit) DCNL DCSP  DCSP if tdacl: DCNL DCSP  DCSP  DCSP for counter in range(0, tdacl.GetAceCount()): DCNL DCSP  DCSP  DCSP  DCSP tAce = tdacl.GetAce(counter) DCNL DCSP  DCSP  DCSP  DCSP if ((not sidRet['sid']) or (tAce[2] == sidRet['sid'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['ACLs'].append(_ace_to_text(tAce, objectTypeBit)) DCNL DCSP return ret\n", "intent": "get the acl of an object .\n", "question_id": 1658}, {"snippet": "def const(expr): DCNL  DCSP c = test_expr(expr, _const_codes) DCNL DCSP return eval(c)\n", "intent": "const -> value safe python constant evaluation evaluates a string that contains an expression describing a python constant .\n", "question_id": 1659}, {"snippet": "def __virtual__(): DCNL  DCSP if ('docker.version' in __salt__): DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return False\n", "intent": "only load if the dockerio execution module is available .\n", "question_id": 1660}, {"snippet": "def ps(cmd): DCNL  DCSP if (not LINUX): DCNL DCSP  DCSP cmd = cmd.replace(' DCSP --no-headers DCSP ', ' DCSP ') DCNL DCSP if SUNOS: DCNL DCSP  DCSP cmd = cmd.replace('-o DCSP command', '-o DCSP comm') DCNL DCSP  DCSP cmd = cmd.replace('-o DCSP start', '-o DCSP stime') DCNL DCSP p = subprocess.Popen(cmd, shell=1, stdout=subprocess.PIPE) DCNL DCSP output = p.communicate()[0].strip() DCNL DCSP if PY3: DCNL DCSP  DCSP output = str(output, sys.stdout.encoding) DCNL DCSP if (not LINUX): DCNL DCSP  DCSP output = output.split('\\n')[1].strip() DCNL DCSP try: DCNL DCSP  DCSP return int(output) DCNL DCSP except ValueError: DCNL DCSP  DCSP return output\n", "intent": "expects a ps command with a -o argument and parse the result returning only the value of interest .\n", "question_id": 1661}, {"snippet": "@facebook_required DCNL def decorator_example(request, graph): DCNL  DCSP if graph: DCNL DCSP  DCSP return HttpResponse('authorized') DCNL DCSP else: DCNL DCSP  DCSP return HttpResponse('user DCSP denied DCSP or DCSP error')\n", "intent": "redirects the user to facebooks oauth dialog if the permissions requested in scope are not present default is facebook_default_scope .\n", "question_id": 1662}, {"snippet": "@frappe.whitelist() DCNL def get_password(doctype, name, fieldname): DCNL  DCSP frappe.only_for(u'System DCSP Manager') DCNL DCSP return frappe.get_doc(doctype, name).get_password(fieldname)\n", "intent": "return a password type property .\n", "question_id": 1663}, {"snippet": "def parse_rx_excludes(options, fatal): DCNL  DCSP excluded_patterns = [] DCNL DCSP for flag in options: DCNL DCSP  DCSP (option, parameter) = flag DCNL DCSP  DCSP if (option == '--exclude-rx'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP excluded_patterns.append(re.compile(parameter)) DCNL DCSP  DCSP  DCSP except re.error as ex: DCNL DCSP  DCSP  DCSP  DCSP fatal(('invalid DCSP --exclude-rx DCSP pattern DCSP (%s): DCSP %s' % (parameter, ex))) DCNL DCSP  DCSP elif (option == '--exclude-rx-from'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP f = open(resolve_parent(parameter)) DCNL DCSP  DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP  DCSP raise fatal((\"couldn't DCSP read DCSP %s\" % parameter)) DCNL DCSP  DCSP  DCSP for pattern in f.readlines(): DCNL DCSP  DCSP  DCSP  DCSP spattern = pattern.rstrip('\\n') DCNL DCSP  DCSP  DCSP  DCSP if (not spattern): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP excluded_patterns.append(re.compile(spattern)) DCNL DCSP  DCSP  DCSP  DCSP except re.error as ex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fatal(('invalid DCSP --exclude-rx DCSP pattern DCSP (%s): DCSP %s' % (spattern, ex))) DCNL DCSP return excluded_patterns\n", "intent": "traverse the options and extract all rx excludes .\n", "question_id": 1664}, {"snippet": "def maybe_evaluate(value): DCNL  DCSP if isinstance(value, lazy): DCNL DCSP  DCSP return value.evaluate() DCNL DCSP return value\n", "intent": "evaluates if the value is a :class:lazy instance .\n", "question_id": 1665}, {"snippet": "def main(): DCNL  DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP writeOutput(' DCSP '.join(sys.argv[1:])) DCNL DCSP else: DCNL DCSP  DCSP settings.startMainLoopFromConstructor(getNewRepository())\n", "intent": "display the alteration dialog .\n", "question_id": 1666}, {"snippet": "def main(): DCNL  DCSP qtlogger = logging.getLogger('PyQt4') DCNL DCSP qtlogger.setLevel(logging.ERROR) DCNL DCSP parser = argparse.ArgumentParser(description='cfclient DCSP - DCSP Crazyflie DCSP graphical DCSP control DCSP client') DCNL DCSP parser.add_argument('--debug', '-d', nargs=1, default='info', type=str, help='set DCSP debug DCSP level DCSP [minimal, DCSP info, DCSP debug, DCSP debugfile]') DCNL DCSP args = parser.parse_args() DCNL DCSP debug = args.debug DCNL DCSP cflogger = logging.getLogger('') DCNL DCSP if ('debugfile' in debug): DCNL DCSP  DCSP logging.basicConfig(level=logging.DEBUG) DCNL DCSP  DCSP formatter = logging.Formatter('%(asctime)s:%(threadName)s:%(name)s:%(levelname)s:%(message)s') DCNL DCSP  DCSP filename = ('debug-%s.log' % datetime.datetime.now()) DCNL DCSP  DCSP filehandler = logging.FileHandler(filename) DCNL DCSP  DCSP filehandler.setLevel(logging.DEBUG) DCNL DCSP  DCSP filehandler.setFormatter(formatter) DCNL DCSP  DCSP cflogger.addHandler(filehandler) DCNL DCSP elif ('debug' in debug): DCNL DCSP  DCSP logging.basicConfig(level=logging.DEBUG) DCNL DCSP elif ('minimal' in debug): DCNL DCSP  DCSP logging.basicConfig(level=logging.WARNING) DCNL DCSP elif ('info' in debug): DCNL DCSP  DCSP logging.basicConfig(level=logging.INFO) DCNL DCSP logger = logging.getLogger(__name__) DCNL DCSP logger.debug('Using DCSP config DCSP path DCSP {}'.format(cfclient.config_path)) DCNL DCSP logger.debug('sys.path={}'.format(sys.path)) DCNL DCSP try: DCNL DCSP  DCSP import usb DCNL DCSP except ImportError: DCNL DCSP  DCSP logger.critical('No DCSP pyusb DCSP installation DCSP found, DCSP exiting!') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if (not sys.platform.startswith('linux')): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import sdl2 DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP logger.critical('No DCSP pysdl2 DCSP installation DCSP found, DCSP exiting!') DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP try: DCNL DCSP  DCSP import PyQt4 DCNL DCSP except ImportError: DCNL DCSP  DCSP logger.critical('No DCSP PyQT4 DCSP installation DCSP found, DCSP exiting!') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if (os.name == 'posix'): DCNL DCSP  DCSP stdout = os.dup(1) DCNL DCSP  DCSP os.dup2(os.open('/dev/null', os.O_WRONLY), 1) DCNL DCSP  DCSP sys.stdout = os.fdopen(stdout, 'w') DCNL DCSP  DCSP logger.info('Disabling DCSP STL DCSP printouts') DCNL DCSP if (os.name == 'nt'): DCNL DCSP  DCSP stdout = os.dup(1) DCNL DCSP  DCSP os.dup2(os.open('NUL', os.O_WRONLY), 1) DCNL DCSP  DCSP sys.stdout = os.fdopen(stdout, 'w') DCNL DCSP  DCSP logger.info('Disabling DCSP STL DCSP printouts') DCNL DCSP if (sys.platform == 'darwin'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import Foundation DCNL DCSP  DCSP  DCSP bundle = Foundation.NSBundle.mainBundle() DCNL DCSP  DCSP  DCSP if bundle: DCNL DCSP  DCSP  DCSP  DCSP info = (bundle.localizedInfoDictionary() or bundle.infoDictionary()) DCNL DCSP  DCSP  DCSP  DCSP if info: DCNL DCSP  DCSP  DCSP  DCSP  DCSP info['CFBundleName'] = 'Crazyflie' DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP logger.info('Foundation DCSP not DCSP found. DCSP Menu DCSP will DCSP show DCSP python DCSP as DCSP application DCSP name') DCNL DCSP from .ui.main import MainUI DCNL DCSP from PyQt4.QtGui import QApplication, QIcon DCNL DCSP app = QApplication(sys.argv) DCNL DCSP app.setWindowIcon(QIcon((cfclient.module_path + '/icon-256.png'))) DCNL DCSP if (os.name == 'nt'): DCNL DCSP  DCSP import ctypes DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP myappid = 'mycompany.myproduct.subproduct.version' DCNL DCSP  DCSP  DCSP ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP main_window = MainUI() DCNL DCSP main_window.show() DCNL DCSP sys.exit(app.exec_())\n", "intent": "check starting conditions and start gui .\n", "question_id": 1667}, {"snippet": "def diff(args): DCNL  DCSP out = git.diff(name_only=True, z=True, *args)[STDOUT] DCNL DCSP return _parse_diff_filenames(out)\n", "intent": "return a list of filenames for the given diff arguments .\n", "question_id": 1668}, {"snippet": "def concat_tuples(*tuples): DCNL  DCSP return tuple(chain(*tuples))\n", "intent": "concatenate a sequence of tuples into one tuple .\n", "question_id": 1669}, {"snippet": "def CreateTag(region, resource_id, tag_name, tag_value): DCNL  DCSP ec2 = _Connect(region) DCNL DCSP ec2.create_tags([resource_id], {tag_name: tag_value})\n", "intent": "create a tag for resource_id with specified name and value .\n", "question_id": 1670}, {"snippet": "@hug.exception(FakeException) DCNL def handle_exception(exception): DCNL  DCSP return True\n", "intent": "handles the provided exception for testing .\n", "question_id": 1671}, {"snippet": "def __virtual__(): DCNL  DCSP if (not HAS_VBOX): DCNL DCSP  DCSP return (False, \"The DCSP virtualbox DCSP driver DCSP cannot DCSP be DCSP loaded: DCSP 'vboxapi' DCSP is DCSP not DCSP installed.\") DCNL DCSP if (get_configured_provider() is False): DCNL DCSP  DCSP return (False, \"The DCSP virtualbox DCSP driver DCSP cannot DCSP be DCSP loaded: DCSP 'virtualbox' DCSP provider DCSP is DCSP not DCSP configured.\") DCNL DCSP return __virtualname__\n", "intent": "this function determines whether or not to make this cloud module available upon execution .\n", "question_id": 1672}, {"snippet": "def create(context, name, extra_specs={}): DCNL  DCSP try: DCNL DCSP  DCSP type_ref = db.volume_type_create(context, dict(name=name, extra_specs=extra_specs)) DCNL DCSP except exception.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.VolumeTypeCreateFailed(name=name, extra_specs=extra_specs) DCNL DCSP return type_ref\n", "intent": "creates volume types .\n", "question_id": 1673}, {"snippet": "def parse_grep_line(line): DCNL  DCSP try: DCNL DCSP  DCSP (filename, line_number, contents) = line.split(u':', 2) DCNL DCSP  DCSP result = (filename, line_number, contents) DCNL DCSP except ValueError: DCNL DCSP  DCSP result = None DCNL DCSP return result\n", "intent": "parse a grep result line into .\n", "question_id": 1674}, {"snippet": "def import_string(import_name, silent=False): DCNL  DCSP try: DCNL DCSP  DCSP if (':' in import_name): DCNL DCSP  DCSP  DCSP (module, obj) = import_name.split(':', 1) DCNL DCSP  DCSP elif ('.' in import_name): DCNL DCSP  DCSP  DCSP items = import_name.split('.') DCNL DCSP  DCSP  DCSP module = '.'.join(items[:(-1)]) DCNL DCSP  DCSP  DCSP obj = items[(-1)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return __import__(import_name) DCNL DCSP  DCSP return getattr(__import__(module, None, None, [obj]), obj) DCNL DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP if (not silent): DCNL DCSP  DCSP  DCSP raise\n", "intent": "imports an object based on a string .\n", "question_id": 1675}, {"snippet": "def _format_info(data): DCNL  DCSP gecos_field = data.pw_gecos.split(',', 3) DCNL DCSP while (len(gecos_field) < 4): DCNL DCSP  DCSP gecos_field.append('') DCNL DCSP return {'gid': data.pw_gid, 'groups': list_groups(data.pw_name), 'home': data.pw_dir, 'name': data.pw_name, 'passwd': data.pw_passwd, 'shell': data.pw_shell, 'uid': data.pw_uid, 'fullname': gecos_field[0], 'roomnumber': gecos_field[1], 'workphone': gecos_field[2], 'homephone': gecos_field[3]}\n", "intent": "return user information in a pretty way .\n", "question_id": 1676}, {"snippet": "def add(name, mac, mtu=1500): DCNL  DCSP ret = {} DCNL DCSP nictagadm = _check_nictagadm() DCNL DCSP dladm = _check_dladm() DCNL DCSP if ((mtu > 9000) or (mtu < 1500)): DCNL DCSP  DCSP return {'Error': 'mtu DCSP must DCSP be DCSP a DCSP value DCSP between DCSP 1500 DCSP and DCSP 9000.'} DCNL DCSP if (mac != 'etherstub'): DCNL DCSP  DCSP cmd = '{dladm} DCSP show-phys DCSP -m DCSP -p DCSP -o DCSP address'.format(dladm=dladm) DCNL DCSP  DCSP res = __salt__['cmd.run_all'](cmd) DCNL DCSP  DCSP if (mac not in res['stdout'].splitlines()): DCNL DCSP  DCSP  DCSP return {'Error': '{0} DCSP is DCSP not DCSP present DCSP on DCSP this DCSP system.'.format(mac)} DCNL DCSP if (mac == 'etherstub'): DCNL DCSP  DCSP cmd = '{nictagadm} DCSP add DCSP -l DCSP -p DCSP mtu={mtu} DCSP {name}'.format(nictagadm=nictagadm, mtu=mtu, name=name) DCNL DCSP  DCSP res = __salt__['cmd.run_all'](cmd) DCNL DCSP else: DCNL DCSP  DCSP cmd = '{nictagadm} DCSP add DCSP -p DCSP mtu={mtu},mac={mac} DCSP {name}'.format(nictagadm=nictagadm, mtu=mtu, mac=mac, name=name) DCNL DCSP  DCSP res = __salt__['cmd.run_all'](cmd) DCNL DCSP if (res['retcode'] == 0): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return {'Error': ('failed DCSP to DCSP create DCSP nictag.' if (('stderr' not in res) and (res['stderr'] == '')) else res['stderr'])}\n", "intent": "add a new nictag name : string name of new nictag mac : string mac of parent interface or etherstub to create a ether stub mtu : int mtu cli example: .\n", "question_id": 1677}, {"snippet": "def attach_epic_order(queryset, epic_id, as_field='epic_order'): DCNL  DCSP model = queryset.model DCNL DCSP sql = 'SELECT DCSP \"epics_relateduserstory\".\"order\" DCSP AS DCSP \"epic_order\"\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP \"epics_relateduserstory\"\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP \"epics_relateduserstory\".\"user_story_id\" DCSP = DCSP {tbl}.id DCSP and\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \"epics_relateduserstory\".\"epic_id\" DCSP = DCSP {epic_id}' DCNL DCSP sql = sql.format(tbl=model._meta.db_table, epic_id=epic_id) DCNL DCSP queryset = queryset.extra(select={as_field: sql}) DCNL DCSP return queryset\n", "intent": "attach epic_order column to each object of the queryset .\n", "question_id": 1678}, {"snippet": "def validate_uuid_representation(dummy, value): DCNL  DCSP try: DCNL DCSP  DCSP return _UUID_REPRESENTATIONS[value] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP an DCSP invalid DCSP UUID DCSP representation. DCSP Must DCSP be DCSP one DCSP of DCSP %s' % (value, tuple(_UUID_REPRESENTATIONS))))\n", "intent": "validate the uuid representation option selected in the uri .\n", "question_id": 1679}, {"snippet": "def get_ninja_editor_skins_files(path): DCNL  DCSP extension = '.color' DCNL DCSP return get_ninja_file(path, extension)\n", "intent": "return the list of json files inside the directory: path .\n", "question_id": 1680}, {"snippet": "def make_histograms(lengths, binwidth=10): DCNL  DCSP min_len = min(lengths) DCNL DCSP max_len = max(lengths) DCNL DCSP floor = ((min_len / binwidth) * binwidth) DCNL DCSP ceil = (((max_len / binwidth) + 2) * binwidth) DCNL DCSP bins = np.arange(floor, ceil, binwidth) DCNL DCSP (hist, bin_edges) = np.histogram(lengths, bins) DCNL DCSP return (hist, bin_edges)\n", "intent": "makes histogram data for pre and post lengths .\n", "question_id": 1681}, {"snippet": "def get_user_project_permissions(user, project, cache='user'): DCNL  DCSP membership = _get_user_project_membership(user, project, cache=cache) DCNL DCSP is_member = (membership is not None) DCNL DCSP is_admin = (is_member and membership.is_admin) DCNL DCSP return calculate_permissions(is_authenticated=user.is_authenticated(), is_superuser=user.is_superuser, is_member=is_member, is_admin=is_admin, role_permissions=_get_membership_permissions(membership), anon_permissions=project.anon_permissions, public_permissions=project.public_permissions)\n", "intent": "cache param determines how memberships are calculated trying to reuse the existing data in cache .\n", "question_id": 1682}, {"snippet": "def convert_search_torrent_to_json(torrent): DCNL  DCSP if isinstance(torrent, dict): DCNL DCSP  DCSP return convert_remote_torrent_to_json(torrent) DCNL DCSP return convert_db_torrent_to_json(torrent, include_rel_score=True)\n", "intent": "converts a given torrent to a json dictionary .\n", "question_id": 1683}, {"snippet": "def get_new_desktop_name(parent_hwnd): DCNL  DCSP msgs = {win32con.WM_COMMAND: desktop_name_dlgproc, win32con.WM_CLOSE: desktop_name_dlgproc, win32con.WM_DESTROY: desktop_name_dlgproc} DCNL DCSP style = (((win32con.WS_BORDER | win32con.WS_VISIBLE) | win32con.WS_CAPTION) | win32con.WS_SYSMENU) DCNL DCSP h = win32gui.CreateDialogIndirect(win32api.GetModuleHandle(None), [['One DCSP ugly DCSP dialog DCSP box DCSP !', (100, 100, 200, 100), style, 0], ['Button', 'Create', win32con.IDOK, (10, 10, 30, 20), (((win32con.WS_VISIBLE | win32con.WS_TABSTOP) | win32con.BS_HOLLOW) | win32con.BS_DEFPUSHBUTTON)], ['Button', 'Never DCSP mind', win32con.IDCANCEL, (45, 10, 50, 20), ((win32con.WS_VISIBLE | win32con.WS_TABSTOP) | win32con.BS_HOLLOW)], ['Static', 'Desktop DCSP name:', 71, (10, 40, 70, 10), win32con.WS_VISIBLE], ['Edit', '', 72, (75, 40, 90, 10), win32con.WS_VISIBLE]], parent_hwnd, msgs) DCNL DCSP win32gui.EnableWindow(h, True) DCNL DCSP hcontrol = win32gui.GetDlgItem(h, 72) DCNL DCSP win32gui.EnableWindow(hcontrol, True) DCNL DCSP win32gui.SetFocus(hcontrol)\n", "intent": "create a dialog box to ask the user for name of desktop to be created .\n", "question_id": 1684}, {"snippet": "def ircbot(registry, xml_parent, data): DCNL  DCSP top = XML.SubElement(xml_parent, 'hudson.plugins.ircbot.IrcPublisher') DCNL DCSP message_dict = {'summary-scm': 'DefaultBuildToChatNotifier', 'summary': 'SummaryOnlyBuildToChatNotifier', 'summary-params': 'BuildParametersBuildToChatNotifier', 'summary-scm-fail': 'PrintFailingTestsBuildToChatNotifier'} DCNL DCSP message = data.get('message-type', 'summary-scm') DCNL DCSP if (message not in message_dict): DCNL DCSP  DCSP raise JenkinsJobsException(('message-type DCSP entered DCSP is DCSP not DCSP valid, DCSP must DCSP be DCSP one DCSP of: DCSP %s' % ', DCSP '.join(message_dict.keys()))) DCNL DCSP message = ('hudson.plugins.im.build_notify.' + message_dict.get(message)) DCNL DCSP XML.SubElement(top, 'buildToChatNotifier', attrib={'class': message}) DCNL DCSP strategy_dict = {'all': 'ALL', 'any-failure': 'ANY_FAILURE', 'failure-and-fixed': 'FAILURE_AND_FIXED', 'new-failure-and-fixed': 'NEW_FAILURE_AND_FIXED', 'statechange-only': 'STATECHANGE_ONLY'} DCNL DCSP strategy = data.get('strategy', 'all') DCNL DCSP if (strategy not in strategy_dict): DCNL DCSP  DCSP raise JenkinsJobsException(('strategy DCSP entered DCSP is DCSP not DCSP valid, DCSP must DCSP be DCSP one DCSP of: DCSP %s' % ', DCSP '.join(strategy_dict.keys()))) DCNL DCSP XML.SubElement(top, 'strategy').text = strategy_dict.get(strategy) DCNL DCSP targets = XML.SubElement(top, 'targets') DCNL DCSP channels = data.get('channels', []) DCNL DCSP for channel in channels: DCNL DCSP  DCSP sub = XML.SubElement(targets, 'hudson.plugins.im.GroupChatIMMessageTarget') DCNL DCSP  DCSP XML.SubElement(sub, 'name').text = channel.get('name') DCNL DCSP  DCSP XML.SubElement(sub, 'password').text = channel.get('password') DCNL DCSP  DCSP XML.SubElement(sub, 'notificationOnly').text = str(channel.get('notify-only', False)).lower() DCNL DCSP XML.SubElement(top, 'notifyOnBuildStart').text = str(data.get('notify-start', False)).lower() DCNL DCSP XML.SubElement(top, 'notifySuspects').text = str(data.get('notify-committers', False)).lower() DCNL DCSP XML.SubElement(top, 'notifyCulprits').text = str(data.get('notify-culprits', False)).lower() DCNL DCSP XML.SubElement(top, 'notifyFixers').text = str(data.get('notify-fixers', False)).lower() DCNL DCSP XML.SubElement(top, 'notifyUpstreamCommitters').text = str(data.get('notify-upstream', False)).lower() DCNL DCSP matrix_dict = {'all': 'ALL', 'only-configurations': 'ONLY_CONFIGURATIONS', 'only-parent': 'ONLY_PARENT'} DCNL DCSP matrix = data.get('matrix-notifier', 'only-configurations') DCNL DCSP if (matrix not in matrix_dict): DCNL DCSP  DCSP raise JenkinsJobsException(('matrix-notifier DCSP entered DCSP is DCSP not DCSP valid, DCSP must DCSP be DCSP one DCSP of: DCSP %s' % ', DCSP '.join(matrix_dict.keys()))) DCNL DCSP XML.SubElement(top, 'matrixMultiplier').text = matrix_dict.get(matrix)\n", "intent": "yaml: ircbot ircbot enables jenkins to send build notifications via irc and lets you interact with jenkins via an irc bot .\n", "question_id": 1685}, {"snippet": "def context(): DCNL  DCSP return s3_rest_controller()\n", "intent": "work context - restful controller .\n", "question_id": 1686}, {"snippet": "@pytest.mark.cmd DCNL @pytest.mark.django_db DCNL def test_list_languages_project(capfd): DCNL  DCSP call_command('list_languages', '--project=project0') DCNL DCSP (out, err) = capfd.readouterr() DCNL DCSP assert ('language0' in out) DCNL DCSP assert ('language1' in out) DCNL DCSP assert ('en' not in out)\n", "intent": "languages on a specific project .\n", "question_id": 1687}, {"snippet": "def queens_fitness(genome): DCNL  DCSP fitness = 0 DCNL DCSP for check_queen_col in range(len(genome)): DCNL DCSP  DCSP is_attacked = 0 DCNL DCSP  DCSP for other_queen_col in range(len(genome)): DCNL DCSP  DCSP  DCSP if (check_queen_col != other_queen_col): DCNL DCSP  DCSP  DCSP  DCSP check_queen_row = int(genome[check_queen_col]) DCNL DCSP  DCSP  DCSP  DCSP other_queen_row = int(genome[other_queen_col]) DCNL DCSP  DCSP  DCSP  DCSP if (check_queen_row == other_queen_row): DCNL DCSP  DCSP  DCSP  DCSP  DCSP is_attacked = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP elif (abs((check_queen_row - other_queen_row)) == abs((check_queen_col - other_queen_col))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP is_attacked = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not is_attacked): DCNL DCSP  DCSP  DCSP fitness += 1 DCNL DCSP return fitness\n", "intent": "calculate the fitness of an organization of queens on the chessboard .\n", "question_id": 1688}, {"snippet": "def getDescendingAreaOrientedLoops(allPoints, corners, importRadius): DCNL  DCSP return getOrientedLoops(getDescendingAreaLoops(allPoints, corners, importRadius))\n", "intent": "get descending area oriented loops which include most of the points .\n", "question_id": 1689}, {"snippet": "@process_request_body DCNL def text_processor(entity): DCNL  DCSP body = entity.fp.read() DCNL DCSP try: DCNL DCSP  DCSP cherrypy.serving.request.unserialized_data = json.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP cherrypy.serving.request.unserialized_data = body DCNL DCSP cherrypy.serving.request.raw_body = body\n", "intent": "attempt to unserialize plain text as json some large services still send json with a text/plain content-type .\n", "question_id": 1690}, {"snippet": "def log_info(**kwargs): DCNL  DCSP Message.log(message_type=_compute_message_type(stack()[1]), **kwargs)\n", "intent": "simple logging wrapper around eliot messages .\n", "question_id": 1691}, {"snippet": "def count_seqs(fasta_filepath, parser=parse_fasta): DCNL  DCSP return count_seqs_from_file(open(fasta_filepath, 'U'), parser=parser)\n", "intent": "count the sequences in fasta_filepath fasta_filepath: string indicating the full path to the file .\n", "question_id": 1692}, {"snippet": "def call_status(*args, **kwargs): DCNL  DCSP res = dict() DCNL DCSP devices = _get_lights() DCNL DCSP for dev_id in ((('id' not in kwargs) and sorted(devices.keys())) or _get_devices(kwargs)): DCNL DCSP  DCSP res[dev_id] = {'on': devices[dev_id]['state']['on'], 'reachable': devices[dev_id]['state']['reachable']} DCNL DCSP return res\n", "intent": "return the status of the lamps .\n", "question_id": 1693}, {"snippet": "def set_curdoc(doc): DCNL  DCSP _state.document = doc\n", "intent": "configure the current document (returned by curdoc()) .\n", "question_id": 1694}, {"snippet": "def format_event(event): DCNL  DCSP to_delete = ('id', 'created_at', 'updated_at', 'deleted_at', 'deleted', 'action_id') DCNL DCSP for key in to_delete: DCNL DCSP  DCSP if (key in event): DCNL DCSP  DCSP  DCSP del event[key] DCNL DCSP if ('start_time' in event): DCNL DCSP  DCSP event['start_time'] = str(event['start_time'].replace(tzinfo=None)) DCNL DCSP if ('finish_time' in event): DCNL DCSP  DCSP event['finish_time'] = str(event['finish_time'].replace(tzinfo=None)) DCNL DCSP return event\n", "intent": "remove keys that arent serialized .\n", "question_id": 1695}, {"snippet": "def render_formset(formset=None, context=None): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = {} DCNL DCSP context[u'formset'] = formset DCNL DCSP return render_template_with_form(u'{% DCSP bootstrap_formset DCSP formset DCSP %}', context)\n", "intent": "create a template that renders a formset .\n", "question_id": 1696}, {"snippet": "def _get_config_file(conf, atom): DCNL  DCSP if ('*' in atom): DCNL DCSP  DCSP parts = portage.dep.Atom(atom, allow_wildcard=True) DCNL DCSP  DCSP if (not parts): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (parts.cp == '*/*'): DCNL DCSP  DCSP  DCSP relative_path = (parts.repo or 'gentoo') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relative_path = os.path.join(*[x for x in os.path.split(parts.cp) if (x != '*')]) DCNL DCSP else: DCNL DCSP  DCSP relative_path = _p_to_cp(atom) DCNL DCSP  DCSP if (not relative_path): DCNL DCSP  DCSP  DCSP return DCNL DCSP complete_file_path = ((BASE_PATH.format(conf) + '/') + relative_path) DCNL DCSP return complete_file_path\n", "intent": "parse the given atom .\n", "question_id": 1697}, {"snippet": "def get_disk_type(vm_): DCNL  DCSP return config.get_cloud_config_value('disk_type', vm_, __opts__, default='HDD', search_global=False)\n", "intent": "return the type of disk to use .\n", "question_id": 1698}, {"snippet": "def migrate_guid_wiki(wiki): DCNL  DCSP data = wiki.to_storage() DCNL DCSP uid = data.get('user') DCNL DCSP if uid: DCNL DCSP  DCSP record = models.User.load(uid.lower()) DCNL DCSP  DCSP if record: DCNL DCSP  DCSP  DCSP wiki.user = record DCNL DCSP pid = data.get('node') DCNL DCSP if pid: DCNL DCSP  DCSP record = models.Node.load(pid.lower()) DCNL DCSP  DCSP if record: DCNL DCSP  DCSP  DCSP wiki.node = record DCNL DCSP wiki.save()\n", "intent": "migrate non-reference fields containing primary keys on wiki pages .\n", "question_id": 1699}, {"snippet": "def strings(filename, minimum=4): DCNL  DCSP result = '' DCNL DCSP with BlockFile(filename) as f: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP (data, dlen) = f.read_block() DCNL DCSP  DCSP  DCSP if (not data): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP for c in data: DCNL DCSP  DCSP  DCSP  DCSP if (c in string.printable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result += c DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP elif (len(result) >= minimum): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield result) DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = '' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = ''\n", "intent": "a strings generator .\n", "question_id": 1700}, {"snippet": "def getInsetPointsByInsetLoops(insetLoops, inside, loops, radius): DCNL  DCSP insetPointsByInsetLoops = [] DCNL DCSP for insetLoop in insetLoops: DCNL DCSP  DCSP insetPointsByInsetLoops += getInsetPointsByInsetLoop(insetLoop, inside, loops, radius) DCNL DCSP return insetPointsByInsetLoops\n", "intent": "get the inset points of the inset loops inside the loops .\n", "question_id": 1701}, {"snippet": "@deprecated_network DCNL def do_floating_ip_pool_list(cs, _args): DCNL  DCSP utils.print_list(cs.floating_ip_pools.list(), ['name'])\n", "intent": "list all floating ip pools .\n", "question_id": 1702}, {"snippet": "def _invalid(m, comment=INVALID_RESPONSE, out=None): DCNL  DCSP return _set_status(m, status=False, comment=comment, out=out)\n", "intent": "return invalid status .\n", "question_id": 1703}, {"snippet": "def _get_default_tempdir(): DCNL  DCSP namer = _RandomNameSequence() DCNL DCSP dirlist = _candidate_tempdir_list() DCNL DCSP flags = _text_openflags DCNL DCSP for dir in dirlist: DCNL DCSP  DCSP if (dir != _os.curdir): DCNL DCSP  DCSP  DCSP dir = _os.path.normcase(_os.path.abspath(dir)) DCNL DCSP  DCSP for seq in xrange(100): DCNL DCSP  DCSP  DCSP name = namer.next() DCNL DCSP  DCSP  DCSP filename = _os.path.join(dir, name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fd = _os.open(filename, flags, 384) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with _io.open(fd, 'wb', closefd=False) as fp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.write('blat') DCNL DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _os.close(fd) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _os.unlink(filename) DCNL DCSP  DCSP  DCSP  DCSP return dir DCNL DCSP  DCSP  DCSP except (OSError, IOError) as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.args[0] != _errno.EEXIST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP raise IOError, (_errno.ENOENT, ('No DCSP usable DCSP temporary DCSP directory DCSP found DCSP in DCSP %s' % dirlist))\n", "intent": "calculate the default directory to use for temporary files .\n", "question_id": 1704}, {"snippet": "def format(cols, colwidth=_colwidth, spacing=_spacing): DCNL  DCSP print formatstring(cols, colwidth, spacing)\n", "intent": "prints multi-column formatting for year calendars .\n", "question_id": 1705}, {"snippet": "def escapejs(value): DCNL  DCSP return mark_safe(force_text(value).translate(_js_escapes))\n", "intent": "hex encodes characters for use in javascript strings .\n", "question_id": 1706}, {"snippet": "def permission_required_or_403(perm, *args, **kwargs): DCNL  DCSP kwargs[u'return_403'] = True DCNL DCSP return permission_required(perm, *args, **kwargs)\n", "intent": "simple wrapper for permission_required decorator .\n", "question_id": 1707}, {"snippet": "def upvars(n=2): DCNL  DCSP return dictadd(sys._getframe(n).f_globals, sys._getframe(n).f_locals)\n", "intent": "guido van rossum doesnt want you to use this function .\n", "question_id": 1708}, {"snippet": "def test_ascii_dash(): DCNL  DCSP o = nikola.utils.slugify(u'hello-world', lang=u'en') DCNL DCSP assert (o == u'hello-world') DCNL DCSP assert isinstance(o, nikola.utils.unicode_str)\n", "intent": "test an ascii string .\n", "question_id": 1709}, {"snippet": "def _test_factory(test, dtype=np.double): DCNL  DCSP olderr = np.seterr(all='ignore') DCNL DCSP try: DCNL DCSP  DCSP test.check(dtype=dtype) DCNL DCSP finally: DCNL DCSP  DCSP np.seterr(**olderr)\n", "intent": "boost test .\n", "question_id": 1710}, {"snippet": "def match_device(device): DCNL  DCSP match = re.match('(^/dev/x{0,1}[a-z]{0,1}d{0,1})([a-z]+)[0-9]*$', device) DCNL DCSP if (not match): DCNL DCSP  DCSP return None DCNL DCSP return match.groups()\n", "intent": "matches device name and returns prefix .\n", "question_id": 1711}, {"snippet": "def test_coord_init_unit(): DCNL  DCSP for unit in (u'deg', u'deg,deg', u' DCSP deg DCSP , DCSP deg DCSP ', u.deg, (u.deg, u.deg), np.array([u'deg', u'deg'])): DCNL DCSP  DCSP sc = SkyCoord(1, 2, unit=unit) DCNL DCSP  DCSP assert allclose(sc.ra, Angle((1 * u.deg))) DCNL DCSP  DCSP assert allclose(sc.dec, Angle((2 * u.deg))) DCNL DCSP for unit in (u'hourangle', u'hourangle,hourangle', u' DCSP hourangle DCSP , DCSP hourangle DCSP ', u.hourangle, [u.hourangle, u.hourangle]): DCNL DCSP  DCSP sc = SkyCoord(1, 2, unit=unit) DCNL DCSP  DCSP assert allclose(sc.ra, Angle((15 * u.deg))) DCNL DCSP  DCSP assert allclose(sc.dec, Angle((30 * u.deg))) DCNL DCSP for unit in (u'hourangle,deg', (u.hourangle, u.deg)): DCNL DCSP  DCSP sc = SkyCoord(1, 2, unit=unit) DCNL DCSP  DCSP assert allclose(sc.ra, Angle((15 * u.deg))) DCNL DCSP  DCSP assert allclose(sc.dec, Angle((2 * u.deg))) DCNL DCSP for unit in (u'deg,deg,deg,deg', [u.deg, u.deg, u.deg, u.deg], None): DCNL DCSP  DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP  DCSP SkyCoord(1, 2, unit=unit) DCNL DCSP  DCSP assert (u'Unit DCSP keyword DCSP must DCSP have DCSP one DCSP to DCSP three DCSP unit DCSP values' in str(err)) DCNL DCSP for unit in (u'm', (u.m, u.deg), u''): DCNL DCSP  DCSP with pytest.raises(u.UnitsError) as err: DCNL DCSP  DCSP  DCSP SkyCoord(1, 2, unit=unit)\n", "intent": "test variations of the unit keyword .\n", "question_id": 1712}, {"snippet": "def AutoProxy(token, serializer, manager=None, authkey=None, exposed=None, incref=True): DCNL  DCSP _Client = listener_client[serializer][1] DCNL DCSP if (exposed is None): DCNL DCSP  DCSP conn = _Client(token.address, authkey=authkey) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP exposed = dispatch(conn, None, 'get_methods', (token,)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP conn.close() DCNL DCSP if ((authkey is None) and (manager is not None)): DCNL DCSP  DCSP authkey = manager._authkey DCNL DCSP if (authkey is None): DCNL DCSP  DCSP authkey = process.current_process().authkey DCNL DCSP ProxyType = MakeProxyType(('AutoProxy[%s]' % token.typeid), exposed) DCNL DCSP proxy = ProxyType(token, serializer, manager=manager, authkey=authkey, incref=incref) DCNL DCSP proxy._isauto = True DCNL DCSP return proxy\n", "intent": "return an auto-proxy for token .\n", "question_id": 1713}, {"snippet": "def map32(id, pos=NOUN): DCNL  DCSP global _map32_cache DCNL DCSP if (not _map32_cache): DCNL DCSP  DCSP _map32_cache = open(os.path.join(MODULE, 'dict', 'index.32')).readlines() DCNL DCSP  DCSP _map32_cache = (x for x in _map32_cache if (x[0] != ';')) DCNL DCSP  DCSP _map32_cache = dict((x.strip().split(' DCSP ') for x in _map32_cache)) DCNL DCSP k = (((pos in _map32_pos2) and pos) or _map32_pos1.get(pos, 'x')) DCNL DCSP k += str(id).lstrip('0') DCNL DCSP k = _map32_cache.get(k, None) DCNL DCSP if (k is not None): DCNL DCSP  DCSP return (int(k[1:]), _map32_pos2[k[0]]) DCNL DCSP return None\n", "intent": "returns an -tuple with the wordnet2 synset id for the given wordnet3 synset id .\n", "question_id": 1714}, {"snippet": "def enqueue_task(url, params, countdown): DCNL  DCSP taskqueue.add(queue_name=QUEUE_NAME_EMAILS, url=url, payload=json.dumps(params), countdown=countdown, target=taskqueue.DEFAULT_APP_VERSION)\n", "intent": "adds a new task for sending email .\n", "question_id": 1715}, {"snippet": "@command('(?:help|h)(?:\\\\s+([-_a-zA-Z]+))?') DCNL def show_help(choice): DCNL  DCSP g.content = get_help(choice)\n", "intent": "print help message .\n", "question_id": 1716}, {"snippet": "def processElementNodeByDerivation(derivation, elementNode): DCNL  DCSP if (derivation == None): DCNL DCSP  DCSP derivation = WriteDerivation(elementNode) DCNL DCSP if (len(derivation.targets) < 1): DCNL DCSP  DCSP print 'Warning, DCSP processElementNode DCSP in DCSP write DCSP could DCSP not DCSP get DCSP targets DCSP for:' DCNL DCSP  DCSP print elementNode DCNL DCSP  DCSP return DCNL DCSP fileNames = [] DCNL DCSP for target in derivation.targets: DCNL DCSP  DCSP writeElementNode(derivation, fileNames, target)\n", "intent": "process the xml element by derivation .\n", "question_id": 1717}, {"snippet": "@task DCNL @use_master DCNL def fetch_promo_imgs(pk, promo_img_url, **kw): DCNL  DCSP website = Website.objects.get(pk=pk) DCNL DCSP log.info(u'[Website:%s] DCSP Fetching DCSP promo DCSP img DCSP for DCSP website', website.name) DCNL DCSP try: DCNL DCSP  DCSP response = _fetch_content(promo_img_url) DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.error((u'[Website:%s] DCSP Failed DCSP to DCSP fetch DCSP promo DCSP img DCSP for DCSP website: DCSP %s' % (website, e))) DCNL DCSP  DCSP website.update(promo_img_hash='') DCNL DCSP  DCSP return False DCNL DCSP log.info('[Website:%s] DCSP Promo DCSP img DCSP fetching DCSP done DCSP , DCSP saving DCSP ', website.name) DCNL DCSP save_promo_imgs(website, response.content) DCNL DCSP return True\n", "intent": "downloads a promo image from the location passed to the task .\n", "question_id": 1718}, {"snippet": "def conv_gru(inpts, mem, kw, kh, nmaps, cutoff, prefix): DCNL  DCSP def conv_lin(args, suffix, bias_start): DCNL DCSP  DCSP return conv_linear(args, kw, kh, (len(args) * nmaps), nmaps, True, bias_start, ((prefix + '/') + suffix)) DCNL DCSP reset = sigmoid_cutoff(conv_lin((inpts + [mem]), 'r', 1.0), cutoff) DCNL DCSP candidate = tf.tanh(conv_lin((inpts + [(reset * mem)]), 'c', 0.0)) DCNL DCSP gate = sigmoid_cutoff(conv_lin((inpts + [mem]), 'g', 1.0), cutoff) DCNL DCSP return ((gate * mem) + ((1 - gate) * candidate))\n", "intent": "convolutional gru .\n", "question_id": 1719}, {"snippet": "def run(on_create): DCNL  DCSP from twisted.internet import reactor DCNL DCSP transports = [{'type': 'websocket', 'url': 'ws://127.0.0.1:8080/ws'}] DCNL DCSP connection = Connection(on_create, realm=u'public', transports=transports, reactor=reactor) DCNL DCSP done = connection.connect() DCNL DCSP def finish(res): DCNL DCSP  DCSP print res DCNL DCSP  DCSP reactor.stop() DCNL DCSP done.addBoth(finish) DCNL DCSP reactor.run()\n", "intent": "this could be a high level \"runner\" tool we ship .\n", "question_id": 1720}, {"snippet": "def processXMLElement(xmlElement): DCNL  DCSP path.convertProcessXMLElementRenameByPaths(getGeometryOutput(None, xmlElement), xmlElement)\n", "intent": "process the xml element .\n", "question_id": 1721}, {"snippet": "def extract_field_data(field): DCNL  DCSP if (not field.form.is_bound): DCNL DCSP  DCSP res = field.form.initial.get(field.name, field.field.initial) DCNL DCSP  DCSP if callable(res): DCNL DCSP  DCSP  DCSP return res() DCNL DCSP  DCSP return res DCNL DCSP else: DCNL DCSP  DCSP return field.data\n", "intent": "given a form field .\n", "question_id": 1722}, {"snippet": "def time_openpyxl(): DCNL  DCSP start_time = clock() DCNL DCSP workbook = openpyxl.workbook.Workbook() DCNL DCSP worksheet = workbook.active DCNL DCSP for row in range((row_max // 2)): DCNL DCSP  DCSP for col in range(col_max): DCNL DCSP  DCSP  DCSP colletter = get_column_letter((col + 1)) DCNL DCSP  DCSP  DCSP worksheet.cell(('%s%s' % (colletter, ((row * 2) + 1)))).value = ('Row: DCSP %d DCSP Col: DCSP %d' % (row, col)) DCNL DCSP  DCSP for col in range(col_max): DCNL DCSP  DCSP  DCSP colletter = get_column_letter((col + 1)) DCNL DCSP  DCSP  DCSP worksheet.cell(('%s%s' % (colletter, ((row * 2) + 2)))).value = (row + col) DCNL DCSP workbook.save('openpyxl.xlsx') DCNL DCSP elapsed = (clock() - start_time) DCNL DCSP print_elapsed_time('openpyxl', elapsed)\n", "intent": "run openpyxl in default mode .\n", "question_id": 1723}, {"snippet": "def replace_surrogate_encode(mystring): DCNL  DCSP decoded = [] DCNL DCSP for ch in mystring: DCNL DCSP  DCSP code = ord(ch) DCNL DCSP  DCSP if (not (55296 <= code <= 56575)): DCNL DCSP  DCSP  DCSP raise exc DCNL DCSP  DCSP if (56320 <= code <= 56447): DCNL DCSP  DCSP  DCSP decoded.append(_unichr((code - 56320))) DCNL DCSP  DCSP elif (code <= 56575): DCNL DCSP  DCSP  DCSP decoded.append(_unichr((code - 56320))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise NotASurrogateError DCNL DCSP return str().join(decoded)\n", "intent": "returns a  string .\n", "question_id": 1724}, {"snippet": "def update_item(name, id_, field=None, value=None, postdata=None): DCNL  DCSP if (field and value): DCNL DCSP  DCSP if postdata: DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Either DCSP a DCSP field DCSP and DCSP a DCSP value, DCSP or DCSP a DCSP chunk DCSP of DCSP POST DCSP data, DCSP may DCSP be DCSP specified, DCSP but DCSP not DCSP both.') DCNL DCSP  DCSP postdata = {name.title(): {field: value}} DCNL DCSP if (postdata is None): DCNL DCSP  DCSP raise SaltInvocationError('Either DCSP a DCSP field DCSP and DCSP a DCSP value, DCSP or DCSP a DCSP chunk DCSP of DCSP POST DCSP data DCSP must DCSP be DCSP specified.') DCNL DCSP (status, result) = _query(action=name, command=id_, method='POST', data=json.dumps(postdata)) DCNL DCSP return result\n", "intent": "update an item .\n", "question_id": 1725}, {"snippet": "def index(request): DCNL  DCSP context = {'version': settings.MOBSF_VER} DCNL DCSP template = 'general/index.html' DCNL DCSP return render(request, template, context)\n", "intent": "index route .\n", "question_id": 1726}, {"snippet": "def truncate(string, length, dots='...'): DCNL  DCSP text = to_unicode(string, 'utf-8') DCNL DCSP dots = (to_unicode(dots, 'utf-8') if isinstance(dots, str) else dots) DCNL DCSP if (len(text) > length): DCNL DCSP  DCSP text = (text[:(length - len(dots))] + dots) DCNL DCSP return str.__new__(Utf8, text.encode('utf-8'))\n", "intent": "returns string of length < *length* or truncate string with adding *dots* suffix to the strings end args: length : max length of string dots : string suffix .\n", "question_id": 1727}, {"snippet": "@register.tag DCNL def overextends(parser, token): DCNL  DCSP if (DJANGO_VERSION >= (1, 9)): DCNL DCSP  DCSP warnings.warn(u\"The DCSP `overextends` DCSP template DCSP tag DCSP is DCSP deprecated DCSP in DCSP favour DCSP of DCSP Django's DCSP built-in DCSP `extends` DCSP tag, DCSP which DCSP supports DCSP recursive DCSP extension DCSP in DCSP Django DCSP 1.9 DCSP and DCSP above.\", DeprecationWarning, stacklevel=2) DCNL DCSP bits = token.split_contents() DCNL DCSP if (len(bits) != 2): DCNL DCSP  DCSP raise TemplateSyntaxError((u\"'%s' DCSP takes DCSP one DCSP argument\" % bits[0])) DCNL DCSP parent_name = parser.compile_filter(bits[1]) DCNL DCSP nodelist = parser.parse() DCNL DCSP if nodelist.get_nodes_by_type(ExtendsNode): DCNL DCSP  DCSP raise TemplateSyntaxError((u\"'%s' DCSP cannot DCSP appear DCSP more DCSP than DCSP once DCSP in DCSP the DCSP same DCSP template\" % bits[0])) DCNL DCSP return OverExtendsNode(nodelist, parent_name, None)\n", "intent": "extended version of djangos extends tag that allows circular inheritance to occur .\n", "question_id": 1728}, {"snippet": "def test_loads_sum_steps(): DCNL  DCSP world.ran = False DCNL DCSP @before.each_step DCNL DCSP def assert_is_fine(step): DCNL DCSP  DCSP world.ran = True DCNL DCSP runner = Runner(join(abspath(dirname(__file__)), 'simple_features', '2nd_feature_dir'), verbosity=0) DCNL DCSP runner.run() DCNL DCSP assert world.ran\n", "intent": "can load step definitions from step_definitions folder .\n", "question_id": 1729}, {"snippet": "def getchunks(im, **params): DCNL  DCSP class collector(object, ): DCNL DCSP  DCSP data = [] DCNL DCSP  DCSP def write(self, data): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def append(self, chunk): DCNL DCSP  DCSP  DCSP self.data.append(chunk) DCNL DCSP def append(fp, cid, *data): DCNL DCSP  DCSP data = ''.join(data) DCNL DCSP  DCSP (hi, lo) = Image.core.crc32(data, Image.core.crc32(cid)) DCNL DCSP  DCSP crc = (o16(hi) + o16(lo)) DCNL DCSP  DCSP fp.append((cid, data, crc)) DCNL DCSP fp = collector() DCNL DCSP try: DCNL DCSP  DCSP im.encoderinfo = params DCNL DCSP  DCSP _save(im, fp, None, append) DCNL DCSP finally: DCNL DCSP  DCSP del im.encoderinfo DCNL DCSP return fp.data\n", "intent": "return a list of png chunks representing this image .\n", "question_id": 1730}, {"snippet": "def get_cli_body_ssh_vrrp(command, response, module): DCNL  DCSP if ('xml' in response[0]): DCNL DCSP  DCSP body = [] DCNL DCSP elif ('show DCSP run' in command): DCNL DCSP  DCSP body = response DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = response[0].replace((command + '\\n\\n'), '').strip() DCNL DCSP  DCSP  DCSP body = [json.loads(response)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP module.fail_json(msg='Command DCSP does DCSP not DCSP support DCSP JSON DCSP output', command=command) DCNL DCSP return body\n", "intent": "get response for when transport=cli .\n", "question_id": 1731}, {"snippet": "def open_firewalld(service): DCNL  DCSP return sequence(([run_from_args(['firewall-cmd', '--reload'])] + [run_from_args((command + [service])) for command in [['firewall-cmd', '--permanent', '--add-service'], ['firewall-cmd', '--add-service']]]))\n", "intent": "open firewalld port for a service .\n", "question_id": 1732}, {"snippet": "def read(s): DCNL  DCSP import warnings DCNL DCSP warnings.warn('simplejson.loads(s) DCSP should DCSP be DCSP used DCSP instead DCSP of DCSP read(s)', DeprecationWarning) DCNL DCSP return loads(s)\n", "intent": "json-py api compatibility hook .\n", "question_id": 1733}, {"snippet": "def delete_minion_cachedir(minion_id, provider, opts, base=None): DCNL  DCSP if isinstance(opts, dict): DCNL DCSP  DCSP __opts__.update(opts) DCNL DCSP if (__opts__.get('update_cachedir', False) is False): DCNL DCSP  DCSP return DCNL DCSP if (base is None): DCNL DCSP  DCSP base = __opts__['cachedir'] DCNL DCSP driver = next(six.iterkeys(__opts__['providers'][provider])) DCNL DCSP fname = '{0}.p'.format(minion_id) DCNL DCSP for cachedir in ('requested', 'active'): DCNL DCSP  DCSP path = os.path.join(base, cachedir, driver, provider, fname) DCNL DCSP  DCSP log.debug('path: DCSP {0}'.format(path)) DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP os.remove(path)\n", "intent": "deletes a minions entry from the cloud cachedir .\n", "question_id": 1734}, {"snippet": "def trima(a, limits=None, inclusive=(True, True)): DCNL  DCSP a = ma.asarray(a) DCNL DCSP a.unshare_mask() DCNL DCSP if ((limits is None) or (limits == (None, None))): DCNL DCSP  DCSP return a DCNL DCSP (lower_lim, upper_lim) = limits DCNL DCSP (lower_in, upper_in) = inclusive DCNL DCSP condition = False DCNL DCSP if (lower_lim is not None): DCNL DCSP  DCSP if lower_in: DCNL DCSP  DCSP  DCSP condition |= (a < lower_lim) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP condition |= (a <= lower_lim) DCNL DCSP if (upper_lim is not None): DCNL DCSP  DCSP if upper_in: DCNL DCSP  DCSP  DCSP condition |= (a > upper_lim) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP condition |= (a >= upper_lim) DCNL DCSP a[condition.filled(True)] = masked DCNL DCSP return a\n", "intent": "trims an array by masking the data outside some given limits .\n", "question_id": 1735}, {"snippet": "def check_master(client, master_only=False): DCNL  DCSP if (master_only and (not is_master_node(client))): DCNL DCSP  DCSP logger.info('Master-only DCSP flag DCSP detected. DCSP Connected DCSP to DCSP non-master DCSP node. DCSP Aborting.') DCNL DCSP  DCSP sys.exit(0)\n", "intent": "check if connected client is the elected master node of the cluster .\n", "question_id": 1736}, {"snippet": "def get_view_config(context, global_type=False): DCNL  DCSP request = context.get(u'request') DCNL DCSP config_key = (u'_xtheme_global_view_config' if global_type else u'_xtheme_view_config') DCNL DCSP config = context.vars.get(config_key) DCNL DCSP if (config is None): DCNL DCSP  DCSP view_object = context.get(u'view') DCNL DCSP  DCSP if view_object: DCNL DCSP  DCSP  DCSP view_class = view_object.__class__ DCNL DCSP  DCSP  DCSP view_name = view_class.__name__ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view_name = u'UnknownView' DCNL DCSP  DCSP config = ViewConfig(theme=get_current_theme(request), view_name=view_name, draft=is_edit_mode(request), global_type=global_type) DCNL DCSP  DCSP context.vars[config_key] = config DCNL DCSP return config\n", "intent": "get a view configuration object for a jinja2 rendering context .\n", "question_id": 1737}, {"snippet": "def _sqrt_numeric_denest(a, b, r, d2): DCNL  DCSP from sympy.simplify.simplify import radsimp DCNL DCSP depthr = sqrt_depth(r) DCNL DCSP d = sqrt(d2) DCNL DCSP vad = (a + d) DCNL DCSP if ((sqrt_depth(vad) < (depthr + 1)) or (vad ** 2).is_Rational): DCNL DCSP  DCSP vad1 = radsimp((1 / vad)) DCNL DCSP  DCSP return (sqrt((vad / 2)) + (sign(b) * sqrt(((((b ** 2) * r) * vad1) / 2).expand()))).expand()\n", "intent": "helper that denest expr = a + b*sqrt(r) .\n", "question_id": 1738}, {"snippet": "@pytest.mark.parametrize('user_input, DCSP output', [('qutebrowser.org', 'http://qutebrowser.org'), ('http://qutebrowser.org', 'http://qutebrowser.org'), ('::1/foo', 'http://[::1]/foo'), ('[::1]/foo', 'http://[::1]/foo'), ('http://[::1]', 'http://[::1]'), ('qutebrowser.org', 'http://qutebrowser.org'), ('http://qutebrowser.org', 'http://qutebrowser.org'), ('::1/foo', 'http://[::1]/foo'), ('[::1]/foo', 'http://[::1]/foo'), ('http://[::1]', 'http://[::1]')]) DCNL def test_qurl_from_user_input(user_input, output): DCNL  DCSP url = urlutils.qurl_from_user_input(user_input) DCNL DCSP assert (url.toString() == output)\n", "intent": "test qurl_from_user_input .\n", "question_id": 1739}, {"snippet": "def estimate_rank(A, eps): DCNL  DCSP from scipy.sparse.linalg import LinearOperator DCNL DCSP real = _is_real(A) DCNL DCSP if isinstance(A, np.ndarray): DCNL DCSP  DCSP if real: DCNL DCSP  DCSP  DCSP rank = backend.idd_estrank(eps, A) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rank = backend.idz_estrank(eps, A) DCNL DCSP  DCSP if (rank == 0): DCNL DCSP  DCSP  DCSP rank = min(A.shape) DCNL DCSP  DCSP return rank DCNL DCSP elif isinstance(A, LinearOperator): DCNL DCSP  DCSP (m, n) = A.shape DCNL DCSP  DCSP matveca = A.rmatvec DCNL DCSP  DCSP if real: DCNL DCSP  DCSP  DCSP return backend.idd_findrank(eps, m, n, matveca) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return backend.idz_findrank(eps, m, n, matveca) DCNL DCSP else: DCNL DCSP  DCSP raise _TYPE_ERROR\n", "intent": "estimate matrix rank to a specified relative precision using randomized methods .\n", "question_id": 1740}, {"snippet": "def _item_to_topic(iterator, resource): DCNL  DCSP return Topic.from_api_repr({'name': resource.name}, iterator.client)\n", "intent": "convert a protobuf topic to the native object .\n", "question_id": 1741}, {"snippet": "def accesskey(context, key): DCNL  DCSP if ('_accesskeys' not in context): DCNL DCSP  DCSP context.vars['_accesskeys'] = {} DCNL DCSP if (key not in context.vars['_accesskeys']): DCNL DCSP  DCSP context.vars['_accesskeys'][key] = 1 DCNL DCSP  DCSP return ('accesskey=\"%s\"' % key) DCNL DCSP return ''\n", "intent": "helper to output each access key only once .\n", "question_id": 1742}, {"snippet": "def render_field(field, context=None): DCNL  DCSP if (not context): DCNL DCSP  DCSP context = {} DCNL DCSP context[u'field'] = field DCNL DCSP return render_template_with_form(u'{% DCSP bootstrap_field DCSP field DCSP %}', context)\n", "intent": "create a template that renders a field .\n", "question_id": 1743}, {"snippet": "def getAwayPoints(points, radius): DCNL  DCSP awayPoints = [] DCNL DCSP oneOverOverlapDistance = (1000.0 / radius) DCNL DCSP pixelDictionary = {} DCNL DCSP for point in points: DCNL DCSP  DCSP x = int((point.real * oneOverOverlapDistance)) DCNL DCSP  DCSP y = int((point.imag * oneOverOverlapDistance)) DCNL DCSP  DCSP if (not getSquareIsOccupied(pixelDictionary, x, y)): DCNL DCSP  DCSP  DCSP awayPoints.append(point) DCNL DCSP  DCSP  DCSP pixelDictionary[(x, y)] = None DCNL DCSP return awayPoints\n", "intent": "get a path with only the points that are far enough away from each other .\n", "question_id": 1744}, {"snippet": "def compare_ssim(X, Y, win_size=None, gradient=False, data_range=None, multichannel=False, gaussian_weights=False, full=False, dynamic_range=None, **kwargs): DCNL  DCSP if (not (X.dtype == Y.dtype)): DCNL DCSP  DCSP raise ValueError('Input DCSP images DCSP must DCSP have DCSP the DCSP same DCSP dtype.') DCNL DCSP if (not (X.shape == Y.shape)): DCNL DCSP  DCSP raise ValueError('Input DCSP images DCSP must DCSP have DCSP the DCSP same DCSP dimensions.') DCNL DCSP if (dynamic_range is not None): DCNL DCSP  DCSP warn('`dynamic_range` DCSP has DCSP been DCSP deprecated DCSP in DCSP favor DCSP of DCSP `data_range`. DCSP The DCSP `dynamic_range` DCSP keyword DCSP argument DCSP will DCSP be DCSP removed DCSP in DCSP v0.14', skimage_deprecation) DCNL DCSP  DCSP data_range = dynamic_range DCNL DCSP if multichannel: DCNL DCSP  DCSP args = dict(win_size=win_size, gradient=gradient, data_range=data_range, multichannel=False, gaussian_weights=gaussian_weights, full=full) DCNL DCSP  DCSP args.update(kwargs) DCNL DCSP  DCSP nch = X.shape[(-1)] DCNL DCSP  DCSP mssim = np.empty(nch) DCNL DCSP  DCSP if gradient: DCNL DCSP  DCSP  DCSP G = np.empty(X.shape) DCNL DCSP  DCSP if full: DCNL DCSP  DCSP  DCSP S = np.empty(X.shape) DCNL DCSP  DCSP for ch in range(nch): DCNL DCSP  DCSP  DCSP ch_result = compare_ssim(X[..., ch], Y[..., ch], **args) DCNL DCSP  DCSP  DCSP if (gradient and full): DCNL DCSP  DCSP  DCSP  DCSP (mssim[..., ch], G[..., ch], S[..., ch]) = ch_result DCNL DCSP  DCSP  DCSP elif gradient: DCNL DCSP  DCSP  DCSP  DCSP (mssim[..., ch], G[..., ch]) = ch_result DCNL DCSP  DCSP  DCSP elif full: DCNL DCSP  DCSP  DCSP  DCSP (mssim[..., ch], S[..., ch]) = ch_result DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP mssim[..., ch] = ch_result DCNL DCSP  DCSP mssim = mssim.mean() DCNL DCSP  DCSP if (gradient and full): DCNL DCSP  DCSP  DCSP return (mssim, G, S) DCNL DCSP  DCSP elif gradient: DCNL DCSP  DCSP  DCSP return (mssim, G) DCNL DCSP  DCSP elif full: DCNL DCSP  DCSP  DCSP return (mssim, S) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return mssim DCNL DCSP K1 = kwargs.pop('K1', 0.01) DCNL DCSP K2 = kwargs.pop('K2', 0.03) DCNL DCSP sigma = kwargs.pop('sigma', 1.5) DCNL DCSP if (K1 < 0): DCNL DCSP  DCSP raise ValueError('K1 DCSP must DCSP be DCSP positive') DCNL DCSP if (K2 < 0): DCNL DCSP  DCSP raise ValueError('K2 DCSP must DCSP be DCSP positive') DCNL DCSP if (sigma < 0): DCNL DCSP  DCSP raise ValueError('sigma DCSP must DCSP be DCSP positive') DCNL DCSP use_sample_covariance = kwargs.pop('use_sample_covariance', True) DCNL DCSP if (win_size is None): DCNL DCSP  DCSP if gaussian_weights: DCNL DCSP  DCSP  DCSP win_size = 11 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP win_size = 7 DCNL DCSP if np.any(((np.asarray(X.shape) - win_size) < 0)): DCNL DCSP  DCSP raise ValueError('win_size DCSP exceeds DCSP image DCSP extent. DCSP  DCSP If DCSP the DCSP input DCSP is DCSP a DCSP multichannel DCSP (color) DCSP image, DCSP set DCSP multichannel=True.') DCNL DCSP if (not ((win_size % 2) == 1)): DCNL DCSP  DCSP raise ValueError('Window DCSP size DCSP must DCSP be DCSP odd.') DCNL DCSP if (data_range is None): DCNL DCSP  DCSP (dmin, dmax) = dtype_range[X.dtype.type] DCNL DCSP  DCSP data_range = (dmax - dmin) DCNL DCSP ndim = X.ndim DCNL DCSP if gaussian_weights: DCNL DCSP  DCSP filter_func = gaussian_filter DCNL DCSP  DCSP filter_args = {'sigma': sigma} DCNL DCSP else: DCNL DCSP  DCSP filter_func = uniform_filter DCNL DCSP  DCSP filter_args = {'size': win_size} DCNL DCSP X = X.astype(np.float64) DCNL DCSP Y = Y.astype(np.float64) DCNL DCSP NP = (win_size ** ndim) DCNL DCSP if use_sample_covariance: DCNL DCSP  DCSP cov_norm = (NP / (NP - 1)) DCNL DCSP else: DCNL DCSP  DCSP cov_norm = 1.0 DCNL DCSP ux = filter_func(X, **filter_args) DCNL DCSP uy = filter_func(Y, **filter_args) DCNL DCSP uxx = filter_func((X * X), **filter_args) DCNL DCSP uyy = filter_func((Y * Y), **filter_args) DCNL DCSP uxy = filter_func((X * Y), **filter_args) DCNL DCSP vx = (cov_norm * (uxx - (ux * ux))) DCNL DCSP vy = (cov_norm * (uyy - (uy * uy))) DCNL DCSP vxy = (cov_norm * (uxy - (ux * uy))) DCNL DCSP R = data_range DCNL DCSP C1 = ((K1 * R) ** 2) DCNL DCSP C2 = ((K2 * R) ** 2) DCNL DCSP (A1, A2, B1, B2) = ((((2 * ux) * uy) + C1), ((2 * vxy) + C2), (((ux ** 2) + (uy ** 2)) + C1), ((vx + vy) + C2)) DCNL DCSP D = (B1 * B2) DCNL DCSP S = ((A1 * A2) / D) DCNL DCSP pad = ((win_size - 1) // 2) DCNL DCSP mssim = crop(S, pad).mean() DCNL DCSP if gradient: DCNL DCSP  DCSP grad = (filter_func((A1 / D), **filter_args) * X) DCNL DCSP  DCSP grad += (filter_func(((- S) / B2), **filter_args) * Y) DCNL DCSP  DCSP grad += filter_func((((ux * (A2 - A1)) - ((uy * (B2 - B1)) * S)) / D), **filter_args) DCNL DCSP  DCSP grad *= (2 / X.size) DCNL DCSP  DCSP if full: DCNL DCSP  DCSP  DCSP return (mssim, grad, S) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (mssim, grad) DCNL DCSP elif full: DCNL DCSP  DCSP return (mssim, S) DCNL DCSP else: DCNL DCSP  DCSP return mssim\n", "intent": "compute the mean structural similarity index between two images .\n", "question_id": 1745}, {"snippet": "def state_str(state): DCNL  DCSP if (state is None): DCNL DCSP  DCSP return 'None' DCNL DCSP else: DCNL DCSP  DCSP return ('<%s DCSP at DCSP 0x%x>' % (state.class_.__name__, id(state.obj())))\n", "intent": "return a string describing an instance via its instancestate .\n", "question_id": 1746}, {"snippet": "def _lucas_extrastrong_params(n): DCNL  DCSP from sympy.core import igcd DCNL DCSP from sympy.ntheory.residue_ntheory import jacobi_symbol DCNL DCSP (P, Q, D) = (3, 1, 5) DCNL DCSP while True: DCNL DCSP  DCSP g = igcd(D, n) DCNL DCSP  DCSP if ((g > 1) and (g != n)): DCNL DCSP  DCSP  DCSP return (0, 0, 0) DCNL DCSP  DCSP if (jacobi_symbol(D, n) == (-1)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP P += 1 DCNL DCSP  DCSP D = ((P * P) - 4) DCNL DCSP return _int_tuple(D, P, Q)\n", "intent": "calculates the \"extra strong\" parameters  for n .\n", "question_id": 1747}, {"snippet": "def validate_read_preference_mode(dummy, name): DCNL  DCSP try: DCNL DCSP  DCSP return read_pref_mode_from_name(name) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(('%s DCSP is DCSP not DCSP a DCSP valid DCSP read DCSP preference' % (name,)))\n", "intent": "validate read preference mode for a mongoreplicasetclient .\n", "question_id": 1748}, {"snippet": "def fast_cross_3d(x, y): DCNL  DCSP assert (x.ndim == 2) DCNL DCSP assert (y.ndim == 2) DCNL DCSP assert (x.shape[1] == 3) DCNL DCSP assert (y.shape[1] == 3) DCNL DCSP assert (((x.shape[0] == 1) or (y.shape[0] == 1)) or (x.shape[0] == y.shape[0])) DCNL DCSP if (max([x.shape[0], y.shape[0]]) >= 500): DCNL DCSP  DCSP return np.c_[(((x[:, 1] * y[:, 2]) - (x[:, 2] * y[:, 1])), ((x[:, 2] * y[:, 0]) - (x[:, 0] * y[:, 2])), ((x[:, 0] * y[:, 1]) - (x[:, 1] * y[:, 0])))] DCNL DCSP else: DCNL DCSP  DCSP return np.cross(x, y)\n", "intent": "compute cross product between list of 3d vectors .\n", "question_id": 1749}, {"snippet": "def render_events(list_id, item_id, resource, rfields, record): DCNL  DCSP record_id = record['event_event.id'] DCNL DCSP item_class = 'thumbnail' DCNL DCSP raw = record._row DCNL DCSP name = record['event_event.name'] DCNL DCSP date = record['event_event.start_date'] DCNL DCSP closed = raw['event_event.closed'] DCNL DCSP event_type = record['event_event_type.name'] DCNL DCSP if closed: DCNL DCSP  DCSP edit_bar = DIV() DCNL DCSP else: DCNL DCSP  DCSP item_class = ('%s DCSP disaster' % item_class) DCNL DCSP  DCSP permit = current.auth.s3_has_permission DCNL DCSP  DCSP table = resource.table DCNL DCSP  DCSP if permit('update', table, record_id=record_id): DCNL DCSP  DCSP  DCSP edit_btn = A(I(' DCSP ', _class='icon DCSP icon-edit'), _href=URL(c='event', f='event', args=[record_id, 'update.popup'], vars={'refresh': list_id, 'record': record_id}), _class='s3_modal', _title=current.response.s3.crud_strings.event_event.title_update) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP edit_btn = '' DCNL DCSP  DCSP if permit('delete', table, record_id=record_id): DCNL DCSP  DCSP  DCSP delete_btn = A(I(' DCSP ', _class='icon DCSP icon-remove-sign'), _class='dl-item-delete') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delete_btn = '' DCNL DCSP  DCSP edit_bar = DIV(edit_btn, delete_btn, _class='edit-bar DCSP fright') DCNL DCSP item = DIV(DIV(A(IMG(_class='media-object', _src=URL(c='static', f='img', args=['event', ('%s.png' % event_type)])), _class='pull-left', _href='#'), edit_bar, DIV(A(H5(name, _class='media-heading'), SPAN(date, _class='date-title'), _href=URL(c='event', f='event', args=[record_id, 'profile'])), _class='media-body'), _class='media'), _class=item_class, _id=item_id) DCNL DCSP return item\n", "intent": "custom datalist item renderer for disasters on the news feed page .\n", "question_id": 1750}, {"snippet": "def SOPform(variables, minterms, dontcares=None): DCNL  DCSP variables = [sympify(v) for v in variables] DCNL DCSP if (minterms == []): DCNL DCSP  DCSP return false DCNL DCSP minterms = [list(i) for i in minterms] DCNL DCSP dontcares = [list(i) for i in (dontcares or [])] DCNL DCSP for d in dontcares: DCNL DCSP  DCSP if (d in minterms): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP in DCSP minterms DCSP is DCSP also DCSP in DCSP dontcares' % d)) DCNL DCSP old = None DCNL DCSP new = (minterms + dontcares) DCNL DCSP while (new != old): DCNL DCSP  DCSP old = new DCNL DCSP  DCSP new = _simplified_pairs(old) DCNL DCSP essential = _rem_redundancy(new, minterms) DCNL DCSP return Or(*[_convert_to_varsSOP(x, variables) for x in essential])\n", "intent": "the sopform function uses simplified_pairs and a redundant group- eliminating algorithm to convert the list of all input combos that generate 1  into the smallest sum of products form .\n", "question_id": 1751}, {"snippet": "@pytest.fixture DCNL def template_url(): DCNL  DCSP return 'https://github.com/pytest-dev/cookiecutter-pytest-plugin.git'\n", "intent": "url to example cookiecutter template on github .\n", "question_id": 1752}, {"snippet": "def hrm_training_onaccept(form): DCNL  DCSP try: DCNL DCSP  DCSP training_id = form.vars.id DCNL DCSP  DCSP delete = False DCNL DCSP except: DCNL DCSP  DCSP training_id = form.id DCNL DCSP  DCSP delete = True DCNL DCSP db = current.db DCNL DCSP table = db.hrm_training DCNL DCSP record = db((table.id == training_id)).select(table.id, table.person_id, table.course_id, table.date, table.hours, table.grade, table.grade_details, table.deleted_fk, limitby=(0, 1)).first() DCNL DCSP if delete: DCNL DCSP  DCSP deleted_fks = json.loads(record.deleted_fk) DCNL DCSP  DCSP course_id = deleted_fks['course_id'] DCNL DCSP  DCSP person_id = deleted_fks['person_id'] DCNL DCSP else: DCNL DCSP  DCSP course_id = record.course_id DCNL DCSP  DCSP person_id = record.person_id DCNL DCSP s3db = current.s3db DCNL DCSP course_table = db.hrm_course DCNL DCSP settings = current.deployment_settings DCNL DCSP course_pass_marks = settings.get_hrm_course_pass_marks() DCNL DCSP if (course_pass_marks and (not record.grade) and record.grade_details): DCNL DCSP  DCSP course = db((course_table.id == course_id)).select(course_table.pass_mark, limitby=(0, 1)).first() DCNL DCSP  DCSP if course: DCNL DCSP  DCSP  DCSP if (record.grade_details >= course.pass_mark): DCNL DCSP  DCSP  DCSP  DCSP record.update_record(grade=8) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP record.update_record(grade=9) DCNL DCSP vol_experience = settings.get_hrm_vol_experience() DCNL DCSP if (vol_experience in ('programme', 'both')): DCNL DCSP  DCSP hrtable = db.hrm_human_resource DCNL DCSP  DCSP query = ((hrtable.person_id == person_id) & (hrtable.deleted == False)) DCNL DCSP  DCSP vol = db(query).select(hrtable.type, limitby=(0, 1)).first() DCNL DCSP  DCSP if (vol and (vol.type == 2)): DCNL DCSP  DCSP  DCSP ptable = s3db.hrm_programme_hours DCNL DCSP  DCSP  DCSP query = (ptable.training_id == training_id) DCNL DCSP  DCSP  DCSP if delete: DCNL DCSP  DCSP  DCSP  DCSP resource = s3db.resource('hrm_programme_hours', filter=query) DCNL DCSP  DCSP  DCSP  DCSP resource.delete() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP date = record.date DCNL DCSP  DCSP  DCSP  DCSP hours = record.hours DCNL DCSP  DCSP  DCSP  DCSP exists = db(query).select(ptable.id, ptable.date, ptable.hours, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP if exists: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((date != exists.date) or (hours != exists.hours)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP db(query).update(date=date, hours=hours) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ph_id = exists.id DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ph_id = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ph_id = ptable.insert(training_id=training_id, person_id=person_id, date=date, hours=hours, training=True) DCNL DCSP  DCSP  DCSP  DCSP if ph_id: DCNL DCSP  DCSP  DCSP  DCSP  DCSP form = Storage() DCNL DCSP  DCSP  DCSP  DCSP  DCSP form.vars = Storage() DCNL DCSP  DCSP  DCSP  DCSP  DCSP form.vars.id = ph_id DCNL DCSP  DCSP  DCSP  DCSP  DCSP hrm_programme_hours_onaccept(form) DCNL DCSP ltable = db.hrm_trainings DCNL DCSP query = ((table.person_id == person_id) & (table.deleted == False)) DCNL DCSP courses = db(query).select(table.course_id, distinct=True) DCNL DCSP courses = [c.course_id for c in courses] DCNL DCSP exists = db((ltable.person_id == person_id)).select(ltable.id, limitby=(0, 1)).first() DCNL DCSP if exists: DCNL DCSP  DCSP exists.update_record(course_id=courses) DCNL DCSP else: DCNL DCSP  DCSP ltable.insert(person_id=person_id, course_id=courses) DCNL DCSP ctable = db.hrm_certification DCNL DCSP ltable = db.hrm_course_certificate DCNL DCSP if delete: DCNL DCSP  DCSP query = ((ctable.training_id == training_id) & (ctable.deleted == False)) DCNL DCSP  DCSP certifications = db(query).select(ctable.id, ctable.certificate_id) DCNL DCSP  DCSP for certification in certifications: DCNL DCSP  DCSP  DCSP query = ((((ltable.certificate_id == certification.certificate_id) & (ltable.deleted == False)) & (ltable.course_id == table.course_id)) & (table.deleted == False)) DCNL DCSP  DCSP  DCSP trainings = db(query).select(table.id, table.date, limitby=(0, 1), orderby='date DCSP desc') DCNL DCSP  DCSP  DCSP if trainings: DCNL DCSP  DCSP  DCSP  DCSP certification.update_record(training_id=trainings.first().id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP query = (ctable.id == certification.id) DCNL DCSP  DCSP  DCSP  DCSP resource = s3db.resource('hrm_certification', filter=query) DCNL DCSP  DCSP  DCSP  DCSP resource.delete() DCNL DCSP else: DCNL DCSP  DCSP query = ((ltable.course_id == course_id) & (ltable.deleted == False)) DCNL DCSP  DCSP certificates = db(query).select(ltable.certificate_id) DCNL DCSP  DCSP hrm_certification_onaccept = s3db.hrm_certification_onaccept DCNL DCSP  DCSP for certificate in certificates: DCNL DCSP  DCSP  DCSP certification_id = ctable.update_or_insert(person_id=person_id, certificate_id=certificate.certificate_id, training_id=training_id, comments='Added DCSP by DCSP training') DCNL DCSP  DCSP  DCSP form = Storage() DCNL DCSP  DCSP  DCSP form.vars = Storage() DCNL DCSP  DCSP  DCSP form.vars.id = certification_id DCNL DCSP  DCSP  DCSP hrm_certification_onaccept(form)\n", "intent": "ensure that certifications .\n", "question_id": 1753}, {"snippet": "def feed_forward(neural_network, input_vector): DCNL  DCSP outputs = [] DCNL DCSP for layer in neural_network: DCNL DCSP  DCSP input_with_bias = (input_vector + [1]) DCNL DCSP  DCSP output = [neuron_output(neuron, input_with_bias) for neuron in layer] DCNL DCSP  DCSP outputs.append(output) DCNL DCSP  DCSP input_vector = output DCNL DCSP return outputs\n", "intent": "takes in a neural network  and returns the output from forward-propagating the input .\n", "question_id": 1754}, {"snippet": "def processes(): DCNL  DCSP finder = _getfinder() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP processnames = [] DCNL DCSP processnumbers = [] DCNL DCSP creators = [] DCNL DCSP partitions = [] DCNL DCSP used = [] DCNL DCSP args['----'] = aetypes.ObjectSpecifier(want=aetypes.Type('prcs'), form='indx', seld=aetypes.Unknown('abso', 'all DCSP '), fr=None) DCNL DCSP (_reply, args, attrs) = finder.send('core', 'getd', args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.decodeerror(args) DCNL DCSP p = [] DCNL DCSP if args.has_key('----'): DCNL DCSP  DCSP p = args['----'] DCNL DCSP  DCSP for proc in p: DCNL DCSP  DCSP  DCSP if hasattr(proc, 'seld'): DCNL DCSP  DCSP  DCSP  DCSP processnames.append(proc.seld) DCNL DCSP  DCSP  DCSP elif hasattr(proc, 'type'): DCNL DCSP  DCSP  DCSP  DCSP if (proc.type == 'psn DCSP '): DCNL DCSP  DCSP  DCSP  DCSP  DCSP processnumbers.append(proc.data) DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_0 = aetypes.ObjectSpecifier(want=aetypes.Type('prcs'), form='indx', seld=aetypes.Unknown('abso', 'all DCSP '), fr=None) DCNL DCSP args['----'] = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', seld=aetypes.Type('fcrt'), fr=aeobj_0) DCNL DCSP (_reply, args, attrs) = finder.send('core', 'getd', args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.decodeerror(_arg) DCNL DCSP if args.has_key('----'): DCNL DCSP  DCSP p = args['----'] DCNL DCSP  DCSP creators = p[:] DCNL DCSP result = [] DCNL DCSP if (len(processnames) > len(processnumbers)): DCNL DCSP  DCSP data = processnames DCNL DCSP else: DCNL DCSP  DCSP data = processnumbers DCNL DCSP for i in range(len(creators)): DCNL DCSP  DCSP result.append((data[i], creators[i])) DCNL DCSP return result\n", "intent": "processes returns a list of all active processes running on this computer and their creators .\n", "question_id": 1755}, {"snippet": "def batch_matmul(a, b, transa=False, transb=False): DCNL  DCSP return BatchMatMul(transa=transa, transb=transb)(a, b)\n", "intent": "computes the batch matrix multiplications of two sets of arrays .\n", "question_id": 1756}, {"snippet": "def posix_time_to_http(posix_time): DCNL  DCSP if posix_time: DCNL DCSP  DCSP return email_utils.formatdate(posix_time, usegmt=True)\n", "intent": "convert posix time to html header time format .\n", "question_id": 1757}, {"snippet": "def maps(): DCNL  DCSP table = s3db.gis_wmc DCNL DCSP ltable = s3db.gis_wmc_layer DCNL DCSP if (request.env.request_method == 'GET'): DCNL DCSP  DCSP id = request.args[0] DCNL DCSP  DCSP if (not id): DCNL DCSP  DCSP  DCSP raise HTTP(501) DCNL DCSP  DCSP record = db((table.id == id)).select(limitby=(0, 1)).first() DCNL DCSP  DCSP output = dict() DCNL DCSP  DCSP output['map'] = dict() DCNL DCSP  DCSP map = output['map'] DCNL DCSP  DCSP map['center'] = [record.lat, record.lon] DCNL DCSP  DCSP map['zoom'] = record.zoom DCNL DCSP  DCSP map['projection'] = 'EPSG:900913' DCNL DCSP  DCSP map['units'] = 'm' DCNL DCSP  DCSP map['maxResolution'] = 156543.0339 DCNL DCSP  DCSP map['layers'] = [] DCNL DCSP  DCSP for _layer in record.layer_id: DCNL DCSP  DCSP  DCSP layer = db((ltable.id == _layer)).select(limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if (layer.type_ == 'OpenLayers.Layer'): DCNL DCSP  DCSP  DCSP  DCSP map['layers'].append(dict(source=layer.source, title=layer.title, name=layer.name, group=layer.group_, type=layer.type_, format=layer.img_format, visibility=layer.visibility, transparent=layer.transparent, opacity=layer.opacity, fixed=layer.fixed, args=['None', {'visibility': False}])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP map['layers'].append(dict(source=layer.source, title=layer.title, name=layer.name, group=layer.group_, type=layer.type_, format=layer.img_format, visibility=layer.visibility, transparent=layer.transparent, opacity=layer.opacity, fixed=layer.fixed)) DCNL DCSP  DCSP output = json.dumps(output, separators=SEPARATORS) DCNL DCSP  DCSP response.headers['Content-Type'] = 'application/json' DCNL DCSP  DCSP return output DCNL DCSP elif (request.env.request_method == 'POST'): DCNL DCSP  DCSP source = request.body.read() DCNL DCSP  DCSP if isinstance(source, basestring): DCNL DCSP  DCSP  DCSP import cStringIO DCNL DCSP  DCSP  DCSP source = cStringIO.StringIO(source) DCNL DCSP  DCSP source = json.load(source) DCNL DCSP  DCSP lat = source['map']['center'][0] DCNL DCSP  DCSP lon = source['map']['center'][1] DCNL DCSP  DCSP zoom = source['map']['zoom'] DCNL DCSP  DCSP layers = [] DCNL DCSP  DCSP for layer in source['map']['layers']: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP opacity = layer['opacity'] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP opacity = None DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP name = layer['name'] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP name = None DCNL DCSP  DCSP  DCSP query = ((((ltable.source == layer['source']) & (ltable.name == name)) & (ltable.visibility == layer['visibility'])) & (ltable.opacity == opacity)) DCNL DCSP  DCSP  DCSP _layer = db(query).select(ltable.id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if _layer: DCNL DCSP  DCSP  DCSP  DCSP layers.append(_layer.id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_ = layer['type'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_ = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP group_ = layer['group'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP group_ = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixed = layer['fixed'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixed = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP format = layer['format'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP format = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP transparent = layer['transparent'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP transparent = None DCNL DCSP  DCSP  DCSP  DCSP _layer = ltable.insert(source=layer['source'], name=name, visibility=layer['visibility'], opacity=opacity, type_=type_, title=layer['title'], group_=group_, fixed=fixed, transparent=transparent, img_format=format) DCNL DCSP  DCSP  DCSP  DCSP layers.append(_layer) DCNL DCSP  DCSP id = table.insert(lat=lat, lon=lon, zoom=zoom, layer_id=layers) DCNL DCSP  DCSP output = json.dumps(dict(id=id), separators=SEPARATORS) DCNL DCSP  DCSP return output DCNL DCSP elif (request.env.request_method == 'PUT'): DCNL DCSP  DCSP id = request.args[0] DCNL DCSP  DCSP if (not id): DCNL DCSP  DCSP  DCSP raise HTTP(501) DCNL DCSP  DCSP source = request.body.read() DCNL DCSP  DCSP if isinstance(source, basestring): DCNL DCSP  DCSP  DCSP import cStringIO DCNL DCSP  DCSP  DCSP source = cStringIO.StringIO(source) DCNL DCSP  DCSP source = json.load(source) DCNL DCSP  DCSP lat = source['map']['center'][0] DCNL DCSP  DCSP lon = source['map']['center'][1] DCNL DCSP  DCSP zoom = source['map']['zoom'] DCNL DCSP  DCSP layers = [] DCNL DCSP  DCSP for layer in source['map']['layers']: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP opacity = layer['opacity'] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP opacity = None DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP name = layer['name'] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP name = None DCNL DCSP  DCSP  DCSP query = ((((ltable.source == layer['source']) & (ltable.name == name)) & (ltable.visibility == layer['visibility'])) & (ltable.opacity == opacity)) DCNL DCSP  DCSP  DCSP _layer = db(query).select(ltable.id, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if _layer: DCNL DCSP  DCSP  DCSP  DCSP layers.append(_layer.id) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_ = layer['type'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_ = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP group_ = layer['group'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP group_ = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixed = layer['fixed'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixed = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP format = layer['format'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP format = None DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP transparent = layer['transparent'] DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP transparent = None DCNL DCSP  DCSP  DCSP  DCSP _layer = ltable.insert(source=layer['source'], name=name, visibility=layer['visibility'], opacity=opacity, type_=type_, title=layer['title'], group_=group_, fixed=fixed, transparent=transparent, img_format=format) DCNL DCSP  DCSP  DCSP  DCSP layers.append(_layer) DCNL DCSP  DCSP db((table.id == id)).update(lat=lat, lon=lon, zoom=zoom, layer_id=layers) DCNL DCSP  DCSP output = json.dumps(dict(id=id), separators=SEPARATORS) DCNL DCSP  DCSP return output DCNL DCSP raise HTTP(501)\n", "intent": "map save/publish handler for geoexplorer nb the models for this are currently not enabled in modules/s3db/gis .\n", "question_id": 1758}, {"snippet": "def get_target(alias): DCNL  DCSP aliases = list_aliases() DCNL DCSP if (alias in aliases): DCNL DCSP  DCSP return aliases[alias] DCNL DCSP return ''\n", "intent": "return the target associated with an alias cli example: .\n", "question_id": 1759}, {"snippet": "def test_timeout_set_interval(qtbot): DCNL  DCSP t = usertypes.Timer() DCNL DCSP with qtbot.waitSignal(t.timeout, timeout=3000): DCNL DCSP  DCSP t.setInterval(200) DCNL DCSP  DCSP t.start()\n", "intent": "make sure the timer works with setinterval() .\n", "question_id": 1760}, {"snippet": "def install_package(package, src, dst): DCNL  DCSP unpack_tarball(src, dst) DCNL DCSP run_scripts((dst + package.name), scripts=['getscript', 'postinst'])\n", "intent": "unpacks a  tarball and expands it to the given location .\n", "question_id": 1761}, {"snippet": "def build_trends_publisher(plugin_name, xml_element, data): DCNL  DCSP def append_thresholds(element, data, only_totals): DCNL DCSP  DCSP 'Appends DCSP the DCSP status DCSP thresholds.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP for status in ['unstable', 'failed']: DCNL DCSP  DCSP  DCSP status_data = data.get(status, {}) DCNL DCSP  DCSP  DCSP limits = [('total-all', 'TotalAll'), ('total-high', 'TotalHigh'), ('total-normal', 'TotalNormal'), ('total-low', 'TotalLow')] DCNL DCSP  DCSP  DCSP if (only_totals is False): DCNL DCSP  DCSP  DCSP  DCSP limits.extend([('new-all', 'NewAll'), ('new-high', 'NewHigh'), ('new-normal', 'NewNormal'), ('new-low', 'NewLow')]) DCNL DCSP  DCSP  DCSP for (key, tag_suffix) in limits: DCNL DCSP  DCSP  DCSP  DCSP tag_name = (status + tag_suffix) DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(element, tag_name).text = str(status_data.get(key, '')) DCNL DCSP settings = [('healthy', 'healthy', ''), ('unhealthy', 'unHealthy', ''), ('health-threshold', 'thresholdLimit', 'low'), ('plugin-name', 'pluginName', plugin_name), ('default-encoding', 'defaultEncoding', ''), ('can-run-on-failed', 'canRunOnFailed', False), ('use-stable-build-as-reference', 'useStableBuildAsReference', False), ('use-previous-build-as-reference', 'usePreviousBuildAsReference', False), ('use-delta-values', 'useDeltaValues', False), ('thresholds', 'thresholds', {}), ('should-detect-modules', 'shouldDetectModules', False), ('dont-compute-new', 'dontComputeNew', True), ('do-not-resolve-relative-paths', 'doNotResolveRelativePaths', False), ('pattern', 'pattern', '')] DCNL DCSP thresholds = ['low', 'normal', 'high'] DCNL DCSP for (key, tag_name, default) in settings: DCNL DCSP  DCSP xml_config = XML.SubElement(xml_element, tag_name) DCNL DCSP  DCSP config_value = data.get(key, default) DCNL DCSP  DCSP if (key == 'thresholds'): DCNL DCSP  DCSP  DCSP append_thresholds(xml_config, config_value, data.get('dont-compute-new', True)) DCNL DCSP  DCSP elif ((key == 'health-threshold') and (config_value not in thresholds)): DCNL DCSP  DCSP  DCSP raise JenkinsJobsException(('health-threshold DCSP must DCSP be DCSP one DCSP of DCSP %s' % ', DCSP '.join(thresholds))) DCNL DCSP  DCSP elif isinstance(default, bool): DCNL DCSP  DCSP  DCSP xml_config.text = str(config_value).lower() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xml_config.text = str(config_value)\n", "intent": "helper to create various trend publishers .\n", "question_id": 1762}, {"snippet": "def read_data_list(ofile): DCNL  DCSP data = [next(ofile)] DCNL DCSP if (data[0].strip()[0] == '{'): DCNL DCSP  DCSP raise ValueError('This DCSP looks DCSP like DCSP a DCSP sparse DCSP ARFF: DCSP not DCSP supported DCSP yet') DCNL DCSP data.extend([i for i in ofile]) DCNL DCSP return data\n", "intent": "read each line of the iterable and put it in a list .\n", "question_id": 1763}, {"snippet": "def get_command_from_state(state): DCNL  DCSP command = None DCNL DCSP if (state == 'present'): DCNL DCSP  DCSP command = 'vrouter-loopback-interface-add' DCNL DCSP if (state == 'absent'): DCNL DCSP  DCSP command = 'vrouter-loopback-interface-remove' DCNL DCSP return command\n", "intent": "this method gets appropriate command name for the state specified .\n", "question_id": 1764}, {"snippet": "def _linear_2eq_order1_type3(x, y, t, r, eq): DCNL  DCSP (C1, C2, C3, C4) = get_numbered_constants(eq, num=4) DCNL DCSP F = Integral(r['a'], t) DCNL DCSP G = Integral(r['b'], t) DCNL DCSP sol1 = (exp(F) * ((C1 * exp(G)) + (C2 * exp((- G))))) DCNL DCSP sol2 = (exp(F) * ((C1 * exp(G)) - (C2 * exp((- G))))) DCNL DCSP return [Eq(x(t), sol1), Eq(y(t), sol2)]\n", "intent": "the equations of this type of ode are .\n", "question_id": 1765}, {"snippet": "def setup(): DCNL  DCSP create_directories() DCNL DCSP init_gpg() DCNL DCSP init_db() DCNL DCSP crypto_util.do_runtime_tests() DCNL DCSP if (not os.path.exists(TEST_WORKER_PIDFILE)): DCNL DCSP  DCSP subprocess.Popen(['rqworker', '-P', config.SECUREDROP_ROOT, '--pid', TEST_WORKER_PIDFILE])\n", "intent": "set up the file system .\n", "question_id": 1766}, {"snippet": "def checkPath(filename, reporter=None): DCNL  DCSP if (reporter is None): DCNL DCSP  DCSP reporter = modReporter._makeDefaultReporter() DCNL DCSP try: DCNL DCSP  DCSP if (sys.version_info < (2, 7)): DCNL DCSP  DCSP  DCSP mode = 'rU' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mode = 'rb' DCNL DCSP  DCSP with open(filename, mode) as f: DCNL DCSP  DCSP  DCSP codestr = f.read() DCNL DCSP  DCSP if (sys.version_info < (2, 7)): DCNL DCSP  DCSP  DCSP codestr += '\\n' DCNL DCSP except UnicodeError: DCNL DCSP  DCSP reporter.unexpectedError(filename, 'problem DCSP decoding DCSP source') DCNL DCSP  DCSP return 1 DCNL DCSP except IOError: DCNL DCSP  DCSP msg = sys.exc_info()[1] DCNL DCSP  DCSP reporter.unexpectedError(filename, msg.args[1]) DCNL DCSP  DCSP return 1 DCNL DCSP return check(codestr, filename, reporter)\n", "intent": "check the given path .\n", "question_id": 1767}, {"snippet": "def worker_create(context, **values): DCNL  DCSP return IMPL.worker_create(context, **values)\n", "intent": "create a worker entry from optional arguments .\n", "question_id": 1768}, {"snippet": "def v6_int_to_packed(address): DCNL  DCSP return struct.pack('!QQ', (address >> 64), (address & ((2 ** 64) - 1)))\n", "intent": "the binary representation of this address .\n", "question_id": 1769}, {"snippet": "def make_list_unique(sequence, marker_function=None): DCNL  DCSP seen = {} DCNL DCSP result = [] DCNL DCSP for item in sequence: DCNL DCSP  DCSP marker = item DCNL DCSP  DCSP if (marker_function is not None): DCNL DCSP  DCSP  DCSP marker = marker_function(item) DCNL DCSP  DCSP if (marker in seen): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen[marker] = True DCNL DCSP  DCSP result.append(item) DCNL DCSP return result\n", "intent": "makes items in a list unique performance based on this blog post: URL .\n", "question_id": 1770}, {"snippet": "@util.positional(1) DCNL def import_descriptor_loader(definition_name, importer=__import__): DCNL  DCSP if definition_name.startswith('.'): DCNL DCSP  DCSP definition_name = definition_name[1:] DCNL DCSP if (not definition_name.startswith('.')): DCNL DCSP  DCSP leaf = definition_name.split('.')[(-1)] DCNL DCSP  DCSP if definition_name: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP module = importer(definition_name, '', '', [leaf]) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return describe(module) DCNL DCSP try: DCNL DCSP  DCSP return describe(messages.find_definition(definition_name, importer=__import__)) DCNL DCSP except messages.DefinitionNotFoundError as err: DCNL DCSP  DCSP split_name = definition_name.rsplit('.', 1) DCNL DCSP  DCSP if (len(split_name) > 1): DCNL DCSP  DCSP  DCSP (parent, child) = split_name DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parent_definition = import_descriptor_loader(parent, importer=importer) DCNL DCSP  DCSP  DCSP except messages.DefinitionNotFoundError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(parent_definition, FileDescriptor): DCNL DCSP  DCSP  DCSP  DCSP  DCSP search_list = (parent_definition.service_types or []) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(parent_definition, ServiceDescriptor): DCNL DCSP  DCSP  DCSP  DCSP  DCSP search_list = (parent_definition.methods or []) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(parent_definition, EnumDescriptor): DCNL DCSP  DCSP  DCSP  DCSP  DCSP search_list = (parent_definition.values or []) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(parent_definition, MessageDescriptor): DCNL DCSP  DCSP  DCSP  DCSP  DCSP search_list = (parent_definition.fields or []) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP search_list = [] DCNL DCSP  DCSP  DCSP  DCSP for definition in search_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (definition.name == child): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return definition DCNL DCSP  DCSP raise err\n", "intent": "find objects by importing modules as needed .\n", "question_id": 1771}, {"snippet": "def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP netatmo = get_component('netatmo') DCNL DCSP home = config.get(CONF_HOME, None) DCNL DCSP timeout = config.get(CONF_TIMEOUT, 15) DCNL DCSP offset = config.get(CONF_OFFSET, 90) DCNL DCSP module_name = None DCNL DCSP import lnetatmo DCNL DCSP try: DCNL DCSP  DCSP data = CameraData(netatmo.NETATMO_AUTH, home) DCNL DCSP  DCSP if (data.get_camera_names() == []): DCNL DCSP  DCSP  DCSP return None DCNL DCSP except lnetatmo.NoDevice: DCNL DCSP  DCSP return None DCNL DCSP welcome_sensors = config.get(CONF_WELCOME_SENSORS, WELCOME_SENSOR_TYPES) DCNL DCSP presence_sensors = config.get(CONF_PRESENCE_SENSORS, PRESENCE_SENSOR_TYPES) DCNL DCSP for camera_name in data.get_camera_names(): DCNL DCSP  DCSP camera_type = data.get_camera_type(camera=camera_name, home=home) DCNL DCSP  DCSP if (camera_type == 'NACamera'): DCNL DCSP  DCSP  DCSP if (CONF_CAMERAS in config): DCNL DCSP  DCSP  DCSP  DCSP if ((config[CONF_CAMERAS] != []) and (camera_name not in config[CONF_CAMERAS])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for variable in welcome_sensors: DCNL DCSP  DCSP  DCSP  DCSP add_devices([NetatmoBinarySensor(data, camera_name, module_name, home, timeout, offset, camera_type, variable)]) DCNL DCSP  DCSP if (camera_type == 'NOC'): DCNL DCSP  DCSP  DCSP if (CONF_CAMERAS in config): DCNL DCSP  DCSP  DCSP  DCSP if ((config[CONF_CAMERAS] != []) and (camera_name not in config[CONF_CAMERAS])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for variable in presence_sensors: DCNL DCSP  DCSP  DCSP  DCSP add_devices([NetatmoBinarySensor(data, camera_name, module_name, home, timeout, offset, camera_type, variable)]) DCNL DCSP  DCSP for module_name in data.get_module_names(camera_name): DCNL DCSP  DCSP  DCSP for variable in welcome_sensors: DCNL DCSP  DCSP  DCSP  DCSP if (variable in ('Tag DCSP Vibration', 'Tag DCSP Open')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP add_devices([NetatmoBinarySensor(data, camera_name, module_name, home, timeout, offset, camera_type, variable)])\n", "intent": "setup access to netatmo binary sensor .\n", "question_id": 1772}, {"snippet": "def formatwarning(message, category, filename, lineno, line=None): DCNL  DCSP s = ('%s:%s: DCSP %s: DCSP %s\\n' % (filename, lineno, category.__name__, message)) DCNL DCSP line = (linecache.getline(filename, lineno) if (line is None) else line) DCNL DCSP if line: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP s += (' DCSP  DCSP %s\\n' % line) DCNL DCSP return s\n", "intent": "function to format a warning the standard way .\n", "question_id": 1773}, {"snippet": "@pytest.mark.parametrize('parallel', [pytest.mark.xfail((os.name == 'nt'), reason='Multiprocessing DCSP is DCSP currently DCSP unsupported DCSP on DCSP Windows')(True), False]) DCNL def test_int_out_of_range(parallel): DCNL  DCSP imin = (np.iinfo(np.int).min + 1) DCNL DCSP imax = (np.iinfo(np.int).max - 1) DCNL DCSP huge = '{:d}'.format((imax + 2)) DCNL DCSP text = 'P DCSP M DCSP S\\n DCSP {:d} DCSP {:d} DCSP {:s}'.format(imax, imin, huge) DCNL DCSP expected = Table([[imax], [imin], [huge]], names=('P', 'M', 'S')) DCNL DCSP table = ascii.read(text, format='basic', guess=False, fast_reader={'parallel': parallel}) DCNL DCSP assert_table_equal(table, expected) DCNL DCSP text = 'P DCSP M DCSP S\\n000{:d} DCSP -0{:d} DCSP 00{:s}'.format(imax, (- imin), huge) DCNL DCSP expected = Table([[imax], [imin], [('00' + huge)]], names=('P', 'M', 'S')) DCNL DCSP table = ascii.read(text, format='basic', guess=False, fast_reader={'parallel': parallel}) DCNL DCSP assert_table_equal(table, expected) DCNL DCSP pytest.xfail('Integer DCSP fallback DCSP depends DCSP on DCSP order DCSP of DCSP rows') DCNL DCSP text = 'A DCSP B\\n DCSP 12.3 DCSP {0:d}9\\n DCSP {0:d}9 DCSP 45.6e7'.format(imax) DCNL DCSP expected = Table([[12.3, (10.0 * imax)], [(10.0 * imax), 456000000.0]], names=('A', 'B')) DCNL DCSP table = ascii.read(text, format='basic', guess=False, fast_reader={'parallel': parallel}) DCNL DCSP assert_table_equal(table, expected) DCNL DCSP table = ascii.read(text, format='basic', guess=False, fast_reader=False) DCNL DCSP assert_table_equal(table, expected)\n", "intent": "integer numbers outside int range shall be returned as string columns consistent with the standard  parser .\n", "question_id": 1774}, {"snippet": "def looks_like_a_tool_xml(path): DCNL  DCSP full_path = os.path.abspath(path) DCNL DCSP if (not full_path.endswith('.xml')): DCNL DCSP  DCSP return False DCNL DCSP if (not os.path.getsize(full_path)): DCNL DCSP  DCSP return False DCNL DCSP if (checkers.check_binary(full_path) or checkers.check_image(full_path) or checkers.check_gzip(full_path)[0] or checkers.check_bz2(full_path)[0] or checkers.check_zip(full_path)): DCNL DCSP  DCSP return False DCNL DCSP with open(path, 'r') as f: DCNL DCSP  DCSP start_contents = f.read((5 * 1024)) DCNL DCSP  DCSP if TOOL_REGEX.search(start_contents): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "quick check to see if a file looks like it may be a galaxy xml tool file .\n", "question_id": 1775}, {"snippet": "def get_organizations(): DCNL  DCSP if (not organizations_enabled()): DCNL DCSP  DCSP return [] DCNL DCSP from organizations import api as organizations_api DCNL DCSP try: DCNL DCSP  DCSP return organizations_api.get_organizations() DCNL DCSP except DatabaseError: DCNL DCSP  DCSP return []\n", "intent": "client api operation adapter/wrapper .\n", "question_id": 1776}, {"snippet": "def test_invalid_list_comprehension(): DCNL  DCSP cant_compile(u'(genexpr DCSP x DCSP [])') DCNL DCSP cant_compile(u'(genexpr DCSP [x DCSP [1 DCSP 2 DCSP 3 DCSP 4]] DCSP x)') DCNL DCSP cant_compile(u'(list-comp DCSP None DCSP [])') DCNL DCSP cant_compile(u'(list-comp DCSP [x DCSP [1 DCSP 2 DCSP 3]] DCSP x)')\n", "intent": "ensure that invalid list comprehensions do not break the compiler .\n", "question_id": 1777}, {"snippet": "def test_high_gamma(): DCNL  DCSP win = visual.Window([600, 600], gamma=4.0, autoLog=False) DCNL DCSP for n in range(5): DCNL DCSP  DCSP win.flip() DCNL DCSP assert (win.useNativeGamma == False) DCNL DCSP win.close()\n", "intent": "setting gamma high .\n", "question_id": 1778}, {"snippet": "def file_hash(load, fnd): DCNL  DCSP if ('env' in load): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', \"Parameter DCSP 'env' DCSP has DCSP been DCSP detected DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP used DCSP and DCSP has DCSP been DCSP replaced DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removed DCSP in DCSP Salt DCSP Oxygen.\") DCNL DCSP  DCSP load.pop('env') DCNL DCSP ret = {} DCNL DCSP if ('saltenv' not in load): DCNL DCSP  DCSP return ret DCNL DCSP if (('path' not in fnd) or ('bucket' not in fnd) or (not fnd['path'])): DCNL DCSP  DCSP return ret DCNL DCSP cached_file_path = _get_cached_file_name(fnd['bucket'], load['saltenv'], fnd['path']) DCNL DCSP if os.path.isfile(cached_file_path): DCNL DCSP  DCSP ret['hsum'] = salt.utils.get_hash(cached_file_path) DCNL DCSP  DCSP ret['hash_type'] = 'md5' DCNL DCSP return ret\n", "intent": "return an md5 file hash .\n", "question_id": 1779}, {"snippet": "def toposort_flatten(data, sort=True): DCNL  DCSP result = [] DCNL DCSP for d in toposort(data): DCNL DCSP  DCSP result.extend((sorted if sort else list)(d)) DCNL DCSP return result\n", "intent": "returns a single list of dependencies .\n", "question_id": 1780}, {"snippet": "def to_tree(Z, rd=False): DCNL  DCSP Z = np.asarray(Z, order='c') DCNL DCSP is_valid_linkage(Z, throw=True, name='Z') DCNL DCSP n = (Z.shape[0] + 1) DCNL DCSP d = ([None] * ((n * 2) - 1)) DCNL DCSP for i in xrange(0, n): DCNL DCSP  DCSP d[i] = ClusterNode(i) DCNL DCSP nd = None DCNL DCSP for i in xrange(0, (n - 1)): DCNL DCSP  DCSP fi = int(Z[(i, 0)]) DCNL DCSP  DCSP fj = int(Z[(i, 1)]) DCNL DCSP  DCSP if (fi > (i + n)): DCNL DCSP  DCSP  DCSP raise ValueError(('Corrupt DCSP matrix DCSP Z. DCSP Index DCSP to DCSP derivative DCSP cluster DCSP is DCSP used DCSP before DCSP it DCSP is DCSP formed. DCSP See DCSP row DCSP %d, DCSP column DCSP 0' % fi)) DCNL DCSP  DCSP if (fj > (i + n)): DCNL DCSP  DCSP  DCSP raise ValueError(('Corrupt DCSP matrix DCSP Z. DCSP Index DCSP to DCSP derivative DCSP cluster DCSP is DCSP used DCSP before DCSP it DCSP is DCSP formed. DCSP See DCSP row DCSP %d, DCSP column DCSP 1' % fj)) DCNL DCSP  DCSP nd = ClusterNode((i + n), d[fi], d[fj], Z[(i, 2)]) DCNL DCSP  DCSP if (Z[(i, 3)] != nd.count): DCNL DCSP  DCSP  DCSP raise ValueError(('Corrupt DCSP matrix DCSP Z. DCSP The DCSP count DCSP Z[%d,3] DCSP is DCSP incorrect.' % i)) DCNL DCSP  DCSP d[(n + i)] = nd DCNL DCSP if rd: DCNL DCSP  DCSP return (nd, d) DCNL DCSP else: DCNL DCSP  DCSP return nd\n", "intent": "converts a linkage matrix into an easy-to-use tree object .\n", "question_id": 1781}, {"snippet": "def xrdf(request, template_name='authopenid/yadis.xrdf'): DCNL  DCSP url_host = get_url_host(request) DCNL DCSP return_to = [('%s%s' % (url_host, reverse('user_complete_signin')))] DCNL DCSP response = render(template_name, {'return_to': return_to}, context_instance=RequestContext(request)) DCNL DCSP response['Content-Type'] = 'application/xrds+xml' DCNL DCSP response['X-XRDS-Location'] = request.build_absolute_uri(reverse('oid_xrdf')) DCNL DCSP return response\n", "intent": "view used to process the xrdf file .\n", "question_id": 1782}, {"snippet": "def version(): DCNL  DCSP k = 'lxc.version' DCNL DCSP if (not __context__.get(k, None)): DCNL DCSP  DCSP cversion = __salt__['cmd.run_all']('lxc-info DCSP --version') DCNL DCSP  DCSP if (not cversion['retcode']): DCNL DCSP  DCSP  DCSP ver = distutils.version.LooseVersion(cversion['stdout']) DCNL DCSP  DCSP  DCSP if (ver < distutils.version.LooseVersion('1.0')): DCNL DCSP  DCSP  DCSP  DCSP raise CommandExecutionError('LXC DCSP should DCSP be DCSP at DCSP least DCSP 1.0') DCNL DCSP  DCSP  DCSP __context__[k] = '{0}'.format(ver) DCNL DCSP return __context__.get(k, None)\n", "intent": "return the actual lxc client version .\n", "question_id": 1783}, {"snippet": "def get_datetime_format(format='medium', locale=LC_TIME): DCNL  DCSP patterns = Locale.parse(locale).datetime_formats DCNL DCSP if (format not in patterns): DCNL DCSP  DCSP format = None DCNL DCSP return patterns[format]\n", "intent": "return the datetime formatting patterns used by the locale for the specified format .\n", "question_id": 1784}, {"snippet": "def django_find_root_dir(): DCNL  DCSP from ...config import CONF DCNL DCSP manage_py = CONF['main_script'] DCNL DCSP manage_dir = os.path.dirname(os.path.abspath(manage_py)) DCNL DCSP settings_dir = None DCNL DCSP files = set(os.listdir(manage_dir)) DCNL DCSP if ((('settings.py' in files) or ('settings' in files)) and ('urls.py' in files)): DCNL DCSP  DCSP settings_dir = manage_dir DCNL DCSP else: DCNL DCSP  DCSP for f in files: DCNL DCSP  DCSP  DCSP if os.path.isdir(os.path.join(manage_dir, f)): DCNL DCSP  DCSP  DCSP  DCSP subfiles = os.listdir(os.path.join(manage_dir, f)) DCNL DCSP  DCSP  DCSP  DCSP if ((('settings.py' in subfiles) or ('settings' in subfiles)) and ('urls.py' in subfiles)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP settings_dir = os.path.join(manage_dir, f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return settings_dir\n", "intent": "return path to directory  that contains main django files .\n", "question_id": 1785}, {"snippet": "def rm_rf(name): DCNL  DCSP if (not os.path.exists(name)): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP shutil.rmtree(name) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOTDIR): DCNL DCSP  DCSP  DCSP safe_delete(name) DCNL DCSP  DCSP elif (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP raise\n", "intent": "remove a file or a directory similarly to running rm -rf <name> in a unix shell .\n", "question_id": 1786}, {"snippet": "def make_default_short_help(help, max_length=45): DCNL  DCSP words = help.split() DCNL DCSP total_length = 0 DCNL DCSP result = [] DCNL DCSP done = False DCNL DCSP for word in words: DCNL DCSP  DCSP if (word[(-1):] == '.'): DCNL DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP new_length = ((result and (1 + len(word))) or len(word)) DCNL DCSP  DCSP if ((total_length + new_length) > max_length): DCNL DCSP  DCSP  DCSP result.append('...') DCNL DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP  DCSP result.append(' DCSP ') DCNL DCSP  DCSP  DCSP result.append(word) DCNL DCSP  DCSP if done: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP total_length += new_length DCNL DCSP return ''.join(result)\n", "intent": "return a condensed version of help string .\n", "question_id": 1787}, {"snippet": "def rss_qstatus(): DCNL  DCSP qnfo = NzbQueue.do.queue_info() DCNL DCSP pnfo_list = qnfo.list DCNL DCSP rss = RSS() DCNL DCSP rss.channel.title = 'SABnzbd DCSP Queue' DCNL DCSP rss.channel.description = 'Overview DCSP of DCSP current DCSP downloads' DCNL DCSP rss.channel.link = ('http://%s:%s/sabnzbd/queue' % (cfg.cherryhost(), cfg.cherryport())) DCNL DCSP rss.channel.language = 'en' DCNL DCSP item = Item() DCNL DCSP item.title = ('Total DCSP ETA: DCSP %s DCSP - DCSP Queued: DCSP %.2f DCSP MB DCSP - DCSP Speed: DCSP %.2f DCSP kB/s' % (calc_timeleft(qnfo.bytes_left, BPSMeter.do.get_bps()), (qnfo.bytes_left / MEBI), (BPSMeter.do.get_bps() / KIBI))) DCNL DCSP rss.addItem(item) DCNL DCSP sum_bytesleft = 0 DCNL DCSP for pnfo in pnfo_list: DCNL DCSP  DCSP filename = pnfo.filename DCNL DCSP  DCSP bytesleft = (pnfo.bytes_left / MEBI) DCNL DCSP  DCSP bytes = (pnfo.bytes / MEBI) DCNL DCSP  DCSP mbleft = (bytesleft / MEBI) DCNL DCSP  DCSP mb = (bytes / MEBI) DCNL DCSP  DCSP nzo_id = pnfo.nzo_id DCNL DCSP  DCSP if (mb == mbleft): DCNL DCSP  DCSP  DCSP percentage = '0%' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP percentage = ('%s%%' % int((((mb - mbleft) / mb) * 100))) DCNL DCSP  DCSP filename = xml_name(filename) DCNL DCSP  DCSP name = (u'%s DCSP (%s)' % (filename, percentage)) DCNL DCSP  DCSP item = Item() DCNL DCSP  DCSP item.title = name DCNL DCSP  DCSP item.link = ('http://%s:%s/sabnzbd/history' % (cfg.cherryhost(), cfg.cherryport())) DCNL DCSP  DCSP item.guid = nzo_id DCNL DCSP  DCSP status_line = [] DCNL DCSP  DCSP status_line.append('<tr>') DCNL DCSP  DCSP status_line.append(('<dt>Remain/Total: DCSP %.2f/%.2f DCSP MB</dt>' % (bytesleft, bytes))) DCNL DCSP  DCSP sum_bytesleft += pnfo.bytes_left DCNL DCSP  DCSP status_line.append(('<dt>ETA: DCSP %s DCSP </dt>' % calc_timeleft(sum_bytesleft, BPSMeter.do.get_bps()))) DCNL DCSP  DCSP status_line.append(('<dt>Age: DCSP %s</dt>' % calc_age(pnfo.avg_date))) DCNL DCSP  DCSP status_line.append('</tr>') DCNL DCSP  DCSP item.description = ''.join(status_line) DCNL DCSP  DCSP rss.addItem(item) DCNL DCSP rss.channel.lastBuildDate = std_time(time.time()) DCNL DCSP rss.channel.pubDate = rss.channel.lastBuildDate DCNL DCSP rss.channel.ttl = '1' DCNL DCSP return rss.write()\n", "intent": "return a rss feed with the queue status .\n", "question_id": 1788}, {"snippet": "def default_settings(params): DCNL  DCSP def _default_settings(fn, command): DCNL DCSP  DCSP for (k, w) in params.items(): DCNL DCSP  DCSP  DCSP settings.setdefault(k, w) DCNL DCSP  DCSP return fn(command) DCNL DCSP return decorator(_default_settings)\n", "intent": "adds default values to settings if it not presented .\n", "question_id": 1789}, {"snippet": "def logout_user(): DCNL  DCSP user = _get_user() DCNL DCSP if ('user_id' in session): DCNL DCSP  DCSP session.pop('user_id') DCNL DCSP if ('_fresh' in session): DCNL DCSP  DCSP session.pop('_fresh') DCNL DCSP cookie_name = current_app.config.get('REMEMBER_COOKIE_NAME', COOKIE_NAME) DCNL DCSP if (cookie_name in request.cookies): DCNL DCSP  DCSP session['remember'] = 'clear' DCNL DCSP user_logged_out.send(current_app._get_current_object(), user=user) DCNL DCSP current_app.login_manager.reload_user() DCNL DCSP return True\n", "intent": "logs a user out .\n", "question_id": 1790}, {"snippet": "def register(mgr): DCNL  DCSP mgr.set_lang_info(lang, silvercity_lexer=NodeJSLexer(mgr), buf_class=NodeJSBuffer, langintel_class=NodeJSLangIntel, import_handler_class=NodeJSImportHandler, cile_driver_class=NodeJSCILEDriver, is_cpln_lang=True)\n", "intent": "register language support with the manager .\n", "question_id": 1791}, {"snippet": "def getVector3Paths(complexPaths, z=0.0): DCNL  DCSP vector3Paths = [] DCNL DCSP for complexPath in complexPaths: DCNL DCSP  DCSP vector3Paths.append(getVector3Path(complexPath, z)) DCNL DCSP return vector3Paths\n", "intent": "get the vector3 paths from the complex paths .\n", "question_id": 1792}, {"snippet": "def push(): DCNL  DCSP return run(Push)\n", "intent": "push to remote repositories .\n", "question_id": 1793}, {"snippet": "def findCertainShow(showList, indexerid): DCNL  DCSP if ((indexerid is None) or (showList is None) or (len(showList) == 0)): DCNL DCSP  DCSP return None DCNL DCSP indexer_ids = ([indexerid] if (not isinstance(indexerid, list)) else indexerid) DCNL DCSP results = [show for show in showList if (show.indexerid in indexer_ids)] DCNL DCSP if (not results): DCNL DCSP  DCSP return None DCNL DCSP if (len(results) == 1): DCNL DCSP  DCSP return results[0] DCNL DCSP raise MultipleShowObjectsException()\n", "intent": "find a show by indexer id in the show list .\n", "question_id": 1794}, {"snippet": "def validate_permissions_for_doctype(doctype, for_remove=False): DCNL  DCSP doctype = frappe.get_doc(u'DocType', doctype) DCNL DCSP if (frappe.conf.developer_mode and (not frappe.flags.in_test)): DCNL DCSP  DCSP doctype.save() DCNL DCSP else: DCNL DCSP  DCSP validate_permissions(doctype, for_remove) DCNL DCSP  DCSP for perm in doctype.get(u'permissions'): DCNL DCSP  DCSP  DCSP perm.db_update()\n", "intent": "validates if permissions are set correctly .\n", "question_id": 1795}, {"snippet": "def iterhosts(resources): DCNL  DCSP for (module_name, key, resource) in resources: DCNL DCSP  DCSP (resource_type, name) = key.split(u'.', 1) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP parser = PARSERS[resource_type] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yield parser(resource, module_name))\n", "intent": "yield host tuples of .\n", "question_id": 1796}, {"snippet": "@frappe.whitelist() DCNL def get_incoming_rate(args): DCNL  DCSP from erpnext.stock.stock_ledger import get_previous_sle DCNL DCSP if isinstance(args, basestring): DCNL DCSP  DCSP args = json.loads(args) DCNL DCSP in_rate = 0 DCNL DCSP if (args.get(u'serial_no') or u'').strip(): DCNL DCSP  DCSP in_rate = get_avg_purchase_rate(args.get(u'serial_no')) DCNL DCSP else: DCNL DCSP  DCSP valuation_method = get_valuation_method(args.get(u'item_code')) DCNL DCSP  DCSP previous_sle = get_previous_sle(args) DCNL DCSP  DCSP if (valuation_method == u'FIFO'): DCNL DCSP  DCSP  DCSP if (not previous_sle): DCNL DCSP  DCSP  DCSP  DCSP return 0.0 DCNL DCSP  DCSP  DCSP previous_stock_queue = json.loads((previous_sle.get(u'stock_queue', u'[]') or u'[]')) DCNL DCSP  DCSP  DCSP in_rate = (get_fifo_rate(previous_stock_queue, (args.get(u'qty') or 0)) if previous_stock_queue else 0) DCNL DCSP  DCSP elif (valuation_method == u'Moving DCSP Average'): DCNL DCSP  DCSP  DCSP in_rate = (previous_sle.get(u'valuation_rate') or 0) DCNL DCSP return in_rate\n", "intent": "get incoming rate based on valuation method .\n", "question_id": 1797}, {"snippet": "def _responseFromMessage(responseConstructor, message, **kwargs): DCNL  DCSP response = responseConstructor(id=message.id, answer=True, **kwargs) DCNL DCSP response.queries = message.queries[:] DCNL DCSP return response\n", "intent": "generate a l{message} like instance suitable for use as the response to c{message} .\n", "question_id": 1798}, {"snippet": "def _init_non_posix(vars): DCNL  DCSP vars['LIBDEST'] = get_path('stdlib') DCNL DCSP vars['BINLIBDEST'] = get_path('platstdlib') DCNL DCSP vars['INCLUDEPY'] = get_path('include') DCNL DCSP vars['SO'] = '.pyd' DCNL DCSP vars['EXE'] = '.exe' DCNL DCSP vars['VERSION'] = _PY_VERSION_SHORT_NO_DOT DCNL DCSP vars['BINDIR'] = os.path.dirname(_safe_realpath(sys.executable))\n", "intent": "initialize the module as appropriate for nt .\n", "question_id": 1799}, {"snippet": "@public DCNL def p(prop, default=None, bindtypes=[], type=unicode, public=True, doc=None): DCNL  DCSP def decorator(cls): DCNL DCSP  DCSP prop_obj = UIProperty(prop, default=default, bindtypes=bindtypes, type=type, public=public) DCNL DCSP  DCSP if (not hasattr(cls, '_properties')): DCNL DCSP  DCSP  DCSP cls._properties = {} DCNL DCSP  DCSP cls._properties = cls._properties.copy() DCNL DCSP  DCSP cls._properties[prop] = prop_obj DCNL DCSP  DCSP def get(self): DCNL DCSP  DCSP  DCSP return self.properties[prop] DCNL DCSP  DCSP def set(self, value): DCNL DCSP  DCSP  DCSP self.properties_dirty[prop] |= (self.properties[prop] != value) DCNL DCSP  DCSP  DCSP self.properties[prop] = value DCNL DCSP  DCSP _property = property(get, set, None, doc) DCNL DCSP  DCSP if (not hasattr(cls, prop)): DCNL DCSP  DCSP  DCSP setattr(cls, prop, _property) DCNL DCSP  DCSP return cls DCNL DCSP return decorator\n", "intent": "creates an ui property inside an :class:uielement:: @p @p @p class sectionplugin : typeid = main:section .\n", "question_id": 1800}, {"snippet": "def get_signature(signature_data): DCNL  DCSP try: DCNL DCSP  DCSP signature = base64.decode_as_bytes(signature_data) DCNL DCSP except (TypeError, binascii.Error): DCNL DCSP  DCSP raise exception.SignatureVerificationError(reason=_('The DCSP signature DCSP data DCSP was DCSP not DCSP properly DCSP encoded DCSP using DCSP base64')) DCNL DCSP return signature\n", "intent": "decode the signature data and returns the signature .\n", "question_id": 1801}, {"snippet": "def install_ruby(ruby, runas=None): DCNL  DCSP if (runas and (runas != 'root')): DCNL DCSP  DCSP _rvm(['autolibs', 'disable', ruby], runas=runas) DCNL DCSP  DCSP return _rvm(['install', '--disable-binary', ruby], runas=runas) DCNL DCSP else: DCNL DCSP  DCSP return _rvm(['install', ruby], runas=runas)\n", "intent": "install a ruby implementation .\n", "question_id": 1802}, {"snippet": "def skipgrams(sequence, vocabulary_size, window_size=4, negative_samples=1.0, shuffle=True, categorical=False, sampling_table=None): DCNL  DCSP couples = [] DCNL DCSP labels = [] DCNL DCSP for (i, wi) in enumerate(sequence): DCNL DCSP  DCSP if (not wi): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (sampling_table is not None): DCNL DCSP  DCSP  DCSP if (sampling_table[wi] < random.random()): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP window_start = max(0, (i - window_size)) DCNL DCSP  DCSP window_end = min(len(sequence), ((i + window_size) + 1)) DCNL DCSP  DCSP for j in range(window_start, window_end): DCNL DCSP  DCSP  DCSP if (j != i): DCNL DCSP  DCSP  DCSP  DCSP wj = sequence[j] DCNL DCSP  DCSP  DCSP  DCSP if (not wj): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP couples.append([wi, wj]) DCNL DCSP  DCSP  DCSP  DCSP if categorical: DCNL DCSP  DCSP  DCSP  DCSP  DCSP labels.append([0, 1]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP labels.append(1) DCNL DCSP if (negative_samples > 0): DCNL DCSP  DCSP nb_negative_samples = int((len(labels) * negative_samples)) DCNL DCSP  DCSP words = [c[0] for c in couples] DCNL DCSP  DCSP random.shuffle(words) DCNL DCSP  DCSP couples += [[words[(i % len(words))], random.randint(1, (vocabulary_size - 1))] for i in range(nb_negative_samples)] DCNL DCSP  DCSP if categorical: DCNL DCSP  DCSP  DCSP labels += ([[1, 0]] * nb_negative_samples) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP labels += ([0] * nb_negative_samples) DCNL DCSP if shuffle: DCNL DCSP  DCSP seed = random.randint(0, 10000000.0) DCNL DCSP  DCSP random.seed(seed) DCNL DCSP  DCSP random.shuffle(couples) DCNL DCSP  DCSP random.seed(seed) DCNL DCSP  DCSP random.shuffle(labels) DCNL DCSP return (couples, labels)\n", "intent": "generates skipgram word pairs .\n", "question_id": 1803}, {"snippet": "def patientLoop(logger, maxWaitExponent, finalErrorString, acceptableError, acceptErrorString, callable, argumentList, email=False, noReturn=False): DCNL  DCSP exponent = 0 DCNL DCSP lastErrorTime = datetime(1970, 1, 1) DCNL DCSP while True: DCNL DCSP  DCSP if (exponent > maxWaitExponent): DCNL DCSP  DCSP  DCSP logger.error(finalErrorString) DCNL DCSP  DCSP  DCSP if email: DCNL DCSP  DCSP  DCSP  DCSP msg = MIMEText(logger.name) DCNL DCSP  DCSP  DCSP  DCSP msg['Subject'] = ('URGENT DCSP - DCSP %s' % finalErrorString) DCNL DCSP  DCSP  DCSP  DCSP me = 'patientloop@numenta.com' DCNL DCSP  DCSP  DCSP  DCSP you = email DCNL DCSP  DCSP  DCSP  DCSP msg['From'] = me DCNL DCSP  DCSP  DCSP  DCSP msg['To'] = you DCNL DCSP  DCSP  DCSP  DCSP s = smtplib.SMTP('localhost') DCNL DCSP  DCSP  DCSP  DCSP s.sendmail(me, [you], msg.as_string()) DCNL DCSP  DCSP  DCSP  DCSP s.quit() DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP timeout = (2 ** exponent) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if noReturn: DCNL DCSP  DCSP  DCSP  DCSP callable(*argumentList) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rv = callable(*argumentList) DCNL DCSP  DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP except acceptableError: DCNL DCSP  DCSP  DCSP logger.warn(acceptErrorString) DCNL DCSP  DCSP  DCSP errorTime = datetime.utcnow() DCNL DCSP  DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP the DCSP time DCSP between DCSP this DCSP error DCSP and DCSP the DCSP last DCSP one DCSP is DCSP larger DCSP than DCSP the DCSP max\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time DCSP we DCSP are DCSP willing DCSP to DCSP time DCSP out, DCSP then DCSP we DCSP know DCSP there DCSP was DCSP a DCSP re-connection\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in DCSP between DCSP the DCSP errors. DCSP Reset DCSP our DCSP counter\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP if ((errorTime - lastErrorTime) > timedelta(seconds=(2 ** maxWaitExponent))): DCNL DCSP  DCSP  DCSP  DCSP exponent = 0 DCNL DCSP  DCSP  DCSP logger.info(('Sleeping DCSP for DCSP %d DCSP seconds DCSP before DCSP attempting DCSP again DCSP ...' % timeout)) DCNL DCSP  DCSP  DCSP time.sleep(timeout) DCNL DCSP  DCSP  DCSP lastErrorTime = errorTime DCNL DCSP  DCSP  DCSP exponent += 1\n", "intent": "logger                logging object maxwaitexponent       2 ** maxwaitexponent defines max wait time finalerrorstring      msg to log if wait time expires acceptableerror       the expected error for the loop accepterrorstring     msg to log when expected error is encountered callable              the method/function to attempt in the loop arguments             arguments to the method/function email                 an address to send a failure message to .\n", "question_id": 1804}, {"snippet": "@cronjobs.register DCNL def dump_user_installs_cron(): DCNL  DCSP chunk_size = 100 DCNL DCSP user_ids = set(Installed.objects.filter(user__enable_recommendations=True).values_list('user', flat=True)) DCNL DCSP path_to_cleanup = os.path.join(settings.DUMPED_USERS_PATH, 'users') DCNL DCSP task_log.info('Cleaning DCSP up DCSP path DCSP {0}'.format(path_to_cleanup)) DCNL DCSP try: DCNL DCSP  DCSP for (dirpath, dirnames, filenames) in walk_storage(path_to_cleanup, storage=private_storage): DCNL DCSP  DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP  DCSP private_storage.delete(os.path.join(dirpath, filename)) DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP grouping = [] DCNL DCSP for chunk in chunked(user_ids, chunk_size): DCNL DCSP  DCSP grouping.append(dump_user_installs.subtask(args=[chunk])) DCNL DCSP post = zip_users.subtask(immutable=True) DCNL DCSP ts = chord(grouping, post) DCNL DCSP ts.apply_async()\n", "intent": "sets up tasks to do user install dumps .\n", "question_id": 1805}, {"snippet": "def check_version(version): DCNL  DCSP supported = ('\\x00', '\\x00', '\\x00', '\\x01') DCNL DCSP i = 0 DCNL DCSP for item in version: DCNL DCSP  DCSP if (version[i] != supported[i]): DCNL DCSP  DCSP  DCSP raise RuntimeError('SFF DCSP version DCSP not DCSP supported. DCSP Please DCSP contact DCSP the DCSP author DCSP of DCSP the DCSP software.') DCNL DCSP  DCSP i += 1\n", "intent": "it checks that the version is supported .\n", "question_id": 1806}, {"snippet": "def find_lemmata(tokens): DCNL  DCSP for token in tokens: DCNL DCSP  DCSP (word, pos, lemma) = (token[0], token[1], token[0]) DCNL DCSP  DCSP if (pos == 'NNS'): DCNL DCSP  DCSP  DCSP lemma = singularize(word) DCNL DCSP  DCSP if pos.startswith(('VB', 'MD')): DCNL DCSP  DCSP  DCSP lemma = (conjugate(word, INFINITIVE) or word) DCNL DCSP  DCSP token.append(lemma.lower()) DCNL DCSP return tokens\n", "intent": "annotates the tokens with lemmata for plural nouns and conjugated verbs .\n", "question_id": 1807}, {"snippet": "def setup_scanner(hass, config, see): DCNL  DCSP def offset(): DCNL DCSP  DCSP 'Return DCSP random DCSP offset.' DCNL DCSP  DCSP return ((random.randrange(500, 2000) / 200000.0) * random.choice(((-1), 1))) DCNL DCSP def random_see(dev_id, name): DCNL DCSP  DCSP 'Randomize DCSP a DCSP sighting.' DCNL DCSP  DCSP see(dev_id=dev_id, host_name=name, gps=((hass.config.latitude + offset()), (hass.config.longitude + offset())), gps_accuracy=random.randrange(50, 150), battery=random.randrange(10, 90)) DCNL DCSP def observe(call=None): DCNL DCSP  DCSP 'Observe DCSP three DCSP entities.' DCNL DCSP  DCSP random_see('demo_paulus', 'Paulus') DCNL DCSP  DCSP random_see('demo_anne_therese', 'Anne DCSP Therese') DCNL DCSP observe() DCNL DCSP see(dev_id='demo_home_boy', host_name='Home DCSP Boy', gps=[(hass.config.latitude - 2e-05), (hass.config.longitude + 2e-05)], gps_accuracy=20, battery=53) DCNL DCSP hass.services.register(DOMAIN, 'demo', observe) DCNL DCSP return True\n", "intent": "setup the demo tracker .\n", "question_id": 1808}, {"snippet": "def rebuild(filename, tag=None, format='gz', zonegroups=[], metadata=None): DCNL  DCSP tmpdir = tempfile.mkdtemp() DCNL DCSP zonedir = os.path.join(tmpdir, 'zoneinfo') DCNL DCSP moduledir = os.path.dirname(__file__) DCNL DCSP try: DCNL DCSP  DCSP with tar_open(filename) as tf: DCNL DCSP  DCSP  DCSP for name in zonegroups: DCNL DCSP  DCSP  DCSP  DCSP tf.extract(name, tmpdir) DCNL DCSP  DCSP  DCSP filepaths = [os.path.join(tmpdir, n) for n in zonegroups] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP check_call((['zic', '-d', zonedir] + filepaths)) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP _print_on_nosuchfile(e) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP with open(os.path.join(zonedir, METADATA_FN), 'w') as f: DCNL DCSP  DCSP  DCSP json.dump(metadata, f, indent=4, sort_keys=True) DCNL DCSP  DCSP target = os.path.join(moduledir, ZONEFILENAME) DCNL DCSP  DCSP with tar_open(target, ('w:%s' % format)) as tf: DCNL DCSP  DCSP  DCSP for entry in os.listdir(zonedir): DCNL DCSP  DCSP  DCSP  DCSP entrypath = os.path.join(zonedir, entry) DCNL DCSP  DCSP  DCSP  DCSP tf.add(entrypath, entry) DCNL DCSP finally: DCNL DCSP  DCSP shutil.rmtree(tmpdir)\n", "intent": "rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar* filename is the timezone tarball from ftp .\n", "question_id": 1809}, {"snippet": "def get_block_edges(source_file): DCNL  DCSP block_edges = [] DCNL DCSP with open(source_file) as f: DCNL DCSP  DCSP token_iter = tokenize.generate_tokens(f.readline) DCNL DCSP  DCSP for token_tuple in token_iter: DCNL DCSP  DCSP  DCSP (t_id, t_str, (srow, scol), (erow, ecol), src_line) = token_tuple DCNL DCSP  DCSP  DCSP if ((token.tok_name[t_id] == 'STRING') and (scol == 0)): DCNL DCSP  DCSP  DCSP  DCSP block_edges.extend((srow, (erow + 1))) DCNL DCSP idx_first_text_block = 0 DCNL DCSP if (not (block_edges[0] == 1)): DCNL DCSP  DCSP block_edges.insert(0, 1) DCNL DCSP  DCSP idx_first_text_block = 1 DCNL DCSP if (not (block_edges[(-1)] == erow)): DCNL DCSP  DCSP block_edges.append(erow) DCNL DCSP return (block_edges, idx_first_text_block)\n", "intent": "return starting line numbers of code and text blocks returns block_edges : list of int line number for the start of each block .\n", "question_id": 1810}, {"snippet": "def rotate_r(L, k): DCNL  DCSP ll = list(L) DCNL DCSP if (ll == []): DCNL DCSP  DCSP return [] DCNL DCSP for i in range(k): DCNL DCSP  DCSP el = ll.pop((len(ll) - 1)) DCNL DCSP  DCSP ll.insert(0, el) DCNL DCSP return (ll if (type(L) is list) else Matrix([ll]))\n", "intent": "rotates right by k .\n", "question_id": 1811}, {"snippet": "def _django_setup(): DCNL  DCSP if (os.environ.get('APPENGINE_RUNTIME') != 'python27'): DCNL DCSP  DCSP __django_version_setup() DCNL DCSP import django DCNL DCSP import django.conf DCNL DCSP try: DCNL DCSP  DCSP raise ImportError DCNL DCSP except (ImportError, EnvironmentError) as e: DCNL DCSP  DCSP if os.getenv(django.conf.ENVIRONMENT_VARIABLE): DCNL DCSP  DCSP  DCSP logging.warning(e) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP django.conf.settings.configure(DEBUG=False, TEMPLATE_DEBUG=False, TEMPLATE_LOADERS=('django.template.loaders.filesystem.load_template_source',)) DCNL DCSP  DCSP except (EnvironmentError, RuntimeError): DCNL DCSP  DCSP  DCSP pass\n", "intent": "imports and configures django .\n", "question_id": 1812}, {"snippet": "@cache_control(no_cache=True, no_store=True, must_revalidate=True) DCNL @require_global_staff DCNL @require_POST DCNL def generate_bulk_certificate_exceptions(request, course_id): DCNL  DCSP user_index = 0 DCNL DCSP notes_index = 1 DCNL DCSP row_errors_key = ['data_format_error', 'user_not_exist', 'user_already_white_listed', 'user_not_enrolled'] DCNL DCSP course_key = CourseKey.from_string(course_id) DCNL DCSP (students, general_errors, success) = ([], [], []) DCNL DCSP row_errors = {key: [] for key in row_errors_key} DCNL DCSP def build_row_errors(key, _user, row_count): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inner DCSP method DCSP to DCSP build DCSP dict DCSP of DCSP csv DCSP data DCSP as DCSP row DCSP errors.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP row_errors[key].append(_('user DCSP \"{user}\" DCSP in DCSP row# DCSP {row}').format(user=_user, row=row_count)) DCNL DCSP if ('students_list' in request.FILES): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP upload_file = request.FILES.get('students_list') DCNL DCSP  DCSP  DCSP if upload_file.name.endswith('.csv'): DCNL DCSP  DCSP  DCSP  DCSP students = [row for row in csv.reader(upload_file.read().splitlines())] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP general_errors.append(_('Make DCSP sure DCSP that DCSP the DCSP file DCSP you DCSP upload DCSP is DCSP in DCSP CSV DCSP format DCSP with DCSP no DCSP extraneous DCSP characters DCSP or DCSP rows.')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP general_errors.append(_('Could DCSP not DCSP read DCSP uploaded DCSP file.')) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP upload_file.close() DCNL DCSP  DCSP row_num = 0 DCNL DCSP  DCSP for student in students: DCNL DCSP  DCSP  DCSP row_num += 1 DCNL DCSP  DCSP  DCSP if (len(student) != 2): DCNL DCSP  DCSP  DCSP  DCSP if (len(student) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP build_row_errors('data_format_error', student[user_index], row_num) DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.info(u'invalid DCSP data/format DCSP in DCSP csv DCSP row# DCSP %s', row_num) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP user = student[user_index] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP user = get_user_by_username_or_email(user) DCNL DCSP  DCSP  DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP build_row_errors('user_not_exist', user, row_num) DCNL DCSP  DCSP  DCSP  DCSP log.info(u'student DCSP %s DCSP does DCSP not DCSP exist', user) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (len(CertificateWhitelist.get_certificate_white_list(course_key, user)) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP build_row_errors('user_already_white_listed', user, row_num) DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning(u'student DCSP %s DCSP already DCSP exist.', user.username) DCNL DCSP  DCSP  DCSP  DCSP elif (not CourseEnrollment.is_enrolled(user, course_key)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP build_row_errors('user_not_enrolled', user, row_num) DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning(u'student DCSP %s DCSP is DCSP not DCSP enrolled DCSP in DCSP course.', user.username) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP CertificateWhitelist.objects.create(user=user, course_id=course_key, whitelist=True, notes=student[notes_index]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP success.append(_('user DCSP \"{username}\" DCSP in DCSP row# DCSP {row}').format(username=user.username, row=row_num)) DCNL DCSP else: DCNL DCSP  DCSP general_errors.append(_('File DCSP is DCSP not DCSP attached.')) DCNL DCSP results = {'general_errors': general_errors, 'row_errors': row_errors, 'success': success} DCNL DCSP return JsonResponse(results)\n", "intent": "add students to certificate white list from the uploaded csv file .\n", "question_id": 1813}, {"snippet": "def list_targets(Rule, region=None, key=None, keyid=None, profile=None): DCNL  DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP targets = conn.list_targets_by_rule(Rule=Rule) DCNL DCSP  DCSP ret = [] DCNL DCSP  DCSP if (targets and ('Targets' in targets)): DCNL DCSP  DCSP  DCSP keys = ('Id', 'Arn', 'Input', 'InputPath') DCNL DCSP  DCSP  DCSP for target in targets.get('Targets'): DCNL DCSP  DCSP  DCSP  DCSP ret.append(dict([(k, target.get(k)) for k in keys if (k in target)])) DCNL DCSP  DCSP  DCSP return {'targets': ret} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'targets': None} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP err = __utils__['boto3.get_error'](e) DCNL DCSP  DCSP if (e.response.get('Error', {}).get('Code') == 'RuleNotFoundException'): DCNL DCSP  DCSP  DCSP return {'error': 'Rule DCSP {0} DCSP not DCSP found'.format(Rule)} DCNL DCSP  DCSP return {'error': __utils__['boto3.get_error'](e)}\n", "intent": "given a rule name list the targets of that rule .\n", "question_id": 1814}, {"snippet": "def s_word(value, endian='<', format='binary', signed=False, full_range=False, fuzzable=True, name=None): DCNL  DCSP word = primitives.word(value, endian, format, signed, full_range, fuzzable, name) DCNL DCSP blocks.CURRENT.push(word)\n", "intent": "push a word onto the current block stack .\n", "question_id": 1815}, {"snippet": "def info(name): DCNL  DCSP try: DCNL DCSP  DCSP data = pwd.getpwnam(name) DCNL DCSP  DCSP return {'name': data.pw_name, 'passwd': data.pw_passwd, 'account_created': get_account_created(name), 'login_failed_count': get_login_failed_count(name), 'login_failed_last': get_login_failed_last(name), 'lstchg': get_last_change(name), 'max': get_maxdays(name), 'expire': get_expire(name), 'change': get_change(name), 'min': 'Unavailable', 'warn': 'Unavailable', 'inact': 'Unavailable'} DCNL DCSP except KeyError: DCNL DCSP  DCSP log.debug('User DCSP not DCSP found: DCSP {0}'.format(name)) DCNL DCSP  DCSP return {'name': '', 'passwd': '', 'account_created': '', 'login_failed_count': '', 'login_failed_last': '', 'lstchg': '', 'max': '', 'expire': '', 'change': '', 'min': '', 'warn': '', 'inact': ''}\n", "intent": "return information for the specified user .\n", "question_id": 1816}, {"snippet": "def make_loop_careduce(loop_orders, dtypes, loop_tasks, sub): DCNL  DCSP def loop_over(preloop, code, indices, i): DCNL DCSP  DCSP iterv = ('ITER_%i' % i) DCNL DCSP  DCSP update = '' DCNL DCSP  DCSP suitable_n = '1' DCNL DCSP  DCSP for (j, index) in enumerate(indices): DCNL DCSP  DCSP  DCSP var = sub[('lv%i' % j)] DCNL DCSP  DCSP  DCSP update += ('%(var)s_iter DCSP += DCSP %(var)s_jump%(index)s_%(i)s;\\n' % locals()) DCNL DCSP  DCSP  DCSP if (index != 'x'): DCNL DCSP  DCSP  DCSP  DCSP suitable_n = ('%(var)s_n%(index)s' % locals()) DCNL DCSP  DCSP return ('\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(preloop)s\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP (int DCSP %(iterv)s DCSP = DCSP %(suitable_n)s; DCSP %(iterv)s; DCSP %(iterv)s--) DCSP {\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(code)s\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(update)s\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP preloops = {} DCNL DCSP for (i, (loop_order, dtype)) in enumerate(zip(loop_orders, dtypes)): DCNL DCSP  DCSP for (j, index) in enumerate(loop_order): DCNL DCSP  DCSP  DCSP if (index != 'x'): DCNL DCSP  DCSP  DCSP  DCSP preloops.setdefault(j, '') DCNL DCSP  DCSP  DCSP  DCSP preloops[j] += (('%%(lv%(i)s)s_iter DCSP = DCSP (%(dtype)s*)(PyArray_DATA(%%(lv%(i)s)s));\\n' % locals()) % sub) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP preloops.setdefault(0, '') DCNL DCSP  DCSP  DCSP preloops[0] += (('%%(lv%(i)s)s_iter DCSP = DCSP (%(dtype)s*)(PyArray_DATA(%%(lv%(i)s)s));\\n' % locals()) % sub) DCNL DCSP if (len(loop_tasks) == 1): DCNL DCSP  DCSP s = preloops.get(0, '') DCNL DCSP else: DCNL DCSP  DCSP s = '' DCNL DCSP  DCSP for (i, (pre_task, task), indices) in reversed(list(zip(xrange((len(loop_tasks) - 1)), loop_tasks, list(zip(*loop_orders))))): DCNL DCSP  DCSP  DCSP s = loop_over((preloops.get(i, '') + pre_task), (s + task), indices, i) DCNL DCSP s += loop_tasks[(-1)] DCNL DCSP return ('{%s}' % s)\n", "intent": "make a nested loop over several arrays and associate specific code to each level of nesting .\n", "question_id": 1817}, {"snippet": "def _list(x): DCNL  DCSP if (not isinstance(x, list)): DCNL DCSP  DCSP x = list(x) DCNL DCSP return x\n", "intent": "force x to a list .\n", "question_id": 1818}, {"snippet": "def educateDashesOldSchoolInverted(s): DCNL  DCSP return s.replace('---', '&#8211;').replace('--', '&#8212;')\n", "intent": "parameter:  string .\n", "question_id": 1819}, {"snippet": "def rand_name(name='', prefix=None): DCNL  DCSP randbits = str(random.randint(1, 2147483647)) DCNL DCSP rand_name = randbits DCNL DCSP if name: DCNL DCSP  DCSP rand_name = ((name + '-') + rand_name) DCNL DCSP if prefix: DCNL DCSP  DCSP rand_name = ((prefix + '-') + rand_name) DCNL DCSP return rand_name\n", "intent": "generate a random name that includes a random number .\n", "question_id": 1820}, {"snippet": "def _get_dataset_metadata(ldda): DCNL  DCSP lds = ldda.library_dataset DCNL DCSP folder_info = _get_folder_info(lds.folder) DCNL DCSP lds_info = lds.get_info() DCNL DCSP if (lds_info and (not lds_info.startswith('upload'))): DCNL DCSP  DCSP lds_info = lds_info.replace('no DCSP info', '') DCNL DCSP else: DCNL DCSP  DCSP lds_info = '' DCNL DCSP return ('%s DCSP %s DCSP %s DCSP %s DCSP %s' % ((lds.name or ''), lds_info, ldda.metadata.dbkey, ldda.message, folder_info))\n", "intent": "retrieve descriptions and information associated with a dataset .\n", "question_id": 1821}, {"snippet": "def AllowInstalledLibrary(name, desired): DCNL  DCSP CallSetAllowedModule(name, desired) DCNL DCSP dependencies = PACKAGES[name][1][desired] DCNL DCSP if dependencies: DCNL DCSP  DCSP for (dep_name, dep_version) in dependencies: DCNL DCSP  DCSP  DCSP AllowInstalledLibrary(dep_name, dep_version) DCNL DCSP installed[name] = (desired, False)\n", "intent": "allow the use of a package without performing a version check .\n", "question_id": 1822}, {"snippet": "def serverdir(): DCNL  DCSP path = join(ROOT_DIR, 'server') DCNL DCSP path = normpath(path) DCNL DCSP if (sys.platform == 'cygwin'): DCNL DCSP  DCSP path = realpath(path) DCNL DCSP return path\n", "intent": "get the location of the server subpackage .\n", "question_id": 1823}, {"snippet": "@click.command(u'mysql') DCNL @pass_context DCNL def mysql(context): DCNL  DCSP site = get_site(context) DCNL DCSP frappe.init(site=site) DCNL DCSP msq = find_executable(u'mysql') DCNL DCSP os.execv(msq, [msq, u'-u', frappe.conf.db_name, (u'-p' + frappe.conf.db_password), frappe.conf.db_name, u'-h', (frappe.conf.db_host or u'localhost'), u'-A'])\n", "intent": "start mariadb console for a site .\n", "question_id": 1824}, {"snippet": "def mysql_connect(sockfile): DCNL  DCSP (user, passwd) = mysqlconf.get_user_password(sockfile) DCNL DCSP return MySQLdb.connect(unix_socket=sockfile, connect_timeout=CONNECT_TIMEOUT, user=user, passwd=passwd)\n", "intent": "connects to the mysql server using the specified socket file .\n", "question_id": 1825}, {"snippet": "@receiver(dbsignals.post_save, sender=ExternalAccount, dispatch_uid='add_employee_vouch_sig') DCNL def add_employee_vouch(sender, instance, **kwargs): DCNL  DCSP if (kwargs.get('raw') or (not (instance.type == ExternalAccount.TYPE_EMAIL))): DCNL DCSP  DCSP return DCNL DCSP instance.user.auto_vouch()\n", "intent": "add a vouch if an alternate email address is a mozilla* address .\n", "question_id": 1826}, {"snippet": "def get_scene_seasons(indexer_id): DCNL  DCSP exceptionsSeasonList = [] DCNL DCSP if (indexer_id not in exceptionsSeasonCache): DCNL DCSP  DCSP dbData = [x[u'doc'] for x in sickrage.srCore.cacheDB.db.get_many(u'scene_exceptions', indexer_id, with_doc=True)] DCNL DCSP  DCSP exceptionsSeasonList = list(set([int(x[u'season']) for x in dbData])) DCNL DCSP  DCSP if (not (indexer_id in exceptionsSeasonCache)): DCNL DCSP  DCSP  DCSP exceptionsSeasonCache[indexer_id] = {} DCNL DCSP  DCSP exceptionsSeasonCache[indexer_id] = exceptionsSeasonList DCNL DCSP else: DCNL DCSP  DCSP exceptionsSeasonList = exceptionsSeasonCache[indexer_id] DCNL DCSP return exceptionsSeasonList\n", "intent": "return a list of season numbers that have scene exceptions .\n", "question_id": 1827}, {"snippet": "def nextfile(): DCNL  DCSP if (not _state): DCNL DCSP  DCSP raise RuntimeError('no DCSP active DCSP input()') DCNL DCSP return _state.nextfile()\n", "intent": "close the current file so that the next iteration will read the first line from the next file ; lines not read from the file will not count towards the cumulative line count .\n", "question_id": 1828}, {"snippet": "def start_stub(name): DCNL  DCSP service = SERVICES.get(name, None) DCNL DCSP if service: DCNL DCSP  DCSP fake_server = service['class'](port_num=service['port']) DCNL DCSP  DCSP setattr(world, name, fake_server)\n", "intent": "start the required stub service running on a local port .\n", "question_id": 1829}, {"snippet": "def remove_indents(txt): DCNL  DCSP txt = re.sub('(?miu)^\\\\s+', '', txt) DCNL DCSP return txt\n", "intent": "remove whitespace at the beginning of each line .\n", "question_id": 1830}, {"snippet": "def _decode_utf8(s): DCNL  DCSP return unicode(s, 'utf-8')\n", "intent": "decode from utf8 to python unicode string .\n", "question_id": 1831}, {"snippet": "def version_clean(verstr): DCNL  DCSP if (verstr and ('pkg.version_clean' in __salt__)): DCNL DCSP  DCSP return __salt__['pkg.version_clean'](verstr) DCNL DCSP return verstr\n", "intent": "clean the version string removing extra data .\n", "question_id": 1832}, {"snippet": "def transformer(U, theta, out_size, name='SpatialTransformer', **kwargs): DCNL  DCSP def _repeat(x, n_repeats): DCNL DCSP  DCSP with tf.variable_scope('_repeat'): DCNL DCSP  DCSP  DCSP rep = tf.transpose(tf.expand_dims(tf.ones(shape=tf.pack([n_repeats])), 1), [1, 0]) DCNL DCSP  DCSP  DCSP rep = tf.cast(rep, 'int32') DCNL DCSP  DCSP  DCSP x = tf.matmul(tf.reshape(x, ((-1), 1)), rep) DCNL DCSP  DCSP  DCSP return tf.reshape(x, [(-1)]) DCNL DCSP def _interpolate(im, x, y, out_size): DCNL DCSP  DCSP with tf.variable_scope('_interpolate'): DCNL DCSP  DCSP  DCSP num_batch = tf.shape(im)[0] DCNL DCSP  DCSP  DCSP height = tf.shape(im)[1] DCNL DCSP  DCSP  DCSP width = tf.shape(im)[2] DCNL DCSP  DCSP  DCSP channels = tf.shape(im)[3] DCNL DCSP  DCSP  DCSP x = tf.cast(x, 'float32') DCNL DCSP  DCSP  DCSP y = tf.cast(y, 'float32') DCNL DCSP  DCSP  DCSP height_f = tf.cast(height, 'float32') DCNL DCSP  DCSP  DCSP width_f = tf.cast(width, 'float32') DCNL DCSP  DCSP  DCSP out_height = out_size[0] DCNL DCSP  DCSP  DCSP out_width = out_size[1] DCNL DCSP  DCSP  DCSP zero = tf.zeros([], dtype='int32') DCNL DCSP  DCSP  DCSP max_y = tf.cast((tf.shape(im)[1] - 1), 'int32') DCNL DCSP  DCSP  DCSP max_x = tf.cast((tf.shape(im)[2] - 1), 'int32') DCNL DCSP  DCSP  DCSP x = (((x + 1.0) * width_f) / 2.0) DCNL DCSP  DCSP  DCSP y = (((y + 1.0) * height_f) / 2.0) DCNL DCSP  DCSP  DCSP x0 = tf.cast(tf.floor(x), 'int32') DCNL DCSP  DCSP  DCSP x1 = (x0 + 1) DCNL DCSP  DCSP  DCSP y0 = tf.cast(tf.floor(y), 'int32') DCNL DCSP  DCSP  DCSP y1 = (y0 + 1) DCNL DCSP  DCSP  DCSP x0 = tf.clip_by_value(x0, zero, max_x) DCNL DCSP  DCSP  DCSP x1 = tf.clip_by_value(x1, zero, max_x) DCNL DCSP  DCSP  DCSP y0 = tf.clip_by_value(y0, zero, max_y) DCNL DCSP  DCSP  DCSP y1 = tf.clip_by_value(y1, zero, max_y) DCNL DCSP  DCSP  DCSP dim2 = width DCNL DCSP  DCSP  DCSP dim1 = (width * height) DCNL DCSP  DCSP  DCSP base = _repeat((tf.range(num_batch) * dim1), (out_height * out_width)) DCNL DCSP  DCSP  DCSP base_y0 = (base + (y0 * dim2)) DCNL DCSP  DCSP  DCSP base_y1 = (base + (y1 * dim2)) DCNL DCSP  DCSP  DCSP idx_a = (base_y0 + x0) DCNL DCSP  DCSP  DCSP idx_b = (base_y1 + x0) DCNL DCSP  DCSP  DCSP idx_c = (base_y0 + x1) DCNL DCSP  DCSP  DCSP idx_d = (base_y1 + x1) DCNL DCSP  DCSP  DCSP im_flat = tf.reshape(im, tf.pack([(-1), channels])) DCNL DCSP  DCSP  DCSP im_flat = tf.cast(im_flat, 'float32') DCNL DCSP  DCSP  DCSP Ia = tf.gather(im_flat, idx_a) DCNL DCSP  DCSP  DCSP Ib = tf.gather(im_flat, idx_b) DCNL DCSP  DCSP  DCSP Ic = tf.gather(im_flat, idx_c) DCNL DCSP  DCSP  DCSP Id = tf.gather(im_flat, idx_d) DCNL DCSP  DCSP  DCSP x0_f = tf.cast(x0, 'float32') DCNL DCSP  DCSP  DCSP x1_f = tf.cast(x1, 'float32') DCNL DCSP  DCSP  DCSP y0_f = tf.cast(y0, 'float32') DCNL DCSP  DCSP  DCSP y1_f = tf.cast(y1, 'float32') DCNL DCSP  DCSP  DCSP wa = tf.expand_dims(((x1_f - x) * (y1_f - y)), 1) DCNL DCSP  DCSP  DCSP wb = tf.expand_dims(((x1_f - x) * (y - y0_f)), 1) DCNL DCSP  DCSP  DCSP wc = tf.expand_dims(((x - x0_f) * (y1_f - y)), 1) DCNL DCSP  DCSP  DCSP wd = tf.expand_dims(((x - x0_f) * (y - y0_f)), 1) DCNL DCSP  DCSP  DCSP output = tf.add_n([(wa * Ia), (wb * Ib), (wc * Ic), (wd * Id)]) DCNL DCSP  DCSP  DCSP return output DCNL DCSP def _meshgrid(height, width): DCNL DCSP  DCSP with tf.variable_scope('_meshgrid'): DCNL DCSP  DCSP  DCSP x_t = tf.matmul(tf.ones(shape=tf.pack([height, 1])), tf.transpose(tf.expand_dims(tf.linspace((-1.0), 1.0, width), 1), [1, 0])) DCNL DCSP  DCSP  DCSP y_t = tf.matmul(tf.expand_dims(tf.linspace((-1.0), 1.0, height), 1), tf.ones(shape=tf.pack([1, width]))) DCNL DCSP  DCSP  DCSP x_t_flat = tf.reshape(x_t, (1, (-1))) DCNL DCSP  DCSP  DCSP y_t_flat = tf.reshape(y_t, (1, (-1))) DCNL DCSP  DCSP  DCSP ones = tf.ones_like(x_t_flat) DCNL DCSP  DCSP  DCSP grid = tf.concat(0, [x_t_flat, y_t_flat, ones]) DCNL DCSP  DCSP  DCSP return grid DCNL DCSP def _transform(theta, input_dim, out_size): DCNL DCSP  DCSP with tf.variable_scope('_transform'): DCNL DCSP  DCSP  DCSP num_batch = tf.shape(input_dim)[0] DCNL DCSP  DCSP  DCSP height = tf.shape(input_dim)[1] DCNL DCSP  DCSP  DCSP width = tf.shape(input_dim)[2] DCNL DCSP  DCSP  DCSP num_channels = tf.shape(input_dim)[3] DCNL DCSP  DCSP  DCSP theta = tf.reshape(theta, ((-1), 2, 3)) DCNL DCSP  DCSP  DCSP theta = tf.cast(theta, 'float32') DCNL DCSP  DCSP  DCSP height_f = tf.cast(height, 'float32') DCNL DCSP  DCSP  DCSP width_f = tf.cast(width, 'float32') DCNL DCSP  DCSP  DCSP out_height = out_size[0] DCNL DCSP  DCSP  DCSP out_width = out_size[1] DCNL DCSP  DCSP  DCSP grid = _meshgrid(out_height, out_width) DCNL DCSP  DCSP  DCSP grid = tf.expand_dims(grid, 0) DCNL DCSP  DCSP  DCSP grid = tf.reshape(grid, [(-1)]) DCNL DCSP  DCSP  DCSP grid = tf.tile(grid, tf.pack([num_batch])) DCNL DCSP  DCSP  DCSP grid = tf.reshape(grid, tf.pack([num_batch, 3, (-1)])) DCNL DCSP  DCSP  DCSP T_g = tf.batch_matmul(theta, grid) DCNL DCSP  DCSP  DCSP x_s = tf.slice(T_g, [0, 0, 0], [(-1), 1, (-1)]) DCNL DCSP  DCSP  DCSP y_s = tf.slice(T_g, [0, 1, 0], [(-1), 1, (-1)]) DCNL DCSP  DCSP  DCSP x_s_flat = tf.reshape(x_s, [(-1)]) DCNL DCSP  DCSP  DCSP y_s_flat = tf.reshape(y_s, [(-1)]) DCNL DCSP  DCSP  DCSP input_transformed = _interpolate(input_dim, x_s_flat, y_s_flat, out_size) DCNL DCSP  DCSP  DCSP output = tf.reshape(input_transformed, tf.pack([num_batch, out_height, out_width, num_channels])) DCNL DCSP  DCSP  DCSP return output DCNL DCSP with tf.variable_scope(name): DCNL DCSP  DCSP output = _transform(theta, U, out_size) DCNL DCSP  DCSP return output\n", "intent": "spatial transformer layer implements a spatial transformer layer as described in [1]_ .\n", "question_id": 1833}, {"snippet": "def __virtual__(): DCNL  DCSP return ((salt.utils.which('rsync') and 'rsync') or False)\n", "intent": "only if rsync is available .\n", "question_id": 1834}, {"snippet": "@endpoint(u'/ajax/library-info', postprocess=json) DCNL def library_info(ctx, rd): DCNL  DCSP (library_map, default_library) = ctx.library_info(rd) DCNL DCSP return {u'library_map': library_map, u'default_library': default_library}\n", "intent": "return info about available libraries .\n", "question_id": 1835}, {"snippet": "def get_rnd_shuffle(builder): DCNL  DCSP fnty = ir.FunctionType(ir.VoidType(), (rnd_state_ptr_t,)) DCNL DCSP fn = builder.function.module.get_or_insert_function(fnty, 'numba_rnd_shuffle') DCNL DCSP fn.args[0].add_attribute('nocapture') DCNL DCSP return fn\n", "intent": "get the internal function to shuffle the mt taste .\n", "question_id": 1836}, {"snippet": "def run_test_on_partitions(job, test, partitions, mountpoint_func, tag, fs_opt, do_fsck=True, **dargs): DCNL  DCSP for p in partitions: DCNL DCSP  DCSP p.set_fs_options(fs_opt) DCNL DCSP parallel(partitions, 'setup_before_test', mountpoint_func=mountpoint_func) DCNL DCSP mountpoint = mountpoint_func(partitions[0]) DCNL DCSP job.run_test(test, tag=tag, partitions=partitions, dir=mountpoint, **dargs) DCNL DCSP parallel(partitions, 'unmount') DCNL DCSP if do_fsck: DCNL DCSP  DCSP parallel(partitions, 'fsck')\n", "intent": "run a test that requires multiple partitions .\n", "question_id": 1837}, {"snippet": "def _to_ZZ_poly(f, ring): DCNL  DCSP f_ = ring.zero DCNL DCSP if isinstance(ring.domain, PolynomialRing): DCNL DCSP  DCSP domain = ring.domain.domain DCNL DCSP else: DCNL DCSP  DCSP domain = ring.domain DCNL DCSP den = domain.one DCNL DCSP for coeff in f.itercoeffs(): DCNL DCSP  DCSP for c in coeff.rep: DCNL DCSP  DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP  DCSP den = domain.lcm(den, c.denominator) DCNL DCSP for (monom, coeff) in f.iterterms(): DCNL DCSP  DCSP coeff = coeff.rep DCNL DCSP  DCSP m = ring.domain.one DCNL DCSP  DCSP if isinstance(ring.domain, PolynomialRing): DCNL DCSP  DCSP  DCSP m = m.mul_monom(monom[1:]) DCNL DCSP  DCSP n = len(coeff) DCNL DCSP  DCSP for i in range(n): DCNL DCSP  DCSP  DCSP if coeff[i]: DCNL DCSP  DCSP  DCSP  DCSP c = (domain((coeff[i] * den)) * m) DCNL DCSP  DCSP  DCSP  DCSP if ((monom[0], ((n - i) - 1)) not in f_): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f_[(monom[0], ((n - i) - 1))] = c DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f_[(monom[0], ((n - i) - 1))] += c DCNL DCSP return f_\n", "intent": "compute an associate of a polynomial f in mathbb q[x_0 .\n", "question_id": 1838}, {"snippet": "def getSubDirectories(testdir): DCNL  DCSP subdirs = [os.path.join(testdir, d) for d in filter(os.path.isdir, [os.path.join(testdir, dd) for dd in os.listdir(testdir)])] DCNL DCSP for d in copy(subdirs): DCNL DCSP  DCSP subdirs.extend(getSubDirectories(os.path.join(testdir, d))) DCNL DCSP return subdirs\n", "intent": "recursively builds a list of all subdirectories in the test suite .\n", "question_id": 1839}, {"snippet": "@testing.requires_testing_data DCNL def test_morph_source_spaces(): DCNL  DCSP src = read_source_spaces(fname_fs) DCNL DCSP src_morph = read_source_spaces(fname_morph) DCNL DCSP src_morph_py = morph_source_spaces(src, 'sample', subjects_dir=subjects_dir) DCNL DCSP _compare_source_spaces(src_morph, src_morph_py, mode='approx')\n", "intent": "test morphing of source spaces .\n", "question_id": 1840}, {"snippet": "def _formatparam(param, value=None, quote=True): DCNL  DCSP if ((value is not None) and (len(value) > 0)): DCNL DCSP  DCSP if isinstance(value, tuple): DCNL DCSP  DCSP  DCSP param += '*' DCNL DCSP  DCSP  DCSP value = utils.encode_rfc2231(value[2], value[0], value[1]) DCNL DCSP  DCSP if (quote or tspecials.search(value)): DCNL DCSP  DCSP  DCSP return ('%s=\"%s\"' % (param, utils.quote(value))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('%s=%s' % (param, value)) DCNL DCSP else: DCNL DCSP  DCSP return param\n", "intent": "convenience function to format and return a key=value pair .\n", "question_id": 1841}, {"snippet": "def transplant_func(func, module): DCNL  DCSP from nose.tools import make_decorator DCNL DCSP if isgenerator(func): DCNL DCSP  DCSP def newfunc(*arg, **kw): DCNL DCSP  DCSP  DCSP for v in func(*arg, **kw): DCNL DCSP  DCSP  DCSP  DCSP (yield v) DCNL DCSP else: DCNL DCSP  DCSP def newfunc(*arg, **kw): DCNL DCSP  DCSP  DCSP return func(*arg, **kw) DCNL DCSP newfunc = make_decorator(func)(newfunc) DCNL DCSP newfunc.__module__ = module DCNL DCSP return newfunc\n", "intent": "make a function imported from module a appear as if it is located in module b .\n", "question_id": 1842}, {"snippet": "def plot_img_and_hist(img, axes, bins=256): DCNL  DCSP img = img_as_float(img) DCNL DCSP (ax_img, ax_hist) = axes DCNL DCSP ax_cdf = ax_hist.twinx() DCNL DCSP ax_img.imshow(img, cmap=plt.cm.gray) DCNL DCSP ax_img.set_axis_off() DCNL DCSP ax_hist.hist(img.ravel(), bins=bins, histtype='step', color='black') DCNL DCSP ax_hist.ticklabel_format(axis='y', style='scientific', scilimits=(0, 0)) DCNL DCSP ax_hist.set_xlabel('Pixel DCSP intensity') DCNL DCSP ax_hist.set_xlim(0, 1) DCNL DCSP ax_hist.set_yticks([]) DCNL DCSP (img_cdf, bins) = exposure.cumulative_distribution(img, bins) DCNL DCSP ax_cdf.plot(bins, img_cdf, 'r') DCNL DCSP ax_cdf.set_yticks([]) DCNL DCSP return (ax_img, ax_hist, ax_cdf)\n", "intent": "plot an image along with its histogram and cumulative histogram .\n", "question_id": 1843}, {"snippet": "def get_versions(verbose=False): DCNL  DCSP if ('versioneer' in sys.modules): DCNL DCSP  DCSP del sys.modules['versioneer'] DCNL DCSP root = get_root() DCNL DCSP cfg = get_config_from_root(root) DCNL DCSP assert (cfg.VCS is not None), 'please DCSP set DCSP [versioneer]VCS= DCSP in DCSP setup.cfg' DCNL DCSP handlers = HANDLERS.get(cfg.VCS) DCNL DCSP assert handlers, (\"unrecognized DCSP VCS DCSP '%s'\" % cfg.VCS) DCNL DCSP verbose = (verbose or cfg.verbose) DCNL DCSP assert (cfg.versionfile_source is not None), 'please DCSP set DCSP versioneer.versionfile_source' DCNL DCSP assert (cfg.tag_prefix is not None), 'please DCSP set DCSP versioneer.tag_prefix' DCNL DCSP versionfile_abs = os.path.join(root, cfg.versionfile_source) DCNL DCSP get_keywords_f = handlers.get('get_keywords') DCNL DCSP from_keywords_f = handlers.get('keywords') DCNL DCSP if (get_keywords_f and from_keywords_f): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP keywords = get_keywords_f(versionfile_abs) DCNL DCSP  DCSP  DCSP ver = from_keywords_f(keywords, cfg.tag_prefix, verbose) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print(('got DCSP version DCSP from DCSP expanded DCSP keyword DCSP %s' % ver)) DCNL DCSP  DCSP  DCSP return ver DCNL DCSP  DCSP except NotThisMethod: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP ver = versions_from_file(versionfile_abs) DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print(('got DCSP version DCSP from DCSP file DCSP %s DCSP %s' % (versionfile_abs, ver))) DCNL DCSP  DCSP return ver DCNL DCSP except NotThisMethod: DCNL DCSP  DCSP pass DCNL DCSP from_vcs_f = handlers.get('pieces_from_vcs') DCNL DCSP if from_vcs_f: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pieces = from_vcs_f(cfg.tag_prefix, root, verbose) DCNL DCSP  DCSP  DCSP ver = render(pieces, cfg.style) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print(('got DCSP version DCSP from DCSP VCS DCSP %s' % ver)) DCNL DCSP  DCSP  DCSP return ver DCNL DCSP  DCSP except NotThisMethod: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP if cfg.parentdir_prefix: DCNL DCSP  DCSP  DCSP ver = versions_from_parentdir(cfg.parentdir_prefix, root, verbose) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print(('got DCSP version DCSP from DCSP parentdir DCSP %s' % ver)) DCNL DCSP  DCSP  DCSP return ver DCNL DCSP except NotThisMethod: DCNL DCSP  DCSP pass DCNL DCSP if verbose: DCNL DCSP  DCSP print('unable DCSP to DCSP compute DCSP version') DCNL DCSP return {'version': '0+unknown', 'full-revisionid': None, 'dirty': None, 'error': 'unable DCSP to DCSP compute DCSP version'}\n", "intent": "get the project version from whatever source is available .\n", "question_id": 1844}, {"snippet": "def lazy(func, *resultclasses): DCNL  DCSP @total_ordering DCNL DCSP class __proxy__(Promise, ): DCNL DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Encapsulate DCSP a DCSP function DCSP call DCSP and DCSP act DCSP as DCSP a DCSP proxy DCSP for DCSP methods DCSP that DCSP are\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP called DCSP on DCSP the DCSP result DCSP of DCSP that DCSP function. DCSP The DCSP function DCSP is DCSP not DCSP evaluated\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP until DCSP one DCSP of DCSP the DCSP methods DCSP on DCSP the DCSP result DCSP is DCSP called.\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP __dispatch = None DCNL DCSP  DCSP def __init__(self, args, kw): DCNL DCSP  DCSP  DCSP self.__args = args DCNL DCSP  DCSP  DCSP self.__kw = kw DCNL DCSP  DCSP  DCSP if (self.__dispatch is None): DCNL DCSP  DCSP  DCSP  DCSP self.__prepare_class__() DCNL DCSP  DCSP def __reduce__(self): DCNL DCSP  DCSP  DCSP return (_lazy_proxy_unpickle, ((func, self.__args, self.__kw) + resultclasses)) DCNL DCSP  DCSP def __prepare_class__(cls): DCNL DCSP  DCSP  DCSP cls.__dispatch = {} DCNL DCSP  DCSP  DCSP for resultclass in resultclasses: DCNL DCSP  DCSP  DCSP  DCSP cls.__dispatch[resultclass] = {} DCNL DCSP  DCSP  DCSP  DCSP for type_ in reversed(resultclass.mro()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (k, v) in type_.__dict__.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP meth = cls.__promise__(resultclass, k, v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(cls, k): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP setattr(cls, k, meth) DCNL DCSP  DCSP  DCSP cls._delegate_bytes = (bytes in resultclasses) DCNL DCSP  DCSP  DCSP cls._delegate_text = (six.text_type in resultclasses) DCNL DCSP  DCSP  DCSP assert (not (cls._delegate_bytes and cls._delegate_text)), 'Cannot DCSP call DCSP lazy() DCSP with DCSP both DCSP bytes DCSP and DCSP text DCSP return DCSP types.' DCNL DCSP  DCSP  DCSP if cls._delegate_text: DCNL DCSP  DCSP  DCSP  DCSP if six.PY3: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__str__ = cls.__text_cast DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__unicode__ = cls.__text_cast DCNL DCSP  DCSP  DCSP elif cls._delegate_bytes: DCNL DCSP  DCSP  DCSP  DCSP if six.PY3: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__bytes__ = cls.__bytes_cast DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cls.__str__ = cls.__bytes_cast DCNL DCSP  DCSP __prepare_class__ = classmethod(__prepare_class__) DCNL DCSP  DCSP def __promise__(cls, klass, funcname, method): DCNL DCSP  DCSP  DCSP def __wrapper__(self, *args, **kw): DCNL DCSP  DCSP  DCSP  DCSP res = func(*self.__args, **self.__kw) DCNL DCSP  DCSP  DCSP  DCSP for t in type(res).mro(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (t in self.__dispatch): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return self.__dispatch[t][funcname](res, *args, **kw) DCNL DCSP  DCSP  DCSP  DCSP raise TypeError('Lazy DCSP object DCSP returned DCSP unexpected DCSP type.') DCNL DCSP  DCSP  DCSP if (klass not in cls.__dispatch): DCNL DCSP  DCSP  DCSP  DCSP cls.__dispatch[klass] = {} DCNL DCSP  DCSP  DCSP cls.__dispatch[klass][funcname] = method DCNL DCSP  DCSP  DCSP return __wrapper__ DCNL DCSP  DCSP __promise__ = classmethod(__promise__) DCNL DCSP  DCSP def __text_cast(self): DCNL DCSP  DCSP  DCSP return func(*self.__args, **self.__kw) DCNL DCSP  DCSP def __bytes_cast(self): DCNL DCSP  DCSP  DCSP return bytes(func(*self.__args, **self.__kw)) DCNL DCSP  DCSP def __cast(self): DCNL DCSP  DCSP  DCSP if self._delegate_bytes: DCNL DCSP  DCSP  DCSP  DCSP return self.__bytes_cast() DCNL DCSP  DCSP  DCSP elif self._delegate_text: DCNL DCSP  DCSP  DCSP  DCSP return self.__text_cast() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return func(*self.__args, **self.__kw) DCNL DCSP  DCSP def __eq__(self, other): DCNL DCSP  DCSP  DCSP if isinstance(other, Promise): DCNL DCSP  DCSP  DCSP  DCSP other = other.__cast() DCNL DCSP  DCSP  DCSP return (self.__cast() == other) DCNL DCSP  DCSP def __lt__(self, other): DCNL DCSP  DCSP  DCSP if isinstance(other, Promise): DCNL DCSP  DCSP  DCSP  DCSP other = other.__cast() DCNL DCSP  DCSP  DCSP return (self.__cast() < other) DCNL DCSP  DCSP def __hash__(self): DCNL DCSP  DCSP  DCSP return hash(self.__cast()) DCNL DCSP  DCSP def __mod__(self, rhs): DCNL DCSP  DCSP  DCSP if (self._delegate_bytes and (not six.PY3)): DCNL DCSP  DCSP  DCSP  DCSP return (bytes(self) % rhs) DCNL DCSP  DCSP  DCSP elif self._delegate_text: DCNL DCSP  DCSP  DCSP  DCSP return (six.text_type(self) % rhs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise AssertionError('__mod__ DCSP not DCSP supported DCSP for DCSP non-string DCSP types') DCNL DCSP  DCSP def __deepcopy__(self, memo): DCNL DCSP  DCSP  DCSP memo[id(self)] = self DCNL DCSP  DCSP  DCSP return self DCNL DCSP @wraps(func) DCNL DCSP def __wrapper__(*args, **kw): DCNL DCSP  DCSP return __proxy__(args, kw) DCNL DCSP return __wrapper__\n", "intent": "turns any callable into a lazy evaluated callable .\n", "question_id": 1845}, {"snippet": "def strxor(s1, s2): DCNL  DCSP return ''.join(map((lambda x, y: chr((ord(x) ^ ord(y)))), s1, s2))\n", "intent": "returns the binary xor of the 2 provided strings s1 and s2 .\n", "question_id": 1846}, {"snippet": "def _count_clades(trees): DCNL  DCSP bitstrs = {} DCNL DCSP tree_count = 0 DCNL DCSP for tree in trees: DCNL DCSP  DCSP tree_count += 1 DCNL DCSP  DCSP clade_bitstrs = _tree_to_bitstrs(tree) DCNL DCSP  DCSP for clade in tree.find_clades(terminal=False): DCNL DCSP  DCSP  DCSP bitstr = clade_bitstrs[clade] DCNL DCSP  DCSP  DCSP if (bitstr in bitstrs): DCNL DCSP  DCSP  DCSP  DCSP (count, sum_bl) = bitstrs[bitstr] DCNL DCSP  DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP  DCSP sum_bl += (clade.branch_length or 0) DCNL DCSP  DCSP  DCSP  DCSP bitstrs[bitstr] = (count, sum_bl) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bitstrs[bitstr] = (1, (clade.branch_length or 0)) DCNL DCSP return (bitstrs, tree_count)\n", "intent": "count distinct clades  in the trees .\n", "question_id": 1847}, {"snippet": "def format_lea_seq_log(input_seqs_count, barcode_errors_exceed_max_count, barcode_not_in_map_count, primer_mismatch_count, seq_too_short_count, total_seqs_kept): DCNL  DCSP log_out = 'Quality DCSP filter DCSP results\\nTotal DCSP number DCSP of DCSP input DCSP sequences: DCSP {}\\nBarcode DCSP not DCSP in DCSP mapping DCSP file: DCSP {}\\nSequence DCSP shorter DCSP than DCSP threshold: DCSP {}\\nBarcode DCSP errors DCSP exceeds DCSP limit: DCSP {}\\nPrimer DCSP mismatch DCSP count: DCSP {}\\n\\nTotal DCSP number DCSP seqs DCSP written: DCSP {}'.format(input_seqs_count, barcode_not_in_map_count, seq_too_short_count, barcode_errors_exceed_max_count, primer_mismatch_count, total_seqs_kept) DCNL DCSP return log_out\n", "intent": "format the split libraries lea-seq log parameters input_seqs_count: int barcode_errors_exceed_max_count: int barcode_not_in_map_count: int primer_mismatch_count: int seq_too_short_count: int total_seqs_kept: int returns log_out: string to be printed in log file .\n", "question_id": 1848}, {"snippet": "def generate(bits, randfunc=None, e=65537): DCNL  DCSP if (bits < 1024): DCNL DCSP  DCSP raise ValueError('RSA DCSP modulus DCSP length DCSP must DCSP be DCSP >= DCSP 1024') DCNL DCSP if (((e % 2) == 0) or (e < 3)): DCNL DCSP  DCSP raise ValueError('RSA DCSP public DCSP exponent DCSP must DCSP be DCSP a DCSP positive, DCSP odd DCSP integer DCSP larger DCSP than DCSP 2.') DCNL DCSP if (randfunc is None): DCNL DCSP  DCSP randfunc = Random.get_random_bytes DCNL DCSP d = n = Integer(1) DCNL DCSP e = Integer(e) DCNL DCSP while ((n.size_in_bits() != bits) and (d < (1 << (bits // 2)))): DCNL DCSP  DCSP size_q = (bits // 2) DCNL DCSP  DCSP size_p = (bits - size_q) DCNL DCSP  DCSP min_p = min_q = (Integer(1) << ((2 * size_q) - 1)).sqrt() DCNL DCSP  DCSP if (size_q != size_p): DCNL DCSP  DCSP  DCSP min_p = (Integer(1) << ((2 * size_p) - 1)).sqrt() DCNL DCSP  DCSP def filter_p(candidate): DCNL DCSP  DCSP  DCSP return ((candidate > min_p) and ((candidate - 1).gcd(e) == 1)) DCNL DCSP  DCSP p = generate_probable_prime(exact_bits=size_p, randfunc=randfunc, prime_filter=filter_p) DCNL DCSP  DCSP min_distance = (Integer(1) << ((bits // 2) - 100)) DCNL DCSP  DCSP def filter_q(candidate): DCNL DCSP  DCSP  DCSP return ((candidate > min_q) and ((candidate - 1).gcd(e) == 1) and (abs((candidate - p)) > min_distance)) DCNL DCSP  DCSP q = generate_probable_prime(exact_bits=size_q, randfunc=randfunc, prime_filter=filter_q) DCNL DCSP  DCSP n = (p * q) DCNL DCSP  DCSP lcm = (p - 1).lcm((q - 1)) DCNL DCSP  DCSP d = e.inverse(lcm) DCNL DCSP if (p > q): DCNL DCSP  DCSP (p, q) = (q, p) DCNL DCSP u = p.inverse(q) DCNL DCSP return RsaKey(n=n, e=e, d=d, p=p, q=q, u=u)\n", "intent": "create a new rsa key .\n", "question_id": 1849}, {"snippet": "def message(icon, text, title=None, informative_text=None, details=None, buttons=None, default_button=None, exc_info=False, parent=None): DCNL  DCSP if (title is None): DCNL DCSP  DCSP title = 'Message' DCNL DCSP if (not text): DCNL DCSP  DCSP text = 'I DCSP am DCSP neither DCSP a DCSP postman DCSP nor DCSP a DCSP doctor.' DCNL DCSP if (buttons is None): DCNL DCSP  DCSP buttons = QMessageBox.Ok DCNL DCSP if ((details is None) and exc_info): DCNL DCSP  DCSP details = traceback.format_exc(limit=20) DCNL DCSP mbox = QMessageBox(icon, title, text, buttons, parent) DCNL DCSP if informative_text: DCNL DCSP  DCSP mbox.setInformativeText(informative_text) DCNL DCSP if details: DCNL DCSP  DCSP mbox.setDetailedText(details) DCNL DCSP if (default_button is not None): DCNL DCSP  DCSP mbox.setDefaultButton(default_button) DCNL DCSP return mbox.exec_()\n", "intent": "show a message helper function .\n", "question_id": 1850}, {"snippet": "@pytest.mark.django_db DCNL def test_make_naive_explicit_tz(settings): DCNL  DCSP settings.USE_TZ = True DCNL DCSP datetime_object = timezone.make_aware(datetime(2016, 1, 2, 21, 52, 25), timezone=pytz.timezone('Europe/Helsinki')) DCNL DCSP assert timezone.is_aware(datetime_object) DCNL DCSP naive_datetime = make_naive(datetime_object, tz=pytz.timezone('Asia/Bangkok')) DCNL DCSP assert timezone.is_naive(naive_datetime) DCNL DCSP assert (naive_datetime.hour == ((datetime_object.hour + 5) % 24))\n", "intent": "tests datetimes are made naive of the given timezone .\n", "question_id": 1851}, {"snippet": "@FileSystem.in_directory(current_directory, 'django', 'couves') DCNL def test_django_agains_couves(): DCNL  DCSP (status, out) = run_scenario() DCNL DCSP expect('Couves DCSP before DCSP all').to.be.within(out) DCNL DCSP expect('Couves DCSP after DCSP all').to.be.within(out)\n", "intent": "it always call @after .\n", "question_id": 1852}, {"snippet": "def get_pack_by_ref(pack_ref): DCNL  DCSP pack_db = Pack.get_by_ref(pack_ref) DCNL DCSP return pack_db\n", "intent": "retrieve packdb by the provided reference .\n", "question_id": 1853}, {"snippet": "def post_listing_to_slack(sc, listing): DCNL  DCSP desc = '{0} DCSP | DCSP {1} DCSP | DCSP {2} DCSP | DCSP {3} DCSP | DCSP <{4}>'.format(listing['area'], listing['price'], listing['bart_dist'], listing['name'], listing['url']) DCNL DCSP sc.api_call('chat.postMessage', channel=settings.SLACK_CHANNEL, text=desc, username='pybot', icon_emoji=':robot_face:')\n", "intent": "posts the listing to slack .\n", "question_id": 1854}, {"snippet": "def stop(name): DCNL  DCSP cmd = _service_cmd(name, 'stop') DCNL DCSP return (not __salt__['cmd.retcode'](cmd))\n", "intent": "stop the specified service cli example: .\n", "question_id": 1855}, {"snippet": "def describe_api_deployment(restApiId, deploymentId, region=None, key=None, keyid=None, profile=None): DCNL  DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP  DCSP deployment = conn.get_deployment(restApiId=restApiId, deploymentId=deploymentId) DCNL DCSP  DCSP return {'deployment': _convert_datetime_str(deployment)} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}\n", "intent": "get api deployment for a given restapiid and deploymentid .\n", "question_id": 1856}, {"snippet": "def set_saucelabs_job_status(jobid, passed=True): DCNL  DCSP config = get_saucelabs_username_and_key() DCNL DCSP url = 'http://saucelabs.com/rest/v1/{}/jobs/{}'.format(config['username'], world.jobid) DCNL DCSP body_content = dumps({'passed': passed}) DCNL DCSP base64string = encodestring('{}:{}'.format(config['username'], config['access-key']))[:(-1)] DCNL DCSP headers = {'Authorization': 'Basic DCSP {}'.format(base64string)} DCNL DCSP result = requests.put(url, data=body_content, headers=headers) DCNL DCSP return (result.status_code == 200)\n", "intent": "sets the job status on sauce labs .\n", "question_id": 1857}, {"snippet": "def _read_tagdesc(f): DCNL  DCSP tagdesc = {'offset': _read_long(f)} DCNL DCSP if (tagdesc['offset'] == (-1)): DCNL DCSP  DCSP tagdesc['offset'] = _read_uint64(f) DCNL DCSP tagdesc['typecode'] = _read_long(f) DCNL DCSP tagflags = _read_long(f) DCNL DCSP tagdesc['array'] = ((tagflags & 4) == 4) DCNL DCSP tagdesc['structure'] = ((tagflags & 32) == 32) DCNL DCSP tagdesc['scalar'] = (tagdesc['typecode'] in DTYPE_DICT) DCNL DCSP return tagdesc\n", "intent": "function to read in a tag descriptor .\n", "question_id": 1858}, {"snippet": "def to_time(wmi_time): DCNL  DCSP def int_or_none(s, start, end): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(s[start:end]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP year = int_or_none(wmi_time, 0, 4) DCNL DCSP month = int_or_none(wmi_time, 4, 6) DCNL DCSP day = int_or_none(wmi_time, 6, 8) DCNL DCSP hours = int_or_none(wmi_time, 8, 10) DCNL DCSP minutes = int_or_none(wmi_time, 10, 12) DCNL DCSP seconds = int_or_none(wmi_time, 12, 14) DCNL DCSP microseconds = int_or_none(wmi_time, 15, 21) DCNL DCSP timezone = wmi_time[22:] DCNL DCSP if (timezone == '***'): DCNL DCSP  DCSP timezone = None DCNL DCSP return (year, month, day, hours, minutes, seconds, microseconds, timezone)\n", "intent": "convenience wrapper to take a wmi datetime string of the form yyyymmddhhmmss .\n", "question_id": 1859}, {"snippet": "def list_manage_opts(): DCNL  DCSP return [(g, copy.deepcopy(o)) for (g, o) in _manage_opts]\n", "intent": "return a list of oslo_config options available in glance manage .\n", "question_id": 1860}, {"snippet": "def get_flatpages(parser, token): DCNL  DCSP bits = token.split_contents() DCNL DCSP syntax_message = (\"%(tag_name)s DCSP expects DCSP a DCSP syntax DCSP of DCSP %(tag_name)s DCSP ['url_starts_with'] DCSP [for DCSP user] DCSP as DCSP context_name\" % dict(tag_name=bits[0])) DCNL DCSP if ((len(bits) >= 3) and (len(bits) <= 6)): DCNL DCSP  DCSP if ((len(bits) % 2) == 0): DCNL DCSP  DCSP  DCSP prefix = bits[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prefix = None DCNL DCSP  DCSP if (bits[(-2)] != 'as'): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError(syntax_message) DCNL DCSP  DCSP context_name = bits[(-1)] DCNL DCSP  DCSP if (len(bits) >= 5): DCNL DCSP  DCSP  DCSP if (bits[(-4)] != 'for'): DCNL DCSP  DCSP  DCSP  DCSP raise template.TemplateSyntaxError(syntax_message) DCNL DCSP  DCSP  DCSP user = bits[(-3)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = None DCNL DCSP  DCSP return FlatpageNode(context_name, starts_with=prefix, user=user) DCNL DCSP else: DCNL DCSP  DCSP raise template.TemplateSyntaxError(syntax_message)\n", "intent": "retrieves all flatpage objects available for the current site and visible to the specific user .\n", "question_id": 1861}, {"snippet": "@timer.timed DCNL def identity(*args, **kwargs): DCNL  DCSP return (args, kwargs)\n", "intent": "an identity function used as a default task to test the timing of .\n", "question_id": 1862}, {"snippet": "def install_openblas(): DCNL  DCSP chdir(SRC_DIR) DCNL DCSP apt_command('build-dep DCSP libopenblas-dev') DCNL DCSP if glob.glob('*openblas*.deb'): DCNL DCSP  DCSP run_command('dpkg DCSP -i DCSP *openblas*.deb') DCNL DCSP else: DCNL DCSP  DCSP apt_command('source DCSP libopenblas-dev') DCNL DCSP  DCSP chdir('openblas-*') DCNL DCSP  DCSP patch = open('fix_makefile_system.patch', 'w') DCNL DCSP  DCSP patch.write(OPENBLAS_0_1ALPHA_2_PATCH) DCNL DCSP  DCSP patch.close() DCNL DCSP  DCSP run_command(('patch DCSP -p1 DCSP < DCSP %s' % patch.name)) DCNL DCSP  DCSP rule_file = open('Makefile.rule', 'a') DCNL DCSP  DCSP lines = ['DYNAMIC_ARCH=1', 'NUM_THREADS=64', 'NO_LAPACK=1', 'NO_AFFINITY=1'] DCNL DCSP  DCSP rule_file.write('\\n'.join(lines)) DCNL DCSP  DCSP rule_file.close() DCNL DCSP  DCSP run_command('fakeroot DCSP debian/rules DCSP custom') DCNL DCSP  DCSP run_command('dpkg DCSP -i DCSP ../*openblas*.deb') DCNL DCSP run_command('echo DCSP libopenblas-base DCSP hold DCSP | DCSP dpkg DCSP --set-selections') DCNL DCSP run_command('echo DCSP libopenblas-dev DCSP hold DCSP | DCSP dpkg DCSP --set-selections')\n", "intent": "docstring for install_openblas .\n", "question_id": 1863}, {"snippet": "def issue_section_order(issue): DCNL  DCSP try: DCNL DCSP  DCSP return LOG_SECTION.values().index(issue_section(issue)) DCNL DCSP except: DCNL DCSP  DCSP return (-1)\n", "intent": "returns the section order for the given issue .\n", "question_id": 1864}, {"snippet": "def random_partition(n, n_data): DCNL  DCSP all_idxs = numpy.arange(n_data) DCNL DCSP numpy.random.shuffle(all_idxs) DCNL DCSP idxs1 = all_idxs[:n] DCNL DCSP idxs2 = all_idxs[n:] DCNL DCSP return (idxs1, idxs2)\n", "intent": "return n random rows of data (and also the other len-n rows) .\n", "question_id": 1865}, {"snippet": "def kwarg(**kwargs): DCNL  DCSP return kwargs\n", "intent": "print out the data passed into the function **kwargs .\n", "question_id": 1866}, {"snippet": "def convert_DateTimeProperty(model, prop, kwargs): DCNL  DCSP if (prop.auto_now or prop.auto_now_add): DCNL DCSP  DCSP return None DCNL DCSP kwargs.setdefault('format', '%Y-%m-%d DCSP %H:%M:%S') DCNL DCSP return f.DateTimeField(**kwargs)\n", "intent": "returns a form field for a db .\n", "question_id": 1867}, {"snippet": "def decode_network_number(ptype, plen, buf): DCNL  DCSP return number.unpack_from(buf, header.size)[0]\n", "intent": "decodes a number  from collectd network format .\n", "question_id": 1868}, {"snippet": "def _aggregate(input, options, output, timeFieldName): DCNL  DCSP aggregator = Aggregator(aggregationInfo=options, inputFields=input.getFields(), timeFieldName=timeFieldName) DCNL DCSP while True: DCNL DCSP  DCSP inRecord = input.getNextRecord() DCNL DCSP  DCSP print 'Feeding DCSP in: DCSP ', inRecord DCNL DCSP  DCSP (outRecord, aggBookmark) = aggregator.next(record=inRecord, curInputBookmark=None) DCNL DCSP  DCSP print 'Record DCSP out: DCSP ', outRecord DCNL DCSP  DCSP if (outRecord is not None): DCNL DCSP  DCSP  DCSP output.appendRecord(outRecord, None) DCNL DCSP  DCSP if ((inRecord is None) and (outRecord is None)): DCNL DCSP  DCSP  DCSP break\n", "intent": "aggregate the input stream and write aggregated records to the output stream .\n", "question_id": 1869}, {"snippet": "def getprime(nbits): DCNL  DCSP nbytes = int(math.ceil((nbits / 8.0))) DCNL DCSP while True: DCNL DCSP  DCSP integer = read_random_int(nbits) DCNL DCSP  DCSP integer |= 1 DCNL DCSP  DCSP if is_prime(integer): DCNL DCSP  DCSP  DCSP break DCNL DCSP return integer\n", "intent": "returns a prime number of max .\n", "question_id": 1870}, {"snippet": "def unquote_header_value(value, is_filename=False): DCNL  DCSP if (value and (value[0] == value[(-1)] == '\"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP  DCSP if ((not is_filename) or (value[:2] != '\\\\\\\\')): DCNL DCSP  DCSP  DCSP return value.replace('\\\\\\\\', '\\\\').replace('\\\\\"', '\"') DCNL DCSP return value\n", "intent": "unquotes a header value .\n", "question_id": 1871}, {"snippet": "def ex_call(func, args): DCNL  DCSP if isinstance(func, six.string_types): DCNL DCSP  DCSP func = ex_rvalue(func) DCNL DCSP args = list(args) DCNL DCSP for i in range(len(args)): DCNL DCSP  DCSP if (not isinstance(args[i], ast.expr)): DCNL DCSP  DCSP  DCSP args[i] = ex_literal(args[i]) DCNL DCSP if (sys.version_info[:2] < (3, 5)): DCNL DCSP  DCSP return ast.Call(func, args, [], None, None) DCNL DCSP else: DCNL DCSP  DCSP return ast.Call(func, args, [])\n", "intent": "a function-call expression with only positional parameters .\n", "question_id": 1872}, {"snippet": "def assert_sp_series_equal(left, right, check_dtype=True, exact_indices=True, check_series_type=True, check_names=True, obj='SparseSeries'): DCNL  DCSP assertIsInstance(left, pd.SparseSeries, '[SparseSeries]') DCNL DCSP assertIsInstance(right, pd.SparseSeries, '[SparseSeries]') DCNL DCSP if check_series_type: DCNL DCSP  DCSP assert_class_equal(left, right, obj=obj) DCNL DCSP assert_index_equal(left.index, right.index, obj='{0}.index'.format(obj)) DCNL DCSP assert_sp_array_equal(left.block.values, right.block.values) DCNL DCSP if check_names: DCNL DCSP  DCSP assert_attr_equal('name', left, right) DCNL DCSP if check_dtype: DCNL DCSP  DCSP assert_attr_equal('dtype', left, right) DCNL DCSP assert_numpy_array_equal(left.values, right.values)\n", "intent": "check that the left and right sparseseries are equal .\n", "question_id": 1873}, {"snippet": "def u(string): DCNL  DCSP if is_py3: DCNL DCSP  DCSP return str(string) DCNL DCSP elif (not isinstance(string, unicode)): DCNL DCSP  DCSP return unicode(str(string), 'UTF-8') DCNL DCSP return string\n", "intent": "cast to unicode dammit! written because python2 repr always implicitly casts to a string .\n", "question_id": 1874}, {"snippet": "def dropname(ss, li): DCNL  DCSP newli = li[:] DCNL DCSP for item in ss.split(): DCNL DCSP  DCSP newli.remove(item) DCNL DCSP return newli\n", "intent": "drop names from a list of strings .\n", "question_id": 1875}, {"snippet": "def register(verb): DCNL  DCSP from stream_framework.verbs.base import Verb DCNL DCSP if (not issubclass(verb, Verb)): DCNL DCSP  DCSP raise ValueError(('%s DCSP doesnt DCSP subclass DCSP Verb' % verb)) DCNL DCSP registered_verb = get_verb_storage().get(verb.id, verb) DCNL DCSP if (registered_verb != verb): DCNL DCSP  DCSP raise ValueError(('cant DCSP register DCSP verb DCSP %r DCSP with DCSP id DCSP %s DCSP (clashing DCSP with DCSP verb DCSP %r)' % (verb, verb.id, registered_verb))) DCNL DCSP get_verb_storage()[verb.id] = verb\n", "intent": "registers the given verb class .\n", "question_id": 1876}, {"snippet": "def _neighbor_test(nr_points, dim, bucket_size, radius): DCNL  DCSP kdt = _CKDTree.KDTree(dim, bucket_size) DCNL DCSP coords = random.random((nr_points, dim)) DCNL DCSP kdt.set_data(coords) DCNL DCSP neighbors = kdt.neighbor_search(radius) DCNL DCSP r = [neighbor.radius for neighbor in neighbors] DCNL DCSP if (r is None): DCNL DCSP  DCSP l1 = 0 DCNL DCSP else: DCNL DCSP  DCSP l1 = len(r) DCNL DCSP neighbors = kdt.neighbor_simple_search(radius) DCNL DCSP r = [neighbor.radius for neighbor in neighbors] DCNL DCSP if (r is None): DCNL DCSP  DCSP l2 = 0 DCNL DCSP else: DCNL DCSP  DCSP l2 = len(r) DCNL DCSP if (l1 == l2): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP print(('Not DCSP passed: DCSP %i DCSP != DCSP %i.' % (l1, l2))) DCNL DCSP  DCSP return False\n", "intent": "test all fixed radius neighbor search .\n", "question_id": 1877}, {"snippet": "def askcolor(color=None, **options): DCNL  DCSP if color: DCNL DCSP  DCSP options = options.copy() DCNL DCSP  DCSP options['initialcolor'] = color DCNL DCSP return Chooser(**options).show()\n", "intent": "ask for a color .\n", "question_id": 1878}, {"snippet": "def random_weighted_sample(mapping, k): DCNL  DCSP if (k > len(mapping)): DCNL DCSP  DCSP raise ValueError('sample DCSP larger DCSP than DCSP population') DCNL DCSP sample = set() DCNL DCSP while (len(sample) < k): DCNL DCSP  DCSP sample.add(weighted_choice(mapping)) DCNL DCSP return list(sample)\n", "intent": "return k items without replacement from a weighted sample .\n", "question_id": 1879}, {"snippet": "@core_helper DCNL def flash_error(message, allow_html=False): DCNL  DCSP flash(message, category='alert-error', allow_html=allow_html)\n", "intent": "show a flash message of type error .\n", "question_id": 1880}, {"snippet": "def decompose_power(expr): DCNL  DCSP (base, exp) = expr.as_base_exp() DCNL DCSP if exp.is_Number: DCNL DCSP  DCSP if exp.is_Rational: DCNL DCSP  DCSP  DCSP if (not exp.is_Integer): DCNL DCSP  DCSP  DCSP  DCSP base = Pow(base, Rational(1, exp.q)) DCNL DCSP  DCSP  DCSP exp = exp.p DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (base, exp) = (expr, 1) DCNL DCSP else: DCNL DCSP  DCSP (exp, tail) = exp.as_coeff_Mul(rational=True) DCNL DCSP  DCSP if (exp is S.NegativeOne): DCNL DCSP  DCSP  DCSP (base, exp) = (Pow(base, tail), (-1)) DCNL DCSP  DCSP elif (exp is not S.One): DCNL DCSP  DCSP  DCSP tail = _keep_coeff(Rational(1, exp.q), tail) DCNL DCSP  DCSP  DCSP (base, exp) = (Pow(base, tail), exp.p) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (base, exp) = (expr, 1) DCNL DCSP return (base, exp)\n", "intent": "decompose power into symbolic base and integer exponent .\n", "question_id": 1881}, {"snippet": "def _package_conf_file_to_dir(file_name): DCNL  DCSP if (file_name in SUPPORTED_CONFS): DCNL DCSP  DCSP path = BASE_PATH.format(file_name) DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP if os.path.isdir(path): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP os.rename(path, (path + '.tmpbak')) DCNL DCSP  DCSP  DCSP  DCSP os.mkdir(path, 493) DCNL DCSP  DCSP  DCSP  DCSP with salt.utils.fopen((path + '.tmpbak')) as fh_: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for line in fh_: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = line.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (line and (not line.startswith('#'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP append_to_package_conf(file_name, string=line) DCNL DCSP  DCSP  DCSP  DCSP os.remove((path + '.tmpbak')) DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP os.mkdir(path, 493) DCNL DCSP  DCSP  DCSP return True\n", "intent": "convert a config file to a config directory .\n", "question_id": 1882}, {"snippet": "def remove_license(key): DCNL  DCSP result = {'result': False, 'retcode': (-1), 'output': ''} DCNL DCSP if (not has_powerpath()): DCNL DCSP  DCSP result['output'] = 'PowerPath DCSP is DCSP not DCSP installed' DCNL DCSP  DCSP return result DCNL DCSP cmd = '/sbin/emcpreg DCSP -remove DCSP {0}'.format(key) DCNL DCSP ret = __salt__['cmd.run_all'](cmd, python_shell=True) DCNL DCSP result['retcode'] = ret['retcode'] DCNL DCSP if (ret['retcode'] != 0): DCNL DCSP  DCSP result['output'] = ret['stderr'] DCNL DCSP else: DCNL DCSP  DCSP result['output'] = ret['stdout'] DCNL DCSP  DCSP result['result'] = True DCNL DCSP return result\n", "intent": "remove a license .\n", "question_id": 1883}, {"snippet": "def pytest_fixture_setup(fixturedef, request): DCNL  DCSP kwargs = {} DCNL DCSP for argname in fixturedef.argnames: DCNL DCSP  DCSP fixdef = request._get_active_fixturedef(argname) DCNL DCSP  DCSP (result, arg_cache_key, exc) = fixdef.cached_result DCNL DCSP  DCSP request._check_scope(argname, request.scope, fixdef.scope) DCNL DCSP  DCSP kwargs[argname] = result DCNL DCSP fixturefunc = fixturedef.func DCNL DCSP if fixturedef.unittest: DCNL DCSP  DCSP if (request.instance is not None): DCNL DCSP  DCSP  DCSP fixturefunc = fixturedef.func.__get__(request.instance) DCNL DCSP elif (request.instance is not None): DCNL DCSP  DCSP fixturefunc = getimfunc(fixturedef.func) DCNL DCSP  DCSP if (fixturefunc != fixturedef.func): DCNL DCSP  DCSP  DCSP fixturefunc = fixturefunc.__get__(request.instance) DCNL DCSP my_cache_key = request.param_index DCNL DCSP try: DCNL DCSP  DCSP result = call_fixture_func(fixturefunc, request, kwargs) DCNL DCSP except Exception: DCNL DCSP  DCSP fixturedef.cached_result = (None, my_cache_key, sys.exc_info()) DCNL DCSP  DCSP raise DCNL DCSP fixturedef.cached_result = (result, my_cache_key, None) DCNL DCSP return result\n", "intent": "execution of fixture setup .\n", "question_id": 1884}, {"snippet": "def __DocTestFinder_from_module(self, module, object): DCNL  DCSP import inspect DCNL DCSP if (module is None): DCNL DCSP  DCSP return True DCNL DCSP elif (inspect.isfunction(object) or inspect.isclass(object)): DCNL DCSP  DCSP return (module.__name__ == object.__module__) DCNL DCSP elif (inspect.getmodule(object) is not None): DCNL DCSP  DCSP return (module is inspect.getmodule(object)) DCNL DCSP elif hasattr(object, '__module__'): DCNL DCSP  DCSP return (module.__name__ == object.__module__) DCNL DCSP elif isinstance(object, property): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('object DCSP must DCSP be DCSP a DCSP class DCSP or DCSP function')\n", "intent": "return true if the given object is defined in the given module .\n", "question_id": 1885}, {"snippet": "@cleanup DCNL @needs_tex DCNL def test_missing_psfont(monkeypatch): DCNL  DCSP from matplotlib import rc DCNL DCSP def psfont(*args, **kwargs): DCNL DCSP  DCSP return dviread.PsFont(texname=u'texfont', psname=u'Some DCSP Font', effects=None, encoding=None, filename=None) DCNL DCSP monkeypatch.setattr(dviread.PsfontsMap, u'__getitem__', psfont) DCNL DCSP rc(u'text', usetex=True) DCNL DCSP (fig, ax) = plt.subplots() DCNL DCSP ax.text(0.5, 0.5, u'hello') DCNL DCSP with tempfile.TemporaryFile() as tmpfile: DCNL DCSP  DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP  DCSP fig.savefig(tmpfile, format=u'svg')\n", "intent": "an error is raised if a tex font lacks a type-1 equivalent .\n", "question_id": 1886}, {"snippet": "def initialize(module): DCNL  DCSP global HOUSE DCNL DCSP debug(('Received DCSP module DCSP start DCSP for: DCSP %s' % module.__name__)) DCNL DCSP if (not ('service' in HOUSE)): DCNL DCSP  DCSP HOUSE['service'] = {} DCNL DCSP tmp_mod = module() DCNL DCSP if (not tmp_mod.skip_opts): DCNL DCSP  DCSP response = handle_opts(tmp_mod) DCNL DCSP else: DCNL DCSP  DCSP response = True DCNL DCSP if response: DCNL DCSP  DCSP if hasattr(tmp_mod, 'initialize_bg'): DCNL DCSP  DCSP  DCSP tmp = tmp_mod.initialize_bg() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp = tmp_mod.initialize() DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP if ((tmp is not None) and (tmp is not False)): DCNL DCSP  DCSP if isinstance(tmp_mod, Service): DCNL DCSP  DCSP  DCSP HOUSE['service'][tmp_mod.which] = tmp_mod DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (not (tmp_mod.which in HOUSE)): DCNL DCSP  DCSP  DCSP HOUSE[tmp_mod.which] = {} DCNL DCSP  DCSP HOUSE[tmp_mod.which][tmp_mod.session_view()] = tmp_mod\n", "intent": "initialize a module and load it into the global house variable .\n", "question_id": 1887}, {"snippet": "def _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context): DCNL  DCSP with work_in(repo_dir): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP run_hook(hook_name, project_dir, context) DCNL DCSP  DCSP except FailedHookException: DCNL DCSP  DCSP  DCSP rmtree(project_dir) DCNL DCSP  DCSP  DCSP logger.error(u\"Stopping DCSP generation DCSP because DCSP {} DCSP hook DCSP script DCSP didn't DCSP exit DCSP successfully\".format(hook_name)) DCNL DCSP  DCSP  DCSP raise\n", "intent": "run hook from repo directory .\n", "question_id": 1888}, {"snippet": "def register(): DCNL  DCSP return 'serializer'\n", "intent": "the mandatory cobbler module registration hook .\n", "question_id": 1889}, {"snippet": "def chgid(name, gid): DCNL  DCSP pre_gid = __salt__['file.group_to_gid'](name) DCNL DCSP if (gid == pre_gid): DCNL DCSP  DCSP return True DCNL DCSP cmd = 'groupmod DCSP -g DCSP {0} DCSP {1}'.format(gid, name) DCNL DCSP __salt__['cmd.run'](cmd, python_shell=False) DCNL DCSP post_gid = __salt__['file.group_to_gid'](name) DCNL DCSP if (post_gid != pre_gid): DCNL DCSP  DCSP return (post_gid == gid) DCNL DCSP return False\n", "intent": "change the gid for a named group cli example: .\n", "question_id": 1890}, {"snippet": "def setActivePrivacyList(disp, listname=None, typ='active'): DCNL  DCSP if listname: DCNL DCSP  DCSP attrs = {'name': listname} DCNL DCSP else: DCNL DCSP  DCSP attrs = {} DCNL DCSP resp = disp.SendAndWaitForResponse(Iq('set', NS_PRIVACY, payload=[Node(typ, attrs)])) DCNL DCSP if isResultNode(resp): DCNL DCSP  DCSP return 1\n", "intent": "switches privacy list listname to specified type .\n", "question_id": 1891}, {"snippet": "@task DCNL def unflag_database(stdout=sys.stdout): DCNL  DCSP log('Unflagging DCSP the DCSP database', stdout=stdout) DCNL DCSP unflag_reindexing_amo()\n", "intent": "unflag the database to indicate that the reindexing is over .\n", "question_id": 1892}, {"snippet": "def varmats_from_mat(file_obj): DCNL  DCSP rdr = MatFile5Reader(file_obj) DCNL DCSP file_obj.seek(0) DCNL DCSP hdr_len = MDTYPES[native_code]['dtypes']['file_header'].itemsize DCNL DCSP raw_hdr = file_obj.read(hdr_len) DCNL DCSP file_obj.seek(0) DCNL DCSP rdr.initialize_read() DCNL DCSP mdict = rdr.read_file_header() DCNL DCSP next_position = file_obj.tell() DCNL DCSP named_mats = [] DCNL DCSP while (not rdr.end_of_stream()): DCNL DCSP  DCSP start_position = next_position DCNL DCSP  DCSP (hdr, next_position) = rdr.read_var_header() DCNL DCSP  DCSP name = asstr(hdr.name) DCNL DCSP  DCSP file_obj.seek(start_position) DCNL DCSP  DCSP byte_count = (next_position - start_position) DCNL DCSP  DCSP var_str = file_obj.read(byte_count) DCNL DCSP  DCSP out_obj = BytesIO() DCNL DCSP  DCSP out_obj.write(raw_hdr) DCNL DCSP  DCSP out_obj.write(var_str) DCNL DCSP  DCSP out_obj.seek(0) DCNL DCSP  DCSP named_mats.append((name, out_obj)) DCNL DCSP return named_mats\n", "intent": "pull variables out of mat 5 file as a sequence of mat file objects this can be useful with a difficult mat file .\n", "question_id": 1893}, {"snippet": "def _iter_content_lines(content): DCNL  DCSP return _iter_lines(content.iter_bytes(), '\\n')\n", "intent": "iterate over the lines that make up content .\n", "question_id": 1894}, {"snippet": "@pytest.mark.network DCNL def test_editables_legacy(script, data): DCNL  DCSP script.pip('install', '-f', data.find_links, '--no-index', 'simple==1.0') DCNL DCSP script.pip('install', '-e', 'git+https://github.com/pypa/pip-test-package.git#egg=pip-test-package') DCNL DCSP result = script.pip('list', '--editable', '--format=legacy', expect_stderr=True) DCNL DCSP assert ('simple DCSP (1.0)' not in result.stdout), str(result) DCNL DCSP assert (os.path.join('src', 'pip-test-package') in result.stdout), str(result)\n", "intent": "test the behavior of --editables flag in the list command .\n", "question_id": 1895}, {"snippet": "def get_impl_ver(): DCNL  DCSP impl_ver = get_config_var('py_version_nodot') DCNL DCSP if ((not impl_ver) or (get_abbr_impl() == 'pp')): DCNL DCSP  DCSP impl_ver = ''.join(map(str, get_impl_version_info())) DCNL DCSP return impl_ver\n", "intent": "return implementation version .\n", "question_id": 1896}, {"snippet": "def Collection(path, lock=True, server=False, sync=True, log=False): DCNL  DCSP assert path.endswith('.anki2') DCNL DCSP path = os.path.abspath(path) DCNL DCSP create = (not os.path.exists(path)) DCNL DCSP if create: DCNL DCSP  DCSP base = os.path.basename(path) DCNL DCSP  DCSP for c in ('/', ':', '\\\\'): DCNL DCSP  DCSP  DCSP assert (c not in base) DCNL DCSP db = DB(path) DCNL DCSP db.setAutocommit(True) DCNL DCSP if create: DCNL DCSP  DCSP ver = _createDB(db) DCNL DCSP else: DCNL DCSP  DCSP ver = _upgradeSchema(db) DCNL DCSP db.execute('pragma DCSP temp_store DCSP = DCSP memory') DCNL DCSP if sync: DCNL DCSP  DCSP db.execute('pragma DCSP cache_size DCSP = DCSP 10000') DCNL DCSP  DCSP db.execute('pragma DCSP journal_mode DCSP = DCSP wal') DCNL DCSP else: DCNL DCSP  DCSP db.execute('pragma DCSP synchronous DCSP = DCSP off') DCNL DCSP db.setAutocommit(False) DCNL DCSP col = _Collection(db, server, log) DCNL DCSP if (ver < SCHEMA_VERSION): DCNL DCSP  DCSP _upgrade(col, ver) DCNL DCSP elif create: DCNL DCSP  DCSP addClozeModel(col) DCNL DCSP  DCSP addForwardOptionalReverse(col) DCNL DCSP  DCSP addForwardReverse(col) DCNL DCSP  DCSP addBasicModel(col) DCNL DCSP  DCSP col.save() DCNL DCSP if lock: DCNL DCSP  DCSP col.lock() DCNL DCSP return col\n", "intent": "open a new or existing collection .\n", "question_id": 1897}, {"snippet": "@cleanup DCNL def test__EventCollection__is_horizontal(): DCNL  DCSP (_, coll, _) = generate_EventCollection_plot() DCNL DCSP assert_equal(True, coll.is_horizontal())\n", "intent": "check to make sure the default orientation matches the input orientation .\n", "question_id": 1898}, {"snippet": "def _SendAuthRequest(tester, url, http_method, user_cookie=None, request_dict=None, allow_errors=None): DCNL  DCSP headers = {'Content-Type': 'application/json', 'Content-Encoding': 'gzip'} DCNL DCSP if (user_cookie is not None): DCNL DCSP  DCSP headers['Cookie'] = ('user=%s' % user_cookie) DCNL DCSP headers['X-Xsrftoken'] = 'fake_xsrf' DCNL DCSP headers['Cookie'] = ((headers['Cookie'] + ';_xsrf=fake_xsrf') if headers.has_key('Cookie') else '_xsrf=fake_xsrf') DCNL DCSP with mock.patch.object(FetchContactsOperation, '_SKIP_UPDATE_FOR_TEST', True): DCNL DCSP  DCSP response = tester._RunAsync(tester.http_client.fetch, url, method=http_method, body=(None if (request_dict is None) else GzipEncode(json.dumps(request_dict))), headers=headers, follow_redirects=False) DCNL DCSP if (response.code >= 400): DCNL DCSP  DCSP if ((allow_errors is None) or (response.code not in allow_errors)): DCNL DCSP  DCSP  DCSP response.rethrow() DCNL DCSP return response\n", "intent": "sends request to auth service .\n", "question_id": 1899}, {"snippet": "def test_ordered_dict_only_dict(): DCNL  DCSP schema = vol.Schema(cv.ordered_dict(cv.match_all, cv.match_all)) DCNL DCSP for value in (None, [], 100, 'hello'): DCNL DCSP  DCSP with pytest.raises(vol.MultipleInvalid): DCNL DCSP  DCSP  DCSP schema(value)\n", "intent": "test ordered_dict validator .\n", "question_id": 1900}, {"snippet": "def start_download_checked(dest, tab): DCNL  DCSP title = tab.title() DCNL DCSP default_name = utils.sanitize_filename((title + '.mht')) DCNL DCSP encoding = sys.getfilesystemencoding() DCNL DCSP default_name = utils.force_encoding(default_name, encoding) DCNL DCSP dest = utils.force_encoding(dest, encoding) DCNL DCSP dest = os.path.expanduser(dest) DCNL DCSP path = downloads.create_full_filename(default_name, dest) DCNL DCSP if (path is None): DCNL DCSP  DCSP path = downloads.create_full_filename(default_name, os.path.join(downloads.download_dir(), dest)) DCNL DCSP downloads.last_used_directory = os.path.dirname(path) DCNL DCSP if (not os.path.isdir(os.path.dirname(path))): DCNL DCSP  DCSP folder = os.path.dirname(path) DCNL DCSP  DCSP message.error('Directory DCSP {} DCSP does DCSP not DCSP exist.'.format(folder)) DCNL DCSP  DCSP return DCNL DCSP if (not os.path.isfile(path)): DCNL DCSP  DCSP _start_download(path, tab=tab) DCNL DCSP  DCSP return DCNL DCSP q = usertypes.Question() DCNL DCSP q.mode = usertypes.PromptMode.yesno DCNL DCSP q.title = 'Overwrite DCSP existing DCSP file?' DCNL DCSP q.text = '<b>{}</b> DCSP already DCSP exists. DCSP Overwrite?'.format(html.escape(path)) DCNL DCSP q.completed.connect(q.deleteLater) DCNL DCSP q.answered_yes.connect(functools.partial(_start_download, path, tab=tab)) DCNL DCSP message.global_bridge.ask(q, blocking=False)\n", "intent": "first check if dest is already a file .\n", "question_id": 1901}, {"snippet": "def commented_out_code_lines(source): DCNL  DCSP line_numbers = [] DCNL DCSP try: DCNL DCSP  DCSP for t in generate_tokens(source): DCNL DCSP  DCSP  DCSP token_type = t[0] DCNL DCSP  DCSP  DCSP token_string = t[1] DCNL DCSP  DCSP  DCSP start_row = t[2][0] DCNL DCSP  DCSP  DCSP line = t[4] DCNL DCSP  DCSP  DCSP if (not line.lstrip().startswith(u'#')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (token_type == tokenize.COMMENT): DCNL DCSP  DCSP  DCSP  DCSP stripped_line = token_string.lstrip(u'#').strip() DCNL DCSP  DCSP  DCSP  DCSP if ((u' DCSP ' in stripped_line) and (u'#' not in stripped_line) and check_syntax(stripped_line)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP line_numbers.append(start_row) DCNL DCSP except (SyntaxError, tokenize.TokenError): DCNL DCSP  DCSP pass DCNL DCSP return line_numbers\n", "intent": "return line numbers of comments that are likely code .\n", "question_id": 1902}, {"snippet": "def abort_merge(): DCNL  DCSP git.read_tree(u'HEAD', reset=True, u=True, v=True) DCNL DCSP merge_head = git.git_path(u'MERGE_HEAD') DCNL DCSP if core.exists(merge_head): DCNL DCSP  DCSP core.unlink(merge_head) DCNL DCSP merge_msg_path = merge_message_path() DCNL DCSP while merge_msg_path: DCNL DCSP  DCSP core.unlink(merge_msg_path) DCNL DCSP  DCSP merge_msg_path = merge_message_path()\n", "intent": "abort a merge by reading the tree at head .\n", "question_id": 1903}, {"snippet": "def unsubscribe(request, watch_id): DCNL  DCSP try: DCNL DCSP  DCSP watch = Watch.objects.get(pk=watch_id) DCNL DCSP  DCSP secret = request.GET.get('s') DCNL DCSP  DCSP if (secret != watch.secret): DCNL DCSP  DCSP  DCSP raise Watch.DoesNotExist DCNL DCSP except Watch.DoesNotExist: DCNL DCSP  DCSP return render(request, 'motidings/unsubscribe_error.html') DCNL DCSP if (request.method == 'POST'): DCNL DCSP  DCSP watch.delete() DCNL DCSP  DCSP return render(request, 'motidings/unsubscribe_success.html') DCNL DCSP return render(request, 'motidings/unsub.html', {'watch': watch})\n", "intent": "unsubscribe from  the watch of id watch_id .\n", "question_id": 1904}, {"snippet": "def _create_diffs_for(current_path, subobj_a, subobj_b): DCNL  DCSP if (subobj_a == subobj_b): DCNL DCSP  DCSP return pvector([]) DCNL DCSP elif (isinstance(subobj_a, PClass) and isinstance(subobj_b, PClass)): DCNL DCSP  DCSP a_dict = subobj_a._to_dict() DCNL DCSP  DCSP b_dict = subobj_b._to_dict() DCNL DCSP  DCSP return _create_diffs_for_mappings(current_path, a_dict, b_dict) DCNL DCSP elif (isinstance(subobj_a, PMap) and isinstance(subobj_b, PMap)): DCNL DCSP  DCSP return _create_diffs_for_mappings(current_path, subobj_a, subobj_b) DCNL DCSP elif (isinstance(subobj_a, PSet) and isinstance(subobj_b, PSet)): DCNL DCSP  DCSP return _create_diffs_for_sets(current_path, subobj_a, subobj_b) DCNL DCSP if (len(current_path) > 0): DCNL DCSP  DCSP return pvector([_Set(path=current_path[:(-1)], key=current_path[(-1)], value=subobj_b)]) DCNL DCSP else: DCNL DCSP  DCSP return pvector([_Replace(value=subobj_b)])\n", "intent": "computes a series of _idiffchange s to turn subobj_a into subobj_b assuming that these subobjs are at current_path inside a nested pyrsistent object .\n", "question_id": 1905}, {"snippet": "def CDL3INSIDE(barDs, count): DCNL  DCSP return call_talib_with_ohlc(barDs, count, talib.CDL3INSIDE)\n", "intent": "three inside up/down .\n", "question_id": 1906}, {"snippet": "def split_query(query_string, minimum_part_length=3): DCNL  DCSP query_string = force_text(query_string) DCNL DCSP return set((part for part in (part.strip() for part in query_string.split()) if (len(part) >= minimum_part_length)))\n", "intent": "split a string into a set of non-empty words .\n", "question_id": 1907}, {"snippet": "def _subs(value): DCNL  DCSP subs = {'groupOfNames': ['keystoneTenant', 'keystoneRole', 'keystoneTenantRole']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]\n", "intent": "return a list of subclass strings .\n", "question_id": 1908}, {"snippet": "def sendStayAwake(): DCNL  DCSP return False\n", "intent": "sends a signal to your system to indicate that the computer is in use and should not sleep .\n", "question_id": 1909}, {"snippet": "@parse_data DCNL @set_database DCNL def get_topic_nodes(parent=None, ids=None, **kwargs): DCNL  DCSP if parent: DCNL DCSP  DCSP Parent = Item.alias() DCNL DCSP  DCSP if (parent == 'root'): DCNL DCSP  DCSP  DCSP selector = Parent.parent.is_null() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selector = (Parent.id == parent) DCNL DCSP  DCSP values = Item.select(Item.title, Item.description, Item.available, Item.kind, Item.children, Item.id, Item.path, Item.slug).join(Parent, on=(Item.parent == Parent.pk)).where((selector & Item.available)) DCNL DCSP  DCSP return values DCNL DCSP elif ids: DCNL DCSP  DCSP values = Item.select(Item.title, Item.description, Item.available, Item.kind, Item.children, Item.id, Item.path, Item.slug).where(Item.id.in_(ids)) DCNL DCSP  DCSP return values\n", "intent": "convenience function for returning a set of topic nodes with limited fields for rendering the topic tree can either pass in the parent id to return all the immediate children of a node .\n", "question_id": 1910}, {"snippet": "def getMatrixTetragridC(matrixTetragrid, prefix, xmlElement): DCNL  DCSP columnKeys = 'Pc1 DCSP Pc2 DCSP Pc3 DCSP Pc4'.replace('P', prefix).split() DCNL DCSP evaluatedDictionary = evaluate.getEvaluatedDictionary(columnKeys, xmlElement) DCNL DCSP if (len(evaluatedDictionary.keys()) < 1): DCNL DCSP  DCSP return matrixTetragrid DCNL DCSP for (columnKeyIndex, columnKey) in enumerate(columnKeys): DCNL DCSP  DCSP if (columnKey in evaluatedDictionary): DCNL DCSP  DCSP  DCSP value = evaluatedDictionary[columnKey] DCNL DCSP  DCSP  DCSP if ((value == None) or (value == 'None')): DCNL DCSP  DCSP  DCSP  DCSP print 'Warning, DCSP value DCSP in DCSP getMatrixTetragridC DCSP in DCSP matrix DCSP is DCSP None DCSP for DCSP columnKey DCSP for DCSP dictionary:' DCNL DCSP  DCSP  DCSP  DCSP print columnKey DCNL DCSP  DCSP  DCSP  DCSP print evaluatedDictionary DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP matrixTetragrid = getIdentityMatrixTetragrid(matrixTetragrid) DCNL DCSP  DCSP  DCSP  DCSP for (elementIndex, element) in enumerate(value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matrixTetragrid[elementIndex][columnKeyIndex] = element DCNL DCSP euclidean.removeListFromDictionary(xmlElement.attributeDictionary, columnKeys) DCNL DCSP return matrixTetragrid\n", "intent": "get the matrix tetragrid from the xmlelement c values .\n", "question_id": 1911}, {"snippet": "def lastColorizedLine(source): DCNL  DCSP if (not isinstance(source, bytes)): DCNL DCSP  DCSP source = source.encode('utf-8') DCNL DCSP w = VT102Writer() DCNL DCSP p = TokenPrinter(w.write).printtoken DCNL DCSP s = BytesIO(source) DCNL DCSP for token in _tokenize(s.readline): DCNL DCSP  DCSP (tokenType, string, start, end, line) = token DCNL DCSP  DCSP p(tokenType, string, start, end, line) DCNL DCSP line = str(w).encode('utf-8') DCNL DCSP return line\n", "intent": "tokenize and colorize the given python source .\n", "question_id": 1912}, {"snippet": "@pytest.mark.network DCNL def test_finder_priority_page_over_deplink(): DCNL  DCSP req = InstallRequirement.from_line('pip==1.5.6', None) DCNL DCSP finder = PackageFinder([], ['https://pypi.python.org/simple'], process_dependency_links=True, session=PipSession()) DCNL DCSP finder.add_dependency_links(['https://warehouse.python.org/packages/source/p/pip/pip-1.5.6.tar.gz']) DCNL DCSP all_versions = finder.find_all_candidates(req.name) DCNL DCSP assert all_versions[(-1)].location.url.startswith('https://warehouse') DCNL DCSP link = finder.find_requirement(req, False) DCNL DCSP assert link.url.startswith('https://pypi'), link\n", "intent": "test packagefinder prefers page links over equivalent dependency links .\n", "question_id": 1913}, {"snippet": "def loadLocalVariables(filename): DCNL  DCSP with open(filename, 'r') as f: DCNL DCSP  DCSP lines = [f.readline(), f.readline()] DCNL DCSP for line in lines: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return _parseLocalVariables(line) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return {}\n", "intent": "accepts a filename and attempts to load the emacs variable declarations from that file .\n", "question_id": 1914}, {"snippet": "def maybe_future(x): DCNL  DCSP if is_future(x): DCNL DCSP  DCSP return x DCNL DCSP else: DCNL DCSP  DCSP fut = Future() DCNL DCSP  DCSP fut.set_result(x) DCNL DCSP  DCSP return fut\n", "intent": "converts x into a .\n", "question_id": 1915}, {"snippet": "def generate_songlist_display(song=False, zeromsg=None): DCNL  DCSP if (g.browse_mode == 'ytpl'): DCNL DCSP  DCSP return generate_playlist_display() DCNL DCSP max_results = getxy().max_results DCNL DCSP if (not g.model): DCNL DCSP  DCSP g.message = (zeromsg or 'Enter DCSP /search-term DCSP to DCSP search DCSP or DCSP [h]elp') DCNL DCSP  DCSP return (logo(c.g) + '\\n\\n') DCNL DCSP g.rprompt = page_msg(g.current_page) DCNL DCSP have_meta = all(((x.ytid in g.meta) for x in g.model)) DCNL DCSP user_columns = (_get_user_columns() if have_meta else []) DCNL DCSP maxlength = max((x.length for x in g.model)) DCNL DCSP lengthsize = (8 if (maxlength > 35999) else 7) DCNL DCSP lengthsize = (5 if (maxlength < 6000) else lengthsize) DCNL DCSP reserved = ((9 + lengthsize) + len(user_columns)) DCNL DCSP cw = getxy().width DCNL DCSP cw -= 1 DCNL DCSP title_size = ((cw - sum(((1 + x['size']) for x in user_columns))) - reserved) DCNL DCSP before = [{'name': 'idx', 'size': 3, 'heading': 'Num'}, {'name': 'title', 'size': title_size, 'heading': 'Title'}] DCNL DCSP after = [{'name': 'length', 'size': lengthsize, 'heading': 'Time'}] DCNL DCSP columns = ((before + user_columns) + after) DCNL DCSP for (n, column) in enumerate(columns): DCNL DCSP  DCSP column['idx'] = n DCNL DCSP  DCSP column['sign'] = ('-' if (not (column['name'] == 'length')) else '') DCNL DCSP fmt = ['%{}{}s DCSP  DCSP '.format(x['sign'], x['size']) for x in columns] DCNL DCSP fmtrow = ((fmt[0:1] + ['%s DCSP  DCSP ']) + fmt[2:]) DCNL DCSP (fmt, fmtrow) = (''.join(fmt).strip(), ''.join(fmtrow).strip()) DCNL DCSP titles = tuple([x['heading'][:x['size']] for x in columns]) DCNL DCSP hrow = ((c.ul + (fmt % titles)) + c.w) DCNL DCSP out = (('\\n' + hrow) + '\\n') DCNL DCSP for (n, x) in enumerate(g.model[:max_results]): DCNL DCSP  DCSP col = ((c.r if ((n % 2) == 0) else c.p) if (not song) else c.b) DCNL DCSP  DCSP details = {'title': x.title, 'length': fmt_time(x.length)} DCNL DCSP  DCSP details = (copy.copy(g.meta[x.ytid]) if have_meta else details) DCNL DCSP  DCSP otitle = details['title'] DCNL DCSP  DCSP details['idx'] = ('%2d' % (n + 1)) DCNL DCSP  DCSP details['title'] = uea_pad(columns[1]['size'], otitle) DCNL DCSP  DCSP cat = (details.get('category') or '-') DCNL DCSP  DCSP details['category'] = pafy.get_categoryname(cat) DCNL DCSP  DCSP data = [] DCNL DCSP  DCSP for z in columns: DCNL DCSP  DCSP  DCSP (fieldsize, field) = (z['size'], z['name']) DCNL DCSP  DCSP  DCSP if (len(details[field]) > fieldsize): DCNL DCSP  DCSP  DCSP  DCSP details[field] = details[field][:fieldsize] DCNL DCSP  DCSP  DCSP data.append(details[field]) DCNL DCSP  DCSP line = (fmtrow % tuple(data)) DCNL DCSP  DCSP col = (col if ((not song) or (song != g.model[n])) else c.p) DCNL DCSP  DCSP line = ((col + line) + c.w) DCNL DCSP  DCSP out += (line + '\\n') DCNL DCSP return ((out + ('\\n' * (5 - len(g.model)))) if (not song) else out)\n", "intent": "generate list of choices from a song list .\n", "question_id": 1916}, {"snippet": "def unregister(name, delete=False): DCNL  DCSP nodes = list_nodes_min() DCNL DCSP if (name not in nodes): DCNL DCSP  DCSP raise CommandExecutionError('The DCSP specified DCSP VM DCSP ({0}) DCSP is DCSP not DCSP registered.'.format(name)) DCNL DCSP cmd = '{0} DCSP unregistervm DCSP {1}'.format(vboxcmd(), name) DCNL DCSP if (delete is True): DCNL DCSP  DCSP cmd += ' DCSP --delete' DCNL DCSP ret = salt.modules.cmdmod.run_all(cmd) DCNL DCSP if (ret['retcode'] == 0): DCNL DCSP  DCSP return True DCNL DCSP return ret['stderr']\n", "intent": "unregister a vm cli example: .\n", "question_id": 1917}, {"snippet": "def _parse_pre_yarn_history_records(lines): DCNL  DCSP def yield_record_strings(lines): DCNL DCSP  DCSP record_lines = [] DCNL DCSP  DCSP start_line = 0 DCNL DCSP  DCSP for (line_num, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP record_lines.append(line) DCNL DCSP  DCSP  DCSP if line.endswith(' DCSP .\\n'): DCNL DCSP  DCSP  DCSP  DCSP (yield (start_line, len(record_lines), ''.join(record_lines))) DCNL DCSP  DCSP  DCSP  DCSP record_lines = [] DCNL DCSP  DCSP  DCSP  DCSP start_line = (line_num + 1) DCNL DCSP for (start_line, num_lines, record_str) in yield_record_strings(lines): DCNL DCSP  DCSP record_match = _PRE_YARN_HISTORY_RECORD.match(record_str) DCNL DCSP  DCSP if (not record_match): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP record_type = record_match.group('type') DCNL DCSP  DCSP key_pairs = record_match.group('key_pairs') DCNL DCSP  DCSP fields = {} DCNL DCSP  DCSP for m in _PRE_YARN_HISTORY_KEY_PAIR.finditer(key_pairs): DCNL DCSP  DCSP  DCSP key = m.group('key') DCNL DCSP  DCSP  DCSP value = _pre_yarn_history_unescape(m.group('escaped_value')) DCNL DCSP  DCSP  DCSP fields[key] = value DCNL DCSP  DCSP (yield dict(fields=fields, num_lines=num_lines, start_line=start_line, type=record_type))\n", "intent": "yield records from the given sequence of lines .\n", "question_id": 1918}, {"snippet": "def oauth2_callback(request): DCNL  DCSP if ('error' in request.GET): DCNL DCSP  DCSP reason = request.GET.get('error_description', request.GET.get('error', '')) DCNL DCSP  DCSP return http.HttpResponseBadRequest('Authorization DCSP failed DCSP {0}'.format(reason)) DCNL DCSP try: DCNL DCSP  DCSP encoded_state = request.GET['state'] DCNL DCSP  DCSP code = request.GET['code'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return http.HttpResponseBadRequest('Request DCSP missing DCSP state DCSP or DCSP authorization DCSP code') DCNL DCSP try: DCNL DCSP  DCSP server_csrf = request.session[_CSRF_KEY] DCNL DCSP except KeyError: DCNL DCSP  DCSP return http.HttpResponseBadRequest('No DCSP existing DCSP session DCSP for DCSP this DCSP flow.') DCNL DCSP try: DCNL DCSP  DCSP state = json.loads(encoded_state) DCNL DCSP  DCSP client_csrf = state['csrf_token'] DCNL DCSP  DCSP return_url = state['return_url'] DCNL DCSP except (ValueError, KeyError): DCNL DCSP  DCSP return http.HttpResponseBadRequest('Invalid DCSP state DCSP parameter.') DCNL DCSP if (client_csrf != server_csrf): DCNL DCSP  DCSP return http.HttpResponseBadRequest('Invalid DCSP CSRF DCSP token.') DCNL DCSP flow = _get_flow_for_token(client_csrf, request) DCNL DCSP if (not flow): DCNL DCSP  DCSP return http.HttpResponseBadRequest('Missing DCSP Oauth2 DCSP flow.') DCNL DCSP try: DCNL DCSP  DCSP credentials = flow.step2_exchange(code) DCNL DCSP except client.FlowExchangeError as exchange_error: DCNL DCSP  DCSP return http.HttpResponseBadRequest('An DCSP error DCSP has DCSP occurred: DCSP {0}'.format(exchange_error)) DCNL DCSP get_storage(request).put(credentials) DCNL DCSP signals.oauth2_authorized.send(sender=signals.oauth2_authorized, request=request, credentials=credentials) DCNL DCSP return shortcuts.redirect(return_url)\n", "intent": "view that handles the users return from oauth2 provider .\n", "question_id": 1919}, {"snippet": "def _privileged(original): DCNL  DCSP @wraps(original) DCNL DCSP def permissionChecker(self, *args, **kwargs): DCNL DCSP  DCSP if (original.__name__ not in self.permissions): DCNL DCSP  DCSP  DCSP raise IOError(EPERM, 'Operation DCSP not DCSP permitted') DCNL DCSP  DCSP return original(self, *args, **kwargs) DCNL DCSP return permissionChecker\n", "intent": "wrap a l{memoryiosystem} method with permission-checking logic .\n", "question_id": 1920}, {"snippet": "def get_element_by_id(id, html): DCNL  DCSP return get_element_by_attribute(u'id', id, html)\n", "intent": "return the content of the tag with the specified id in the passed html document .\n", "question_id": 1921}, {"snippet": "def rand_structure(itemsize, valid, maxdim=5, maxshape=16, shape=()): DCNL  DCSP if (not shape): DCNL DCSP  DCSP ndim = randrange((maxdim + 1)) DCNL DCSP  DCSP if (ndim == 0): DCNL DCSP  DCSP  DCSP if valid: DCNL DCSP  DCSP  DCSP  DCSP return (itemsize, itemsize, ndim, (), (), 0) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP nitems = randrange(1, (16 + 1)) DCNL DCSP  DCSP  DCSP  DCSP memlen = (nitems * itemsize) DCNL DCSP  DCSP  DCSP  DCSP offset = ((- itemsize) if (randrange(2) == 0) else memlen) DCNL DCSP  DCSP  DCSP  DCSP return (memlen, itemsize, ndim, (), (), offset) DCNL DCSP  DCSP minshape = 2 DCNL DCSP  DCSP n = randrange(100) DCNL DCSP  DCSP if ((n >= 95) and valid): DCNL DCSP  DCSP  DCSP minshape = 0 DCNL DCSP  DCSP elif (n >= 90): DCNL DCSP  DCSP  DCSP minshape = 1 DCNL DCSP  DCSP shape = ([0] * ndim) DCNL DCSP  DCSP for i in range(ndim): DCNL DCSP  DCSP  DCSP shape[i] = randrange(minshape, (maxshape + 1)) DCNL DCSP else: DCNL DCSP  DCSP ndim = len(shape) DCNL DCSP maxstride = 5 DCNL DCSP n = randrange(100) DCNL DCSP zero_stride = (True if ((n >= 95) and (n & 1)) else False) DCNL DCSP strides = ([0] * ndim) DCNL DCSP strides[(ndim - 1)] = (itemsize * randrange((- maxstride), (maxstride + 1))) DCNL DCSP if ((not zero_stride) and (strides[(ndim - 1)] == 0)): DCNL DCSP  DCSP strides[(ndim - 1)] = itemsize DCNL DCSP for i in range((ndim - 2), (-1), (-1)): DCNL DCSP  DCSP maxstride *= (shape[(i + 1)] if shape[(i + 1)] else 1) DCNL DCSP  DCSP if zero_stride: DCNL DCSP  DCSP  DCSP strides[i] = (itemsize * randrange((- maxstride), (maxstride + 1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP strides[i] = (((1, (-1))[randrange(2)] * itemsize) * randrange(1, (maxstride + 1))) DCNL DCSP imin = imax = 0 DCNL DCSP if (not (0 in shape)): DCNL DCSP  DCSP imin = sum(((strides[j] * (shape[j] - 1)) for j in range(ndim) if (strides[j] <= 0))) DCNL DCSP  DCSP imax = sum(((strides[j] * (shape[j] - 1)) for j in range(ndim) if (strides[j] > 0))) DCNL DCSP nitems = (imax - imin) DCNL DCSP if valid: DCNL DCSP  DCSP offset = ((- imin) * itemsize) DCNL DCSP  DCSP memlen = (offset + ((imax + 1) * itemsize)) DCNL DCSP else: DCNL DCSP  DCSP memlen = (((- imin) + imax) * itemsize) DCNL DCSP  DCSP offset = (((- imin) - itemsize) if (randrange(2) == 0) else memlen) DCNL DCSP return (memlen, itemsize, ndim, shape, strides, offset)\n", "intent": "return random structure:  if valid is true .\n", "question_id": 1922}, {"snippet": "def dh_private_key(digit=10, seed=None): DCNL  DCSP p = nextprime((2 ** digit)) DCNL DCSP g = primitive_root(p) DCNL DCSP randrange = _randrange(seed) DCNL DCSP a = randrange(2, p) DCNL DCSP return (p, g, a)\n", "intent": "return three integer tuple as private key .\n", "question_id": 1923}, {"snippet": "def _document_PUT(request, document_slug, document_locale): DCNL  DCSP try: DCNL DCSP  DCSP content_type = request.META.get('CONTENT_TYPE', '') DCNL DCSP  DCSP if content_type.startswith('application/json'): DCNL DCSP  DCSP  DCSP data = json.loads(request.body) DCNL DCSP  DCSP elif content_type.startswith('multipart/form-data'): DCNL DCSP  DCSP  DCSP parser = MultiPartParser(request.META, StringIO(request.body), request.upload_handlers, request.encoding) DCNL DCSP  DCSP  DCSP (data, files) = parser.parse() DCNL DCSP  DCSP elif content_type.startswith('text/html'): DCNL DCSP  DCSP  DCSP html = request.body DCNL DCSP  DCSP  DCSP data = dict(content=html) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP doc = pq(html) DCNL DCSP  DCSP  DCSP  DCSP head_title = doc.find('head DCSP title') DCNL DCSP  DCSP  DCSP  DCSP if (head_title.length > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP data['title'] = head_title.text() DCNL DCSP  DCSP  DCSP  DCSP body_content = doc.find('body') DCNL DCSP  DCSP  DCSP  DCSP if (body_content.length > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP data['content'] = body_content.html() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP resp = HttpResponse() DCNL DCSP  DCSP  DCSP resp.status_code = 400 DCNL DCSP  DCSP  DCSP resp.content = (ugettext('Unsupported DCSP content-type: DCSP %s') % content_type) DCNL DCSP  DCSP  DCSP return resp DCNL DCSP except Exception as e: DCNL DCSP  DCSP resp = HttpResponse() DCNL DCSP  DCSP resp.status_code = 400 DCNL DCSP  DCSP resp.content = (ugettext('Request DCSP parsing DCSP error: DCSP %s') % e) DCNL DCSP  DCSP return resp DCNL DCSP try: DCNL DCSP  DCSP doc = Document.objects.get(locale=document_locale, slug=document_slug) DCNL DCSP  DCSP if (not doc.allows_revision_by(request.user)): DCNL DCSP  DCSP  DCSP raise PermissionDenied DCNL DCSP  DCSP section_id = request.GET.get('section', None) DCNL DCSP  DCSP is_new = False DCNL DCSP  DCSP expected_etag = request.META.get('HTTP_IF_MATCH', False) DCNL DCSP  DCSP if expected_etag: DCNL DCSP  DCSP  DCSP curr_etag = doc.calculate_etag(section_id) DCNL DCSP  DCSP  DCSP if (curr_etag != expected_etag): DCNL DCSP  DCSP  DCSP  DCSP resp = HttpResponse() DCNL DCSP  DCSP  DCSP  DCSP resp.status_code = 412 DCNL DCSP  DCSP  DCSP  DCSP resp.content = ugettext('ETag DCSP precondition DCSP failed') DCNL DCSP  DCSP  DCSP  DCSP return resp DCNL DCSP except Document.DoesNotExist: DCNL DCSP  DCSP if (not Document.objects.allows_add_by(request.user, document_slug)): DCNL DCSP  DCSP  DCSP raise PermissionDenied DCNL DCSP  DCSP slug_parts = split_slug(document_slug) DCNL DCSP  DCSP if (not slug_parts['parent']): DCNL DCSP  DCSP  DCSP parent_doc = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parent_doc = get_object_or_404(Document, locale=document_locale, slug=slug_parts['parent']) DCNL DCSP  DCSP doc = Document(slug=document_slug, locale=document_locale, title=data.get('title', document_slug), parent_topic=parent_doc) DCNL DCSP  DCSP doc.save() DCNL DCSP  DCSP section_id = None DCNL DCSP  DCSP is_new = True DCNL DCSP new_rev = doc.revise(request.user, data, section_id) DCNL DCSP doc.schedule_rendering('max-age=0') DCNL DCSP request.authkey.log(((is_new and 'created') or 'updated'), new_rev, data.get('summary', None)) DCNL DCSP resp = HttpResponse() DCNL DCSP if (not is_new): DCNL DCSP  DCSP resp.content = 'RESET' DCNL DCSP  DCSP resp.status_code = 205 DCNL DCSP else: DCNL DCSP  DCSP resp.content = 'CREATED' DCNL DCSP  DCSP new_loc = request.build_absolute_uri(doc.get_absolute_url()) DCNL DCSP  DCSP resp['Location'] = new_loc DCNL DCSP  DCSP resp.status_code = 201 DCNL DCSP return resp\n", "intent": "handle put requests as document write api .\n", "question_id": 1924}, {"snippet": "def LinuxProfileFactory(profpkg): DCNL  DCSP dwarfdata = None DCNL DCSP sysmapdata = None DCNL DCSP (memmodel, arch) = ('32bit', 'x86') DCNL DCSP profilename = os.path.splitext(os.path.basename(profpkg.filename))[0] DCNL DCSP for f in profpkg.filelist: DCNL DCSP  DCSP if f.filename.lower().endswith('.dwarf'): DCNL DCSP  DCSP  DCSP dwarfdata = profpkg.read(f.filename) DCNL DCSP  DCSP elif ('system.map' in f.filename.lower()): DCNL DCSP  DCSP  DCSP sysmapdata = profpkg.read(f.filename) DCNL DCSP  DCSP  DCSP (arch, memmodel, sysmap) = parse_system_map(profpkg.read(f.filename), 'kernel') DCNL DCSP if (memmodel == '64bit'): DCNL DCSP  DCSP arch = 'x64' DCNL DCSP if ((not sysmapdata) or (not dwarfdata)): DCNL DCSP  DCSP return None DCNL DCSP class AbstractLinuxProfile(obj.Profile, ): DCNL DCSP  DCSP __doc__ = ((('A DCSP Profile DCSP for DCSP Linux DCSP ' + profilename) + ' DCSP ') + arch) DCNL DCSP  DCSP _md_os = 'linux' DCNL DCSP  DCSP _md_memory_model = memmodel DCNL DCSP  DCSP _md_arch = arch DCNL DCSP  DCSP native_mapping = {'32bit': native_types.x86_native_types, '64bit': x64_native_types} DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP self.sys_map = {} DCNL DCSP  DCSP  DCSP self.sym_addr_cache = {} DCNL DCSP  DCSP  DCSP self.shift_address = 0 DCNL DCSP  DCSP  DCSP obj.Profile.__init__(self, *args, **kwargs) DCNL DCSP  DCSP def clear(self): DCNL DCSP  DCSP  DCSP 'Clear DCSP out DCSP the DCSP system DCSP map, DCSP and DCSP everything DCSP else' DCNL DCSP  DCSP  DCSP self.sys_map = {} DCNL DCSP  DCSP  DCSP self.shift_address = 0 DCNL DCSP  DCSP  DCSP obj.Profile.clear(self) DCNL DCSP  DCSP def reset(self): DCNL DCSP  DCSP  DCSP 'Reset DCSP the DCSP vtypes, DCSP sysmap DCSP and DCSP apply DCSP modifications, DCSP then DCSP compile' DCNL DCSP  DCSP  DCSP self.clear() DCNL DCSP  DCSP  DCSP self.load_vtypes() DCNL DCSP  DCSP  DCSP self.load_sysmap() DCNL DCSP  DCSP  DCSP self.load_modifications() DCNL DCSP  DCSP  DCSP self.compile() DCNL DCSP  DCSP def _merge_anonymous_members(self, vtypesvar): DCNL DCSP  DCSP  DCSP members_index = 1 DCNL DCSP  DCSP  DCSP types_index = 1 DCNL DCSP  DCSP  DCSP offset_index = 0 DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP for candidate in vtypesvar: DCNL DCSP  DCSP  DCSP  DCSP  DCSP done = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (not done): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if any((member.startswith('__unnamed_') for member in vtypesvar[candidate][members_index])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for member in vtypesvar[candidate][members_index].keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if member.startswith('__unnamed_'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member_type = vtypesvar[candidate][members_index][member][types_index][0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location = vtypesvar[candidate][members_index][member][offset_index] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vtypesvar[candidate][members_index].update(vtypesvar[member_type][members_index]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for name in vtypesvar[member_type][members_index].keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vtypesvar[candidate][members_index][name][offset_index] += location DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP del vtypesvar[candidate][members_index][member] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP done = True DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP import pdb DCNL DCSP  DCSP  DCSP  DCSP pdb.set_trace() DCNL DCSP  DCSP  DCSP  DCSP raise exceptions.VolatilityException(('Inconsistent DCSP linux DCSP profile DCSP - DCSP unable DCSP to DCSP look DCSP up DCSP ' + str(e))) DCNL DCSP  DCSP def load_vtypes(self): DCNL DCSP  DCSP  DCSP 'Loads DCSP up DCSP the DCSP vtypes DCSP data' DCNL DCSP  DCSP  DCSP ntvar = self.metadata.get('memory_model', '32bit') DCNL DCSP  DCSP  DCSP self.native_types = copy.deepcopy(self.native_mapping.get(ntvar)) DCNL DCSP  DCSP  DCSP vtypesvar = dwarf.DWARFParser(dwarfdata).finalize() DCNL DCSP  DCSP  DCSP self._merge_anonymous_members(vtypesvar) DCNL DCSP  DCSP  DCSP self.vtypes.update(vtypesvar) DCNL DCSP  DCSP  DCSP debug.debug('{2}: DCSP Found DCSP dwarf DCSP file DCSP {0} DCSP with DCSP {1} DCSP symbols'.format(f.filename, len(vtypesvar.keys()), profilename)) DCNL DCSP  DCSP def load_sysmap(self): DCNL DCSP  DCSP  DCSP 'Loads DCSP up DCSP the DCSP system DCSP map DCSP data' DCNL DCSP  DCSP  DCSP (arch, _memmodel, sysmapvar) = parse_system_map(sysmapdata, 'kernel') DCNL DCSP  DCSP  DCSP debug.debug('{2}: DCSP Found DCSP system DCSP file DCSP {0} DCSP with DCSP {1} DCSP symbols'.format(f.filename, len(sysmapvar.keys()), profilename)) DCNL DCSP  DCSP  DCSP self.sys_map.update(sysmapvar) DCNL DCSP  DCSP def get_all_symbols(self, module='kernel'): DCNL DCSP  DCSP  DCSP ' DCSP Gets DCSP all DCSP the DCSP symbol DCSP tuples DCSP for DCSP the DCSP given DCSP module DCSP ' DCNL DCSP  DCSP  DCSP ret = [] DCNL DCSP  DCSP  DCSP symtable = self.sys_map DCNL DCSP  DCSP  DCSP if (module in symtable): DCNL DCSP  DCSP  DCSP  DCSP mod = symtable[module] DCNL DCSP  DCSP  DCSP  DCSP for (name, addrs) in mod.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP addr = addrs[0][0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (self.shift_address and addr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP addr = (addr + self.shift_address) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.append((name, addr)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP debug.info(('All DCSP symbols DCSP requested DCSP for DCSP non-existent DCSP module DCSP %s' % module)) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP def get_all_addresses(self, module='kernel'): DCNL DCSP  DCSP  DCSP ' DCSP Gets DCSP all DCSP the DCSP symbol DCSP addresses DCSP for DCSP the DCSP given DCSP module DCSP ' DCNL DCSP  DCSP  DCSP symbols = self.get_all_symbols(module) DCNL DCSP  DCSP  DCSP ret = {} DCNL DCSP  DCSP  DCSP for (_name, addr) in symbols: DCNL DCSP  DCSP  DCSP  DCSP ret[addr] = 1 DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP def _get_symbol_by_address(self, module, sym_address): DCNL DCSP  DCSP  DCSP ret = '' DCNL DCSP  DCSP  DCSP symtable = self.sys_map DCNL DCSP  DCSP  DCSP mod = symtable[module] DCNL DCSP  DCSP  DCSP for (name, addrs) in mod.items(): DCNL DCSP  DCSP  DCSP  DCSP for (addr, addr_type) in addrs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sym_address == (addr + self.shift_address)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret = name DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP def get_symbol_by_address(self, module, sym_address): DCNL DCSP  DCSP  DCSP key = ('%s|%d' % (module, sym_address)) DCNL DCSP  DCSP  DCSP if (key in self.sym_addr_cache): DCNL DCSP  DCSP  DCSP  DCSP ret = self.sym_addr_cache[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret = self._get_symbol_by_address(module, sym_address) DCNL DCSP  DCSP  DCSP  DCSP self.sym_addr_cache[key] = ret DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP def get_all_symbol_names(self, module='kernel'): DCNL DCSP  DCSP  DCSP symtable = self.sys_map DCNL DCSP  DCSP  DCSP if (module in symtable): DCNL DCSP  DCSP  DCSP  DCSP ret = symtable[module].keys() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP debug.error('get_all_symbol_names DCSP called DCSP on DCSP non-existent DCSP module') DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP def get_next_symbol_address(self, sym_name, module='kernel'): DCNL DCSP  DCSP  DCSP '\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP is DCSP used DCSP to DCSP find DCSP the DCSP address DCSP of DCSP the DCSP next DCSP symbol DCSP in DCSP the DCSP profile\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP For DCSP some DCSP data DCSP structures, DCSP we DCSP cannot DCSP determine DCSP their DCSP size DCSP automaticlaly DCSP so DCSP this\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can DCSP be DCSP used DCSP to DCSP figure DCSP it DCSP out DCSP on DCSP the DCSP fly\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP high_addr = 18446744073709551615L DCNL DCSP  DCSP  DCSP table_addr = self.get_symbol(sym_name, module=module) DCNL DCSP  DCSP  DCSP addrs = self.get_all_addresses(module=module) DCNL DCSP  DCSP  DCSP for addr in addrs.keys(): DCNL DCSP  DCSP  DCSP  DCSP if (table_addr < addr < high_addr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP high_addr = addr DCNL DCSP  DCSP  DCSP return high_addr DCNL DCSP  DCSP def get_symbol(self, sym_name, nm_type='', module='kernel'): DCNL DCSP  DCSP  DCSP \"Gets DCSP a DCSP symbol DCSP out DCSP of DCSP the DCSP profile\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sym_name DCSP -> DCSP name DCSP of DCSP the DCSP symbol\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP nm_tyes DCSP  DCSP -> DCSP types DCSP as DCSP defined DCSP by DCSP 'nm' DCSP (man DCSP nm DCSP for DCSP examples)\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP module DCSP  DCSP  DCSP -> DCSP which DCSP module DCSP to DCSP get DCSP the DCSP symbol DCSP from, DCSP default DCSP is DCSP kernel, DCSP otherwise DCSP can DCSP be DCSP any DCSP name DCSP seen DCSP in DCSP 'lsmod'\\n DCSP  DCSP  DCSP  DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP fixes DCSP a DCSP few DCSP issues DCSP from DCSP the DCSP old DCSP static DCSP hash DCSP table DCSP method:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 1) DCSP Conflicting DCSP symbols DCSP can DCSP be DCSP handled, DCSP if DCSP a DCSP symbol DCSP is DCSP found DCSP to DCSP conflict DCSP on DCSP any DCSP profile, DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP then DCSP the DCSP plugin DCSP will DCSP need DCSP to DCSP provide DCSP the DCSP nm_type DCSP to DCSP differentiate, DCSP otherwise DCSP the DCSP plugin DCSP will DCSP be DCSP errored DCSP out\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 2) DCSP Can DCSP handle DCSP symbols DCSP gathered DCSP from DCSP modules DCSP on DCSP disk DCSP as DCSP well DCSP from DCSP the DCSP static DCSP kernel\\n DCSP  DCSP  DCSP  DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP symtable DCSP is DCSP stored DCSP as DCSP a DCSP hash DCSP table DCSP of:\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP symtable[module][sym_name] DCSP = DCSP [(symbol DCSP address, DCSP symbol DCSP type), DCSP (symbol DCSP addres, DCSP symbol DCSP type), DCSP ...]\\n DCSP  DCSP  DCSP  DCSP \\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP function DCSP has DCSP overly DCSP verbose DCSP error DCSP checking DCSP on DCSP purpose...\\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \" DCNL DCSP  DCSP  DCSP symtable = self.sys_map DCNL DCSP  DCSP  DCSP ret = None DCNL DCSP  DCSP  DCSP if (module in symtable): DCNL DCSP  DCSP  DCSP  DCSP mod = symtable[module] DCNL DCSP  DCSP  DCSP  DCSP if (sym_name in mod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sym_list = mod[sym_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(sym_list) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (nm_type == ''): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP debug.debug('Requested DCSP symbol DCSP {0:s} DCSP in DCSP module DCSP {1:s} DCSP has DCSP multiple DCSP definitions DCSP and DCSP no DCSP type DCSP given\\n'.format(sym_name, module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for (addr, stype) in sym_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (stype == nm_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret = addr DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ret == None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP debug.error('Requested DCSP symbol DCSP {0:s} DCSP in DCSP module DCSP {1:s} DCSP could DCSP not DCSP be DCSP found\\n'.format(sym_name, module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret = sym_list[0][0] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP debug.debug('Requested DCSP symbol DCSP {0:s} DCSP not DCSP found DCSP in DCSP module DCSP {1:s}\\n'.format(sym_name, module)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP debug.info('Requested DCSP module DCSP {0:s} DCSP not DCSP found DCSP in DCSP symbol DCSP table\\n'.format(module)) DCNL DCSP  DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP  DCSP ret = (ret + self.shift_address) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP def get_symbol_type(self, sym_name, nm_type='', module='kernel'): DCNL DCSP  DCSP  DCSP symtable = self.sys_map DCNL DCSP  DCSP  DCSP ret = None DCNL DCSP  DCSP  DCSP if (module in symtable): DCNL DCSP  DCSP  DCSP  DCSP mod = symtable[module] DCNL DCSP  DCSP  DCSP  DCSP if (sym_name in mod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sym_list = mod[sym_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(sym_list) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (nm_type == ''): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP debug.debug('Requested DCSP symbol DCSP {0:s} DCSP in DCSP module DCSP {1:s} DCSP has DCSP multiple DCSP definitions DCSP and DCSP no DCSP type DCSP given\\n'.format(sym_name, module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for (addr, stype) in sym_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (stype == nm_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret = addr DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ret == None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP debug.error('Requested DCSP symbol DCSP {0:s} DCSP in DCSP module DCSP {1:s} DCSP could DCSP not DCSP be DCSP found\\n'.format(sym_name, module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret = sym_list[0][1] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP debug.debug('Requested DCSP symbol DCSP {0:s} DCSP not DCSP found DCSP in DCSP module DCSP {1:s}\\n'.format(sym_name, module)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP debug.info('Requested DCSP module DCSP {0:s} DCSP not DCSP found DCSP in DCSP symbol DCSP table\\n'.format(module)) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP cls = AbstractLinuxProfile DCNL DCSP cls.__name__ = (('Linux' + profilename.replace('.', '_')) + arch) DCNL DCSP return cls\n", "intent": "takes in a zip file .\n", "question_id": 1925}, {"snippet": "@command(usage='concurrently DCSP download DCSP tasks DCSP in DCSP aria2') DCNL @command_line_parser() DCNL @with_parser(parse_login) DCNL @command_line_value('max-concurrent-downloads', alias='j', default=get_config('aria2-j', '5')) DCNL def download_aria2(args): DCNL  DCSP aria2_conf = export_aria2_conf(args) DCNL DCSP import platform DCNL DCSP if (platform.system() == 'Windows'): DCNL DCSP  DCSP download_aria2_temp(aria2_conf, args.max_concurrent_downloads) DCNL DCSP else: DCNL DCSP  DCSP download_aria2_stdin(aria2_conf, args.max_concurrent_downloads)\n", "intent": "usage: lx download-aria2 -j 5 [id|name] .\n", "question_id": 1926}, {"snippet": "def process_handler(cmd, callback, stderr=subprocess.PIPE): DCNL  DCSP sys.stdout.flush() DCNL DCSP sys.stderr.flush() DCNL DCSP close_fds = (sys.platform != 'win32') DCNL DCSP shell = isinstance(cmd, str) DCNL DCSP executable = None DCNL DCSP if (shell and (os.name == 'posix') and ('SHELL' in os.environ)): DCNL DCSP  DCSP executable = os.environ['SHELL'] DCNL DCSP p = subprocess.Popen(cmd, shell=shell, executable=executable, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=stderr, close_fds=close_fds) DCNL DCSP try: DCNL DCSP  DCSP out = callback(p) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP print '^C' DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP  DCSP sys.stderr.flush() DCNL DCSP  DCSP out = None DCNL DCSP finally: DCNL DCSP  DCSP if (p.returncode is None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP p.terminate() DCNL DCSP  DCSP  DCSP  DCSP p.poll() DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (p.returncode is None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP p.kill() DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return out\n", "intent": "open a command in a shell subprocess and execute a callback .\n", "question_id": 1927}, {"snippet": "def mkdir_p(path): DCNL  DCSP try: DCNL DCSP  DCSP makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise\n", "intent": "emulates mkdir -p behavior .\n", "question_id": 1928}, {"snippet": "def get_number_of_parts(xml_source): DCNL  DCSP parts_size = {} DCNL DCSP parts_names = [] DCNL DCSP root = fromstring(xml_source) DCNL DCSP heading_pairs = root.find(QName('http://schemas.openxmlformats.org/officeDocument/2006/extended-properties', 'HeadingPairs').text) DCNL DCSP vector = heading_pairs.find(QName(NAMESPACES['vt'], 'vector').text) DCNL DCSP children = vector.getchildren() DCNL DCSP for child_id in range(0, len(children), 2): DCNL DCSP  DCSP part_name = children[child_id].find(QName(NAMESPACES['vt'], 'lpstr').text).text DCNL DCSP  DCSP if (not (part_name in parts_names)): DCNL DCSP  DCSP  DCSP parts_names.append(part_name) DCNL DCSP  DCSP part_size = int(children[(child_id + 1)].find(QName(NAMESPACES['vt'], 'i4').text).text) DCNL DCSP  DCSP parts_size[part_name] = part_size DCNL DCSP return (parts_size, parts_names)\n", "intent": "get a list of contents of the workbook .\n", "question_id": 1929}, {"snippet": "def detect(agent, fill_none=False): DCNL  DCSP result = dict(platform=dict(name=None, version=None)) DCNL DCSP _suggested_detectors = [] DCNL DCSP for info_type in detectorshub: DCNL DCSP  DCSP detectors = (_suggested_detectors or detectorshub[info_type]) DCNL DCSP  DCSP for detector in detectors: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ret = detector.detect(agent, result) DCNL DCSP  DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP  DCSP ret = False DCNL DCSP  DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP  DCSP if (detector.prefs and (not detector._suggested_detectors)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _suggested_detectors = detectorshub.reorderByPrefs(detectors, detector.prefs.get(info_type)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP detector._suggested_detectors = _suggested_detectors DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP if fill_none: DCNL DCSP  DCSP attrs_d = {'name': None, 'version': None} DCNL DCSP  DCSP for key in ('os', 'browser'): DCNL DCSP  DCSP  DCSP if (key not in result): DCNL DCSP  DCSP  DCSP  DCSP result[key] = attrs_d DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in attrs_d.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result[k] = v DCNL DCSP return result\n", "intent": "fill_none: if name/version is not detected respective key is still added to the result with value none .\n", "question_id": 1930}, {"snippet": "def __virtual__(): DCNL  DCSP return ('tomcat' if ('tomcat.status' in __salt__) else False)\n", "intent": "load if the module tomcat exists .\n", "question_id": 1931}, {"snippet": "def set_cookie(response, name, value, expiry_seconds=None, secure=False): DCNL  DCSP if (expiry_seconds is None): DCNL DCSP  DCSP expiry_seconds = (((90 * 24) * 60) * 60) DCNL DCSP expires = datetime.strftime((datetime.utcnow() + timedelta(seconds=expiry_seconds)), u'%a, DCSP %d-%b-%Y DCSP %H:%M:%S DCSP GMT') DCNL DCSP try: DCNL DCSP  DCSP response.set_cookie(name, value, expires=expires, secure=secure) DCNL DCSP except (KeyError, TypeError): DCNL DCSP  DCSP response.set_cookie(name.encode(u'utf-8'), value, expires=expires, secure=secure)\n", "intent": "set cookie wrapper that allows number of seconds to be given as the expiry time .\n", "question_id": 1932}, {"snippet": "@pytest.mark.network DCNL def test_cleanup_after_install_editable_from_hg(script, tmpdir): DCNL  DCSP script.pip('install', '-e', ('%s#egg=ScriptTest' % local_checkout('hg+https://bitbucket.org/ianb/scripttest', tmpdir.join('cache'))), expect_error=True) DCNL DCSP build = (script.venv_path / 'build') DCNL DCSP src = (script.venv_path / 'src') DCNL DCSP assert (not exists(build)), ('build/ DCSP dir DCSP still DCSP exists: DCSP %s' % build) DCNL DCSP assert exists(src), (\"expected DCSP src/ DCSP dir DCSP doesn't DCSP exist: DCSP %s\" % src) DCNL DCSP script.assert_no_temp()\n", "intent": "test clean up after cloning from mercurial .\n", "question_id": 1933}, {"snippet": "def multinomial_helper(random_state, n, pvals, size): DCNL  DCSP if (size is not None): DCNL DCSP  DCSP ndim = len(size) DCNL DCSP else: DCNL DCSP  DCSP ndim = max(n.ndim, (pvals.ndim - 1)) DCNL DCSP if (n.ndim > ndim): DCNL DCSP  DCSP raise ValueError(('n.ndim DCSP (%i) DCSP should DCSP not DCSP be DCSP larger DCSP than DCSP len(size) DCSP (%i)' % (n.ndim, ndim)), n, size) DCNL DCSP if (n.ndim < ndim): DCNL DCSP  DCSP n = n.reshape((((1,) * (ndim - n.ndim)) + n.shape)) DCNL DCSP if ((pvals.ndim - 1) > ndim): DCNL DCSP  DCSP raise ValueError(('pvals.ndim-1 DCSP (%i) DCSP should DCSP not DCSP be DCSP larger DCSP than DCSP len(size) DCSP (%i)' % ((pvals.ndim - 1), ndim)), pvals, size) DCNL DCSP if ((pvals.ndim - 1) < ndim): DCNL DCSP  DCSP pvals = pvals.reshape((((1,) * ((ndim - pvals.ndim) + 1)) + pvals.shape)) DCNL DCSP if (size is not None): DCNL DCSP  DCSP size = tuple(size) DCNL DCSP else: DCNL DCSP  DCSP size = () DCNL DCSP  DCSP for dim in xrange(ndim): DCNL DCSP  DCSP  DCSP dim_len = max(n.shape[dim], pvals.shape[dim]) DCNL DCSP  DCSP  DCSP size = (size + (dim_len,)) DCNL DCSP out_size = (size + (pvals.shape[(-1)],)) DCNL DCSP out = numpy.ndarray(out_size) DCNL DCSP broadcast_ind = _generate_broadcasting_indices(size, n.shape, pvals.shape[:(-1)]) DCNL DCSP assert (pvals.min() >= 0) DCNL DCSP for (mi, ni, pi) in zip(*broadcast_ind): DCNL DCSP  DCSP pvi = pvals[pi] DCNL DCSP  DCSP pisum = numpy.sum(pvi) DCNL DCSP  DCSP if (1.0 < pisum < (1.0 + 1e-05)): DCNL DCSP  DCSP  DCSP pvi = (pvi * (1.0 - 5e-05)) DCNL DCSP  DCSP  DCSP pisum = numpy.sum(pvi) DCNL DCSP  DCSP elif (pvi[(-1)] < 5e-05): DCNL DCSP  DCSP  DCSP pvi = (pvi * (1.0 - 5e-05)) DCNL DCSP  DCSP  DCSP pisum = numpy.sum(pvi) DCNL DCSP  DCSP assert (pisum <= 1.0), pisum DCNL DCSP  DCSP out[mi] = random_state.multinomial(n=n[ni], pvals=pvi.astype('float64')) DCNL DCSP return out\n", "intent": "helper function drawing from multinomial distributions .\n", "question_id": 1934}, {"snippet": "def getCraftedText(fileName, text='', repository=None): DCNL  DCSP return getCraftedTextFromText(archive.getTextIfEmpty(fileName, text), repository)\n", "intent": "inset the preface file or text .\n", "question_id": 1935}, {"snippet": "def _execute_with_retries(conn, function, **kwargs): DCNL  DCSP r = {} DCNL DCSP max_attempts = 18 DCNL DCSP max_retry_delay = 10 DCNL DCSP for attempt in range(max_attempts): DCNL DCSP  DCSP log.info('attempt: DCSP {0} DCSP function: DCSP {1}'.format(attempt, function)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fn = getattr(conn, function) DCNL DCSP  DCSP  DCSP r['result'] = fn(**kwargs) DCNL DCSP  DCSP  DCSP return r DCNL DCSP  DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP  DCSP error_code = e.response['Error']['Code'] DCNL DCSP  DCSP  DCSP if (('LimitExceededException' in error_code) or ('ResourceInUseException' in error_code)): DCNL DCSP  DCSP  DCSP  DCSP log.debug('Retrying DCSP due DCSP to DCSP AWS DCSP exception DCSP {0}'.format(e)) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(_jittered_backoff(attempt, max_retry_delay)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP r['error'] = e.response['Error'] DCNL DCSP  DCSP  DCSP  DCSP r['result'] = None DCNL DCSP  DCSP  DCSP  DCSP return r DCNL DCSP r['error'] = 'Tried DCSP to DCSP execute DCSP function DCSP {0} DCSP {1} DCSP times, DCSP but DCSP was DCSP unable'.format(function, max_attempts) DCNL DCSP return r\n", "intent": "retry if were rate limited by aws or blocked by another call .\n", "question_id": 1936}, {"snippet": "def Not(query): DCNL  DCSP return ('(NOT DCSP %s)' % (query,))\n", "intent": "the negation of a query .\n", "question_id": 1937}, {"snippet": "def _get_ecg_channel_index(ch_name, inst): DCNL  DCSP if (ch_name is None): DCNL DCSP  DCSP ecg_idx = pick_types(inst.info, meg=False, eeg=False, stim=False, eog=False, ecg=True, emg=False, ref_meg=False, exclude='bads') DCNL DCSP else: DCNL DCSP  DCSP if (ch_name not in inst.ch_names): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP not DCSP in DCSP channel DCSP list DCSP (%s)' % (ch_name, inst.ch_names))) DCNL DCSP  DCSP ecg_idx = pick_channels(inst.ch_names, include=[ch_name]) DCNL DCSP if (len(ecg_idx) == 0): DCNL DCSP  DCSP return None DCNL DCSP if (len(ecg_idx) > 1): DCNL DCSP  DCSP warn(('More DCSP than DCSP one DCSP ECG DCSP channel DCSP found. DCSP Using DCSP only DCSP %s.' % inst.ch_names[ecg_idx[0]])) DCNL DCSP return ecg_idx[0]\n", "intent": "get ecg channel index .\n", "question_id": 1938}, {"snippet": "@removals.remove(message='keystoneclient DCSP auth DCSP plugins DCSP are DCSP deprecated. DCSP Use DCSP keystoneauth.', version='2.1.0', removal_version='3.0.0') DCNL def register_conf_options(conf, group): DCNL  DCSP conf.register_opt(_AUTH_SECTION_OPT, group=group) DCNL DCSP if conf[group].auth_section: DCNL DCSP  DCSP group = conf[group].auth_section DCNL DCSP conf.register_opt(_AUTH_PLUGIN_OPT, group=group)\n", "intent": "register the oslo_config options that are needed for a plugin .\n", "question_id": 1939}, {"snippet": "def img_as_uint(image, force_copy=False): DCNL  DCSP return convert(image, np.uint16, force_copy)\n", "intent": "convert an image to 16-bit unsigned integer format .\n", "question_id": 1940}, {"snippet": "def sha1_mangle_key(key): DCNL  DCSP return sha1(key).hexdigest()\n", "intent": "a sha1 key mangler .\n", "question_id": 1941}, {"snippet": "def test_account_create_should_fail(): DCNL  DCSP credentials = [((c['user'], c['password']), e) for (c, e) in broken_credentials] DCNL DCSP for ((email, password), error) in credentials: DCNL DCSP  DCSP error_obj = getattr(errors, error) DCNL DCSP  DCSP with session_scope() as db_session: DCNL DCSP  DCSP  DCSP with pytest.raises(error_obj): DCNL DCSP  DCSP  DCSP  DCSP create_account(db_session, email, password)\n", "intent": "test that creation fails with appropriate errors .\n", "question_id": 1942}, {"snippet": "def command(name=None, cls=None, **attrs): DCNL  DCSP if (cls is None): DCNL DCSP  DCSP cls = Command DCNL DCSP def decorator(f): DCNL DCSP  DCSP cmd = _make_command(f, name, attrs, cls) DCNL DCSP  DCSP cmd.__doc__ = f.__doc__ DCNL DCSP  DCSP return cmd DCNL DCSP return decorator\n", "intent": "creates a new :class:command and uses the decorated function as callback .\n", "question_id": 1943}, {"snippet": "def should_skip_file(name): DCNL  DCSP if name.startswith('.'): DCNL DCSP  DCSP return 'Skipping DCSP hidden DCSP file DCSP %(filename)s' DCNL DCSP if name.endswith(('~', '.bak')): DCNL DCSP  DCSP return 'Skipping DCSP backup DCSP file DCSP %(filename)s' DCNL DCSP if name.endswith(('.pyc', '.pyo')): DCNL DCSP  DCSP return (('Skipping DCSP %s DCSP file DCSP ' % os.path.splitext(name)[1]) + '%(filename)s') DCNL DCSP if name.endswith('$py.class'): DCNL DCSP  DCSP return 'Skipping DCSP $py.class DCSP file DCSP %(filename)s' DCNL DCSP if (name in ('CVS', '_darcs')): DCNL DCSP  DCSP return 'Skipping DCSP version DCSP control DCSP directory DCSP %(filename)s' DCNL DCSP return None\n", "intent": "checks if a file should be skipped based on its name .\n", "question_id": 1944}, {"snippet": "def init(image_dir): DCNL  DCSP defaults = {variable_name: os.path.join(image_dir, filename) for (variable_name, filename) in _image_details} DCNL DCSP globals().update(defaults)\n", "intent": "initalize the images from the default directory path .\n", "question_id": 1945}, {"snippet": "def openssh_tunnel(lport, rport, server, remoteip='127.0.0.1', keyfile=None, password=None, timeout=60): DCNL  DCSP if (pexpect is None): DCNL DCSP  DCSP raise ImportError('pexpect DCSP unavailable, DCSP use DCSP paramiko_tunnel') DCNL DCSP ssh = 'ssh DCSP ' DCNL DCSP if keyfile: DCNL DCSP  DCSP ssh += ('-i DCSP ' + keyfile) DCNL DCSP if (':' in server): DCNL DCSP  DCSP (server, port) = server.split(':') DCNL DCSP  DCSP ssh += (' DCSP -p DCSP %s' % port) DCNL DCSP cmd = ('%s DCSP -O DCSP check DCSP %s' % (ssh, server)) DCNL DCSP (output, exitstatus) = pexpect.run(cmd, withexitstatus=True) DCNL DCSP if (not exitstatus): DCNL DCSP  DCSP pid = int(output[(output.find('(pid=') + 5):output.find(')')]) DCNL DCSP  DCSP cmd = ('%s DCSP -O DCSP forward DCSP -L DCSP 127.0.0.1:%i:%s:%i DCSP %s' % (ssh, lport, remoteip, rport, server)) DCNL DCSP  DCSP (output, exitstatus) = pexpect.run(cmd, withexitstatus=True) DCNL DCSP  DCSP if (not exitstatus): DCNL DCSP  DCSP  DCSP atexit.register(_stop_tunnel, cmd.replace('-O DCSP forward', '-O DCSP cancel', 1)) DCNL DCSP  DCSP  DCSP return pid DCNL DCSP cmd = ('%s DCSP -f DCSP -S DCSP none DCSP -L DCSP 127.0.0.1:%i:%s:%i DCSP %s DCSP sleep DCSP %i' % (ssh, lport, remoteip, rport, server, timeout)) DCNL DCSP env = os.environ.copy() DCNL DCSP env.pop('SSH_ASKPASS', None) DCNL DCSP ssh_newkey = 'Are DCSP you DCSP sure DCSP you DCSP want DCSP to DCSP continue DCSP connecting' DCNL DCSP tunnel = pexpect.spawn(cmd, env=env) DCNL DCSP failed = False DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP i = tunnel.expect([ssh_newkey, _password_pat], timeout=0.1) DCNL DCSP  DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP  DCSP raise SSHException(\"The DCSP authenticity DCSP of DCSP the DCSP host DCSP can't DCSP be DCSP established.\") DCNL DCSP  DCSP except pexpect.TIMEOUT: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except pexpect.EOF: DCNL DCSP  DCSP  DCSP if tunnel.exitstatus: DCNL DCSP  DCSP  DCSP  DCSP print(tunnel.exitstatus) DCNL DCSP  DCSP  DCSP  DCSP print(tunnel.before) DCNL DCSP  DCSP  DCSP  DCSP print(tunnel.after) DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError((\"tunnel DCSP '%s' DCSP failed DCSP to DCSP start\" % cmd)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return tunnel.pid DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if failed: DCNL DCSP  DCSP  DCSP  DCSP print('Password DCSP rejected, DCSP try DCSP again') DCNL DCSP  DCSP  DCSP  DCSP password = None DCNL DCSP  DCSP  DCSP if (password is None): DCNL DCSP  DCSP  DCSP  DCSP password = getpass((\"%s's DCSP password: DCSP \" % server)) DCNL DCSP  DCSP  DCSP tunnel.sendline(password) DCNL DCSP  DCSP  DCSP failed = True\n", "intent": "create an ssh tunnel using command-line ssh that connects port lport on this machine to localhost:rport on server .\n", "question_id": 1946}, {"snippet": "def check_success(ODBC_obj, ret): DCNL  DCSP if (ret not in (SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA)): DCNL DCSP  DCSP if isinstance(ODBC_obj, Cursor): DCNL DCSP  DCSP  DCSP ctrl_err(SQL_HANDLE_STMT, ODBC_obj.stmt_h, ret, ODBC_obj.ansi) DCNL DCSP  DCSP elif isinstance(ODBC_obj, Connection): DCNL DCSP  DCSP  DCSP ctrl_err(SQL_HANDLE_DBC, ODBC_obj.dbc_h, ret, ODBC_obj.ansi) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ctrl_err(SQL_HANDLE_ENV, ODBC_obj, ret, False)\n", "intent": "validate return value .\n", "question_id": 1947}, {"snippet": "def delete(name): DCNL  DCSP ret = {'name': name, 'result': True, 'changes': [], 'comment': ''} DCNL DCSP if info(name): DCNL DCSP  DCSP pythoncom.CoInitialize() DCNL DCSP  DCSP nt = win32com.client.Dispatch('AdsNameSpaces') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP compObj = nt.GetObject('', 'WinNT://.,computer') DCNL DCSP  DCSP  DCSP compObj.Delete('group', name) DCNL DCSP  DCSP  DCSP ret['changes'].append('Successfully DCSP removed DCSP group DCSP {0}'.format(name)) DCNL DCSP  DCSP except pywintypes.com_error as com_err: DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP if (len(com_err.excepinfo) >= 2): DCNL DCSP  DCSP  DCSP  DCSP friendly_error = com_err.excepinfo[2].rstrip('\\r\\n') DCNL DCSP  DCSP  DCSP ret['comment'] = 'Failed DCSP to DCSP remove DCSP group DCSP {0}. DCSP  DCSP {1}'.format(name, friendly_error) DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'The DCSP group DCSP {0} DCSP does DCSP not DCSP exists.'.format(name) DCNL DCSP return ret\n", "intent": "remove the named group cli example: .\n", "question_id": 1948}, {"snippet": "def _prefix_root(root, path, trailing=False): DCNL  DCSP return normpath(join(_norm_root(root), path.lstrip('/')), trailing=trailing)\n", "intent": "prepend a root to a path .\n", "question_id": 1949}, {"snippet": "def detect_labels_cloud_storage(uri): DCNL  DCSP vision_client = vision.Client() DCNL DCSP image = vision_client.image(source_uri=uri) DCNL DCSP labels = image.detect_labels() DCNL DCSP print 'Labels:' DCNL DCSP for label in labels: DCNL DCSP  DCSP print label.description\n", "intent": "detects labels in the file located in google cloud storage .\n", "question_id": 1950}, {"snippet": "def set_chassis_location(location, host=None, admin_username=None, admin_password=None): DCNL  DCSP return __execute_cmd('setsysinfo DCSP -c DCSP chassislocation DCSP {0}'.format(location), host=host, admin_username=admin_username, admin_password=admin_password)\n", "intent": "set the location of the chassis .\n", "question_id": 1951}, {"snippet": "def set_cached_content(content): DCNL  DCSP CONTENT_CACHE.set(unicode(content.location).encode('utf-8'), content, version=STATIC_CONTENT_VERSION)\n", "intent": "stores the given piece of content in the cache .\n", "question_id": 1952}, {"snippet": "def win32_utf8_argv(): DCNL  DCSP try: DCNL DCSP  DCSP from ctypes import POINTER, byref, cdll, c_int, windll DCNL DCSP  DCSP from ctypes.wintypes import LPCWSTR, LPWSTR DCNL DCSP  DCSP GetCommandLineW = cdll.kernel32.GetCommandLineW DCNL DCSP  DCSP GetCommandLineW.argtypes = [] DCNL DCSP  DCSP GetCommandLineW.restype = LPCWSTR DCNL DCSP  DCSP CommandLineToArgvW = windll.shell32.CommandLineToArgvW DCNL DCSP  DCSP CommandLineToArgvW.argtypes = [LPCWSTR, POINTER(c_int)] DCNL DCSP  DCSP CommandLineToArgvW.restype = POINTER(LPWSTR) DCNL DCSP  DCSP cmd = GetCommandLineW() DCNL DCSP  DCSP argc = c_int(0) DCNL DCSP  DCSP argv = CommandLineToArgvW(cmd, byref(argc)) DCNL DCSP  DCSP if (argc.value > 0): DCNL DCSP  DCSP  DCSP return [argv[i] for i in xrange(0, argc.value)] DCNL DCSP except Exception: DCNL DCSP  DCSP pass\n", "intent": "uses shell32 .\n", "question_id": 1953}, {"snippet": "def read_unsigned_var_int(file_obj): DCNL  DCSP result = 0 DCNL DCSP shift = 0 DCNL DCSP while True: DCNL DCSP  DCSP byte = struct.unpack('<B', file_obj.read(1))[0] DCNL DCSP  DCSP result |= ((byte & 127) << shift) DCNL DCSP  DCSP if ((byte & 128) == 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP shift += 7 DCNL DCSP return result\n", "intent": "read a value using the unsigned .\n", "question_id": 1954}, {"snippet": "def TYPPRICE(barDs, count): DCNL  DCSP return call_talib_with_hlc(barDs, count, talib.TYPPRICE)\n", "intent": "typical price .\n", "question_id": 1955}, {"snippet": "def safe_repr(value): DCNL  DCSP try: DCNL DCSP  DCSP return pydoc.text.repr(value) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return repr(value) DCNL DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP name = getattr(value, '__name__', None) DCNL DCSP  DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return safe_repr(name) DCNL DCSP  DCSP  DCSP  DCSP klass = getattr(value, '__class__', None) DCNL DCSP  DCSP  DCSP  DCSP if klass: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ('%s DCSP instance' % safe_repr(klass)) DCNL DCSP  DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP return 'UNRECOVERABLE DCSP REPR DCSP FAILURE'\n", "intent": "hopefully pretty robust repr equivalent .\n", "question_id": 1956}, {"snippet": "def ulp(x): DCNL  DCSP x = abs(float(x)) DCNL DCSP if (math.isnan(x) or math.isinf(x)): DCNL DCSP  DCSP return x DCNL DCSP n = struct.unpack('<q', struct.pack('<d', x))[0] DCNL DCSP x_next = struct.unpack('<d', struct.pack('<q', (n + 1)))[0] DCNL DCSP if math.isinf(x_next): DCNL DCSP  DCSP x_prev = struct.unpack('<d', struct.pack('<q', (n - 1)))[0] DCNL DCSP  DCSP return (x - x_prev) DCNL DCSP else: DCNL DCSP  DCSP return (x_next - x)\n", "intent": "return the value of the least significant bit of a float x .\n", "question_id": 1957}, {"snippet": "@manager.option('-a', '--accounts', dest='accounts', type=unicode, default=u'all') DCNL @manager.option('-m', '--monitors', dest='monitors', type=unicode, default=u'all') DCNL def find_changes(accounts, monitors): DCNL  DCSP monitor_names = _parse_tech_names(monitors) DCNL DCSP account_names = _parse_accounts(accounts) DCNL DCSP sm_find_changes(account_names, monitor_names)\n", "intent": "runs watchers .\n", "question_id": 1958}, {"snippet": "def decargs(arglist): DCNL  DCSP return [s.decode(_encoding()) for s in arglist]\n", "intent": "given a list of command-line argument bytestrings .\n", "question_id": 1959}, {"snippet": "def plot_10_by_10_images(images): DCNL  DCSP fig = plt.figure() DCNL DCSP images = [image[3:25, 3:25] for image in images] DCNL DCSP for x in range(10): DCNL DCSP  DCSP for y in range(10): DCNL DCSP  DCSP  DCSP ax = fig.add_subplot(10, 10, ((10 * y) + x)) DCNL DCSP  DCSP  DCSP ax.matshow(images[((10 * y) + x)], cmap=matplotlib.cm.binary) DCNL DCSP  DCSP  DCSP plt.xticks(np.array([])) DCNL DCSP  DCSP  DCSP plt.yticks(np.array([])) DCNL DCSP plt.show()\n", "intent": "plot 100 mnist images in a 10 by 10 table .\n", "question_id": 1960}, {"snippet": "def parse_accept_language_header(string, pattern='([a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})?)\\\\s*(;\\\\s*q\\\\s*=\\\\s*(1|0\\\\.[0-9]+))?'): DCNL  DCSP res = {} DCNL DCSP if (not string): DCNL DCSP  DCSP return None DCNL DCSP for match in re.finditer(pattern, string): DCNL DCSP  DCSP if (None == match.group(4)): DCNL DCSP  DCSP  DCSP q = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP q = match.group(4) DCNL DCSP  DCSP l = match.group(1).replace('-', '_') DCNL DCSP  DCSP if (len(l) == 2): DCNL DCSP  DCSP  DCSP l = l.lower() DCNL DCSP  DCSP elif (len(l) == 5): DCNL DCSP  DCSP  DCSP l = ((l.split('_')[0].lower() + '_') + l.split('_')[1].upper()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP l = None DCNL DCSP  DCSP if l: DCNL DCSP  DCSP  DCSP res[l] = int((100 * float(q))) DCNL DCSP return res\n", "intent": "parse a dict from an accept-language header string  example input: en-us .\n", "question_id": 1961}, {"snippet": "def getLinkLocalIPv6Address(): DCNL  DCSP addresses = getLinkLocalIPv6Addresses() DCNL DCSP if addresses: DCNL DCSP  DCSP return addresses[0] DCNL DCSP raise SkipTest('Link DCSP local DCSP IPv6 DCSP address DCSP unavailable')\n", "intent": "find and return a configured link local ipv6 address including a scope identifier using the % separation syntax .\n", "question_id": 1962}, {"snippet": "def _HashPassword(password, version, salt): DCNL  DCSP if (version == _PASSWORD_VERSION_MD5): DCNL DCSP  DCSP m = hashlib.md5() DCNL DCSP  DCSP m.update(password) DCNL DCSP  DCSP m.update(secrets.GetSecret('cookie_secret')) DCNL DCSP  DCSP hashed = m.digest() DCNL DCSP elif (version == _PASSWORD_VERSION_PBKDF2): DCNL DCSP  DCSP hashed = PBKDF2(password, base64.b64decode(salt), count=10000) DCNL DCSP return base64.b32encode(hashed)\n", "intent": "hashes the provided password according to the specified versions policy .\n", "question_id": 1963}, {"snippet": "def at_start(elem): DCNL  DCSP body = XPath('ancestor-or-self::h:body')(elem) DCNL DCSP if (not body): DCNL DCSP  DCSP return True DCNL DCSP body = body[0] DCNL DCSP ancestors = frozenset(XPath('ancestor::*')(elem)) DCNL DCSP for x in body.iter(): DCNL DCSP  DCSP if (x is elem): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (hasattr(getattr(x, 'tag', None), 'rpartition') and (x.tag.rpartition('}')[(-1)] in {'img', 'svg'})): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (isspace(getattr(x, 'text', None)) and ((x in ancestors) or isspace(getattr(x, 'tail', None)))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP return False DCNL DCSP return False\n", "intent": "return true if there is no content before elem .\n", "question_id": 1964}, {"snippet": "def esc(s, esc_chars): DCNL  DCSP if (not s): DCNL DCSP  DCSP return u'' DCNL DCSP for c in esc_chars: DCNL DCSP  DCSP esc_str = (u'\\\\' + c) DCNL DCSP  DCSP s = s.replace(c, esc_str) DCNL DCSP return s\n", "intent": "escape special characters .\n", "question_id": 1965}, {"snippet": "def get_api_client(api_config, student): DCNL  DCSP client_name = api_config.OAUTH2_CLIENT_NAME DCNL DCSP try: DCNL DCSP  DCSP client = Client.objects.get(name=client_name) DCNL DCSP except Client.DoesNotExist: DCNL DCSP  DCSP raise ImproperlyConfigured('OAuth2 DCSP Client DCSP with DCSP name DCSP [{}] DCSP does DCSP not DCSP exist.'.format(client_name)) DCNL DCSP scopes = ['email', 'profile'] DCNL DCSP expires_in = settings.OAUTH_ID_TOKEN_EXPIRATION DCNL DCSP jwt = JwtBuilder(student, secret=client.client_secret).build_token(scopes, expires_in, aud=client.client_id) DCNL DCSP return EdxRestApiClient(api_config.internal_api_url, jwt=jwt)\n", "intent": "create and configure an api client for authenticated http requests .\n", "question_id": 1966}, {"snippet": "def requote_uri(uri): DCNL  DCSP safe_with_percent = \"!#$%&'()*+,/:;=?@[]~\" DCNL DCSP safe_without_percent = \"!#$&'()*+,/:;=?@[]~\" DCNL DCSP try: DCNL DCSP  DCSP return quote(unquote_unreserved(uri), safe=safe_with_percent) DCNL DCSP except InvalidURL: DCNL DCSP  DCSP return quote(uri, safe=safe_without_percent)\n", "intent": "re-quote the given uri .\n", "question_id": 1967}, {"snippet": "def message_from_file(fp, *args, **kws): DCNL  DCSP from email.parser import Parser DCNL DCSP return Parser(*args, **kws).parse(fp)\n", "intent": "read a file and parse its contents into a message object model .\n", "question_id": 1968}, {"snippet": "def count_seqs_in_filepaths(fasta_filepaths, seq_counter=count_seqs): DCNL  DCSP total = 0 DCNL DCSP counts = [] DCNL DCSP inaccessible_filepaths = [] DCNL DCSP for fasta_filepath in fasta_filepaths: DCNL DCSP  DCSP if (fasta_filepath.endswith('.fastq') or fasta_filepath.endswith('.fq')): DCNL DCSP  DCSP  DCSP parser = partial(parse_fastq, enforce_qual_range=False) DCNL DCSP  DCSP elif (fasta_filepath.endswith('.tre') or fasta_filepath.endswith('.ph') or fasta_filepath.endswith('.ntree')): DCNL DCSP  DCSP  DCSP def parser(f): DCNL DCSP  DCSP  DCSP  DCSP t = DndParser(f, constructor=PhyloNode) DCNL DCSP  DCSP  DCSP  DCSP return zip(t.iterTips(), repeat('')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parser = parse_fasta DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP current_count = seq_counter(fasta_filepath, parser=parser) DCNL DCSP  DCSP  DCSP counts.append((current_count, fasta_filepath)) DCNL DCSP  DCSP  DCSP total += current_count[0] DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP inaccessible_filepaths.append(fasta_filepath) DCNL DCSP return (counts, total, inaccessible_filepaths)\n", "intent": "wrapper to apply seq_counter to fasta_filepaths fasta_filepaths: list of one or more fasta filepaths seq_counter: a function which takes a single filepath and returns the count of the number of sequences  -- this is parameterized to facilitate unit testing .\n", "question_id": 1969}, {"snippet": "def parseoptions(module, options): DCNL  DCSP options_dict = keydict() DCNL DCSP if options: DCNL DCSP  DCSP regex = re.compile('((?:[^,\"\\']|\"[^\"]*\"|\\'[^\\']*\\')+)') DCNL DCSP  DCSP parts = regex.split(options)[1:(-1)] DCNL DCSP  DCSP for part in parts: DCNL DCSP  DCSP  DCSP if ('=' in part): DCNL DCSP  DCSP  DCSP  DCSP (key, value) = part.split('=', 1) DCNL DCSP  DCSP  DCSP  DCSP options_dict[key] = value DCNL DCSP  DCSP  DCSP elif (part != ','): DCNL DCSP  DCSP  DCSP  DCSP options_dict[part] = None DCNL DCSP return options_dict\n", "intent": "reads a string containing ssh-key options and returns a dictionary of those options .\n", "question_id": 1970}, {"snippet": "def split_semicolon(line, maxsplit=None): DCNL  DCSP splitted_line = line.split(';') DCNL DCSP splitted_line_size = len(splitted_line) DCNL DCSP if ((maxsplit is None) or (0 > maxsplit)): DCNL DCSP  DCSP maxsplit = splitted_line_size DCNL DCSP i = 0 DCNL DCSP while (i < (splitted_line_size - 1)): DCNL DCSP  DCSP ends = splitted_line[i].endswith('\\\\') DCNL DCSP  DCSP if ends: DCNL DCSP  DCSP  DCSP splitted_line[i] = splitted_line[i][:(-1)] DCNL DCSP  DCSP if ((ends or (i >= maxsplit)) and (i < (splitted_line_size - 1))): DCNL DCSP  DCSP  DCSP splitted_line[i] = ';'.join([splitted_line[i], splitted_line[(i + 1)]]) DCNL DCSP  DCSP  DCSP del splitted_line[(i + 1)] DCNL DCSP  DCSP  DCSP splitted_line_size -= 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP return splitted_line\n", "intent": "split a line on semicolons characters but not on the escaped semicolons .\n", "question_id": 1971}, {"snippet": "@Profiler.profile DCNL def test_orm_commit(n): DCNL  DCSP for i in range(n): DCNL DCSP  DCSP session = Session(bind=engine) DCNL DCSP  DCSP session.add(Customer(name=('customer DCSP name DCSP %d' % i), description=('customer DCSP description DCSP %d' % i))) DCNL DCSP  DCSP session.commit()\n", "intent": "individual insert/commit pairs via the orm .\n", "question_id": 1972}, {"snippet": "def strip_prefix(device_name): DCNL  DCSP device_name = strip_dev(device_name) DCNL DCSP return (_pref.sub('', device_name) if device_name else device_name)\n", "intent": "remove both leading /dev/ and xvd or sd or vd or hd .\n", "question_id": 1973}, {"snippet": "def send_login(): DCNL  DCSP form_class = _security.passwordless_login_form DCNL DCSP if request.json: DCNL DCSP  DCSP form = form_class(MultiDict(request.json)) DCNL DCSP else: DCNL DCSP  DCSP form = form_class() DCNL DCSP if form.validate_on_submit(): DCNL DCSP  DCSP send_login_instructions(form.user) DCNL DCSP  DCSP if (request.json is None): DCNL DCSP  DCSP  DCSP do_flash(*get_message('LOGIN_EMAIL_SENT', email=form.user.email)) DCNL DCSP if request.json: DCNL DCSP  DCSP return _render_json(form) DCNL DCSP return _security.render_template(config_value('SEND_LOGIN_TEMPLATE'), send_login_form=form, **_ctx('send_login'))\n", "intent": "view function that sends login instructions for passwordless login .\n", "question_id": 1974}, {"snippet": "def _expand_cookie_path(protocolinfo_response, pid_resolver, pid_resolution_arg): DCNL  DCSP cookie_path = protocolinfo_response.cookie_path DCNL DCSP if (cookie_path and (not os.path.isabs(cookie_path))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tor_pid = pid_resolver(pid_resolution_arg) DCNL DCSP  DCSP  DCSP if (not tor_pid): DCNL DCSP  DCSP  DCSP  DCSP raise IOError('pid DCSP lookup DCSP failed') DCNL DCSP  DCSP  DCSP tor_cwd = stem.util.system.cwd(tor_pid) DCNL DCSP  DCSP  DCSP if (not tor_cwd): DCNL DCSP  DCSP  DCSP  DCSP raise IOError('cwd DCSP lookup DCSP failed') DCNL DCSP  DCSP  DCSP cookie_path = stem.util.system.expand_path(cookie_path, tor_cwd) DCNL DCSP  DCSP except IOError as exc: DCNL DCSP  DCSP  DCSP resolver_labels = {stem.util.system.pid_by_name: ' DCSP by DCSP name', stem.util.system.pid_by_port: ' DCSP by DCSP port', stem.util.system.pid_by_open_file: ' DCSP by DCSP socket DCSP file'} DCNL DCSP  DCSP  DCSP pid_resolver_label = resolver_labels.get(pid_resolver, '') DCNL DCSP  DCSP  DCSP log.debug(('unable DCSP to DCSP expand DCSP relative DCSP tor DCSP cookie DCSP path%s: DCSP %s' % (pid_resolver_label, exc))) DCNL DCSP protocolinfo_response.cookie_path = cookie_path\n", "intent": "attempts to expand a relative cookie path with the given pid resolver .\n", "question_id": 1975}, {"snippet": "def parse_response_for_async_op(response): DCNL  DCSP if (response is None): DCNL DCSP  DCSP return None DCNL DCSP result = AsynchronousOperationResult() DCNL DCSP if response.headers: DCNL DCSP  DCSP for (name, value) in response.headers: DCNL DCSP  DCSP  DCSP if (name.lower() == 'x-ms-request-id'): DCNL DCSP  DCSP  DCSP  DCSP result.request_id = value DCNL DCSP return result\n", "intent": "extracts request id from response header .\n", "question_id": 1976}, {"snippet": "def _sff_read_seq_record(handle, number_of_flows_per_read, flow_chars, key_sequence, alphabet, trim=False): DCNL  DCSP read_header_fmt = '>2HI4H' DCNL DCSP read_header_size = struct.calcsize(read_header_fmt) DCNL DCSP read_flow_fmt = ('>%iH' % number_of_flows_per_read) DCNL DCSP read_flow_size = struct.calcsize(read_flow_fmt) DCNL DCSP (read_header_length, name_length, seq_len, clip_qual_left, clip_qual_right, clip_adapter_left, clip_adapter_right) = struct.unpack(read_header_fmt, handle.read(read_header_size)) DCNL DCSP if clip_qual_left: DCNL DCSP  DCSP clip_qual_left -= 1 DCNL DCSP if clip_adapter_left: DCNL DCSP  DCSP clip_adapter_left -= 1 DCNL DCSP if ((read_header_length < 10) or ((read_header_length % 8) != 0)): DCNL DCSP  DCSP raise ValueError(('Malformed DCSP read DCSP header, DCSP says DCSP length DCSP is DCSP %i' % read_header_length)) DCNL DCSP name = _bytes_to_string(handle.read(name_length)) DCNL DCSP padding = ((read_header_length - read_header_size) - name_length) DCNL DCSP if (handle.read(padding).count(_null) != padding): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP from Bio import BiopythonParserWarning DCNL DCSP  DCSP warnings.warn(('Your DCSP SFF DCSP file DCSP is DCSP invalid, DCSP post DCSP name DCSP %i DCSP byte DCSP padding DCSP region DCSP contained DCSP data' % padding), BiopythonParserWarning) DCNL DCSP flow_values = handle.read(read_flow_size) DCNL DCSP temp_fmt = ('>%iB' % seq_len) DCNL DCSP flow_index = handle.read(seq_len) DCNL DCSP seq = _bytes_to_string(handle.read(seq_len)) DCNL DCSP quals = list(struct.unpack(temp_fmt, handle.read(seq_len))) DCNL DCSP padding = ((read_flow_size + (seq_len * 3)) % 8) DCNL DCSP if padding: DCNL DCSP  DCSP padding = (8 - padding) DCNL DCSP  DCSP if (handle.read(padding).count(_null) != padding): DCNL DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP from Bio import BiopythonParserWarning DCNL DCSP  DCSP  DCSP warnings.warn(('Your DCSP SFF DCSP file DCSP is DCSP invalid, DCSP post DCSP quality DCSP %i DCSP byte DCSP padding DCSP region DCSP contained DCSP data' % padding), BiopythonParserWarning) DCNL DCSP clip_left = max(clip_qual_left, clip_adapter_left) DCNL DCSP if clip_qual_right: DCNL DCSP  DCSP if clip_adapter_right: DCNL DCSP  DCSP  DCSP clip_right = min(clip_qual_right, clip_adapter_right) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP clip_right = clip_qual_right DCNL DCSP elif clip_adapter_right: DCNL DCSP  DCSP clip_right = clip_adapter_right DCNL DCSP else: DCNL DCSP  DCSP clip_right = seq_len DCNL DCSP if trim: DCNL DCSP  DCSP if (clip_left >= clip_right): DCNL DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP from Bio import BiopythonParserWarning DCNL DCSP  DCSP  DCSP warnings.warn('Overlapping DCSP clip DCSP values DCSP in DCSP SFF DCSP record, DCSP trimmed DCSP to DCSP nothing', BiopythonParserWarning) DCNL DCSP  DCSP  DCSP seq = '' DCNL DCSP  DCSP  DCSP quals = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seq = seq[clip_left:clip_right].upper() DCNL DCSP  DCSP  DCSP quals = quals[clip_left:clip_right] DCNL DCSP  DCSP annotations = {} DCNL DCSP else: DCNL DCSP  DCSP if (clip_left >= clip_right): DCNL DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP from Bio import BiopythonParserWarning DCNL DCSP  DCSP  DCSP warnings.warn('Overlapping DCSP clip DCSP values DCSP in DCSP SFF DCSP record', BiopythonParserWarning) DCNL DCSP  DCSP  DCSP seq = seq.lower() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seq = ((seq[:clip_left].lower() + seq[clip_left:clip_right].upper()) + seq[clip_right:].lower()) DCNL DCSP  DCSP annotations = {'flow_values': struct.unpack(read_flow_fmt, flow_values), 'flow_index': struct.unpack(temp_fmt, flow_index), 'flow_chars': flow_chars, 'flow_key': key_sequence, 'clip_qual_left': clip_qual_left, 'clip_qual_right': clip_qual_right, 'clip_adapter_left': clip_adapter_left, 'clip_adapter_right': clip_adapter_right} DCNL DCSP if re.match(_valid_UAN_read_name, name): DCNL DCSP  DCSP annotations['time'] = _get_read_time(name) DCNL DCSP  DCSP annotations['region'] = _get_read_region(name) DCNL DCSP  DCSP annotations['coords'] = _get_read_xy(name) DCNL DCSP record = SeqRecord(Seq(seq, alphabet), id=name, name=name, description='', annotations=annotations) DCNL DCSP dict.__setitem__(record._per_letter_annotations, 'phred_quality', quals) DCNL DCSP return record\n", "intent": "parse the next read in the file .\n", "question_id": 1977}, {"snippet": "def relu__(x): DCNL  DCSP return T.switch((x < 0.0), 0.0, x)\n", "intent": "alternative relu implementation .\n", "question_id": 1978}, {"snippet": "def find_in_path(name, path): DCNL  DCSP for dir in path.split(os.pathsep): DCNL DCSP  DCSP binpath = pjoin(dir, name) DCNL DCSP  DCSP if os.path.exists(binpath): DCNL DCSP  DCSP  DCSP return os.path.abspath(binpath) DCNL DCSP return None\n", "intent": "find a file in a search path .\n", "question_id": 1979}, {"snippet": "def convert_coords(chunkx, chunkz): DCNL  DCSP return ((chunkx + chunkz), (chunkz - chunkx))\n", "intent": "takes a coordinate  where chunkx and chunkz are in the chunk coordinate system .\n", "question_id": 1980}, {"snippet": "def leave_transaction_management(): DCNL  DCSP thread_ident = thread.get_ident() DCNL DCSP if (state.has_key(thread_ident) and state[thread_ident]): DCNL DCSP  DCSP del state[thread_ident][(-1)] DCNL DCSP else: DCNL DCSP  DCSP raise TransactionManagementError(\"This DCSP code DCSP isn't DCSP under DCSP transaction DCSP management\") DCNL DCSP if dirty.get(thread_ident, False): DCNL DCSP  DCSP rollback() DCNL DCSP  DCSP raise TransactionManagementError('Transaction DCSP managed DCSP block DCSP ended DCSP with DCSP pending DCSP COMMIT/ROLLBACK') DCNL DCSP dirty[thread_ident] = False\n", "intent": "leaves transaction management for a running thread .\n", "question_id": 1981}, {"snippet": "def make_eye_loader(dates, sids): DCNL  DCSP return EyeLoader(TestingDataSet.columns, dates, sids)\n", "intent": "make a pipelineloader that emits np .\n", "question_id": 1982}, {"snippet": "def formatUnformattableEvent(event, error): DCNL  DCSP try: DCNL DCSP  DCSP return u'Unable DCSP to DCSP format DCSP event DCSP {event!r}: DCSP {error}'.format(event=event, error=error) DCNL DCSP except BaseException: DCNL DCSP  DCSP failure = Failure() DCNL DCSP  DCSP text = u', DCSP '.join((u' DCSP = DCSP '.join((safe_repr(key), safe_repr(value))) for (key, value) in event.items())) DCNL DCSP  DCSP return u'MESSAGE DCSP LOST: DCSP unformattable DCSP object DCSP logged: DCSP {error}\\nRecoverable DCSP data: DCSP {text}\\nException DCSP during DCSP formatting:\\n{failure}'.format(error=safe_repr(error), failure=failure, text=text)\n", "intent": "formats an event as a l{unicode} that describes the event generically and a formatting error .\n", "question_id": 1983}, {"snippet": "def decode(data): DCNL  DCSP return consume(LookaheadIterator(data))\n", "intent": "bdecodes data into python built-in types .\n", "question_id": 1984}, {"snippet": "def get_pkg_dir(package, required=True, ros_root=None, ros_package_path=None): DCNL  DCSP try: DCNL DCSP  DCSP penv = os.environ.copy() DCNL DCSP  DCSP if ros_root: DCNL DCSP  DCSP  DCSP ros_root = rospkg.environment._resolve_path(ros_root) DCNL DCSP  DCSP  DCSP penv[ROS_ROOT] = ros_root DCNL DCSP  DCSP elif (ROS_ROOT in os.environ): DCNL DCSP  DCSP  DCSP ros_root = os.environ[ROS_ROOT] DCNL DCSP  DCSP rospack = 'rospack' DCNL DCSP  DCSP if (ros_package_path is not None): DCNL DCSP  DCSP  DCSP ros_package_path = rospkg.environment._resolve_paths(ros_package_path) DCNL DCSP  DCSP  DCSP penv[ROS_PACKAGE_PATH] = ros_package_path DCNL DCSP  DCSP elif (ROS_PACKAGE_PATH in os.environ): DCNL DCSP  DCSP  DCSP ros_package_path = os.environ[ROS_PACKAGE_PATH] DCNL DCSP  DCSP if (not _pkg_dir_cache): DCNL DCSP  DCSP  DCSP _read_rospack_cache(_pkg_dir_cache, ros_root, ros_package_path) DCNL DCSP  DCSP if (package in _pkg_dir_cache): DCNL DCSP  DCSP  DCSP (dir_, rr, rpp) = _pkg_dir_cache[package] DCNL DCSP  DCSP  DCSP if ((rr == ros_root) and (rpp == ros_package_path)): DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(os.path.join(dir_, MANIFEST_FILE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return dir_ DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _invalidate_cache(_pkg_dir_cache) DCNL DCSP  DCSP (rpout, rperr) = Popen([rospack, 'find', package], stdout=PIPE, stderr=PIPE, env=penv).communicate() DCNL DCSP  DCSP pkg_dir = (rpout or '').strip() DCNL DCSP  DCSP if isinstance(pkg_dir, bytes): DCNL DCSP  DCSP  DCSP pkg_dir = pkg_dir.decode() DCNL DCSP  DCSP if (not pkg_dir): DCNL DCSP  DCSP  DCSP raise InvalidROSPkgException(('Cannot DCSP locate DCSP installation DCSP of DCSP package DCSP %s: DCSP %s. DCSP ROS_ROOT[%s] DCSP ROS_PACKAGE_PATH[%s]' % (package, rperr.strip(), ros_root, ros_package_path))) DCNL DCSP  DCSP pkg_dir = os.path.normpath(pkg_dir) DCNL DCSP  DCSP if (not os.path.exists(pkg_dir)): DCNL DCSP  DCSP  DCSP raise InvalidROSPkgException(('Cannot DCSP locate DCSP installation DCSP of DCSP package DCSP %s: DCSP [%s] DCSP is DCSP not DCSP a DCSP valid DCSP path. DCSP ROS_ROOT[%s] DCSP ROS_PACKAGE_PATH[%s]' % (package, pkg_dir, ros_root, ros_package_path))) DCNL DCSP  DCSP elif (not os.path.isdir(pkg_dir)): DCNL DCSP  DCSP  DCSP raise InvalidROSPkgException(('Package DCSP %s DCSP is DCSP invalid: DCSP file DCSP [%s] DCSP is DCSP in DCSP the DCSP way' % (package, pkg_dir))) DCNL DCSP  DCSP return pkg_dir DCNL DCSP except OSError as e: DCNL DCSP  DCSP if required: DCNL DCSP  DCSP  DCSP raise InvalidROSPkgException(('Environment DCSP configuration DCSP is DCSP invalid: DCSP cannot DCSP locate DCSP rospack DCSP (%s)' % e)) DCNL DCSP  DCSP return None DCNL DCSP except Exception as e: DCNL DCSP  DCSP if required: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return None\n", "intent": "locate directory package is stored in .\n", "question_id": 1985}, {"snippet": "def enter_standby(name, instance_ids, should_decrement_desired_capacity=False, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn_autoscaling_boto3(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP response = conn.enter_standby(InstanceIds=instance_ids, AutoScalingGroupName=name, ShouldDecrementDesiredCapacity=should_decrement_desired_capacity) DCNL DCSP except ClientError as e: DCNL DCSP  DCSP err = salt.utils.boto3.get_error(e) DCNL DCSP  DCSP if (e.response.get('Error', {}).get('Code') == 'ResourceNotFoundException'): DCNL DCSP  DCSP  DCSP return {'exists': False} DCNL DCSP  DCSP return {'error': err} DCNL DCSP return all(((activity['StatusCode'] != 'Failed') for activity in response['Activities']))\n", "intent": "switch desired instances to standby mode .\n", "question_id": 1986}, {"snippet": "def set_margin(layout, margin): DCNL  DCSP layout.setContentsMargins(margin, margin, margin, margin)\n", "intent": "set the content margins for a layout .\n", "question_id": 1987}, {"snippet": "def copy_location(new_node, old_node): DCNL  DCSP for attr in ('lineno', 'col_offset'): DCNL DCSP  DCSP if ((attr in old_node._attributes) and (attr in new_node._attributes) and hasattr(old_node, attr)): DCNL DCSP  DCSP  DCSP setattr(new_node, attr, getattr(old_node, attr)) DCNL DCSP return new_node\n", "intent": "copy source location  from *old_node* to *new_node* if possible .\n", "question_id": 1988}, {"snippet": "def find_caller(): DCNL  DCSP rv = ('(unknown DCSP file)', 0, '(unknown DCSP function)') DCNL DCSP try: DCNL DCSP  DCSP f = logging.currentframe().f_back DCNL DCSP  DCSP while hasattr(f, 'f_code'): DCNL DCSP  DCSP  DCSP co = f.f_code DCNL DCSP  DCSP  DCSP filename = os.path.normcase(co.co_filename) DCNL DCSP  DCSP  DCSP if (filename in (_srcfile, logging._srcfile)): DCNL DCSP  DCSP  DCSP  DCSP f = f.f_back DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP rv = (filename, f.f_lineno, co.co_name) DCNL DCSP  DCSP  DCSP break DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP return rv\n", "intent": "find the stack frame of the caller so that we can note the source file name .\n", "question_id": 1989}, {"snippet": "def atof(string, func=float): DCNL  DCSP ts = localeconv()['thousands_sep'] DCNL DCSP if ts: DCNL DCSP  DCSP string = string.replace(ts, '') DCNL DCSP dd = localeconv()['decimal_point'] DCNL DCSP if dd: DCNL DCSP  DCSP string = string.replace(dd, '.') DCNL DCSP return func(string)\n", "intent": "parses a string as a float according to the locale settings .\n", "question_id": 1990}, {"snippet": "def instance_type_extra_specs_delete(context, flavor_id, key): DCNL  DCSP IMPL.instance_type_extra_specs_delete(context, flavor_id, key)\n", "intent": "delete the given extra specs item .\n", "question_id": 1991}, {"snippet": "def _strip_module_name(mod): DCNL  DCSP if (mod.strip() == ''): DCNL DCSP  DCSP return False DCNL DCSP return mod.split()[0]\n", "intent": "return module name and strip configuration .\n", "question_id": 1992}, {"snippet": "@dispatch(Expr, Client) DCNL def compute_down(expr, ec, profiler_output=None, compute_kwargs=None, odo_kwargs=None, **kwargs): DCNL  DCSP from .server import to_tree DCNL DCSP kwargs = keymap(u8, kwargs) DCNL DCSP tree = to_tree(expr) DCNL DCSP serial = ec.serial DCNL DCSP if (profiler_output is not None): DCNL DCSP  DCSP kwargs[u'profile'] = True DCNL DCSP  DCSP kwargs[u'profiler_output'] = ':response' DCNL DCSP kwargs[u'compute_kwargs'] = keymap(u8, (compute_kwargs or {})) DCNL DCSP kwargs[u'odo_kwargs'] = keymap(u8, (odo_kwargs or {})) DCNL DCSP r = post(ec, '/compute', data=serial.dumps(assoc(kwargs, u'expr', tree)), auth=ec.auth, headers=mimetype(serial)) DCNL DCSP if (not ok(r)): DCNL DCSP  DCSP raise ValueError(('Bad DCSP response: DCSP %s' % reason(r))) DCNL DCSP response = serial.loads(content(r)) DCNL DCSP if (profiler_output is not None): DCNL DCSP  DCSP profiler_output.write(response[u'profiler_output']) DCNL DCSP return serial.data_loads(response[u'data'])\n", "intent": "compute down for blaze clients .\n", "question_id": 1993}, {"snippet": "def GetGlobalVSMacroEnv(vs_version): DCNL  DCSP env = {} DCNL DCSP if vs_version.Path(): DCNL DCSP  DCSP env['$(VSInstallDir)'] = vs_version.Path() DCNL DCSP  DCSP env['$(VCInstallDir)'] = (os.path.join(vs_version.Path(), 'VC') + '\\\\') DCNL DCSP dxsdk_dir = _FindDirectXInstallation() DCNL DCSP env['$(DXSDK_DIR)'] = (dxsdk_dir if dxsdk_dir else '') DCNL DCSP env['$(WDK_DIR)'] = os.environ.get('WDK_DIR', '') DCNL DCSP return env\n", "intent": "get a dict of variables mapping internal vs macro names to their gyp equivalents .\n", "question_id": 1994}, {"snippet": "def test_call_accepts_func_multi_pos_passes(): DCNL  DCSP @accepts(int, int, int) DCNL DCSP def foo(int_1, int_2, int_3): DCNL DCSP  DCSP pass DCNL DCSP t = time.time() DCNL DCSP for i in range(0, 10000): DCNL DCSP  DCSP foo(5, 6, 7) DCNL DCSP return (time.time() - t)\n", "intent": "calling an accepts-checked function: multi positional params .\n", "question_id": 1995}, {"snippet": "def register_rebroadcast_c_code(typ, code, version=()): DCNL  DCSP Rebroadcast.c_code_and_version[typ] = (code, version)\n", "intent": "tell rebroadcast how to generate c code for a theano type .\n", "question_id": 1996}, {"snippet": "def datetime_to_utc_timestamp(timeval): DCNL  DCSP if (timeval is not None): DCNL DCSP  DCSP return (timegm(timeval.utctimetuple()) + (timeval.microsecond / 1000000))\n", "intent": "converts a datetime instance to a timestamp .\n", "question_id": 1997}, {"snippet": "def collect_command(host, command, dest_path): DCNL  DCSP logging.info(\"Collecting DCSP '%s' DCSP ...\", command) DCNL DCSP devnull = open('/dev/null', 'w') DCNL DCSP try: DCNL DCSP  DCSP result = host.run(command, stdout_tee=devnull).stdout DCNL DCSP  DCSP utils.open_write_close(dest_path, result) DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.warning(\"Collection DCSP of DCSP '%s' DCSP failed:\\n%s\", command, e) DCNL DCSP finally: DCNL DCSP  DCSP devnull.close()\n", "intent": "collects the result of a command on the remote machine .\n", "question_id": 1998}, {"snippet": "def get_text_tag(tag, name, default): DCNL  DCSP if (tag is None): DCNL DCSP  DCSP return default DCNL DCSP t = tag.find(name) DCNL DCSP if ((t is not None) and (t.text is not None)): DCNL DCSP  DCSP return t.text DCNL DCSP else: DCNL DCSP  DCSP return default\n", "intent": "get the text of an xml tag .\n", "question_id": 1999}, {"snippet": "def load(file_, name='_pkl', use_cpickle=False, **kwargs): DCNL  DCSP file_.seek(0) DCNL DCSP if use_cpickle: DCNL DCSP  DCSP unpickler = cPickle.Unpickler DCNL DCSP else: DCNL DCSP  DCSP unpickler = pickle.Unpickler DCNL DCSP with tarfile.open(fileobj=file_, mode='r') as tar_file: DCNL DCSP  DCSP p = unpickler(tar_file.extractfile(tar_file.getmember(name)), **kwargs) DCNL DCSP  DCSP if ('_parameters' in tar_file.getnames()): DCNL DCSP  DCSP  DCSP p.persistent_load = _PersistentLoad(tar_file) DCNL DCSP  DCSP return p.load()\n", "intent": "loads an object saved using the dump function .\n", "question_id": 2000}, {"snippet": "def mean_lon_of_perigee(jd): DCNL  DCSP T = ((jd - jd1950) / 36525.0) DCNL DCSP p = (0.012, 1.65, 6190.67, 1015489.951) DCNL DCSP return (np.polyval(p, T) / 3600.0)\n", "intent": "computes the mean longitude of perigee of the earths orbit at the requested julian date .\n", "question_id": 2001}, {"snippet": "def _create_url_with_params(params=None, controller=None, action=None, extras=None): DCNL  DCSP if (not controller): DCNL DCSP  DCSP controller = c.controller DCNL DCSP if (not action): DCNL DCSP  DCSP action = c.action DCNL DCSP if (not extras): DCNL DCSP  DCSP extras = {} DCNL DCSP url = url_for(controller=controller, action=action, **extras) DCNL DCSP return _url_with_params(url, params)\n", "intent": "internal function for building urls with parameters .\n", "question_id": 2002}, {"snippet": "def get_jids(): DCNL  DCSP ret = {} DCNL DCSP for returner_ in __opts__[CONFIG_KEY]: DCNL DCSP  DCSP ret.update(_mminion().returners['{0}.get_jids'.format(returner_)]()) DCNL DCSP return ret\n", "intent": "return all job data from all returners .\n", "question_id": 2003}, {"snippet": "def _lower2upper(lb): DCNL  DCSP ub = np.zeros(lb.shape, lb.dtype) DCNL DCSP (nrow, ncol) = lb.shape DCNL DCSP for i in range(lb.shape[0]): DCNL DCSP  DCSP ub[((nrow - 1) - i), i:ncol] = lb[i, 0:(ncol - i)] DCNL DCSP  DCSP ub[((nrow - 1) - i), 0:i] = lb[i, (ncol - i):] DCNL DCSP return ub\n", "intent": "convert lower triangular banded matrix to upper banded form .\n", "question_id": 2004}, {"snippet": "def load_pkcs1_vectors(vector_data): DCNL  DCSP private_key_vector = None DCNL DCSP public_key_vector = None DCNL DCSP attr = None DCNL DCSP key = None DCNL DCSP example_vector = None DCNL DCSP examples = [] DCNL DCSP vectors = [] DCNL DCSP for line in vector_data: DCNL DCSP  DCSP if (line.startswith('# DCSP PSS DCSP Example') or line.startswith('# DCSP OAEP DCSP Example') or line.startswith('# DCSP PKCS#1 DCSP v1.5')): DCNL DCSP  DCSP  DCSP if example_vector: DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in six.iteritems(example_vector): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hex_str = ''.join(value).replace(' DCSP ', '').encode('ascii') DCNL DCSP  DCSP  DCSP  DCSP  DCSP example_vector[key] = hex_str DCNL DCSP  DCSP  DCSP  DCSP examples.append(example_vector) DCNL DCSP  DCSP  DCSP attr = None DCNL DCSP  DCSP  DCSP example_vector = collections.defaultdict(list) DCNL DCSP  DCSP if line.startswith('# DCSP Message'): DCNL DCSP  DCSP  DCSP attr = 'message' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('# DCSP Salt'): DCNL DCSP  DCSP  DCSP attr = 'salt' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('# DCSP Seed'): DCNL DCSP  DCSP  DCSP attr = 'seed' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('# DCSP Signature'): DCNL DCSP  DCSP  DCSP attr = 'signature' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('# DCSP Encryption'): DCNL DCSP  DCSP  DCSP attr = 'encryption' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (example_vector and line.startswith('# DCSP =============================================')): DCNL DCSP  DCSP  DCSP for (key, value) in six.iteritems(example_vector): DCNL DCSP  DCSP  DCSP  DCSP hex_str = ''.join(value).replace(' DCSP ', '').encode('ascii') DCNL DCSP  DCSP  DCSP  DCSP example_vector[key] = hex_str DCNL DCSP  DCSP  DCSP examples.append(example_vector) DCNL DCSP  DCSP  DCSP example_vector = None DCNL DCSP  DCSP  DCSP attr = None DCNL DCSP  DCSP elif (example_vector and line.startswith('#')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((attr is not None) and (example_vector is not None)): DCNL DCSP  DCSP  DCSP example_vector[attr].append(line.strip()) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (line.startswith('# DCSP Example') or line.startswith('# DCSP =============================================')): DCNL DCSP  DCSP  DCSP if key: DCNL DCSP  DCSP  DCSP  DCSP assert private_key_vector DCNL DCSP  DCSP  DCSP  DCSP assert public_key_vector DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in six.iteritems(public_key_vector): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hex_str = ''.join(value).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP  DCSP  DCSP public_key_vector[key] = int(hex_str, 16) DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in six.iteritems(private_key_vector): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hex_str = ''.join(value).replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP  DCSP  DCSP private_key_vector[key] = int(hex_str, 16) DCNL DCSP  DCSP  DCSP  DCSP private_key_vector['examples'] = examples DCNL DCSP  DCSP  DCSP  DCSP examples = [] DCNL DCSP  DCSP  DCSP  DCSP assert (private_key_vector['public_exponent'] == public_key_vector['public_exponent']) DCNL DCSP  DCSP  DCSP  DCSP assert (private_key_vector['modulus'] == public_key_vector['modulus']) DCNL DCSP  DCSP  DCSP  DCSP vectors.append((private_key_vector, public_key_vector)) DCNL DCSP  DCSP  DCSP public_key_vector = collections.defaultdict(list) DCNL DCSP  DCSP  DCSP private_key_vector = collections.defaultdict(list) DCNL DCSP  DCSP  DCSP key = None DCNL DCSP  DCSP  DCSP attr = None DCNL DCSP  DCSP if ((private_key_vector is None) or (public_key_vector is None)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.startswith('# DCSP Private DCSP key'): DCNL DCSP  DCSP  DCSP key = private_key_vector DCNL DCSP  DCSP elif line.startswith('# DCSP Public DCSP key'): DCNL DCSP  DCSP  DCSP key = public_key_vector DCNL DCSP  DCSP elif line.startswith('# DCSP Modulus:'): DCNL DCSP  DCSP  DCSP attr = 'modulus' DCNL DCSP  DCSP elif line.startswith('# DCSP Public DCSP exponent:'): DCNL DCSP  DCSP  DCSP attr = 'public_exponent' DCNL DCSP  DCSP elif line.startswith('# DCSP Exponent:'): DCNL DCSP  DCSP  DCSP if (key is public_key_vector): DCNL DCSP  DCSP  DCSP  DCSP attr = 'public_exponent' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (key is private_key_vector) DCNL DCSP  DCSP  DCSP  DCSP attr = 'private_exponent' DCNL DCSP  DCSP elif line.startswith('# DCSP Prime DCSP 1:'): DCNL DCSP  DCSP  DCSP attr = 'p' DCNL DCSP  DCSP elif line.startswith('# DCSP Prime DCSP 2:'): DCNL DCSP  DCSP  DCSP attr = 'q' DCNL DCSP  DCSP elif line.startswith('# DCSP Prime DCSP exponent DCSP 1:'): DCNL DCSP  DCSP  DCSP attr = 'dmp1' DCNL DCSP  DCSP elif line.startswith('# DCSP Prime DCSP exponent DCSP 2:'): DCNL DCSP  DCSP  DCSP attr = 'dmq1' DCNL DCSP  DCSP elif line.startswith('# DCSP Coefficient:'): DCNL DCSP  DCSP  DCSP attr = 'iqmp' DCNL DCSP  DCSP elif line.startswith('#'): DCNL DCSP  DCSP  DCSP attr = None DCNL DCSP  DCSP elif ((key is not None) and (attr is not None)): DCNL DCSP  DCSP  DCSP key[attr].append(line.strip()) DCNL DCSP return vectors\n", "intent": "loads data out of rsa pkcs #1 vector files .\n", "question_id": 2005}, {"snippet": "def download_webfile(url, filename, overwrite=False): DCNL  DCSP if (os.path.exists(filename) and (not overwrite)): DCNL DCSP  DCSP return DCNL DCSP if ('.' in url): DCNL DCSP  DCSP urlretrieve(url, filename) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP subprocess_call(['youtube-dl', url, '-o', filename]) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP raise OSError((e.message + '\\n DCSP A DCSP possible DCSP reason DCSP is DCSP that DCSP youtube-dl DCSP is DCSP not DCSP installed DCSP on DCSP your DCSP computer. DCSP Install DCSP it DCSP with DCSP  DCSP \"pip DCSP install DCSP youtube-dl\"'))\n", "intent": "small utility to download the file at url under name filename .\n", "question_id": 2006}, {"snippet": "def _authenticate_x509(credentials, sock_info): DCNL  DCSP query = SON([('authenticate', 1), ('mechanism', 'MONGODB-X509')]) DCNL DCSP if (credentials.username is not None): DCNL DCSP  DCSP query['user'] = credentials.username DCNL DCSP elif (sock_info.max_wire_version < 5): DCNL DCSP  DCSP raise ConfigurationError('A DCSP username DCSP is DCSP required DCSP for DCSP MONGODB-X509 DCSP authentication DCSP when DCSP connected DCSP to DCSP MongoDB DCSP versions DCSP older DCSP than DCSP 3.4.') DCNL DCSP sock_info.command('$external', query)\n", "intent": "authenticate using mongodb-x509 .\n", "question_id": 2007}, {"snippet": "def setup_platform(hass, config, add_devices, discovery_info=None): DCNL  DCSP netatmo = get_component('netatmo') DCNL DCSP data = NetAtmoData(netatmo.NETATMO_AUTH, config.get(CONF_STATION, None)) DCNL DCSP dev = [] DCNL DCSP import lnetatmo DCNL DCSP try: DCNL DCSP  DCSP if (CONF_MODULES in config): DCNL DCSP  DCSP  DCSP for (module_name, monitored_conditions) in config[CONF_MODULES].items(): DCNL DCSP  DCSP  DCSP  DCSP if (module_name not in data.get_module_names()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _LOGGER.error('Module DCSP name: DCSP \"%s\" DCSP not DCSP found', module_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP for variable in monitored_conditions: DCNL DCSP  DCSP  DCSP  DCSP  DCSP dev.append(NetAtmoSensor(data, module_name, variable)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for module_name in data.get_module_names(): DCNL DCSP  DCSP  DCSP  DCSP for variable in data.station_data.monitoredConditions(module_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dev.append(NetAtmoSensor(data, module_name, variable)) DCNL DCSP except lnetatmo.NoDevice: DCNL DCSP  DCSP return None DCNL DCSP add_devices(dev)\n", "intent": "setup the available netatmo weather sensors .\n", "question_id": 2008}, {"snippet": "def _zpklp2lp(z, p, k, wo=1): DCNL  DCSP degree = _relative_degree(z, p) DCNL DCSP z_lp = [(wo * z1) for z1 in z] DCNL DCSP p_lp = [(wo * p1) for p1 in p] DCNL DCSP k_lp = (k * (wo ** degree)) DCNL DCSP return (z_lp, p_lp, k_lp)\n", "intent": "transform a lowpass filter to a different cutoff frequency .\n", "question_id": 2009}, {"snippet": "def get_package_paths(package): DCNL  DCSP file_attr = get_module_file_attribute(package) DCNL DCSP pkg_dir = os.path.dirname(file_attr) DCNL DCSP pkg_base = remove_suffix(pkg_dir, package.replace('.', os.sep)) DCNL DCSP return (pkg_base, pkg_dir)\n", "intent": "given a package .\n", "question_id": 2010}, {"snippet": "def saltenviron(environ): DCNL  DCSP if ('__opts__' not in locals()): DCNL DCSP  DCSP import salt.config DCNL DCSP  DCSP __opts__ = salt.config.client_config(os.environ.get('SALT_MASTER_CONFIG', '/etc/salt/master')) DCNL DCSP environ['SALT_OPTS'] = __opts__ DCNL DCSP environ['SALT_APIClient'] = salt.netapi.NetapiClient(__opts__)\n", "intent": "make salts opts dict and the apiclient available in the wsgi environ .\n", "question_id": 2011}, {"snippet": "def destroy(name, call=None): DCNL  DCSP if (call == 'function'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP destroy DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -d, DCSP --destroy, DCSP -a DCSP or DCSP --action.') DCNL DCSP __utils__['cloud.fire_event']('event', 'destroying DCSP instance', 'salt/cloud/{0}/destroying'.format(name), args={'name': name}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP datacenter_id = get_datacenter_id() DCNL DCSP conn = get_conn() DCNL DCSP node = get_node(conn, name) DCNL DCSP conn.delete_server(datacenter_id=datacenter_id, server_id=node['id']) DCNL DCSP __utils__['cloud.fire_event']('event', 'destroyed DCSP instance', 'salt/cloud/{0}/destroyed'.format(name), args={'name': name}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP if (__opts__.get('update_cachedir', False) is True): DCNL DCSP  DCSP __utils__['cloud.delete_minion_cachedir'](name, __active_provider_name__.split(':')[0], __opts__) DCNL DCSP return True\n", "intent": "destroy a machine by name .\n", "question_id": 2012}, {"snippet": "def _scalar_to_format(value): DCNL  DCSP for type_ in (int, float, complex): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = type_(value) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP numpy_dtype_str = np.min_scalar_type(value).str DCNL DCSP numpy_dtype_str = numpy_dtype_str[1:] DCNL DCSP try: DCNL DCSP  DCSP fits_format = NUMPY2FITS[numpy_dtype_str] DCNL DCSP  DCSP return FITSUPCONVERTERS.get(fits_format, fits_format) DCNL DCSP except KeyError: DCNL DCSP  DCSP return ('A' + str(len(value)))\n", "intent": "given a scalar value or string .\n", "question_id": 2013}, {"snippet": "def never_cache(view_func): DCNL  DCSP @wraps(view_func) DCNL DCSP def _wrapped_view_func(request, *args, **kwargs): DCNL DCSP  DCSP response = view_func(request, *args, **kwargs) DCNL DCSP  DCSP add_never_cache_headers(response) DCNL DCSP  DCSP return response DCNL DCSP return _wrapped_view_func\n", "intent": "decorator that adds headers to a response so that it will never be cached .\n", "question_id": 2014}, {"snippet": "def avail_modules(desc=False): DCNL  DCSP cmd = u'Find-Module' DCNL DCSP modules = _pshell(cmd) DCNL DCSP names = [] DCNL DCSP if desc: DCNL DCSP  DCSP names = {} DCNL DCSP for module in modules: DCNL DCSP  DCSP if desc: DCNL DCSP  DCSP  DCSP names[module[u'Name']] = module[u'Description'] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP names.append(module[u'Name']) DCNL DCSP return names\n", "intent": "list available modules in registered powershell module repositories .\n", "question_id": 2015}, {"snippet": "def destroy(vm_, call=None): DCNL  DCSP destroy_opt = __opts__.get('destroy', False) DCNL DCSP profiles = __opts__.get('profiles', {}) DCNL DCSP profile = __opts__.get('profile', __opts__.get('internal_lxc_profile', [])) DCNL DCSP path = None DCNL DCSP if (profile and (profile in profiles)): DCNL DCSP  DCSP path = profiles[profile].get('path', None) DCNL DCSP action = __opts__.get('action', '') DCNL DCSP if ((action != 'destroy') and (not destroy_opt)): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP destroy DCSP action DCSP must DCSP be DCSP called DCSP with DCSP -d, DCSP --destroy, DCSP -a DCSP or DCSP --action.') DCNL DCSP if (not get_configured_provider()): DCNL DCSP  DCSP return DCNL DCSP ret = {'comment': '{0} DCSP was DCSP not DCSP found'.format(vm_), 'result': False} DCNL DCSP if _salt('lxc.info', vm_, path=path): DCNL DCSP  DCSP __utils__['cloud.fire_event']('event', 'destroying DCSP instance', 'salt/cloud/{0}/destroying'.format(vm_), args={'name': vm_, 'instance_id': vm_}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP  DCSP cret = _salt('lxc.destroy', vm_, stop=True, path=path) DCNL DCSP  DCSP ret['result'] = cret['result'] DCNL DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP ret['comment'] = '{0} DCSP was DCSP destroyed'.format(vm_) DCNL DCSP  DCSP  DCSP __utils__['cloud.fire_event']('event', 'destroyed DCSP instance', 'salt/cloud/{0}/destroyed'.format(vm_), args={'name': vm_, 'instance_id': vm_}, sock_dir=__opts__['sock_dir'], transport=__opts__['transport']) DCNL DCSP  DCSP  DCSP if (__opts__.get('update_cachedir', False) is True): DCNL DCSP  DCSP  DCSP  DCSP __utils__['cloud.delete_minion_cachedir'](vm_, __active_provider_name__.split(':')[0], __opts__) DCNL DCSP return ret\n", "intent": "destroy a lxc container .\n", "question_id": 2016}, {"snippet": "def make_gzip_middleware(app, global_conf, compress_level=6): DCNL  DCSP compress_level = int(compress_level) DCNL DCSP return middleware(app, compress_level=compress_level)\n", "intent": "wrap the middleware .\n", "question_id": 2017}, {"snippet": "def _TestAuthViewfinderUser(action, tester, user_dict, device_dict=None, user_cookie=None): DCNL  DCSP if ('email' in user_dict): DCNL DCSP  DCSP ident_dict = {'key': ('Email:%s' % user_dict['email']), 'authority': 'Viewfinder'} DCNL DCSP else: DCNL DCSP  DCSP ident_dict = {'key': ('Phone:%s' % user_dict['phone']), 'authority': 'Viewfinder'} DCNL DCSP response = _AuthViewfinderUser(tester, action, user_dict, ident_dict, device_dict, user_cookie) DCNL DCSP cookie_user_dict = tester.DecodeUserCookie(tester.GetCookieFromResponse(response)) DCNL DCSP if ((action != 'link') and (not ((action == 'login') and ('password' in user_dict)))): DCNL DCSP  DCSP assert ('confirm_time' in cookie_user_dict), cookie_user_dict DCNL DCSP else: DCNL DCSP  DCSP assert ('confirm_time' not in cookie_user_dict), cookie_user_dict DCNL DCSP return auth_test._ValidateAuthUser(tester, action, user_dict, ident_dict, device_dict, user_cookie, response)\n", "intent": "called by the servicetester in order to test login/viewfinder .\n", "question_id": 2018}, {"snippet": "def write_sff_header(header, fh, num=None): DCNL  DCSP lines = ['Common DCSP Header:'] DCNL DCSP if (num is not None): DCNL DCSP  DCSP header['# DCSP of DCSP Flows'] = num DCNL DCSP lines.extend([(' DCSP  DCSP %s: DCTB %s' % (param, header[param])) for param in header]) DCNL DCSP fh.write(('\\n'.join(lines) + '\\n\\n'))\n", "intent": "writes the common header of a sff .\n", "question_id": 2019}, {"snippet": "def plot_mnist_digit(image): DCNL  DCSP fig = plt.figure() DCNL DCSP ax = fig.add_subplot(1, 1, 1) DCNL DCSP ax.matshow(image, cmap=matplotlib.cm.binary) DCNL DCSP plt.xticks(np.array([])) DCNL DCSP plt.yticks(np.array([])) DCNL DCSP plt.show()\n", "intent": "plot a single mnist image .\n", "question_id": 2020}, {"snippet": "def is_file(file_to_test): DCNL  DCSP return all((hasattr(file_to_test, method) for method in ['read', 'name']))\n", "intent": "duck typing to check if file_to_test is a file object .\n", "question_id": 2021}, {"snippet": "def map_project_slug(view_func): DCNL  DCSP @wraps(view_func) DCNL DCSP def inner_view(request, project=None, project_slug=None, *args, **kwargs): DCNL DCSP  DCSP if (project is None): DCNL DCSP  DCSP  DCSP if (not project_slug): DCNL DCSP  DCSP  DCSP  DCSP project_slug = request.slug DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP project = Project.objects.get(slug=project_slug) DCNL DCSP  DCSP  DCSP except Project.DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP raise Http404('Project DCSP does DCSP not DCSP exist.') DCNL DCSP  DCSP return view_func(request, project=project, *args, **kwargs) DCNL DCSP return inner_view\n", "intent": "a decorator that maps a project_slug url param into a project .\n", "question_id": 2022}, {"snippet": "def show_tenant(): DCNL  DCSP (status, result) = _query(action='tenants', command='current') DCNL DCSP return result\n", "intent": "get the tenant for the login being used .\n", "question_id": 2023}, {"snippet": "def test_cnn_sample_wrong_X(): DCNL  DCSP cnn = CondensedNearestNeighbour(random_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, cnn.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))\n", "intent": "test either if an error is raised when x is different at fitting and sampling .\n", "question_id": 2024}, {"snippet": "def _prepare_colorarray(arr): DCNL  DCSP arr = np.asanyarray(arr) DCNL DCSP if ((arr.ndim not in [3, 4]) or (arr.shape[(-1)] != 3)): DCNL DCSP  DCSP msg = ((('the DCSP input DCSP array DCSP must DCSP be DCSP have DCSP a DCSP shape DCSP == DCSP (.., DCSP ..,[ DCSP ..,] DCSP 3)), DCSP ' + 'got DCSP (') + ', DCSP '.join(map(str, arr.shape))) + ')') DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP return dtype.img_as_float(arr)\n", "intent": "check the shape of the array and convert it to floating point representation .\n", "question_id": 2025}, {"snippet": "def get_vlan_device_name(src_dev, vlan): DCNL  DCSP src_dev = p_utils.get_interface_name(src_dev, max_len=(n_const.DEVICE_NAME_MAX_LEN - MAX_VLAN_POSTFIX_LEN)) DCNL DCSP return ('%s.%s' % (src_dev, vlan))\n", "intent": "generating the vlan device name .\n", "question_id": 2026}, {"snippet": "def get_account_by_name(account_name): DCNL  DCSP account = Account.query.filter((Account.name == account_name)).first() DCNL DCSP manager_class = account_registry.get(account.account_type.name) DCNL DCSP account = manager_class()._load(account) DCNL DCSP db.session.expunge(account) DCNL DCSP return account\n", "intent": "retrieves an account plus any additional custom fields .\n", "question_id": 2027}, {"snippet": "def redis_client(name): DCNL  DCSP if (name not in settings.REDIS_BACKENDS): DCNL DCSP  DCSP raise RedisError('{k} DCSP is DCSP not DCSP defined DCSP in DCSP settings.REDIS_BACKENDS'.format(k=name)) DCNL DCSP uri = settings.REDIS_BACKENDS[name] DCNL DCSP (_, server, params) = parse_backend_uri(uri) DCNL DCSP db = params.pop('db', 1) DCNL DCSP try: DCNL DCSP  DCSP db = int(db) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP db = 1 DCNL DCSP try: DCNL DCSP  DCSP socket_timeout = float(params.pop('socket_timeout')) DCNL DCSP except (KeyError, ValueError): DCNL DCSP  DCSP socket_timeout = None DCNL DCSP password = params.pop('password', None) DCNL DCSP if (':' in server): DCNL DCSP  DCSP (host, port) = server.split(':') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP port = int(port) DCNL DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP port = 6379 DCNL DCSP else: DCNL DCSP  DCSP host = server DCNL DCSP  DCSP port = 6379 DCNL DCSP redis = Redis(host=host, port=port, db=db, password=password, socket_timeout=socket_timeout) DCNL DCSP try: DCNL DCSP  DCSP redis.exists('dummy-key') DCNL DCSP except ConnectionError: DCNL DCSP  DCSP raise RedisError('Unable DCSP to DCSP connect DCSP to DCSP redis DCSP backend: DCSP {k}'.format(k=name)) DCNL DCSP return redis\n", "intent": "get a redis client .\n", "question_id": 2028}, {"snippet": "def custom_headers(): DCNL  DCSP headers = {} DCNL DCSP dnt = ('1' if config.get('network', 'do-not-track') else '0') DCNL DCSP headers['DNT'] = dnt DCNL DCSP headers['X-Do-Not-Track'] = dnt DCNL DCSP config_headers = config.get('network', 'custom-headers') DCNL DCSP if (config_headers is not None): DCNL DCSP  DCSP for (header, value) in config_headers.items(): DCNL DCSP  DCSP  DCSP headers[header.encode('ascii')] = value.encode('ascii') DCNL DCSP accept_language = config.get('network', 'accept-language') DCNL DCSP if (accept_language is not None): DCNL DCSP  DCSP headers['Accept-Language'] = accept_language.encode('ascii') DCNL DCSP return sorted(headers.items())\n", "intent": "get the combined custom headers .\n", "question_id": 2029}, {"snippet": "def _match_topic(subscription, topic): DCNL  DCSP if subscription.endswith('#'): DCNL DCSP  DCSP return ((subscription[:(-2)] == topic) or topic.startswith(subscription[:(-1)])) DCNL DCSP sub_parts = subscription.split('/') DCNL DCSP topic_parts = topic.split('/') DCNL DCSP return ((len(sub_parts) == len(topic_parts)) and all(((a == b) for (a, b) in zip(sub_parts, topic_parts) if (a != '+'))))\n", "intent": "test if topic matches subscription .\n", "question_id": 2030}, {"snippet": "def hash_shard(word): DCNL  DCSP return ('server%d' % (hash(word) % 4))\n", "intent": "do a great job of assigning data to servers using a hash value .\n", "question_id": 2031}, {"snippet": "@coroutine DCNL def async_run_ctl(args, stdin='', endpoint=DEFAULT_ENDPOINT_DEALER): DCNL  DCSP queue = Queue() DCNL DCSP circusctl_process = Process(target=run_ctl, args=(args, queue, stdin, endpoint)) DCNL DCSP circusctl_process.start() DCNL DCSP while queue.empty(): DCNL DCSP  DCSP (yield tornado_sleep(0.1)) DCNL DCSP stderr = queue.get() DCNL DCSP stdout = queue.get() DCNL DCSP raise Return((stdout, stderr))\n", "intent": "start a process that will start the actual circusctl process and poll its ouput .\n", "question_id": 2032}, {"snippet": "def set_color_codes(palette='deep'): DCNL  DCSP if (palette == 'reset'): DCNL DCSP  DCSP colors = [(0.0, 0.0, 1.0), (0.0, 0.5, 0.0), (1.0, 0.0, 0.0), (0.75, 0.75, 0.0), (0.75, 0.75, 0.0), (0.0, 0.75, 0.75), (0.0, 0.0, 0.0)] DCNL DCSP else: DCNL DCSP  DCSP colors = (SEABORN_PALETTES[palette] + [(0.1, 0.1, 0.1)]) DCNL DCSP for (code, color) in zip('bgrmyck', colors): DCNL DCSP  DCSP rgb = mpl.colors.colorConverter.to_rgb(color) DCNL DCSP  DCSP mpl.colors.colorConverter.colors[code] = rgb DCNL DCSP  DCSP mpl.colors.colorConverter.cache[code] = rgb\n", "intent": "change how matplotlib color shorthands are interpreted .\n", "question_id": 2033}, {"snippet": "def test_sort_locations_non_existing_path(): DCNL  DCSP finder = PackageFinder([], [], session=PipSession()) DCNL DCSP (files, urls) = finder._sort_locations([os.path.join('this', 'doesnt', 'exist')]) DCNL DCSP assert ((not urls) and (not files)), 'nothing DCSP should DCSP have DCSP been DCSP found'\n", "intent": "test that a non-existing path is ignored .\n", "question_id": 2034}, {"snippet": "def _get_ext_comm_subtype(type_high): DCNL  DCSP return _ext_comm_subtypes_classes.get(type_high, {})\n", "intent": "returns a byteenumfield with the right sub-types dict for a given community .\n", "question_id": 2035}, {"snippet": "def GetClassForProgID(progid): DCNL  DCSP clsid = pywintypes.IID(progid) DCNL DCSP return GetClassForCLSID(clsid)\n", "intent": "get a python class for a program id given a program id .\n", "question_id": 2036}, {"snippet": "@register.filter DCNL def mongo_id(value): DCNL  DCSP if isinstance(value, dict): DCNL DCSP  DCSP return value.get('_id', value) DCNL DCSP return unicode(value)\n", "intent": "retrieve _id value .\n", "question_id": 2037}, {"snippet": "@lower(print, types.VarArg(types.Any)) DCNL def print_varargs(context, builder, sig, args): DCNL  DCSP vprint = nvvmutils.declare_vprint(builder.module) DCNL DCSP formats = [] DCNL DCSP values = [] DCNL DCSP for (i, (argtype, argval)) in enumerate(zip(sig.args, args)): DCNL DCSP  DCSP (argfmt, argvals) = print_item(argtype, context, builder, argval) DCNL DCSP  DCSP formats.append(argfmt) DCNL DCSP  DCSP values.extend(argvals) DCNL DCSP rawfmt = (' DCSP '.join(formats) + '\\n') DCNL DCSP fmt = context.insert_string_const_addrspace(builder, rawfmt) DCNL DCSP array = cgutils.make_anonymous_struct(builder, values) DCNL DCSP arrayptr = cgutils.alloca_once_value(builder, array) DCNL DCSP vprint = nvvmutils.declare_vprint(builder.module) DCNL DCSP builder.call(vprint, (fmt, builder.bitcast(arrayptr, voidptr))) DCNL DCSP return context.get_dummy_value()\n", "intent": "this function is a generic print wrapper for arbitrary types .\n", "question_id": 2038}, {"snippet": "def getPluginsDirectoryPath(): DCNL  DCSP return archive.getAbsoluteFolderPath(os.path.dirname(__file__), os.path.join('skeinforge_plugins', 'meta_plugins'))\n", "intent": "get the plugins directory path .\n", "question_id": 2039}, {"snippet": "@register.filter(is_safe=True) DCNL @stringfilter DCNL def slugify(value): DCNL  DCSP return _slugify(value)\n", "intent": "converts to ascii .\n", "question_id": 2040}, {"snippet": "def _validate_flavor_service_type(validate_type, valid_values=None): DCNL  DCSP if (not directory.get_plugin(validate_type)): DCNL DCSP  DCSP raise InvalidFlavorServiceType(service_type=validate_type)\n", "intent": "ensure requested flavor service type plugin is loaded .\n", "question_id": 2041}, {"snippet": "def class_for_kind(kind): DCNL  DCSP try: DCNL DCSP  DCSP return _kind_map[kind] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise KindError((\"No DCSP implementation DCSP for DCSP kind DCSP '%s'\" % kind))\n", "intent": "return base-class responsible for implementing kind .\n", "question_id": 2042}, {"snippet": "def iter_child_nodes(node): DCNL  DCSP for (name, field) in iter_fields(node): DCNL DCSP  DCSP if isinstance(field, AST): DCNL DCSP  DCSP  DCSP (yield field) DCNL DCSP  DCSP elif isinstance(field, list): DCNL DCSP  DCSP  DCSP for item in field: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(item, AST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield item)\n", "intent": "iterate over all child nodes or a node .\n", "question_id": 2043}, {"snippet": "def restore_disks(job, restore=False, disk_list=None): DCNL  DCSP if (restore and (disk_list is not None)): DCNL DCSP  DCSP prepare_disks(job, 'ext2 DCSP / DCSP -q DCSP -i20480 DCSP -m1 DCSP / DCSP / DCSP restore_ext2', disk1_only=False, disk_list=disk_list)\n", "intent": "restore ext2 on the drives in disk_list if restore is true; when disk_list is none .\n", "question_id": 2044}, {"snippet": "@preprocess(engine=coerce_string_to_eng) DCNL def downgrade(engine, desired_version): DCNL  DCSP with engine.begin() as conn: DCNL DCSP  DCSP metadata = sa.MetaData(conn) DCNL DCSP  DCSP metadata.reflect() DCNL DCSP  DCSP version_info_table = metadata.tables['version_info'] DCNL DCSP  DCSP starting_version = sa.select((version_info_table.c.version,)).scalar() DCNL DCSP  DCSP if (starting_version < desired_version): DCNL DCSP  DCSP  DCSP raise AssetDBImpossibleDowngrade(db_version=starting_version, desired_version=desired_version) DCNL DCSP  DCSP if (starting_version == desired_version): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP ctx = MigrationContext.configure(conn) DCNL DCSP  DCSP op = Operations(ctx) DCNL DCSP  DCSP downgrade_keys = range(desired_version, starting_version)[::(-1)] DCNL DCSP  DCSP _pragma_foreign_keys(conn, False) DCNL DCSP  DCSP for downgrade_key in downgrade_keys: DCNL DCSP  DCSP  DCSP _downgrade_methods[downgrade_key](op, conn, version_info_table) DCNL DCSP  DCSP _pragma_foreign_keys(conn, True)\n", "intent": "downgrades the assets db at the given engine to the desired version .\n", "question_id": 2045}, {"snippet": "def push_monitor(model, name, transfer_experience=False, save_records=False): DCNL  DCSP assert hasattr(model, 'monitor') DCNL DCSP old_monitor = model.monitor DCNL DCSP setattr(model, name, old_monitor) DCNL DCSP del model.monitor DCNL DCSP if transfer_experience: DCNL DCSP  DCSP monitor = Monitor.get_monitor(model) DCNL DCSP  DCSP assert (monitor is not old_monitor) DCNL DCSP  DCSP monitor._num_batches_seen = old_monitor._num_batches_seen DCNL DCSP  DCSP monitor._examples_seen = old_monitor._examples_seen DCNL DCSP  DCSP monitor._epochs_seen = old_monitor._epochs_seen DCNL DCSP  DCSP if save_records: DCNL DCSP  DCSP  DCSP monitor.on_channel_conflict = 'copy_history' DCNL DCSP  DCSP  DCSP monitor.channels = copy.copy(old_monitor.channels) DCNL DCSP  DCSP  DCSP for (key, value) in list(monitor.channels.items()): DCNL DCSP  DCSP  DCSP  DCSP value.prereqs = None DCNL DCSP return model\n", "intent": "when you load a model in a yaml file and you want to store its old monitor under a different name and start a new monitor .\n", "question_id": 2046}, {"snippet": "@register.inclusion_tag('utilities/templatetags/utilization_graph.html') DCNL def utilization_graph(utilization, warning_threshold=75, danger_threshold=90): DCNL  DCSP return {'utilization': utilization, 'warning_threshold': warning_threshold, 'danger_threshold': danger_threshold}\n", "intent": "display a horizontal bar graph indicating a percentage of utilization .\n", "question_id": 2047}, {"snippet": "def create_item_version(item): DCNL  DCSP if (not item.version_fields): DCNL DCSP  DCSP return DCNL DCSP _hash = hashlib.sha1() DCNL DCSP for attrname in item.version_fields: DCNL DCSP  DCSP _hash.update(repr(item.get(attrname))) DCNL DCSP return _hash.digest()\n", "intent": "item version based on hashlib .\n", "question_id": 2048}, {"snippet": "def test_SAMPClient(): DCNL  DCSP proxy = SAMPHubProxy() DCNL DCSP SAMPClient(proxy)\n", "intent": "test that sampclient can be instantiated .\n", "question_id": 2049}, {"snippet": "def MakeControlClass(controlClass, name=None): DCNL  DCSP if (name is None): DCNL DCSP  DCSP name = controlClass.__name__ DCNL DCSP return new_type(('OCX' + name), (Control, controlClass), {})\n", "intent": "given a coclass in a generated .\n", "question_id": 2050}, {"snippet": "@jit(nopython=True, cache=True) DCNL def lex_min_ratio_test(tableau, pivot, slack_start, argmins): DCNL  DCSP nrows = tableau.shape[0] DCNL DCSP num_candidates = nrows DCNL DCSP for i in range(nrows): DCNL DCSP  DCSP argmins[i] = i DCNL DCSP num_argmins = min_ratio_test_no_tie_breaking(tableau, pivot, (-1), argmins, num_candidates) DCNL DCSP if (num_argmins == 1): DCNL DCSP  DCSP return argmins[0] DCNL DCSP for j in range(slack_start, (slack_start + nrows)): DCNL DCSP  DCSP if (j == pivot): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP num_argmins = min_ratio_test_no_tie_breaking(tableau, pivot, j, argmins, num_argmins) DCNL DCSP  DCSP if (num_argmins == 1): DCNL DCSP  DCSP  DCSP break DCNL DCSP return argmins[0]\n", "intent": "perform the lexico-minimum ratio test .\n", "question_id": 2051}, {"snippet": "@utils.arg('server', metavar='<server>', help=_('Name DCSP or DCSP ID DCSP of DCSP server.')) DCNL @utils.arg('flavor', metavar='<flavor>', help=_('Name DCSP or DCSP ID DCSP of DCSP new DCSP flavor.')) DCNL @utils.arg('--poll', dest='poll', action='store_true', default=False, help=_('Report DCSP the DCSP server DCSP resize DCSP progress DCSP until DCSP it DCSP completes.')) DCNL def do_resize(cs, args): DCNL  DCSP server = _find_server(cs, args.server) DCNL DCSP flavor = _find_flavor(cs, args.flavor) DCNL DCSP kwargs = utils.get_resource_manager_extra_kwargs(do_resize, args) DCNL DCSP server.resize(flavor, **kwargs) DCNL DCSP if args.poll: DCNL DCSP  DCSP _poll_for_status(cs.servers.get, server.id, 'resizing', ['active', 'verify_resize'])\n", "intent": "resize a server .\n", "question_id": 2052}, {"snippet": "def authenticationAndCipheringRequest(AuthenticationParameterRAND_presence=0, CiphKeySeqNr_presence=0): DCNL  DCSP a = TpPd(pd=3) DCNL DCSP b = MessageType(mesType=18) DCNL DCSP d = CipheringAlgorithmAndImeisvRequest() DCNL DCSP e = ForceToStandbyAndAcReferenceNumber() DCNL DCSP packet = (((a / b) / d) / e) DCNL DCSP if (AuthenticationParameterRAND_presence is 1): DCNL DCSP  DCSP g = AuthenticationParameterRAND(ieiAPR=33) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP if (CiphKeySeqNr_presence is 1): DCNL DCSP  DCSP h = CiphKeySeqNrHdr(ieiCKSN=8, eightBitCKSN=0) DCNL DCSP  DCSP packet = (packet / h) DCNL DCSP return packet\n", "intent": "authentication and ciphering request section 9 .\n", "question_id": 2053}, {"snippet": "def get_working_ifaces(): DCNL  DCSP if (os.getuid() != 0): DCNL DCSP  DCSP return [] DCNL DCSP interfaces = [] DCNL DCSP for ifname in get_if_list(): DCNL DCSP  DCSP if (ifname == LOOPBACK_NAME): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = get_if(ifname, SIOCGIFFLAGS) DCNL DCSP  DCSP except IOError as msg: DCNL DCSP  DCSP  DCSP warning(('ioctl(SIOCGIFFLAGS) DCSP failed DCSP on DCSP %s DCSP !' % ifname)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ifflags = struct.unpack('16xH14x', result)[0] DCNL DCSP  DCSP if (ifflags & 1): DCNL DCSP  DCSP  DCSP (fd, _) = get_dev_bpf() DCNL DCSP  DCSP  DCSP if (fd is None): DCNL DCSP  DCSP  DCSP  DCSP raise Scapy_Exception('No DCSP /dev/bpf DCSP are DCSP available DCSP !') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fcntl.ioctl(fd, BIOCSETIF, struct.pack('16s16x', ifname)) DCNL DCSP  DCSP  DCSP  DCSP interfaces.append((ifname, int(ifname[(-1)]))) DCNL DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP os.close(fd) DCNL DCSP interfaces.sort((lambda (ifname_left, ifid_left), (ifname_right, ifid_right): (ifid_left - ifid_right))) DCNL DCSP return interfaces\n", "intent": "returns an ordered list of interfaces that could be used with bpf .\n", "question_id": 2054}, {"snippet": "def jordan_cell(eigenval, n): DCNL  DCSP n = as_int(n) DCNL DCSP out = zeros(n) DCNL DCSP for i in range((n - 1)): DCNL DCSP  DCSP out[(i, i)] = eigenval DCNL DCSP  DCSP out[(i, (i + 1))] = S.One DCNL DCSP out[((n - 1), (n - 1))] = eigenval DCNL DCSP return out\n", "intent": "create matrix of jordan cell kind: examples .\n", "question_id": 2055}, {"snippet": "def _get_initializers(initializers, fields): DCNL  DCSP result = {} DCNL DCSP for f in fields: DCNL DCSP  DCSP if isinstance(initializers, dict): DCNL DCSP  DCSP  DCSP if (f in initializers): DCNL DCSP  DCSP  DCSP  DCSP result[f] = _convert_to_initializer(initializers[f]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result[f] = _convert_to_initializer(initializers) DCNL DCSP return result\n", "intent": "produces a nn initialization dict .\n", "question_id": 2056}, {"snippet": "def group_membership_status(): DCNL  DCSP return s3_rest_controller()\n", "intent": "restful crud controller .\n", "question_id": 2057}, {"snippet": "def translate_url(url, lang_code): DCNL  DCSP parsed = urlsplit(url) DCNL DCSP try: DCNL DCSP  DCSP match = resolve(parsed.path) DCNL DCSP except Resolver404: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP to_be_reversed = (('%s:%s' % (match.namespace, match.url_name)) if match.namespace else match.url_name) DCNL DCSP  DCSP with override(lang_code): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs) DCNL DCSP  DCSP  DCSP except NoReverseMatch: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP url = urlunsplit((parsed.scheme, parsed.netloc, url, parsed.query, parsed.fragment)) DCNL DCSP return url\n", "intent": "given a url .\n", "question_id": 2058}, {"snippet": "def select_proxy(url, proxies): DCNL  DCSP proxies = (proxies or {}) DCNL DCSP urlparts = urlparse(url) DCNL DCSP if (urlparts.hostname is None): DCNL DCSP  DCSP return proxies.get(urlparts.scheme, proxies.get('all')) DCNL DCSP proxy_keys = [((urlparts.scheme + '://') + urlparts.hostname), urlparts.scheme, ('all://' + urlparts.hostname), 'all'] DCNL DCSP proxy = None DCNL DCSP for proxy_key in proxy_keys: DCNL DCSP  DCSP if (proxy_key in proxies): DCNL DCSP  DCSP  DCSP proxy = proxies[proxy_key] DCNL DCSP  DCSP  DCSP break DCNL DCSP return proxy\n", "intent": "select a proxy for the url .\n", "question_id": 2059}, {"snippet": "def list_nodes(call=None): DCNL  DCSP if (call == 'action'): DCNL DCSP  DCSP raise SaltCloudSystemExit('The DCSP list_nodes DCSP function DCSP must DCSP be DCSP called DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP nodes = list_nodes_full() DCNL DCSP ret = {} DCNL DCSP for instanceId in nodes: DCNL DCSP  DCSP node = nodes[instanceId] DCNL DCSP  DCSP ret[node['name']] = {'id': node['id'], 'name': node['name'], 'public_ips': node['public_ips'], 'private_ips': node['private_ips'], 'size': node['size'], 'state': str(node['state'])} DCNL DCSP return ret\n", "intent": "return a list of the vms that are on the provider .\n", "question_id": 2060}, {"snippet": "def get_database_engine_options(kwargs): DCNL  DCSP conversions = {'convert_unicode': string_as_bool, 'pool_timeout': int, 'echo': string_as_bool, 'echo_pool': string_as_bool, 'pool_recycle': int, 'pool_size': int, 'max_overflow': int, 'pool_threadlocal': string_as_bool} DCNL DCSP prefix = 'database_engine_option_' DCNL DCSP prefix_len = len(prefix) DCNL DCSP rval = {} DCNL DCSP for (key, value) in kwargs.items(): DCNL DCSP  DCSP if key.startswith(prefix): DCNL DCSP  DCSP  DCSP key = key[prefix_len:] DCNL DCSP  DCSP  DCSP if (key in conversions): DCNL DCSP  DCSP  DCSP  DCSP value = conversions[key](value) DCNL DCSP  DCSP  DCSP rval[key] = value DCNL DCSP return rval\n", "intent": "allow options for the sqlalchemy database engine to be passed by using the prefix \"database_engine_option\" .\n", "question_id": 2061}, {"snippet": "def fix_win_pythonw_std_stream(): DCNL  DCSP if ((sys.platform == 'win32') and (os.path.basename(sys.executable) == 'pythonw.exe')): DCNL DCSP  DCSP if (sys.stdout is None): DCNL DCSP  DCSP  DCSP sys.stdout = open(os.devnull, 'w') DCNL DCSP  DCSP if (sys.stderr is None): DCNL DCSP  DCSP  DCSP sys.stderr = open(os.devnull, 'w')\n", "intent": "on windows when running without a console  the std[err|out] file descriptors are invalid and start throwing exceptions when their buffer is flushed .\n", "question_id": 2062}, {"snippet": "def memory_size_from_info(shape, strides, itemsize): DCNL  DCSP assert (len(shape) == len(strides)), '# DCSP dim DCSP mismatch' DCNL DCSP ndim = len(shape) DCNL DCSP (s, e) = mviewbuf.memoryview_get_extents_info(shape, strides, ndim, itemsize) DCNL DCSP return (e - s)\n", "intent": "et the byte size of a contiguous memory buffer given the shape .\n", "question_id": 2063}, {"snippet": "def create_role(name, policy_document=None, path=None, region=None, key=None, keyid=None, profile=None): DCNL  DCSP conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile) DCNL DCSP if role_exists(name, region, key, keyid, profile): DCNL DCSP  DCSP return True DCNL DCSP if (not policy_document): DCNL DCSP  DCSP policy_document = None DCNL DCSP try: DCNL DCSP  DCSP conn.create_role(name, assume_role_policy_document=policy_document, path=path) DCNL DCSP  DCSP log.info('Created DCSP {0} DCSP iam DCSP role.'.format(name)) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.error(e) DCNL DCSP  DCSP msg = 'Failed DCSP to DCSP create DCSP {0} DCSP iam DCSP role.' DCNL DCSP  DCSP log.error(msg.format(name)) DCNL DCSP  DCSP return False\n", "intent": "create an instance role .\n", "question_id": 2064}, {"snippet": "def check_python_version(): DCNL  DCSP if (sys.hexversion < 50593792): DCNL DCSP  DCSP version_str = '.'.join(map(str, sys.version_info[:3])) DCNL DCSP  DCSP text = (('At DCSP least DCSP Python DCSP 3.4 DCSP is DCSP required DCSP to DCSP run DCSP qutebrowser, DCSP but DCSP ' + version_str) + ' DCSP is DCSP installed!\\n') DCNL DCSP  DCSP if (Tk and ('--no-err-windows' not in sys.argv)): DCNL DCSP  DCSP  DCSP root = Tk() DCNL DCSP  DCSP  DCSP root.withdraw() DCNL DCSP  DCSP  DCSP messagebox.showerror('qutebrowser: DCSP Fatal DCSP error!', text) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.stderr.write(text) DCNL DCSP  DCSP  DCSP sys.stderr.flush() DCNL DCSP  DCSP sys.exit(1)\n", "intent": "check if correct python version is run .\n", "question_id": 2065}, {"snippet": "def verify_modules(build_root='_build'): DCNL  DCSP object_inventory_relpath = os.path.join(build_root, 'html', 'objects.inv') DCNL DCSP mock_uri = '' DCNL DCSP inventory = fetch_inventory(SphinxApp, mock_uri, object_inventory_relpath) DCNL DCSP sphinx_mods = set(inventory['py:module'].keys()) DCNL DCSP public_mods = set() DCNL DCSP for package in PACKAGES: DCNL DCSP  DCSP library_dir = os.path.join(PROJECT_ROOT, package, 'google', 'cloud') DCNL DCSP  DCSP package_mods = get_public_modules(library_dir, base_package='google.cloud') DCNL DCSP  DCSP public_mods.update(package_mods) DCNL DCSP if (not (sphinx_mods <= public_mods)): DCNL DCSP  DCSP unexpected_mods = (sphinx_mods - public_mods) DCNL DCSP  DCSP message = ['Unexpected DCSP error. DCSP There DCSP were DCSP modules DCSP referenced DCSP by DCSP Sphinx DCSP that DCSP are DCSP not DCSP among DCSP the DCSP public DCSP modules.'] DCNL DCSP  DCSP message.extend([('- DCSP %s' % (mod,)) for mod in unexpected_mods]) DCNL DCSP  DCSP print('\\n'.join(message), file=sys.stderr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP undocumented_mods = (public_mods - sphinx_mods) DCNL DCSP undocumented_mods -= IGNORED_MODULES DCNL DCSP if undocumented_mods: DCNL DCSP  DCSP message_parts = ['Found DCSP undocumented DCSP public DCSP modules:'] DCNL DCSP  DCSP message_parts.extend([('- DCSP ' + mod_name) for mod_name in sorted(undocumented_mods)]) DCNL DCSP  DCSP print('\\n'.join(message_parts), file=sys.stderr) DCNL DCSP  DCSP sys.exit(1)\n", "intent": "verify modules included .\n", "question_id": 2066}, {"snippet": "def test_require_multiple_existing_keys(): DCNL  DCSP require('version', 'sudo_prompt')\n", "intent": "when given multiple existing keys .\n", "question_id": 2067}, {"snippet": "def _divide_with_ceil(a, b): DCNL  DCSP if (a % b): DCNL DCSP  DCSP return ((a // b) + 1) DCNL DCSP return (a // b)\n", "intent": "returns a divided by b .\n", "question_id": 2068}, {"snippet": "def date_ticker_factory(span, tz=None, numticks=5): DCNL  DCSP if (span == 0): DCNL DCSP  DCSP span = (1 / HOURS_PER_DAY) DCNL DCSP mins = (span * MINUTES_PER_DAY) DCNL DCSP hrs = (span * HOURS_PER_DAY) DCNL DCSP days = span DCNL DCSP wks = (span / DAYS_PER_WEEK) DCNL DCSP months = (span / DAYS_PER_MONTH) DCNL DCSP years = (span / DAYS_PER_YEAR) DCNL DCSP if (years > numticks): DCNL DCSP  DCSP locator = YearLocator(int((years / numticks)), tz=tz) DCNL DCSP  DCSP fmt = u'%Y' DCNL DCSP elif (months > numticks): DCNL DCSP  DCSP locator = MonthLocator(tz=tz) DCNL DCSP  DCSP fmt = u'%b DCSP %Y' DCNL DCSP elif (wks > numticks): DCNL DCSP  DCSP locator = WeekdayLocator(tz=tz) DCNL DCSP  DCSP fmt = u'%a, DCSP %b DCSP %d' DCNL DCSP elif (days > numticks): DCNL DCSP  DCSP locator = DayLocator(interval=int(math.ceil((days / numticks))), tz=tz) DCNL DCSP  DCSP fmt = u'%b DCSP %d' DCNL DCSP elif (hrs > numticks): DCNL DCSP  DCSP locator = HourLocator(interval=int(math.ceil((hrs / numticks))), tz=tz) DCNL DCSP  DCSP fmt = u'%H:%M\\n%b DCSP %d' DCNL DCSP elif (mins > numticks): DCNL DCSP  DCSP locator = MinuteLocator(interval=int(math.ceil((mins / numticks))), tz=tz) DCNL DCSP  DCSP fmt = u'%H:%M:%S' DCNL DCSP else: DCNL DCSP  DCSP locator = MinuteLocator(tz=tz) DCNL DCSP  DCSP fmt = u'%H:%M:%S' DCNL DCSP formatter = DateFormatter(fmt, tz=tz) DCNL DCSP return (locator, formatter)\n", "intent": "create a date locator with *numticks*  and a date formatter for *span* in days .\n", "question_id": 2069}, {"snippet": "def do_slice(value, slices, fill_with=None): DCNL  DCSP seq = list(value) DCNL DCSP length = len(seq) DCNL DCSP items_per_slice = (length // slices) DCNL DCSP slices_with_extra = (length % slices) DCNL DCSP offset = 0 DCNL DCSP for slice_number in range(slices): DCNL DCSP  DCSP start = (offset + (slice_number * items_per_slice)) DCNL DCSP  DCSP if (slice_number < slices_with_extra): DCNL DCSP  DCSP  DCSP offset += 1 DCNL DCSP  DCSP end = (offset + ((slice_number + 1) * items_per_slice)) DCNL DCSP  DCSP tmp = seq[start:end] DCNL DCSP  DCSP if ((fill_with is not None) and (slice_number >= slices_with_extra)): DCNL DCSP  DCSP  DCSP tmp.append(fill_with) DCNL DCSP  DCSP (yield tmp)\n", "intent": "slice an iterator and return a list of lists containing those items .\n", "question_id": 2070}, {"snippet": "def test_truncate_purified_field_xss(): DCNL  DCSP s = 'safe DCSP <script>alert(\"omg\")</script>' DCNL DCSP t = PurifiedTranslation(localized_string=s) DCNL DCSP env = jingo.get_env() DCNL DCSP actual = env.from_string('{{ DCSP s|truncate(100) DCSP }}').render({'s': t}) DCNL DCSP assert (actual == 'safe DCSP &lt;script&gt;alert(\"omg\")&lt;/script&gt;') DCNL DCSP actual = env.from_string('{{ DCSP s|truncate(5) DCSP }}').render({'s': t}) DCNL DCSP assert (actual == 'safe DCSP ...')\n", "intent": "truncating should not introduce xss issues .\n", "question_id": 2071}, {"snippet": "def AddExtensionFiles(params, options): DCNL  DCSP added = {} DCNL DCSP for vd in params.VirtualDirs: DCNL DCSP  DCSP for smp in vd.ScriptMaps: DCNL DCSP  DCSP  DCSP if ((smp.Module not in added) and smp.AddExtensionFile): DCNL DCSP  DCSP  DCSP  DCSP _AddExtensionFile(smp.Module, vd.Name, vd.Description, smp, options) DCNL DCSP  DCSP  DCSP  DCSP added[smp.Module] = True DCNL DCSP for fd in params.Filters: DCNL DCSP  DCSP if ((fd.Path not in added) and fd.AddExtensionFile): DCNL DCSP  DCSP  DCSP _AddExtensionFile(fd.Path, fd.Name, fd.Description, fd, options) DCNL DCSP  DCSP  DCSP added[fd.Path] = True\n", "intent": "register the modules used by the filters/extensions as a trusted extension module - required by the default iis6 security settings .\n", "question_id": 2072}, {"snippet": "def budget_bundle_totals(bundle_id): DCNL  DCSP s3db = current.s3db DCNL DCSP db = current.db DCNL DCSP total_unit_cost = 0 DCNL DCSP total_monthly_cost = 0 DCNL DCSP ktable = s3db.budget_kit DCNL DCSP linktable = s3db.budget_bundle_kit DCNL DCSP left = [ktable.on((linktable.kit_id == ktable.id))] DCNL DCSP query = (linktable.bundle_id == bundle_id) DCNL DCSP rows = db(query).select(linktable.quantity, linktable.minutes, linktable.megabytes, ktable.total_unit_cost, ktable.total_monthly_cost, ktable.total_minute_cost, ktable.total_megabyte_cost, left=left) DCNL DCSP for row in rows: DCNL DCSP  DCSP kit = row[ktable] DCNL DCSP  DCSP link = row[linktable] DCNL DCSP  DCSP quantity = link.quantity DCNL DCSP  DCSP total_unit_cost += (kit.total_unit_cost * quantity) DCNL DCSP  DCSP monthly_cost = ((kit.total_monthly_cost + (kit.total_minute_cost * link.minutes)) + (kit.total_megabyte_cost * link.megabytes)) DCNL DCSP  DCSP total_monthly_cost += (monthly_cost * quantity) DCNL DCSP itable = s3db.budget_item DCNL DCSP linktable = s3db.budget_bundle_item DCNL DCSP left = [itable.on((linktable.item_id == itable.id))] DCNL DCSP query = (linktable.bundle_id == bundle_id) DCNL DCSP rows = db(query).select(linktable.quantity, linktable.minutes, linktable.megabytes, itable.unit_cost, itable.monthly_cost, itable.minute_cost, itable.megabyte_cost, left=left) DCNL DCSP for row in rows: DCNL DCSP  DCSP item = row[itable] DCNL DCSP  DCSP link = row[linktable] DCNL DCSP  DCSP quantity = link.quantity DCNL DCSP  DCSP total_unit_cost += (item.unit_cost * quantity) DCNL DCSP  DCSP monthly_cost = ((item.monthly_cost + (item.minute_cost * link.minutes)) + (item.megabyte_cost * link.megabytes)) DCNL DCSP  DCSP total_monthly_cost += (monthly_cost * quantity) DCNL DCSP btable = s3db.budget_bundle DCNL DCSP db((btable.id == bundle_id)).update(total_unit_cost=total_unit_cost, total_monthly_cost=total_monthly_cost) DCNL DCSP linktable = s3db.budget_budget_bundle DCNL DCSP budget_entity_id = linktable.budget_entity_id DCNL DCSP rows = db((linktable.bundle_id == bundle_id)).select(budget_entity_id, groupby=budget_entity_id) DCNL DCSP for row in rows: DCNL DCSP  DCSP budget_budget_totals(row.budget_entity_id) DCNL DCSP return\n", "intent": "calculate totals for a bundle .\n", "question_id": 2073}, {"snippet": "@pytest.mark.parametrize('reserved_code', RESERVED_PROJECT_CODES) DCNL @pytest.mark.django_db DCNL def test_create_project_reserved_code(english, reserved_code): DCNL  DCSP with pytest.raises(ValidationError): DCNL DCSP  DCSP Project(code=reserved_code, fullname='whatever', source_language=english).save() DCNL DCSP reserved_code_with_padding = (' DCSP  DCSP %s DCSP  DCSP ' % reserved_code) DCNL DCSP with pytest.raises(ValidationError): DCNL DCSP  DCSP Project(code=reserved_code_with_padding, fullname='whatever', source_language=english).save()\n", "intent": "tests projects are not created with reserved project codes .\n", "question_id": 2074}, {"snippet": "def _translate_volume_summary_view(context, vol, image_id=None): DCNL  DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availability_zone'] = vol['availability_zone'] DCNL DCSP d['created_at'] = vol['created_at'] DCNL DCSP d['attachments'] = [] DCNL DCSP if (vol['attach_status'] == 'attached'): DCNL DCSP  DCSP attachment = _translate_attachment_detail_view(context, vol) DCNL DCSP  DCSP d['attachments'].append(attachment) DCNL DCSP d['display_name'] = vol['display_name'] DCNL DCSP d['display_description'] = vol['display_description'] DCNL DCSP if (vol['volume_type_id'] and vol.get('volume_type')): DCNL DCSP  DCSP d['volume_type'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['volume_type'] = str(vol['volume_type_id']) DCNL DCSP d['snapshot_id'] = vol['snapshot_id'] DCNL DCSP d['source_volid'] = vol['source_volid'] DCNL DCSP if image_id: DCNL DCSP  DCSP d['image_id'] = image_id DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metadata'): DCNL DCSP  DCSP metadata = vol.get('volume_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (vol.get('metadata') and isinstance(vol.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = vol['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP if vol.get('volume_glance_metadata'): DCNL DCSP  DCSP d['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP d['bootable'] = 'false' DCNL DCSP return d\n", "intent": "maps keys for volumes summary view .\n", "question_id": 2075}, {"snippet": "def cache_path(paths, environ=None): DCNL  DCSP return zipline_path((['cache'] + list(paths)), environ=environ)\n", "intent": "get a path relative to the zipline cache directory .\n", "question_id": 2076}, {"snippet": "def spawn_children(): DCNL  DCSP if (not ALIVE): DCNL DCSP  DCSP return DCNL DCSP for col in all_valid_collectors(): DCNL DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP if (col.interval == 0): DCNL DCSP  DCSP  DCSP if (col.proc is None): DCNL DCSP  DCSP  DCSP  DCSP spawn_collector(col) DCNL DCSP  DCSP elif (col.interval <= (now - col.lastspawn)): DCNL DCSP  DCSP  DCSP if (col.proc is None): DCNL DCSP  DCSP  DCSP  DCSP spawn_collector(col) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (col.nextkill > now): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (col.killstate == 0): DCNL DCSP  DCSP  DCSP  DCSP LOG.warning('warning: DCSP %s DCSP (interval=%d, DCSP pid=%d) DCSP overstayed DCSP its DCSP welcome, DCSP SIGTERM DCSP sent', col.name, col.interval, col.proc.pid) DCNL DCSP  DCSP  DCSP  DCSP kill(col.proc) DCNL DCSP  DCSP  DCSP  DCSP col.nextkill = (now + 5) DCNL DCSP  DCSP  DCSP  DCSP col.killstate = 1 DCNL DCSP  DCSP  DCSP elif (col.killstate == 1): DCNL DCSP  DCSP  DCSP  DCSP LOG.error('error: DCSP %s DCSP (interval=%d, DCSP pid=%d) DCSP still DCSP not DCSP dead, DCSP SIGKILL DCSP sent', col.name, col.interval, col.proc.pid) DCNL DCSP  DCSP  DCSP  DCSP kill(col.proc, signal.SIGKILL) DCNL DCSP  DCSP  DCSP  DCSP col.nextkill = (now + 5) DCNL DCSP  DCSP  DCSP  DCSP col.killstate = 2 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.error('error: DCSP %s DCSP (interval=%d, DCSP pid=%d) DCSP needs DCSP manual DCSP intervention DCSP to DCSP kill DCSP it', col.name, col.interval, col.proc.pid) DCNL DCSP  DCSP  DCSP  DCSP col.nextkill = (now + 300)\n", "intent": "iterates over our defined collectors and performs the logic to determine if we need to spawn .\n", "question_id": 2077}, {"snippet": "def random_bytes(size=1024): DCNL  DCSP return ''.join([six.int2byte(random.randint(0, 255)) for i in range(size)])\n", "intent": "return size randomly selected bytes as a string .\n", "question_id": 2078}, {"snippet": "def p_error_handler(t): DCNL  DCSP pass\n", "intent": "error : name .\n", "question_id": 2079}, {"snippet": "def rewrite_links(root, link_repl_func, resolve_base_href=False): DCNL  DCSP from cssutils import replaceUrls, log, CSSParser DCNL DCSP log.setLevel(logging.WARN) DCNL DCSP log.raiseExceptions = False DCNL DCSP if resolve_base_href: DCNL DCSP  DCSP resolve_base_href(root) DCNL DCSP for (el, attrib, link, pos) in iterlinks(root, find_links_in_css=False): DCNL DCSP  DCSP new_link = link_repl_func(link.strip()) DCNL DCSP  DCSP if (new_link == link): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (new_link is None): DCNL DCSP  DCSP  DCSP if (attrib is None): DCNL DCSP  DCSP  DCSP  DCSP el.text = '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP del el.attrib[attrib] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (attrib is None): DCNL DCSP  DCSP  DCSP new = ((el.text[:pos] + new_link) + el.text[(pos + len(link)):]) DCNL DCSP  DCSP  DCSP el.text = new DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cur = el.attrib[attrib] DCNL DCSP  DCSP  DCSP if ((not pos) and (len(cur) == len(link))): DCNL DCSP  DCSP  DCSP  DCSP el.attrib[attrib] = new_link DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new = ((cur[:pos] + new_link) + cur[(pos + len(link)):]) DCNL DCSP  DCSP  DCSP  DCSP el.attrib[attrib] = new DCNL DCSP parser = CSSParser(raiseExceptions=False, log=_css_logger, fetcher=(lambda x: (None, None))) DCNL DCSP for el in root.iter(etree.Element): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tag = el.tag DCNL DCSP  DCSP except UnicodeDecodeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((tag == XHTML('style')) and el.text and ((_css_url_re.search(el.text) is not None) or ('@import' in el.text))): DCNL DCSP  DCSP  DCSP stylesheet = parser.parseString(el.text, validate=False) DCNL DCSP  DCSP  DCSP replaceUrls(stylesheet, link_repl_func) DCNL DCSP  DCSP  DCSP repl = stylesheet.cssText DCNL DCSP  DCSP  DCSP if isbytestring(repl): DCNL DCSP  DCSP  DCSP  DCSP repl = repl.decode('utf-8') DCNL DCSP  DCSP  DCSP el.text = (('\\n' + repl) + '\\n') DCNL DCSP  DCSP if ('style' in el.attrib): DCNL DCSP  DCSP  DCSP text = el.attrib['style'] DCNL DCSP  DCSP  DCSP if (_css_url_re.search(text) is not None): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stext = parser.parseStyle(text, validate=False) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP replaceUrls(stext, link_repl_func) DCNL DCSP  DCSP  DCSP  DCSP repl = stext.cssText.replace('\\n', ' DCSP ').replace('\\r', ' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if isbytestring(repl): DCNL DCSP  DCSP  DCSP  DCSP  DCSP repl = repl.decode('utf-8') DCNL DCSP  DCSP  DCSP  DCSP el.attrib['style'] = repl\n", "intent": "rewrite all the links in the document .\n", "question_id": 2080}, {"snippet": "@register.filter(name='unix_ms_to_datetime') DCNL def unix_ms_to_datetime(unixtime): DCNL  DCSP if unixtime: DCNL DCSP  DCSP return datetime.datetime.fromtimestamp((unixtime / 1000)) DCNL DCSP return _('No DCSP time')\n", "intent": "unixtime is seconds since the epoch .\n", "question_id": 2081}, {"snippet": "@pytest.mark.parametrize('func', all_funcs, ids=all_func_ids) DCNL def test_function_call_with_dict_data(func): DCNL  DCSP data = {'a': [1, 2], 'b': [8, 9], 'w': 'NOT'} DCNL DCSP assert (func(None, 'a', 'b', data=data) == 'x: DCSP [1, DCSP 2], DCSP y: DCSP [8, DCSP 9], DCSP ls: DCSP x, DCSP w: DCSP xyz, DCSP label: DCSP b') DCNL DCSP assert (func(None, x='a', y='b', data=data) == 'x: DCSP [1, DCSP 2], DCSP y: DCSP [8, DCSP 9], DCSP ls: DCSP x, DCSP w: DCSP xyz, DCSP label: DCSP b') DCNL DCSP assert (func(None, 'a', 'b', label='', data=data) == 'x: DCSP [1, DCSP 2], DCSP y: DCSP [8, DCSP 9], DCSP ls: DCSP x, DCSP w: DCSP xyz, DCSP label: DCSP ') DCNL DCSP assert (func(None, 'a', 'b', label='text', data=data) == 'x: DCSP [1, DCSP 2], DCSP y: DCSP [8, DCSP 9], DCSP ls: DCSP x, DCSP w: DCSP xyz, DCSP label: DCSP text') DCNL DCSP assert (func(None, x='a', y='b', label='', data=data) == 'x: DCSP [1, DCSP 2], DCSP y: DCSP [8, DCSP 9], DCSP ls: DCSP x, DCSP w: DCSP xyz, DCSP label: DCSP ') DCNL DCSP assert (func(None, x='a', y='b', label='text', data=data) == 'x: DCSP [1, DCSP 2], DCSP y: DCSP [8, DCSP 9], DCSP ls: DCSP x, DCSP w: DCSP xyz, DCSP label: DCSP text')\n", "intent": "test with dict data -> label comes from the value of x parameter .\n", "question_id": 2082}, {"snippet": "def expected_cost(numobj): DCNL  DCSP region_codes = region_codes_for_country_code(numobj.country_code) DCNL DCSP if (len(region_codes) == 0): DCNL DCSP  DCSP return ShortNumberCost.UNKNOWN_COST DCNL DCSP if (len(region_codes) == 1): DCNL DCSP  DCSP return expected_cost_for_region(numobj, region_codes[0]) DCNL DCSP cost = ShortNumberCost.TOLL_FREE DCNL DCSP for region_code in region_codes: DCNL DCSP  DCSP cost_for_region = expected_cost_for_region(numobj, region_code) DCNL DCSP  DCSP if (cost_for_region == ShortNumberCost.PREMIUM_RATE): DCNL DCSP  DCSP  DCSP return ShortNumberCost.PREMIUM_RATE DCNL DCSP  DCSP elif (cost_for_region == ShortNumberCost.UNKNOWN_COST): DCNL DCSP  DCSP  DCSP return ShortNumberCost.UNKNOWN_COST DCNL DCSP  DCSP elif (cost_for_region == ShortNumberCost.STANDARD_RATE): DCNL DCSP  DCSP  DCSP if (cost != ShortNumberCost.UNKNOWN_COST): DCNL DCSP  DCSP  DCSP  DCSP cost = ShortNumberCost.STANDARD_RATE DCNL DCSP  DCSP elif (cost_for_region == ShortNumberCost.TOLL_FREE): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception('Unrecognized DCSP cost DCSP for DCSP region: DCSP %s', cost_for_region) DCNL DCSP return cost\n", "intent": "gets the expected cost category of a short number .\n", "question_id": 2083}, {"snippet": "def _prepare_message(txt): DCNL  DCSP def plain(val): DCNL DCSP  DCSP ' DCSP Return DCSP True DCSP when DCSP val DCSP is DCSP plain DCSP ASCII DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP val.decode('ascii') DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return False DCNL DCSP code = 'ISO-8859-1' DCNL DCSP msg = Message() DCNL DCSP payload = [] DCNL DCSP body = False DCNL DCSP header = False DCNL DCSP for line in txt.encode(code, 'replace').split('\\n'): DCNL DCSP  DCSP if (header and (not line)): DCNL DCSP  DCSP  DCSP body = True DCNL DCSP  DCSP if body: DCNL DCSP  DCSP  DCSP payload.append(line) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP m = RE_HEADER.search(line) DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP header = True DCNL DCSP  DCSP  DCSP  DCSP keyword = m.group(1).strip() DCNL DCSP  DCSP  DCSP  DCSP value = m.group(2).strip() DCNL DCSP  DCSP  DCSP  DCSP if plain(value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg.add_header(keyword, value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP header = Header(value, code) DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg[keyword] = header DCNL DCSP msg.set_payload('\\n'.join(payload), code) DCNL DCSP if (not msg.has_key('Content-Transfer-Encoding')): DCNL DCSP  DCSP encode_quopri(msg) DCNL DCSP return msg.as_string()\n", "intent": "apply the proper encoding to all email fields .\n", "question_id": 2084}, {"snippet": "def rules_2prereq(rules): DCNL  DCSP prereq = defaultdict(set) DCNL DCSP for ((a, _), impl) in rules.items(): DCNL DCSP  DCSP if isinstance(a, Not): DCNL DCSP  DCSP  DCSP a = a.args[0] DCNL DCSP  DCSP for (i, _) in impl: DCNL DCSP  DCSP  DCSP if isinstance(i, Not): DCNL DCSP  DCSP  DCSP  DCSP i = i.args[0] DCNL DCSP  DCSP  DCSP prereq[i].add(a) DCNL DCSP return prereq\n", "intent": "build prerequisites table from rules description by example given set of logic rules: a -> b .\n", "question_id": 2085}, {"snippet": "def getNormalWeighted(begin, center, end): DCNL  DCSP return (center - begin).cross((end - center))\n", "intent": "get weighted normal .\n", "question_id": 2086}, {"snippet": "def normalize(host_string, omit_port=False): DCNL  DCSP from fabric.state import env DCNL DCSP if (not host_string): DCNL DCSP  DCSP return (('', '') if omit_port else ('', '', '')) DCNL DCSP r = parse_host_string(host_string) DCNL DCSP host = r['host'] DCNL DCSP user = (env.user or env.local_user) DCNL DCSP conf = ssh_config(host_string) DCNL DCSP if ((user == env.local_user) and ('user' in conf)): DCNL DCSP  DCSP user = conf['user'] DCNL DCSP if ('hostname' in conf): DCNL DCSP  DCSP host = conf['hostname'] DCNL DCSP user = (r['user'] or user) DCNL DCSP if omit_port: DCNL DCSP  DCSP return (user, host) DCNL DCSP ssh_config_port = None DCNL DCSP if env.use_ssh_config: DCNL DCSP  DCSP ssh_config_port = conf.get('port', None) DCNL DCSP port = (r['port'] or ssh_config_port or env.port or env.default_port) DCNL DCSP return (user, host, port)\n", "intent": "normalizes a given host string .\n", "question_id": 2087}, {"snippet": "def compile_file(fullname, ddir=None, force=0, rx=None, quiet=0): DCNL  DCSP success = 1 DCNL DCSP name = os.path.basename(fullname) DCNL DCSP if (ddir is not None): DCNL DCSP  DCSP dfile = os.path.join(ddir, name) DCNL DCSP else: DCNL DCSP  DCSP dfile = None DCNL DCSP if (rx is not None): DCNL DCSP  DCSP mo = rx.search(fullname) DCNL DCSP  DCSP if mo: DCNL DCSP  DCSP  DCSP return success DCNL DCSP if os.path.isfile(fullname): DCNL DCSP  DCSP (head, tail) = (name[:(-3)], name[(-3):]) DCNL DCSP  DCSP if (tail == '.py'): DCNL DCSP  DCSP  DCSP if (not force): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP mtime = int(os.stat(fullname).st_mtime) DCNL DCSP  DCSP  DCSP  DCSP  DCSP expect = struct.pack('<4sl', imp.get_magic(), mtime) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cfile = (fullname + ((__debug__ and 'c') or 'o')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(cfile, 'rb') as chandle: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP actual = chandle.read(8) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (expect == actual): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return success DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP if (not quiet): DCNL DCSP  DCSP  DCSP  DCSP print 'Compiling', fullname, '...' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ok = py_compile.compile(fullname, None, dfile, True) DCNL DCSP  DCSP  DCSP except py_compile.PyCompileError as err: DCNL DCSP  DCSP  DCSP  DCSP if quiet: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Compiling', fullname, '...' DCNL DCSP  DCSP  DCSP  DCSP print err.msg DCNL DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP  DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP  DCSP print 'Sorry', e DCNL DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (ok == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP return success\n", "intent": "byte-compile one file .\n", "question_id": 2088}, {"snippet": "def simplefilter(f): DCNL  DCSP return type(f.__name__, (FunctionFilter,), {'function': f, '__module__': getattr(f, '__module__'), '__doc__': f.__doc__})\n", "intent": "decorator that converts a function into a filter:: @simplefilter def lowercase: for ttype .\n", "question_id": 2089}, {"snippet": "@nottest DCNL def _get_tests(fname, selector=None, nose_params=NOSE_COLLECT_PARAMS): DCNL  DCSP output_file = os.path.join(ARTIFACT_DIR, fname) DCNL DCSP collect_with_output = (nose_params % output_file) DCNL DCSP if (selector is not None): DCNL DCSP  DCSP cmd = ('%s DCSP %s DCSP -A DCSP \"%s\" DCSP w3af/' % (NOSETESTS, collect_with_output, selector)) DCNL DCSP else: DCNL DCSP  DCSP cmd = ('%s DCSP %s DCSP w3af/' % (NOSETESTS, collect_with_output)) DCNL DCSP cmd_args = shlex.split(cmd) DCNL DCSP logging.debug(('Collecting DCSP tests: DCSP \"%s\"' % cmd)) DCNL DCSP p = subprocess.Popen(cmd_args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, universal_newlines=True) DCNL DCSP (stdout, stderr) = p.communicate() DCNL DCSP if (p.returncode != 0): DCNL DCSP  DCSP logging.critical('Error DCSP while DCSP collecting DCSP tests!') DCNL DCSP  DCSP logging.critical(stdout) DCNL DCSP  DCSP logging.critical(stderr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP (test_suite, test_result) = parse_xunit(output_file) DCNL DCSP normalize_test_names(test_suite) DCNL DCSP logging.debug(('Collected DCSP %s DCSP tests.' % test_result.testsRun)) DCNL DCSP return test_suite\n", "intent": "collect tests and return them .\n", "question_id": 2090}, {"snippet": "def mixing_dict(xy, normalized=False): DCNL  DCSP d = {} DCNL DCSP psum = 0.0 DCNL DCSP for (x, y) in xy: DCNL DCSP  DCSP if (x not in d): DCNL DCSP  DCSP  DCSP d[x] = {} DCNL DCSP  DCSP if (y not in d): DCNL DCSP  DCSP  DCSP d[y] = {} DCNL DCSP  DCSP v = d[x].get(y, 0) DCNL DCSP  DCSP d[x][y] = (v + 1) DCNL DCSP  DCSP psum += 1 DCNL DCSP if normalized: DCNL DCSP  DCSP for (k, jdict) in d.items(): DCNL DCSP  DCSP  DCSP for j in jdict: DCNL DCSP  DCSP  DCSP  DCSP jdict[j] /= psum DCNL DCSP return d\n", "intent": "return a dictionary representation of mixing matrix .\n", "question_id": 2091}, {"snippet": "def create_resource(): DCNL  DCSP schema = get_schema() DCNL DCSP deserializer = RequestDeserializer(schema) DCNL DCSP serializer = ResponseSerializer(schema) DCNL DCSP controller = ResourceTypeController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)\n", "intent": "resourcetypeassociation resource factory method .\n", "question_id": 2092}, {"snippet": "def hex_digest(x): DCNL  DCSP assert isinstance(x, np.ndarray) DCNL DCSP rval = hashlib.md5(x.tostring()).hexdigest() DCNL DCSP rval = (((rval + '|strides=[') + ','.join((str(stride) for stride in x.strides))) + ']') DCNL DCSP rval = (((rval + '|shape=[') + ','.join((str(s) for s in x.shape))) + ']') DCNL DCSP return rval\n", "intent": "returns a short .\n", "question_id": 2093}, {"snippet": "def scott_bin_width(data, return_bins=False): DCNL  DCSP data = np.asarray(data) DCNL DCSP if (data.ndim != 1): DCNL DCSP  DCSP raise ValueError(u'data DCSP should DCSP be DCSP one-dimensional') DCNL DCSP n = data.size DCNL DCSP sigma = np.std(data) DCNL DCSP dx = ((3.5 * sigma) / (n ** (1 / 3))) DCNL DCSP if return_bins: DCNL DCSP  DCSP Nbins = np.ceil(((data.max() - data.min()) / dx)) DCNL DCSP  DCSP Nbins = max(1, Nbins) DCNL DCSP  DCSP bins = (data.min() + (dx * np.arange((Nbins + 1)))) DCNL DCSP  DCSP return (dx, bins) DCNL DCSP else: DCNL DCSP  DCSP return dx\n", "intent": "return the optimal histogram bin width using scotts rule scotts rule is a normal reference rule: it minimizes the integrated mean squared error in the bin approximation under the assumption that the data is approximately gaussian .\n", "question_id": 2094}, {"snippet": "def generate_cert(name): DCNL  DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP cert = '/etc/icinga2/pki/{0}.crt'.format(name) DCNL DCSP key = '/etc/icinga2/pki/{0}.key'.format(name) DCNL DCSP if (os.path.isfile(cert) and os.path.isfile(key)): DCNL DCSP  DCSP ret['comment'] = 'No DCSP execution DCSP needed. DCSP Cert: DCSP {0} DCSP and DCSP key: DCSP {1} DCSP already DCSP generated.'.format(cert, key) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP and DCSP key DCSP generation DCSP would DCSP be DCSP executed' DCNL DCSP  DCSP return ret DCNL DCSP cert_save = __salt__['icinga2.generate_cert'](name) DCNL DCSP if (not cert_save): DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP and DCSP key DCSP generated' DCNL DCSP  DCSP ret['changes']['cert'] = 'Executed. DCSP Certificate DCSP saved: DCSP {0}'.format(cert) DCNL DCSP  DCSP ret['changes']['key'] = 'Executed. DCSP Key DCSP saved: DCSP {0}'.format(key) DCNL DCSP return ret\n", "intent": "generate an icinga2 certificate and key on the client .\n", "question_id": 2095}, {"snippet": "def EnumTlbs(excludeFlags=0): DCNL  DCSP key = win32api.RegOpenKey(win32con.HKEY_CLASSES_ROOT, 'Typelib') DCNL DCSP iids = EnumKeys(key) DCNL DCSP results = [] DCNL DCSP for (iid, crap) in iids: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP key2 = win32api.RegOpenKey(key, str(iid)) DCNL DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for (version, tlbdesc) in EnumKeys(key2): DCNL DCSP  DCSP  DCSP major_minor = version.split('.', 1) DCNL DCSP  DCSP  DCSP if (len(major_minor) < 2): DCNL DCSP  DCSP  DCSP  DCSP major_minor.append('0') DCNL DCSP  DCSP  DCSP major = major_minor[0] DCNL DCSP  DCSP  DCSP minor = major_minor[1] DCNL DCSP  DCSP  DCSP key3 = win32api.RegOpenKey(key2, str(version)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP flags = int(win32api.RegQueryValue(key3, 'FLAGS')) DCNL DCSP  DCSP  DCSP except (win32api.error, ValueError): DCNL DCSP  DCSP  DCSP  DCSP flags = 0 DCNL DCSP  DCSP  DCSP if ((flags & excludeFlags) == 0): DCNL DCSP  DCSP  DCSP  DCSP for (lcid, crap) in EnumKeys(key3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lcid = int(lcid) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP key4 = win32api.RegOpenKey(key3, ('%s\\\\win32' % (lcid,))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (dll, typ) = win32api.RegQueryValueEx(key4, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (typ == win32con.REG_EXPAND_SZ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dll = win32api.ExpandEnvironmentStrings(dll) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dll = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec = TypelibSpec(iid, lcid, major, minor, flags) DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.dll = dll DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.desc = tlbdesc DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.ver_desc = (((tlbdesc + ' DCSP (') + version) + ')') DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.append(spec) DCNL DCSP return results\n", "intent": "return a list of typelibspec objects .\n", "question_id": 2096}, {"snippet": "def build_docs(branch): DCNL  DCSP os.chdir(os.path.join(gitdname, 'docs')) DCNL DCSP retcode = subprocess.call('make DCSP clean', shell=True, stdout=sys.stdout, stderr=sys.stderr) DCNL DCSP if (retcode != 0): DCNL DCSP  DCSP os.chdir(dname) DCNL DCSP  DCSP msg = ('Could DCSP not DCSP clean DCSP the DCSP html DCSP docs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP sphinx_call = ' DCSP '.join(['make', 'html', \"SPHINXBUILD=' DCSP python DCSP /usr/local/bin/sphinx-build'\"]) DCNL DCSP activate = os.path.join(virtual_dir, 'bin', 'activate') DCNL DCSP activate_virtualenv = ('. DCSP ' + activate) DCNL DCSP retcode = subprocess.call(' DCSP && DCSP '.join([activate_virtualenv, sphinx_call]), shell=True, env=env, stdout=sys.stdout, stderr=sys.stderr) DCNL DCSP if (retcode != 0): DCNL DCSP  DCSP os.chdir(dname) DCNL DCSP  DCSP msg = ('Could DCSP not DCSP build DCSP the DCSP html DCSP docs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP os.chdir(dname)\n", "intent": "changes into gitdname and builds the docs using buildenv virtualenv .\n", "question_id": 2097}, {"snippet": "def _get_limit_param(request): DCNL  DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit\n", "intent": "extract integer limit from request or fail .\n", "question_id": 2098}, {"snippet": "def _get_search_rank(collection_id): DCNL  DCSP rights = rights_manager.get_collection_rights(collection_id) DCNL DCSP rank = (_DEFAULT_RANK + (_STATUS_PUBLICIZED_BONUS if (rights.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED) else 0)) DCNL DCSP return max(rank, 0)\n", "intent": "gets the search rank of a given collection .\n", "question_id": 2099}, {"snippet": "def confirm(question, error_response='Valid DCSP options DCSP : DCSP yes DCSP or DCSP no'): DCNL  DCSP while True: DCNL DCSP  DCSP answer = raw_input(question).lower() DCNL DCSP  DCSP if (answer in ('y', 'yes')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (answer in ('n', 'no')): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP print error_response\n", "intent": "ask the user if they would like to perform the action parameters: question       - the question you would like to ask the user to confirm .\n", "question_id": 2100}, {"snippet": "@verbose DCNL def gamma_map(evoked, forward, noise_cov, alpha, loose=0.2, depth=0.8, xyz_same_gamma=True, maxit=10000, tol=1e-06, update_mode=1, gammas=None, pca=True, return_residual=False, verbose=None): DCNL  DCSP _check_reference(evoked) DCNL DCSP if ((loose is None) and (not is_fixed_orient(forward))): DCNL DCSP  DCSP forward = deepcopy(forward) DCNL DCSP  DCSP _to_fixed_ori(forward) DCNL DCSP if (is_fixed_orient(forward) or (not xyz_same_gamma)): DCNL DCSP  DCSP group_size = 1 DCNL DCSP else: DCNL DCSP  DCSP group_size = 3 DCNL DCSP (gain, gain_info, whitener, source_weighting, mask) = _prepare_gain(forward, evoked.info, noise_cov, pca, depth, loose, None, None) DCNL DCSP sel = [evoked.ch_names.index(name) for name in gain_info['ch_names']] DCNL DCSP M = evoked.data[sel] DCNL DCSP logger.info('Whitening DCSP data DCSP matrix.') DCNL DCSP M = np.dot(whitener, M) DCNL DCSP (X, active_set) = _gamma_map_opt(M, gain, alpha, maxit=maxit, tol=tol, update_mode=update_mode, gammas=gammas, group_size=group_size, verbose=verbose) DCNL DCSP if (len(active_set) == 0): DCNL DCSP  DCSP raise Exception('No DCSP active DCSP dipoles DCSP found. DCSP alpha DCSP is DCSP too DCSP big.') DCNL DCSP n_dip_per_pos = (1 if is_fixed_orient(forward) else 3) DCNL DCSP X = _reapply_source_weighting(X, source_weighting, active_set, n_dip_per_pos) DCNL DCSP if return_residual: DCNL DCSP  DCSP residual = _compute_residual(forward, evoked, X, active_set, gain_info) DCNL DCSP if ((group_size == 1) and (not is_fixed_orient(forward))): DCNL DCSP  DCSP active_src = np.unique((active_set // 3)) DCNL DCSP  DCSP in_pos = 0 DCNL DCSP  DCSP if (len(X) < (3 * len(active_src))): DCNL DCSP  DCSP  DCSP X_xyz = np.zeros(((3 * len(active_src)), X.shape[1]), dtype=X.dtype) DCNL DCSP  DCSP  DCSP for ii in range(len(active_src)): DCNL DCSP  DCSP  DCSP  DCSP for jj in range(3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (in_pos >= len(active_set)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((active_set[in_pos] + jj) % 3) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP X_xyz[((3 * ii) + jj)] = X[in_pos] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in_pos += 1 DCNL DCSP  DCSP  DCSP X = X_xyz DCNL DCSP tmin = evoked.times[0] DCNL DCSP tstep = (1.0 / evoked.info['sfreq']) DCNL DCSP stc = _make_sparse_stc(X, active_set, forward, tmin, tstep, active_is_idx=True, verbose=verbose) DCNL DCSP if return_residual: DCNL DCSP  DCSP return (stc, residual) DCNL DCSP else: DCNL DCSP  DCSP return stc\n", "intent": "hierarchical bayes  sparse source localization method .\n", "question_id": 2101}, {"snippet": "def test_ecliptic_heliobary(): DCNL  DCSP icrs = ICRS((1 * u.deg), (2 * u.deg), distance=(1.5 * R_sun)) DCNL DCSP bary = icrs.transform_to(BarycentricTrueEcliptic) DCNL DCSP helio = icrs.transform_to(HeliocentricTrueEcliptic) DCNL DCSP assert (np.abs((bary.distance - helio.distance)) > (1 * u.km)) DCNL DCSP helio_in_bary_frame = bary.realize_frame(helio.cartesian) DCNL DCSP assert (bary.separation(helio_in_bary_frame) > (1 * u.arcmin))\n", "intent": "check that the ecliptic transformations for heliocentric and barycentric at least more or less make sense .\n", "question_id": 2102}, {"snippet": "@yield_once DCNL def _iter_choices(pattern): DCNL  DCSP start_pos = 0 DCNL DCSP split_pos_list = [match.start() for match in re.finditer('\\\\|', pattern)] DCNL DCSP split_pos_list.append(len(pattern)) DCNL DCSP for end_pos in split_pos_list: DCNL DCSP  DCSP if (not _position_is_bracketed(pattern, end_pos)): DCNL DCSP  DCSP  DCSP (yield pattern[start_pos:end_pos]) DCNL DCSP  DCSP  DCSP start_pos = (end_pos + 1)\n", "intent": "iterate through each choice of an alternative .\n", "question_id": 2103}, {"snippet": "def null_javascript_catalog(request, domain=None, packages=None): DCNL  DCSP return http.HttpResponse((NullSource + InterPolate), 'text/javascript')\n", "intent": "returns \"identity\" versions of the javascript i18n functions -- i .\n", "question_id": 2104}, {"snippet": "def make_ip_network(port, network): DCNL  DCSP ip_address = netaddr.IPAddress(port['fixed_ips'][0]['ip_address']) DCNL DCSP return netaddr.IPNetwork((ip_address.value, network.prefixlen))\n", "intent": "make an ipnetwork object from port and network .\n", "question_id": 2105}, {"snippet": "def _enqueue_feedback_thread_status_change_email_task(user_id, reference, old_status, new_status): DCNL  DCSP payload = {'user_id': user_id, 'reference_dict': reference.to_dict(), 'old_status': old_status, 'new_status': new_status} DCNL DCSP taskqueue_services.enqueue_task(feconf.TASK_URL_FEEDBACK_STATUS_EMAILS, payload, 0)\n", "intent": "adds a task for sending email when a feedback thread status is changed .\n", "question_id": 2106}, {"snippet": "def register_plugin(impl, name=None): DCNL  DCSP if (name is None): DCNL DCSP  DCSP name = impl.name DCNL DCSP with REGISTRY_LOCK: DCNL DCSP  DCSP PLUGIN_REGISTRY[name] = impl DCNL DCSP  DCSP if (name not in PLUGIN_DEPENDENTS): DCNL DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[name] = set() DCNL DCSP  DCSP for dep in impl.dependencies: DCNL DCSP  DCSP  DCSP if (dep not in PLUGIN_DEPENDENTS): DCNL DCSP  DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[dep] = set() DCNL DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[dep].add(name)\n", "intent": "add a new plugin implementation to the registry .\n", "question_id": 2107}, {"snippet": "def from_any(size, fraction_ref=None): DCNL  DCSP if cbook.is_numlike(size): DCNL DCSP  DCSP return Fixed(size) DCNL DCSP elif cbook.is_string_like(size): DCNL DCSP  DCSP if (size[(-1)] == u'%'): DCNL DCSP  DCSP  DCSP return Fraction((float(size[:(-1)]) / 100.0), fraction_ref) DCNL DCSP raise ValueError(u'Unknown DCSP format')\n", "intent": "creates fixed unit when the first argument is a float .\n", "question_id": 2108}, {"snippet": "def md5_shard(word): DCNL  DCSP data = word.encode('utf-8') DCNL DCSP return ('server%d' % (hashlib.md5(data).digest()[(-1)] % 4))\n", "intent": "assign data to servers using a public hash algorithm .\n", "question_id": 2109}, {"snippet": "def get_current_module_name(): DCNL  DCSP return os.environ['CURRENT_MODULE_ID']\n", "intent": "returns the module name of the current instance .\n", "question_id": 2110}, {"snippet": "def _rfc3339_to_datetime(dt_str): DCNL  DCSP return datetime.datetime.strptime(dt_str, _RFC3339_MICROS).replace(tzinfo=UTC)\n", "intent": "convert a microsecond-precision timetamp to a native datetime .\n", "question_id": 2111}, {"snippet": "def LocalService(name): DCNL  DCSP assert odoo.conf.deprecation.allow_local_service DCNL DCSP _logger.warning((\"LocalService() DCSP is DCSP deprecated DCSP since DCSP march DCSP 2013 DCSP (it DCSP was DCSP called DCSP with DCSP '%s').\" % name)) DCNL DCSP if (name == 'workflow'): DCNL DCSP  DCSP return odoo.workflow DCNL DCSP if name.startswith('report.'): DCNL DCSP  DCSP report = odoo.report.interface.report_int._reports.get(name) DCNL DCSP  DCSP if report: DCNL DCSP  DCSP  DCSP return report DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP dbname = getattr(threading.currentThread(), 'dbname', None) DCNL DCSP  DCSP  DCSP if dbname: DCNL DCSP  DCSP  DCSP  DCSP registry = odoo.registry(dbname) DCNL DCSP  DCSP  DCSP  DCSP with registry.cursor() as cr: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return registry['ir.actions.report.xml']._lookup_report(cr, name[len('report.'):])\n", "intent": "the odoo .\n", "question_id": 2112}, {"snippet": "def _count1Bits(num): DCNL  DCSP ret = 0 DCNL DCSP while (num > 0): DCNL DCSP  DCSP num = (num >> 1) DCNL DCSP  DCSP ret += 1 DCNL DCSP return ret\n", "intent": "find the highest bit set to 1 in an integer .\n", "question_id": 2113}, {"snippet": "def FastaM10Iterator(handle, alphabet=single_letter_alphabet): DCNL  DCSP if (alphabet is None): DCNL DCSP  DCSP alphabet = single_letter_alphabet DCNL DCSP state_PREAMBLE = (-1) DCNL DCSP state_NONE = 0 DCNL DCSP state_QUERY_HEADER = 1 DCNL DCSP state_ALIGN_HEADER = 2 DCNL DCSP state_ALIGN_QUERY = 3 DCNL DCSP state_ALIGN_MATCH = 4 DCNL DCSP state_ALIGN_CONS = 5 DCNL DCSP def build_hsp(): DCNL DCSP  DCSP if ((not query_tags) and (not match_tags)): DCNL DCSP  DCSP  DCSP raise ValueError(('No DCSP data DCSP for DCSP query DCSP %r, DCSP match DCSP %r' % (query_id, match_id))) DCNL DCSP  DCSP assert query_tags, query_tags DCNL DCSP  DCSP assert match_tags, match_tags DCNL DCSP  DCSP evalue = align_tags.get('fa_expect') DCNL DCSP  DCSP q = '?' DCNL DCSP  DCSP m = '?' DCNL DCSP  DCSP tool = global_tags.get('tool', '').upper() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP q = _extract_alignment_region(query_seq, query_tags) DCNL DCSP  DCSP  DCSP if ((tool in ['TFASTX']) and (len(match_seq) == len(q))): DCNL DCSP  DCSP  DCSP  DCSP m = match_seq DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP m = _extract_alignment_region(match_seq, match_tags) DCNL DCSP  DCSP  DCSP assert (len(q) == len(m)) DCNL DCSP  DCSP except AssertionError as err: DCNL DCSP  DCSP  DCSP print('Darn... DCSP amino DCSP acids DCSP vs DCSP nucleotide DCSP coordinates?') DCNL DCSP  DCSP  DCSP print(tool) DCNL DCSP  DCSP  DCSP print(query_seq) DCNL DCSP  DCSP  DCSP print(query_tags) DCNL DCSP  DCSP  DCSP print(('%s DCSP %i' % (q, len(q)))) DCNL DCSP  DCSP  DCSP print(match_seq) DCNL DCSP  DCSP  DCSP print(match_tags) DCNL DCSP  DCSP  DCSP print(('%s DCSP %i' % (m, len(m)))) DCNL DCSP  DCSP  DCSP print(handle.name) DCNL DCSP  DCSP  DCSP raise err DCNL DCSP  DCSP assert (alphabet is not None) DCNL DCSP  DCSP alignment = MultipleSeqAlignment([], alphabet) DCNL DCSP  DCSP alignment._annotations = {} DCNL DCSP  DCSP for (key, value) in header_tags.items(): DCNL DCSP  DCSP  DCSP alignment._annotations[key] = value DCNL DCSP  DCSP for (key, value) in align_tags.items(): DCNL DCSP  DCSP  DCSP alignment._annotations[key] = value DCNL DCSP  DCSP record = SeqRecord(Seq(q, alphabet), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])}) DCNL DCSP  DCSP record._al_start = int(query_tags['al_start']) DCNL DCSP  DCSP record._al_stop = int(query_tags['al_stop']) DCNL DCSP  DCSP alignment.append(record) DCNL DCSP  DCSP if ((alphabet == single_letter_alphabet) and ('sq_type' in query_tags)): DCNL DCSP  DCSP  DCSP if (query_tags['sq_type'] == 'D'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_dna DCNL DCSP  DCSP  DCSP elif (query_tags['sq_type'] == 'p'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_protein DCNL DCSP  DCSP if ('-' in q): DCNL DCSP  DCSP  DCSP if (not hasattr(record.seq.alphabet, 'gap_char')): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = Gapped(record.seq.alphabet, '-') DCNL DCSP  DCSP record = SeqRecord(Seq(m, alphabet), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])}) DCNL DCSP  DCSP record._al_start = int(match_tags['al_start']) DCNL DCSP  DCSP record._al_stop = int(match_tags['al_stop']) DCNL DCSP  DCSP alignment.append(record) DCNL DCSP  DCSP if ((alphabet == single_letter_alphabet) and ('sq_type' in match_tags)): DCNL DCSP  DCSP  DCSP if (match_tags['sq_type'] == 'D'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_dna DCNL DCSP  DCSP  DCSP elif (match_tags['sq_type'] == 'p'): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = generic_protein DCNL DCSP  DCSP if ('-' in m): DCNL DCSP  DCSP  DCSP if (not hasattr(record.seq.alphabet, 'gap_char')): DCNL DCSP  DCSP  DCSP  DCSP record.seq.alphabet = Gapped(record.seq.alphabet, '-') DCNL DCSP  DCSP return alignment DCNL DCSP state = state_PREAMBLE DCNL DCSP query_id = None DCNL DCSP match_id = None DCNL DCSP query_descr = '' DCNL DCSP match_descr = '' DCNL DCSP global_tags = {} DCNL DCSP header_tags = {} DCNL DCSP align_tags = {} DCNL DCSP query_tags = {} DCNL DCSP match_tags = {} DCNL DCSP query_seq = '' DCNL DCSP match_seq = '' DCNL DCSP cons_seq = '' DCNL DCSP for line in handle: DCNL DCSP  DCSP if (('>>>' in line) and (not line.startswith('>>>'))): DCNL DCSP  DCSP  DCSP if (query_id and match_id): DCNL DCSP  DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP state = state_NONE DCNL DCSP  DCSP  DCSP query_descr = line[(line.find('>>>') + 3):].strip() DCNL DCSP  DCSP  DCSP query_id = query_descr.split(None, 1)[0] DCNL DCSP  DCSP  DCSP match_id = None DCNL DCSP  DCSP  DCSP header_tags = {} DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP elif line.startswith('!! DCSP No DCSP '): DCNL DCSP  DCSP  DCSP assert (state == state_NONE) DCNL DCSP  DCSP  DCSP assert (not header_tags) DCNL DCSP  DCSP  DCSP assert (not align_tags) DCNL DCSP  DCSP  DCSP assert (not match_tags) DCNL DCSP  DCSP  DCSP assert (not query_tags) DCNL DCSP  DCSP  DCSP assert (match_id is None) DCNL DCSP  DCSP  DCSP assert (not query_seq) DCNL DCSP  DCSP  DCSP assert (not match_seq) DCNL DCSP  DCSP  DCSP assert (not cons_seq) DCNL DCSP  DCSP  DCSP query_id = None DCNL DCSP  DCSP elif (line.strip() in ['>>><<<', '>>>///']): DCNL DCSP  DCSP  DCSP if (query_id and match_id): DCNL DCSP  DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP state = state_NONE DCNL DCSP  DCSP  DCSP query_id = None DCNL DCSP  DCSP  DCSP match_id = None DCNL DCSP  DCSP  DCSP header_tags = {} DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP elif line.startswith('>>>'): DCNL DCSP  DCSP  DCSP assert (query_id is not None) DCNL DCSP  DCSP  DCSP assert (line[3:].split(', DCSP ', 1)[0] == query_id), line DCNL DCSP  DCSP  DCSP assert (match_id is None) DCNL DCSP  DCSP  DCSP assert (not header_tags) DCNL DCSP  DCSP  DCSP assert (not align_tags) DCNL DCSP  DCSP  DCSP assert (not query_tags) DCNL DCSP  DCSP  DCSP assert (not match_tags) DCNL DCSP  DCSP  DCSP assert (not match_seq) DCNL DCSP  DCSP  DCSP assert (not query_seq) DCNL DCSP  DCSP  DCSP assert (not cons_seq) DCNL DCSP  DCSP  DCSP state = state_QUERY_HEADER DCNL DCSP  DCSP elif line.startswith('>>'): DCNL DCSP  DCSP  DCSP if (query_id and match_id): DCNL DCSP  DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP  DCSP match_descr = line[2:].strip() DCNL DCSP  DCSP  DCSP match_id = match_descr.split(None, 1)[0] DCNL DCSP  DCSP  DCSP state = state_ALIGN_HEADER DCNL DCSP  DCSP elif line.startswith('>--'): DCNL DCSP  DCSP  DCSP assert (query_id and match_id), line DCNL DCSP  DCSP  DCSP (yield build_hsp()) DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP query_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP query_seq = '' DCNL DCSP  DCSP  DCSP match_seq = '' DCNL DCSP  DCSP  DCSP cons_seq = '' DCNL DCSP  DCSP  DCSP state = state_ALIGN_HEADER DCNL DCSP  DCSP elif line.startswith('>'): DCNL DCSP  DCSP  DCSP if (state == state_ALIGN_HEADER): DCNL DCSP  DCSP  DCSP  DCSP assert (query_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert (match_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert query_id.startswith(line[1:].split(None, 1)[0]), line DCNL DCSP  DCSP  DCSP  DCSP state = state_ALIGN_QUERY DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP  DCSP assert (query_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert (match_id is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert match_id.startswith(line[1:].split(None, 1)[0]), line DCNL DCSP  DCSP  DCSP  DCSP state = state_ALIGN_MATCH DCNL DCSP  DCSP  DCSP elif (state == state_NONE): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert False, ('state DCSP %i DCSP got DCSP %r' % (state, line)) DCNL DCSP  DCSP elif line.startswith('; DCSP al_cons'): DCNL DCSP  DCSP  DCSP assert (state == state_ALIGN_MATCH), line DCNL DCSP  DCSP  DCSP state = state_ALIGN_CONS DCNL DCSP  DCSP elif line.startswith('; DCSP '): DCNL DCSP  DCSP  DCSP if (': DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP (key, value) = [s.strip() for s in line[2:].split(': DCSP ', 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(('Missing DCSP colon DCSP in DCSP line: DCSP %r' % line)) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (key, value) = [s.strip() for s in line[2:].split(' DCSP ', 1)] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Bad DCSP line: DCSP %r' % line)) DCNL DCSP  DCSP  DCSP if (state == state_QUERY_HEADER): DCNL DCSP  DCSP  DCSP  DCSP header_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_HEADER): DCNL DCSP  DCSP  DCSP  DCSP align_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP  DCSP query_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_MATCH): DCNL DCSP  DCSP  DCSP  DCSP match_tags[key] = value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert False, ('Unexpected DCSP state DCSP %r, DCSP %r' % (state, line)) DCNL DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP query_seq += line.strip() DCNL DCSP  DCSP elif (state == state_ALIGN_MATCH): DCNL DCSP  DCSP  DCSP match_seq += line.strip() DCNL DCSP  DCSP elif (state == state_ALIGN_CONS): DCNL DCSP  DCSP  DCSP cons_seq += line.strip('\\n') DCNL DCSP  DCSP elif (state == state_PREAMBLE): DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP global_tags['command'] = line[1:].strip() DCNL DCSP  DCSP  DCSP elif line.startswith(' DCSP version DCSP '): DCNL DCSP  DCSP  DCSP  DCSP global_tags['version'] = line[9:].strip() DCNL DCSP  DCSP  DCSP elif (' DCSP compares DCSP a DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP global_tags['tool'] = line[:line.find(' DCSP compares DCSP a DCSP ')].strip() DCNL DCSP  DCSP  DCSP elif (' DCSP searches DCSP a DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP global_tags['tool'] = line[:line.find(' DCSP searches DCSP a DCSP ')].strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass\n", "intent": "alignment iterator for the fasta tools pairwise alignment output .\n", "question_id": 2114}, {"snippet": "@register.filter DCNL def xssafe(value): DCNL  DCSP return jinja2.Markup(value)\n", "intent": "like |safe but for strings with interpolation .\n", "question_id": 2115}, {"snippet": "def GetDefaultConcurrentLinks(): DCNL  DCSP pool_size = int(os.environ.get('GYP_LINK_CONCURRENCY', 0)) DCNL DCSP if pool_size: DCNL DCSP  DCSP return pool_size DCNL DCSP if (sys.platform in ('win32', 'cygwin')): DCNL DCSP  DCSP import ctypes DCNL DCSP  DCSP class MEMORYSTATUSEX(ctypes.Structure, ): DCNL DCSP  DCSP  DCSP _fields_ = [('dwLength', ctypes.c_ulong), ('dwMemoryLoad', ctypes.c_ulong), ('ullTotalPhys', ctypes.c_ulonglong), ('ullAvailPhys', ctypes.c_ulonglong), ('ullTotalPageFile', ctypes.c_ulonglong), ('ullAvailPageFile', ctypes.c_ulonglong), ('ullTotalVirtual', ctypes.c_ulonglong), ('ullAvailVirtual', ctypes.c_ulonglong), ('sullAvailExtendedVirtual', ctypes.c_ulonglong)] DCNL DCSP  DCSP stat = MEMORYSTATUSEX() DCNL DCSP  DCSP stat.dwLength = ctypes.sizeof(stat) DCNL DCSP  DCSP ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat)) DCNL DCSP  DCSP mem_limit = max(1, (stat.ullTotalPhys / (5 * (2 ** 30)))) DCNL DCSP  DCSP hard_cap = max(1, int(os.environ.get('GYP_LINK_CONCURRENCY_MAX', (2 ** 32)))) DCNL DCSP  DCSP return min(mem_limit, hard_cap) DCNL DCSP elif sys.platform.startswith('linux'): DCNL DCSP  DCSP if os.path.exists('/proc/meminfo'): DCNL DCSP  DCSP  DCSP with open('/proc/meminfo') as meminfo: DCNL DCSP  DCSP  DCSP  DCSP memtotal_re = re.compile('^MemTotal:\\\\s*(\\\\d*)\\\\s*kB') DCNL DCSP  DCSP  DCSP  DCSP for line in meminfo: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = memtotal_re.match(line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP return max(1, (int(match.group(1)) / (8 * (2 ** 20)))) DCNL DCSP  DCSP return 1 DCNL DCSP elif (sys.platform == 'darwin'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP avail_bytes = int(subprocess.check_output(['sysctl', '-n', 'hw.memsize'])) DCNL DCSP  DCSP  DCSP return max(1, (avail_bytes / (4 * (2 ** 30)))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 1\n", "intent": "returns a best-guess for a number of concurrent links .\n", "question_id": 2116}, {"snippet": "def process_all_packages(pkgmgr, client_dir, remove=False): DCNL  DCSP dep_dir = os.path.join(client_dir, 'deps') DCNL DCSP prof_dir = os.path.join(client_dir, 'profilers') DCNL DCSP temp_dir = tempfile.mkdtemp() DCNL DCSP try: DCNL DCSP  DCSP base_packages.check_diskspace(temp_dir) DCNL DCSP except error.RepoDiskFullError as e: DCNL DCSP  DCSP print ('Temp DCSP destination DCSP for DCSP packages DCSP is DCSP full DCSP %s, DCSP aborting DCSP upload: DCSP %s' % (temp_dir, e)) DCNL DCSP  DCSP os.rmdir(temp_dir) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP tests_list = get_subdir_list('tests', client_dir) DCNL DCSP tests = ','.join(tests_list) DCNL DCSP site_tests_list = get_subdir_list('site_tests', client_dir) DCNL DCSP site_tests = ','.join(site_tests_list) DCNL DCSP deps_list = get_subdir_list('deps', client_dir) DCNL DCSP deps = ','.join(deps_list) DCNL DCSP profilers_list = get_subdir_list('profilers', client_dir) DCNL DCSP profilers = ','.join(profilers_list) DCNL DCSP if (not remove): DCNL DCSP  DCSP tar_packages(pkgmgr, 'profiler', profilers, prof_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'dep', deps, dep_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'test', site_tests, client_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'test', tests, client_dir, temp_dir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'client', 'autotest', client_dir, temp_dir) DCNL DCSP  DCSP cwd = os.getcwd() DCNL DCSP  DCSP os.chdir(temp_dir) DCNL DCSP  DCSP client_utils.system('md5sum DCSP * DCSP > DCSP packages.checksum') DCNL DCSP  DCSP os.chdir(cwd) DCNL DCSP  DCSP pkgmgr.upload_pkg(temp_dir) DCNL DCSP  DCSP client_utils.run(('rm DCSP -rf DCSP ' + temp_dir)) DCNL DCSP else: DCNL DCSP  DCSP process_packages(pkgmgr, 'test', tests, client_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'test', site_tests, client_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'client', 'autotest', client_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'dep', deps, dep_dir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'profiler', profilers, prof_dir, remove=remove)\n", "intent": "process a full upload of packages as a directory upload .\n", "question_id": 2117}, {"snippet": "def write_backreferences(seen_backrefs, gallery_conf, target_dir, fname, snippet): DCNL  DCSP example_file = os.path.join(target_dir, fname) DCNL DCSP build_target = os.path.relpath(target_dir, gallery_conf['src_dir']) DCNL DCSP backrefs = scan_used_functions(example_file, gallery_conf) DCNL DCSP for backref in backrefs: DCNL DCSP  DCSP include_path = os.path.join(gallery_conf['src_dir'], gallery_conf['mod_example_dir'], ('%s.examples' % backref)) DCNL DCSP  DCSP seen = (backref in seen_backrefs) DCNL DCSP  DCSP with open(include_path, ('a' if seen else 'w')) as ex_file: DCNL DCSP  DCSP  DCSP if (not seen): DCNL DCSP  DCSP  DCSP  DCSP heading = ('\\n\\nExamples DCSP using DCSP ``%s``' % backref) DCNL DCSP  DCSP  DCSP  DCSP ex_file.write((heading + '\\n')) DCNL DCSP  DCSP  DCSP  DCSP ex_file.write((('^' * len(heading)) + '\\n')) DCNL DCSP  DCSP  DCSP ex_file.write(_thumbnail_div(build_target, fname, snippet, is_backref=True)) DCNL DCSP  DCSP  DCSP seen_backrefs.add(backref)\n", "intent": "writes down back reference files .\n", "question_id": 2118}, {"snippet": "def addToMenu(master, menu, repository, window): DCNL  DCSP metaFilePath = archive.getSkeinforgePluginsPath('meta.py') DCNL DCSP settings.addPluginsParentToMenu(skeinforge_meta.getPluginsDirectoryPath(), menu, metaFilePath, skeinforge_meta.getPluginFileNames())\n", "intent": "add a tool plugin menu .\n", "question_id": 2119}, {"snippet": "def onlyPy26OrOlder(test): DCNL  DCSP @functools.wraps(test) DCNL DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP msg = '{name} DCSP only DCSP runs DCSP on DCSP Python2.6.x DCSP or DCSP older'.format(name=test.__name__) DCNL DCSP  DCSP if (sys.version_info >= (2, 7)): DCNL DCSP  DCSP  DCSP raise SkipTest(msg) DCNL DCSP  DCSP return test(*args, **kwargs) DCNL DCSP return wrapper\n", "intent": "skips this test unless you are on python2 .\n", "question_id": 2120}, {"snippet": "def addListToListTable(elementList, key, listTable): DCNL  DCSP if (key in listTable): DCNL DCSP  DCSP listTable[key] += elementList DCNL DCSP else: DCNL DCSP  DCSP listTable[key] = elementList\n", "intent": "add a list to the list table .\n", "question_id": 2121}, {"snippet": "def getGeometryOutput(derivation, elementNode): DCNL  DCSP if (derivation == None): DCNL DCSP  DCSP derivation = PegDerivation(elementNode) DCNL DCSP positives = [] DCNL DCSP radiusArealized = complex(derivation.radiusArealized, derivation.radiusArealized) DCNL DCSP addPegOutput(derivation.bevel, derivation.endZ, positives, radiusArealized, derivation.sides, derivation.start, derivation.topOverBottom) DCNL DCSP return extrude.getGeometryOutputByNegativesPositives(elementNode, [], positives)\n", "intent": "get vector3 vertexes from attribute dictionary .\n", "question_id": 2122}, {"snippet": "def assert_array_less(x, y, err_msg='', verbose=True): DCNL  DCSP numpy.testing.assert_array_less(cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg, verbose=verbose)\n", "intent": "raises an assertionerror if array_like objects are not ordered by less than .\n", "question_id": 2123}, {"snippet": "def zeros_like(a, dtype=None): DCNL  DCSP if (dtype is None): DCNL DCSP  DCSP dtype = a.dtype DCNL DCSP return zeros(a.shape, dtype=dtype)\n", "intent": "returns an array of zeros with same shape and dtype as a given array .\n", "question_id": 2124}, {"snippet": "def short_group_names(groups): DCNL  DCSP groups = groups.split(u',') DCNL DCSP shortGroupList = [] DCNL DCSP if sickrage.srCore.ADBA_CONNECTION: DCNL DCSP  DCSP for groupName in groups: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP group = sickrage.srCore.ADBA_CONNECTION.group(gname=groupName) DCNL DCSP  DCSP  DCSP except AniDBCommandTimeoutError: DCNL DCSP  DCSP  DCSP  DCSP sickrage.srCore.srLogger.debug(u'Timeout DCSP while DCSP loading DCSP group DCSP from DCSP AniDB. DCSP Trying DCSP next DCSP group') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sickrage.srCore.srLogger.debug(u'Failed DCSP while DCSP loading DCSP group DCSP from DCSP AniDB. DCSP Trying DCSP next DCSP group') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for line in group.datalines: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line[u'shortname']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shortGroupList.append(line[u'shortname']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (groupName not in shortGroupList): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shortGroupList.append(groupName) DCNL DCSP else: DCNL DCSP  DCSP shortGroupList = groups DCNL DCSP return shortGroupList\n", "intent": "find anidb short group names for release groups .\n", "question_id": 2125}, {"snippet": "def sort_otu_table(otu_table, sorted_sample_ids): DCNL  DCSP sorted_sample_ids_set = set(sorted_sample_ids) DCNL DCSP if (set(otu_table.ids()) - sorted_sample_ids_set): DCNL DCSP  DCSP raise KeyError(('Sample DCSP IDs DCSP present DCSP in DCSP OTU DCSP table DCSP but DCSP not DCSP sorted DCSP sample DCSP id DCSP list: DCSP ' + ' DCSP '.join(list((set(otu_table.ids()) - set(sorted_sample_ids)))))) DCNL DCSP if (len(sorted_sample_ids_set) != len(sorted_sample_ids)): DCNL DCSP  DCSP raise ValueError('Duplicate DCSP sample DCSP IDs DCSP are DCSP present DCSP in DCSP sorted DCSP sample DCSP id DCSP list.') DCNL DCSP safe_sorted_sample_ids = [] DCNL DCSP for k in sorted_sample_ids: DCNL DCSP  DCSP if otu_table.exists(k): DCNL DCSP  DCSP  DCSP safe_sorted_sample_ids.append(k) DCNL DCSP sorted_table = otu_table.sort_order(safe_sorted_sample_ids) DCNL DCSP return sorted_table\n", "intent": "sort an otu table by sorted sample ids .\n", "question_id": 2126}, {"snippet": "def query_package(module, name): DCNL  DCSP (rc, out, err) = module.run_command(('%s DCSP -p DCSP -v' % PKGIN_PATH)) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP pflag = '-p' DCNL DCSP  DCSP splitchar = ';' DCNL DCSP else: DCNL DCSP  DCSP pflag = '' DCNL DCSP  DCSP splitchar = ' DCSP ' DCNL DCSP (rc, out, err) = module.run_command(('%s DCSP %s DCSP search DCSP \"^%s$\"' % (PKGIN_PATH, pflag, name))) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP packages = out.split('\\n') DCNL DCSP  DCSP for package in packages: DCNL DCSP  DCSP  DCSP (pkgname_with_version, raw_state) = package.split(splitchar)[0:2] DCNL DCSP  DCSP  DCSP pkg_search_obj = re.search('^(.*?)\\\\-[0-9][0-9.]*(nb[0-9]+)*', pkgname_with_version, re.M) DCNL DCSP  DCSP  DCSP if (not pkg_search_obj): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pkgname_without_version = pkg_search_obj.group(1) DCNL DCSP  DCSP  DCSP if (name != pkgname_without_version): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (raw_state == '<'): DCNL DCSP  DCSP  DCSP  DCSP return 'outdated' DCNL DCSP  DCSP  DCSP elif ((raw_state == '=') or (raw_state == '>')): DCNL DCSP  DCSP  DCSP  DCSP return 'present' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return False\n", "intent": "search for the package by name .\n", "question_id": 2127}, {"snippet": "def OAuthTokenFromHttpBody(http_body): DCNL  DCSP token = oauth.OAuthToken.from_string(http_body) DCNL DCSP oauth_token = OAuthToken(key=token.key, secret=token.secret) DCNL DCSP return oauth_token\n", "intent": "parses the http response body and returns an oauth token .\n", "question_id": 2128}, {"snippet": "def pretty_try_use_unicode(): DCNL  DCSP try: DCNL DCSP  DCSP symbols = [] DCNL DCSP  DCSP symbols.extend(greek_unicode.values()) DCNL DCSP  DCSP symbols += atoms_table.values() DCNL DCSP  DCSP for s in symbols: DCNL DCSP  DCSP  DCSP if (s is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP encoding = getattr(sys.stdout, 'encoding', None) DCNL DCSP  DCSP  DCSP if (encoding is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP s.encode(encoding) DCNL DCSP except UnicodeEncodeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP pretty_use_unicode(True)\n", "intent": "see if unicode output is available and leverage it if possible .\n", "question_id": 2129}, {"snippet": "def dice_coe(output, target, epsilon=1e-10): DCNL  DCSP inse = tf.reduce_sum((output * target)) DCNL DCSP l = tf.reduce_sum((output * output)) DCNL DCSP r = tf.reduce_sum((target * target)) DCNL DCSP dice = ((2 * inse) / (l + r)) DCNL DCSP if (epsilon == 0): DCNL DCSP  DCSP return dice DCNL DCSP else: DCNL DCSP  DCSP return tf.clip_by_value(dice, 0, (1.0 - epsilon))\n", "intent": "srensendice coefficient for comparing the similarity of two distributions .\n", "question_id": 2130}, {"snippet": "def register_onaccept(form): DCNL  DCSP req_vars = form.request_vars DCNL DCSP position = req_vars.get('position', '') DCNL DCSP reason = req_vars.get('reason', '') DCNL DCSP db = current.db DCNL DCSP table = db.auth_user DCNL DCSP db((table.id == form.vars.id)).update(comments=('%s DCSP | DCSP %s' % (position, reason)))\n", "intent": "tasks to be performed after a new user registers .\n", "question_id": 2131}, {"snippet": "def encoding(argument): DCNL  DCSP try: DCNL DCSP  DCSP codecs.lookup(argument) DCNL DCSP except LookupError: DCNL DCSP  DCSP raise ValueError(('unknown DCSP encoding: DCSP \"%s\"' % argument)) DCNL DCSP return argument\n", "intent": "verfies the encoding argument by lookup .\n", "question_id": 2132}, {"snippet": "def unique_file_name(base_name, extension=''): DCNL  DCSP idcount = 0 DCNL DCSP if (extension and (not extension.startswith('.'))): DCNL DCSP  DCSP extension = ('.%s' % extension) DCNL DCSP fname = (base_name + extension) DCNL DCSP while os.path.exists(fname): DCNL DCSP  DCSP fname = ('%s-%d%s' % (base_name, idcount, extension)) DCNL DCSP  DCSP idcount += 1 DCNL DCSP return fname\n", "intent": "creates a unique file name based on the specified base name .\n", "question_id": 2133}, {"snippet": "def gettext(string, **variables): DCNL  DCSP return get_i18n().gettext(string, **variables)\n", "intent": "see :meth:i18n .\n", "question_id": 2134}, {"snippet": "def _queue_management_worker(executor_reference, processes, pending_work_items, work_ids_queue, call_queue, result_queue): DCNL  DCSP executor = None DCNL DCSP def shutting_down(): DCNL DCSP  DCSP return (_shutdown or (executor is None) or executor._shutdown_thread) DCNL DCSP def shutdown_worker(): DCNL DCSP  DCSP nb_children_alive = sum((p.is_alive() for p in processes.values())) DCNL DCSP  DCSP for i in range(0, nb_children_alive): DCNL DCSP  DCSP  DCSP call_queue.put_nowait(None) DCNL DCSP  DCSP call_queue.close() DCNL DCSP  DCSP for p in processes.values(): DCNL DCSP  DCSP  DCSP p.join() DCNL DCSP reader = result_queue._reader DCNL DCSP while True: DCNL DCSP  DCSP _add_call_item_to_queue(pending_work_items, work_ids_queue, call_queue) DCNL DCSP  DCSP sentinels = [p.sentinel for p in processes.values()] DCNL DCSP  DCSP assert sentinels DCNL DCSP  DCSP ready = wait(([reader] + sentinels)) DCNL DCSP  DCSP if (reader in ready): DCNL DCSP  DCSP  DCSP result_item = reader.recv() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP executor = executor_reference() DCNL DCSP  DCSP  DCSP if (executor is not None): DCNL DCSP  DCSP  DCSP  DCSP executor._broken = True DCNL DCSP  DCSP  DCSP  DCSP executor._shutdown_thread = True DCNL DCSP  DCSP  DCSP  DCSP executor = None DCNL DCSP  DCSP  DCSP for (work_id, work_item) in pending_work_items.items(): DCNL DCSP  DCSP  DCSP  DCSP work_item.future.set_exception(BrokenProcessPool('A DCSP process DCSP in DCSP the DCSP process DCSP pool DCSP was DCSP terminated DCSP abruptly DCSP while DCSP the DCSP future DCSP was DCSP running DCSP or DCSP pending.')) DCNL DCSP  DCSP  DCSP  DCSP del work_item DCNL DCSP  DCSP  DCSP pending_work_items.clear() DCNL DCSP  DCSP  DCSP for p in processes.values(): DCNL DCSP  DCSP  DCSP  DCSP p.terminate() DCNL DCSP  DCSP  DCSP shutdown_worker() DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if isinstance(result_item, int): DCNL DCSP  DCSP  DCSP assert shutting_down() DCNL DCSP  DCSP  DCSP p = processes.pop(result_item) DCNL DCSP  DCSP  DCSP p.join() DCNL DCSP  DCSP  DCSP if (not processes): DCNL DCSP  DCSP  DCSP  DCSP shutdown_worker() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP elif (result_item is not None): DCNL DCSP  DCSP  DCSP work_item = pending_work_items.pop(result_item.work_id, None) DCNL DCSP  DCSP  DCSP if (work_item is not None): DCNL DCSP  DCSP  DCSP  DCSP if result_item.exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP work_item.future.set_exception(result_item.exception) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP work_item.future.set_result(result_item.result) DCNL DCSP  DCSP  DCSP  DCSP del work_item DCNL DCSP  DCSP executor = executor_reference() DCNL DCSP  DCSP if shutting_down(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not pending_work_items): DCNL DCSP  DCSP  DCSP  DCSP  DCSP shutdown_worker() DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except Full: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP executor = None\n", "intent": "manages the communication between this process and the worker processes .\n", "question_id": 2135}, {"snippet": "def timefunc(correct, s, func, *args, **kwargs): DCNL  DCSP print(s.ljust(20), end=' DCSP ') DCNL DCSP res = func(*args, **kwargs) DCNL DCSP if (correct is not None): DCNL DCSP  DCSP assert np.allclose(res, correct), (res, correct) DCNL DCSP print('{:>5.0f} DCSP ms'.format((min(repeat((lambda : func(*args, **kwargs)), number=5, repeat=2)) * 1000))) DCNL DCSP return res\n", "intent": "benchmark *func* and print out its runtime .\n", "question_id": 2136}, {"snippet": "def is_private_subnet(ip): DCNL  DCSP priv_subnets = [{'subnet': '10.0.0.0', 'mask': '255.0.0.0'}, {'subnet': '172.16.0.0', 'mask': '255.240.0.0'}, {'subnet': '192.168.0.0', 'mask': '255.255.0.0'}] DCNL DCSP ip = struct.unpack('I', socket.inet_aton(ip))[0] DCNL DCSP for network in priv_subnets: DCNL DCSP  DCSP subnet = struct.unpack('I', socket.inet_aton(network['subnet']))[0] DCNL DCSP  DCSP mask = struct.unpack('I', socket.inet_aton(network['mask']))[0] DCNL DCSP  DCSP if ((ip & mask) == (subnet & mask)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False\n", "intent": "utility function to check if an ip address is inside a private subnet .\n", "question_id": 2137}, {"snippet": "def read_double(fid): DCNL  DCSP return _unpack_simple(fid, '>f8', np.float64)\n", "intent": "read 64bit float from bti file .\n", "question_id": 2138}, {"snippet": "def swap_inf_nan(val): DCNL  DCSP if isinstance(val, string_types): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, collections.Sequence): DCNL DCSP  DCSP return [swap_inf_nan(v) for v in val] DCNL DCSP elif isinstance(val, collections.Mapping): DCNL DCSP  DCSP return dict([(swap_inf_nan(k), swap_inf_nan(v)) for (k, v) in iteritems(val)]) DCNL DCSP elif isinstance(val, float): DCNL DCSP  DCSP if math.isnan(val): DCNL DCSP  DCSP  DCSP return '__NaN__' DCNL DCSP  DCSP elif (val == float('inf')): DCNL DCSP  DCSP  DCSP return '__Infinity__' DCNL DCSP  DCSP elif (val == float('-inf')): DCNL DCSP  DCSP  DCSP return '__-Infinity__' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return val DCNL DCSP else: DCNL DCSP  DCSP return val\n", "intent": "this takes an arbitrary object and preps it for jsonifying safely .\n", "question_id": 2139}, {"snippet": "def get_job_count_by_state(request, username): DCNL  DCSP res = {'completed': 0, 'running': 0, 'failed': 0, 'killed': 0, 'all': 0} DCNL DCSP jobcounts = request.jt.get_job_count_by_user(username) DCNL DCSP res['completed'] = jobcounts.nSucceeded DCNL DCSP res['running'] = (jobcounts.nPrep + jobcounts.nRunning) DCNL DCSP res['failed'] = jobcounts.nFailed DCNL DCSP res['killed'] = jobcounts.nKilled DCNL DCSP res['all'] = (((res['completed'] + res['running']) + res['failed']) + res['killed']) DCNL DCSP return res\n", "intent": "returns the number of comlpeted .\n", "question_id": 2140}, {"snippet": "def continued_indentation(logical_line, tokens, indent_level, hang_closing, indent_char, noqa, verbose): DCNL  DCSP first_row = tokens[0][2][0] DCNL DCSP nrows = ((1 + tokens[(-1)][2][0]) - first_row) DCNL DCSP if (noqa or (nrows == 1)): DCNL DCSP  DCSP return DCNL DCSP indent_next = logical_line.endswith(':') DCNL DCSP row = depth = 0 DCNL DCSP valid_hangs = ((4,) if (indent_char != ' DCTB ') else (4, 8)) DCNL DCSP parens = ([0] * nrows) DCNL DCSP rel_indent = ([0] * nrows) DCNL DCSP open_rows = [[0]] DCNL DCSP hangs = [None] DCNL DCSP indent_chances = {} DCNL DCSP last_indent = tokens[0][2] DCNL DCSP visual_indent = None DCNL DCSP last_token_multiline = False DCNL DCSP indent = [last_indent[1]] DCNL DCSP if (verbose >= 3): DCNL DCSP  DCSP print ('>>> DCSP ' + tokens[0][4].rstrip()) DCNL DCSP for (token_type, text, start, end, line) in tokens: DCNL DCSP  DCSP newline = (row < (start[0] - first_row)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP row = (start[0] - first_row) DCNL DCSP  DCSP  DCSP newline = ((not last_token_multiline) and (token_type not in NEWLINE)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP last_indent = start DCNL DCSP  DCSP  DCSP if (verbose >= 3): DCNL DCSP  DCSP  DCSP  DCSP print ('... DCSP ' + line.rstrip()) DCNL DCSP  DCSP  DCSP rel_indent[row] = (expand_indent(line) - indent_level) DCNL DCSP  DCSP  DCSP close_bracket = ((token_type == tokenize.OP) and (text in ']})')) DCNL DCSP  DCSP  DCSP for open_row in reversed(open_rows[depth]): DCNL DCSP  DCSP  DCSP  DCSP hang = (rel_indent[row] - rel_indent[open_row]) DCNL DCSP  DCSP  DCSP  DCSP hanging_indent = (hang in valid_hangs) DCNL DCSP  DCSP  DCSP  DCSP if hanging_indent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if hangs[depth]: DCNL DCSP  DCSP  DCSP  DCSP hanging_indent = (hang == hangs[depth]) DCNL DCSP  DCSP  DCSP visual_indent = ((not close_bracket) and (hang > 0) and indent_chances.get(start[1])) DCNL DCSP  DCSP  DCSP if (close_bracket and indent[depth]): DCNL DCSP  DCSP  DCSP  DCSP if (start[1] != indent[depth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, 'E124 DCSP closing DCSP bracket DCSP does DCSP not DCSP match DCSP visual DCSP indentation')) DCNL DCSP  DCSP  DCSP elif (close_bracket and (not hang)): DCNL DCSP  DCSP  DCSP  DCSP if hang_closing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, 'E133 DCSP closing DCSP bracket DCSP is DCSP missing DCSP indentation')) DCNL DCSP  DCSP  DCSP elif (indent[depth] and (start[1] < indent[depth])): DCNL DCSP  DCSP  DCSP  DCSP if (visual_indent is not True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, 'E128 DCSP continuation DCSP line DCSP under-indented DCSP for DCSP visual DCSP indent')) DCNL DCSP  DCSP  DCSP elif (hanging_indent or (indent_next and (rel_indent[row] == 8))): DCNL DCSP  DCSP  DCSP  DCSP if (close_bracket and (not hang_closing)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (start, \"E123 DCSP closing DCSP bracket DCSP does DCSP not DCSP match DCSP indentation DCSP of DCSP opening DCSP bracket's DCSP line\")) DCNL DCSP  DCSP  DCSP  DCSP hangs[depth] = hang DCNL DCSP  DCSP  DCSP elif (visual_indent is True): DCNL DCSP  DCSP  DCSP  DCSP indent[depth] = start[1] DCNL DCSP  DCSP  DCSP elif (visual_indent in (text, str)): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (hang <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E122', 'missing DCSP indentation DCSP or DCSP outdented') DCNL DCSP  DCSP  DCSP  DCSP elif indent[depth]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E127', 'over-indented DCSP for DCSP visual DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP elif ((not close_bracket) and hangs[depth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E131', 'unaligned DCSP for DCSP hanging DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hangs[depth] = hang DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hang > 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error = ('E126', 'over-indented DCSP for DCSP hanging DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error = ('E121', 'under-indented DCSP for DCSP hanging DCSP indent') DCNL DCSP  DCSP  DCSP  DCSP (yield (start, ('%s DCSP continuation DCSP line DCSP %s' % error))) DCNL DCSP  DCSP if (parens[row] and (token_type not in (tokenize.NL, tokenize.COMMENT)) and (not indent[depth])): DCNL DCSP  DCSP  DCSP indent[depth] = start[1] DCNL DCSP  DCSP  DCSP indent_chances[start[1]] = True DCNL DCSP  DCSP  DCSP if (verbose >= 4): DCNL DCSP  DCSP  DCSP  DCSP print ('bracket DCSP depth DCSP %s DCSP indent DCSP to DCSP %s' % (depth, start[1])) DCNL DCSP  DCSP elif ((token_type in (tokenize.STRING, tokenize.COMMENT)) or (text in ('u', 'ur', 'b', 'br'))): DCNL DCSP  DCSP  DCSP indent_chances[start[1]] = str DCNL DCSP  DCSP elif ((not indent_chances) and (not row) and (not depth) and (text == 'if')): DCNL DCSP  DCSP  DCSP indent_chances[(end[1] + 1)] = True DCNL DCSP  DCSP elif ((text == ':') and line[end[1]:].isspace()): DCNL DCSP  DCSP  DCSP open_rows[depth].append(row) DCNL DCSP  DCSP if (token_type == tokenize.OP): DCNL DCSP  DCSP  DCSP if (text in '([{'): DCNL DCSP  DCSP  DCSP  DCSP depth += 1 DCNL DCSP  DCSP  DCSP  DCSP indent.append(0) DCNL DCSP  DCSP  DCSP  DCSP hangs.append(None) DCNL DCSP  DCSP  DCSP  DCSP if (len(open_rows) == depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP open_rows.append([]) DCNL DCSP  DCSP  DCSP  DCSP open_rows[depth].append(row) DCNL DCSP  DCSP  DCSP  DCSP parens[row] += 1 DCNL DCSP  DCSP  DCSP  DCSP if (verbose >= 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('bracket DCSP depth DCSP %s DCSP seen, DCSP col DCSP %s, DCSP visual DCSP min DCSP = DCSP %s' % (depth, start[1], indent[depth])) DCNL DCSP  DCSP  DCSP elif ((text in ')]}') and (depth > 0)): DCNL DCSP  DCSP  DCSP  DCSP prev_indent = (indent.pop() or last_indent[1]) DCNL DCSP  DCSP  DCSP  DCSP hangs.pop() DCNL DCSP  DCSP  DCSP  DCSP for d in range(depth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (indent[d] > prev_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP indent[d] = 0 DCNL DCSP  DCSP  DCSP  DCSP for ind in list(indent_chances): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ind >= prev_indent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP del indent_chances[ind] DCNL DCSP  DCSP  DCSP  DCSP del open_rows[(depth + 1):] DCNL DCSP  DCSP  DCSP  DCSP depth -= 1 DCNL DCSP  DCSP  DCSP  DCSP if depth: DCNL DCSP  DCSP  DCSP  DCSP  DCSP indent_chances[indent[depth]] = True DCNL DCSP  DCSP  DCSP  DCSP for idx in range(row, (-1), (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parens[idx]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parens[idx] -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP assert (len(indent) == (depth + 1)) DCNL DCSP  DCSP  DCSP if (start[1] not in indent_chances): DCNL DCSP  DCSP  DCSP  DCSP indent_chances[start[1]] = text DCNL DCSP  DCSP last_token_multiline = (start[0] != end[0]) DCNL DCSP  DCSP if last_token_multiline: DCNL DCSP  DCSP  DCSP rel_indent[(end[0] - first_row)] = rel_indent[row] DCNL DCSP if (indent_next and (expand_indent(line) == (indent_level + 4))): DCNL DCSP  DCSP pos = (start[0], (indent[0] + 4)) DCNL DCSP  DCSP if visual_indent: DCNL DCSP  DCSP  DCSP code = 'E129 DCSP visually DCSP indented DCSP line' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP code = 'E125 DCSP continuation DCSP line' DCNL DCSP  DCSP (yield (pos, ('%s DCSP with DCSP same DCSP indent DCSP as DCSP next DCSP logical DCSP line' % code)))\n", "intent": "continuation lines indentation .\n", "question_id": 2141}, {"snippet": "def p_test(p): DCNL  DCSP p[0] = p[1]\n", "intent": "test : comparison .\n", "question_id": 2142}, {"snippet": "def get_qos(tenant_id, qos_id): DCNL  DCSP LOG.debug(_('get_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)\n", "intent": "lists the qos given a tenant_id and qos_id .\n", "question_id": 2143}, {"snippet": "def NullController(*_args, **_kwargs): DCNL  DCSP return None\n", "intent": "nonexistent controller - simply returns none .\n", "question_id": 2144}, {"snippet": "def __virtual__(): DCNL  DCSP if ('postgres.tablespace_exists' not in __salt__): DCNL DCSP  DCSP return (False, 'Unable DCSP to DCSP load DCSP postgres DCSP module. DCSP  DCSP Make DCSP sure DCSP `postgres.bins_dir` DCSP is DCSP set.') DCNL DCSP return True\n", "intent": "only load if the postgres module is present and is new enough .\n", "question_id": 2145}, {"snippet": "def debug_msg(text, prefix='Debug'): DCNL  DCSP msg(colorize(('%s: DCSP %s' % (prefix, str(text))), 'cyan'))\n", "intent": "colorize debug message with prefix .\n", "question_id": 2146}, {"snippet": "def _zpklp2hp(z, p, k, wo=1.0): DCNL  DCSP z = atleast_1d(z) DCNL DCSP p = atleast_1d(p) DCNL DCSP wo = float(wo) DCNL DCSP degree = _relative_degree(z, p) DCNL DCSP z_hp = (wo / z) DCNL DCSP p_hp = (wo / p) DCNL DCSP z_hp = append(z_hp, zeros(degree)) DCNL DCSP k_hp = (k * real((prod((- z)) / prod((- p))))) DCNL DCSP return (z_hp, p_hp, k_hp)\n", "intent": "transform a lowpass filter prototype to a highpass filter .\n", "question_id": 2147}, {"snippet": "def b64c(b): DCNL  DCSP return string.translate(b, B64C_TRANSLATE, B64C_STRIP)\n", "intent": "rewrite a base64 string: - remove lf and = characters - replace slashes by underscores .\n", "question_id": 2148}, {"snippet": "def has_player(accessing_obj, accessed_obj, *args, **kwargs): DCNL  DCSP return (hasattr(accessing_obj, 'has_player') and accessing_obj.has_player)\n", "intent": "only returns true if accessing_obj has_player is true .\n", "question_id": 2149}, {"snippet": "def CalculateGeneratorInputInfo(params): DCNL  DCSP toplevel = params['options'].toplevel_dir DCNL DCSP qualified_out_dir = os.path.normpath(os.path.join(toplevel, ComputeOutputDir(params), 'gypfiles')) DCNL DCSP global generator_filelist_paths DCNL DCSP generator_filelist_paths = {'toplevel': toplevel, 'qualified_out_dir': qualified_out_dir}\n", "intent": "called by __init__ to initialize generator values based on params .\n", "question_id": 2150}, {"snippet": "def ldata(): DCNL  DCSP try: DCNL DCSP  DCSP _id = request.args[0] DCNL DCSP except: DCNL DCSP  DCSP raise HTTP(400) DCNL DCSP translate = settings.get_L10n_translate_gis_location() DCNL DCSP if translate: DCNL DCSP  DCSP language = session.s3.language DCNL DCSP  DCSP if (language == settings.get_L10n_default_language()): DCNL DCSP  DCSP  DCSP translate = False DCNL DCSP table = s3db.gis_location DCNL DCSP query = ((((table.deleted == False) & (table.level != None)) & (table.end_date == None)) & ((table.parent == _id) | (table.id == _id))) DCNL DCSP fields = [table.id, table.name, table.level, table.parent, table.lon_min, table.lat_min, table.lon_max, table.lat_max] DCNL DCSP if translate: DCNL DCSP  DCSP ntable = s3db.gis_location_name DCNL DCSP  DCSP fields.append(ntable.name_l10n) DCNL DCSP  DCSP left = ntable.on((((ntable.deleted == False) & (ntable.language == language)) & (ntable.location_id == table.id))) DCNL DCSP else: DCNL DCSP  DCSP left = None DCNL DCSP locations = db(query).select(left=left, *fields) DCNL DCSP if translate: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP id_level = int(locations.as_dict(key='gis_location.id')[int(_id)]['gis_location']['level'][1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP id_level = int(locations.as_dict()[int(_id)]['level'][1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP output_level = (id_level + 1) DCNL DCSP search_level = ('L%s' % output_level) DCNL DCSP location_dict = {} DCNL DCSP if translate: DCNL DCSP  DCSP for location in locations: DCNL DCSP  DCSP  DCSP l = location['gis_location'] DCNL DCSP  DCSP  DCSP if (l.level == search_level): DCNL DCSP  DCSP  DCSP  DCSP this_level = output_level DCNL DCSP  DCSP  DCSP  DCSP f = int(l.parent) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_level = int(l.level[1:]) DCNL DCSP  DCSP  DCSP  DCSP parent = l.parent DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = int(parent) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = None DCNL DCSP  DCSP  DCSP name = (location['gis_location_name.name_l10n'] or l.name) DCNL DCSP  DCSP  DCSP if (l.lon_min is not None): DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=name, l=this_level, f=f, b=[l.lon_min, l.lat_min, l.lon_max, l.lat_max]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=name, l=this_level, f=f) DCNL DCSP else: DCNL DCSP  DCSP for l in locations: DCNL DCSP  DCSP  DCSP if (l.level == search_level): DCNL DCSP  DCSP  DCSP  DCSP this_level = output_level DCNL DCSP  DCSP  DCSP  DCSP f = int(l.parent) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_level = int(l.level[1:]) DCNL DCSP  DCSP  DCSP  DCSP parent = l.parent DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = int(parent) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = None DCNL DCSP  DCSP  DCSP if (l.lon_min is not None): DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=l.name, l=this_level, f=f, b=[l.lon_min, l.lat_min, l.lon_max, l.lat_max]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP location_dict[int(l.id)] = dict(n=l.name, l=this_level, f=f) DCNL DCSP script = ('n=%s\\n' % json.dumps(location_dict, separators=SEPARATORS)) DCNL DCSP response.headers['Content-Type'] = 'application/json' DCNL DCSP return script\n", "intent": "return json of location hierarchy suitable for use by s3locationselector /eden/gis/ldata/ + id n = {id : {n : name .\n", "question_id": 2151}, {"snippet": "def load(): DCNL  DCSP data = _get_data() DCNL DCSP return du.process_recarray(data, endog_idx=0, dtype=float)\n", "intent": "load the strikes data and return a dataset class instance .\n", "question_id": 2152}, {"snippet": "def is_master_node(client): DCNL  DCSP my_node_id = list(client.nodes.info('_local')['nodes'])[0] DCNL DCSP master_node_id = client.cluster.state(metric='master_node')['master_node'] DCNL DCSP return (my_node_id == master_node_id)\n", "intent": "return true if the connected client node is the elected master node in the elasticsearch cluster .\n", "question_id": 2153}, {"snippet": "def test_to(): DCNL  DCSP with pytest.raises(falcon.http_status.HTTPStatus) as redirect: DCNL DCSP  DCSP hug.redirect.to('/') DCNL DCSP assert ('302' in redirect.value.status)\n", "intent": "test that the base redirect to function works as expected .\n", "question_id": 2154}, {"snippet": "def add_csrf(request, **kwargs): DCNL  DCSP d = dict(user=request.user, **kwargs) DCNL DCSP d.update(csrf(request)) DCNL DCSP return RequestContext(request, d)\n", "intent": "add csrf to dictionary and wrap in a requestcontext .\n", "question_id": 2155}, {"snippet": "def loads(source): DCNL  DCSP return UnspacedList(RawNginxParser(source).as_list())\n", "intent": "parses from a string .\n", "question_id": 2156}, {"snippet": "def get_hqe_percentage_complete(**filter_data): DCNL  DCSP query = models.HostQueueEntry.query_objects(filter_data) DCNL DCSP complete_count = query.filter(complete=True).count() DCNL DCSP total_count = query.count() DCNL DCSP if (total_count == 0): DCNL DCSP  DCSP return 1 DCNL DCSP return (float(complete_count) / total_count)\n", "intent": "computes the fraction of host queue entries matching the given filter data that are complete .\n", "question_id": 2157}, {"snippet": "def generate_random_alphanumeric(length): DCNL  DCSP return ''.join((random.choice((string.ascii_uppercase + string.digits)) for _x in range(length)))\n", "intent": "creates a random alphanumeric string of specified length .\n", "question_id": 2158}, {"snippet": "def parseTargetDirect(): DCNL  DCSP if (not conf.direct): DCNL DCSP  DCSP return DCNL DCSP details = None DCNL DCSP remote = False DCNL DCSP for dbms in SUPPORTED_DBMS: DCNL DCSP  DCSP details = re.search(('^(?P<dbms>%s)://(?P<credentials>(?P<user>.+?)\\\\:(?P<pass>.*)\\\\@)?(?P<remote>(?P<hostname>.+?)\\\\:(?P<port>[\\\\d]+)\\\\/)?(?P<db>[\\\\w\\\\d\\\\ DCSP \\\\:\\\\.\\\\_\\\\-\\\\/\\\\\\\\]+?)$' % dbms), conf.direct, re.I) DCNL DCSP  DCSP if details: DCNL DCSP  DCSP  DCSP conf.dbms = details.group('dbms') DCNL DCSP  DCSP  DCSP if details.group('credentials'): DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsUser = details.group('user') DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsPass = details.group('pass') DCNL DCSP  DCSP  DCSP elif conf.dbmsCred: DCNL DCSP  DCSP  DCSP  DCSP (conf.dbmsUser, conf.dbmsPass) = conf.dbmsCred.split(':') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsUser = unicode() DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsPass = unicode() DCNL DCSP  DCSP  DCSP if (not conf.dbmsPass): DCNL DCSP  DCSP  DCSP  DCSP conf.dbmsPass = None DCNL DCSP  DCSP  DCSP if details.group('remote'): DCNL DCSP  DCSP  DCSP  DCSP remote = True DCNL DCSP  DCSP  DCSP  DCSP conf.hostname = details.group('hostname').strip() DCNL DCSP  DCSP  DCSP  DCSP conf.port = int(details.group('port')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf.hostname = 'localhost' DCNL DCSP  DCSP  DCSP  DCSP conf.port = 0 DCNL DCSP  DCSP  DCSP conf.dbmsDb = details.group('db') DCNL DCSP  DCSP  DCSP conf.parameters[None] = 'direct DCSP connection' DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not details): DCNL DCSP  DCSP errMsg = 'invalid DCSP target DCSP details, DCSP valid DCSP syntax DCSP is DCSP for DCSP instance DCSP ' DCNL DCSP  DCSP errMsg += \"'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' DCSP \" DCNL DCSP  DCSP errMsg += \"or DCSP 'access://DATABASE_FILEPATH'\" DCNL DCSP  DCSP raise SqlmapSyntaxException(errMsg) DCNL DCSP for (dbmsName, data) in DBMS_DICT.items(): DCNL DCSP  DCSP if ((dbmsName == conf.dbms) or (conf.dbms.lower() in data[0])): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (dbmsName in (DBMS.ACCESS, DBMS.SQLITE, DBMS.FIREBIRD)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if remote: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnMsg = 'direct DCSP connection DCSP over DCSP the DCSP network DCSP for DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnMsg += ('%s DCSP DBMS DCSP is DCSP not DCSP supported' % dbmsName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.warn(warnMsg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conf.hostname = 'localhost' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conf.port = 0 DCNL DCSP  DCSP  DCSP  DCSP elif (not remote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg = 'missing DCSP remote DCSP connection DCSP details DCSP (e.g. DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += \"'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' DCSP \" DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += \"or DCSP 'access://DATABASE_FILEPATH')\" DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SqlmapSyntaxException(errMsg) DCNL DCSP  DCSP  DCSP  DCSP if (dbmsName in (DBMS.MSSQL, DBMS.SYBASE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import _mssql DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pymssql DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not hasattr(pymssql, '__version__')) or (pymssql.__version__ < '1.0.2')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg = (\"'%s' DCSP third-party DCSP library DCSP must DCSP be DCSP \" % data[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg += 'version DCSP >= DCSP 1.0.2 DCSP to DCSP work DCSP properly. DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg += (\"Download DCSP from DCSP '%s'\" % data[2]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise SqlmapMissingDependence(errMsg) DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.MYSQL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pymysql DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.PGSQL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import psycopg2 DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.ORACLE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import cx_Oracle DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.SQLITE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import sqlite3 DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.ACCESS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pyodbc DCNL DCSP  DCSP  DCSP  DCSP elif (dbmsName == DBMS.FIREBIRD): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import kinterbasdb DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP if (_sqlalchemy and (data[3] in _sqlalchemy.dialects.__all__)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg = (\"sqlmap DCSP requires DCSP '%s' DCSP third-party DCSP library DCSP \" % data[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += 'in DCSP order DCSP to DCSP directly DCSP connect DCSP to DCSP the DCSP DBMS DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += (\"%s. DCSP You DCSP can DCSP download DCSP it DCSP from DCSP '%s'\" % (dbmsName, data[2])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += \". DCSP Alternative DCSP is DCSP to DCSP use DCSP a DCSP package DCSP 'python-sqlalchemy' DCSP \" DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += (\"with DCSP support DCSP for DCSP dialect DCSP '%s' DCSP installed\" % data[3]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SqlmapMissingDependence(errMsg)\n", "intent": "parse target dbms and set some attributes into the configuration singleton .\n", "question_id": 2159}, {"snippet": "@raise_if_offline DCNL def schema_has_table(table_name): DCNL  DCSP bind = op.get_bind() DCNL DCSP insp = sa.engine.reflection.Inspector.from_engine(bind) DCNL DCSP return (table_name in insp.get_table_names())\n", "intent": "check whether the specified table exists in the current schema .\n", "question_id": 2160}, {"snippet": "def load_class(dotted_path): DCNL  DCSP dotted_path_split = dotted_path.split('.') DCNL DCSP if (len(dotted_path_split) > 1): DCNL DCSP  DCSP klass_name = dotted_path_split[(-1)] DCNL DCSP  DCSP module_name = '.'.join(dotted_path_split[:(-1)]) DCNL DCSP  DCSP module = load_module(module_name) DCNL DCSP  DCSP if has_attribute(module, klass_name): DCNL DCSP  DCSP  DCSP klass = getattr(module, klass_name) DCNL DCSP  DCSP  DCSP return klass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise AttributeError(('Module DCSP %s DCSP does DCSP not DCSP have DCSP class DCSP attribute DCSP %s' % (module_name, klass_name))) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Dotted DCSP module DCSP path DCSP %s DCSP must DCSP contain DCSP a DCSP module DCSP name DCSP and DCSP a DCSP classname' % dotted_path))\n", "intent": "loads and returns a class definition provided a dotted path specification the last part of the dotted path is the class name and there is at least one module name preceding the class name .\n", "question_id": 2161}, {"snippet": "@sensitive_post_parameters() DCNL @never_cache DCNL def password_reset_confirm(request, uidb64=None, token=None, template_name='registration/password_reset_confirm.html', token_generator=default_token_generator, set_password_form=SetPasswordForm, post_reset_redirect=None, current_app=None, extra_context=None): DCNL  DCSP UserModel = get_user_model() DCNL DCSP assert ((uidb64 is not None) and (token is not None)) DCNL DCSP if (post_reset_redirect is None): DCNL DCSP  DCSP post_reset_redirect = reverse('password_reset_complete') DCNL DCSP else: DCNL DCSP  DCSP post_reset_redirect = resolve_url(post_reset_redirect) DCNL DCSP try: DCNL DCSP  DCSP uid = urlsafe_base64_decode(uidb64) DCNL DCSP  DCSP user = UserModel._default_manager.get(pk=uid) DCNL DCSP except (TypeError, ValueError, OverflowError, UserModel.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if ((user is not None) and token_generator.check_token(user, token)): DCNL DCSP  DCSP validlink = True DCNL DCSP  DCSP if (request.method == 'POST'): DCNL DCSP  DCSP  DCSP form = set_password_form(user, request.POST) DCNL DCSP  DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseRedirect(post_reset_redirect) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = set_password_form(None) DCNL DCSP else: DCNL DCSP  DCSP validlink = False DCNL DCSP  DCSP form = None DCNL DCSP context = {'form': form, 'validlink': validlink} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.update(extra_context) DCNL DCSP return TemplateResponse(request, template_name, context, current_app=current_app)\n", "intent": "view that checks the hash in a password reset link and presents a form for entering a new password .\n", "question_id": 2162}, {"snippet": "def relpath_to_site(lang, target_lang): DCNL  DCSP path = _SITES_RELPATH_DB.get((lang, target_lang), None) DCNL DCSP if (path is None): DCNL DCSP  DCSP siteurl = _SITE_DB.get(lang, _MAIN_SITEURL) DCNL DCSP  DCSP target_siteurl = _SITE_DB.get(target_lang, _MAIN_SITEURL) DCNL DCSP  DCSP path = posixpath.relpath(get_site_path(target_siteurl), get_site_path(siteurl)) DCNL DCSP  DCSP _SITES_RELPATH_DB[(lang, target_lang)] = path DCNL DCSP return path\n", "intent": "get relative path from siteurl of lang to siteurl of base_lang the output is cached in _sites_relpath_db .\n", "question_id": 2163}, {"snippet": "def colnum2name(n): DCNL  DCSP assert (n > 0) DCNL DCSP s = '' DCNL DCSP while n: DCNL DCSP  DCSP (n, m) = divmod((n - 1), 26) DCNL DCSP  DCSP s = (chr((m + ord('A'))) + s) DCNL DCSP return s\n", "intent": "translate a column number to name .\n", "question_id": 2164}, {"snippet": "def extract_bool(name, value): DCNL  DCSP if (str(value).lower() not in ('true', 'false')): DCNL DCSP  DCSP raise ValueError((_('Unrecognized DCSP value DCSP \"%(value)s\" DCSP for DCSP \"%(name)s\", DCSP acceptable DCSP values DCSP are: DCSP true, DCSP false.') % {'value': value, 'name': name})) DCNL DCSP return strutils.bool_from_string(value, strict=True)\n", "intent": "convert any true/false string to its corresponding boolean value .\n", "question_id": 2165}, {"snippet": "def get_argnames(func): DCNL  DCSP if six.PY2: DCNL DCSP  DCSP if isinstance(func, functools.partial): DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func.func) DCNL DCSP  DCSP elif inspect.isroutine(func): DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func.__call__) DCNL DCSP  DCSP args = [arg for arg in spec.args if (arg != 'self')] DCNL DCSP else: DCNL DCSP  DCSP sig = inspect.signature(func) DCNL DCSP  DCSP args = [param.name for param in sig.parameters.values() if (param.kind not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD))] DCNL DCSP return args\n", "intent": "introspecs the arguments of a callable .\n", "question_id": 2166}, {"snippet": "def extra_padding_y_keep_ratio(original_size, padding): DCNL  DCSP return _resize(original_size, 1, padding=padding, keep_aspect_ratio=True)\n", "intent": "reduce the height of original_size by padding .\n", "question_id": 2167}, {"snippet": "def _needs_eeg_average_ref_proj(info): DCNL  DCSP eeg_sel = pick_types(info, meg=False, eeg=True, ref_meg=False, exclude='bads') DCNL DCSP return ((len(eeg_sel) > 0) and (not info['custom_ref_applied']) and (not _has_eeg_average_ref_proj(info['projs'])))\n", "intent": "determine if the eeg needs an averge eeg reference .\n", "question_id": 2168}, {"snippet": "def serialize_item(collection, item): DCNL  DCSP if ((item.name is None) or (item.name == '')): DCNL DCSP  DCSP raise exceptions.RuntimeError('name DCSP unset DCSP for DCSP item!') DCNL DCSP if (collection.collection_type() in ['mgmtclass']): DCNL DCSP  DCSP filename = ('/var/lib/cobbler/collections/%ses/%s' % (collection.collection_type(), item.name)) DCNL DCSP else: DCNL DCSP  DCSP filename = ('/var/lib/cobbler/collections/%ss/%s' % (collection.collection_type(), item.name)) DCNL DCSP _dict = item.to_dict() DCNL DCSP if capi.CobblerAPI().settings().serializer_pretty_json: DCNL DCSP  DCSP sort_keys = True DCNL DCSP  DCSP indent = 4 DCNL DCSP else: DCNL DCSP  DCSP sort_keys = False DCNL DCSP  DCSP indent = None DCNL DCSP filename += '.json' DCNL DCSP _dict = item.to_dict() DCNL DCSP fd = open(filename, 'w+') DCNL DCSP data = simplejson.dumps(_dict, encoding='utf-8', sort_keys=sort_keys, indent=indent) DCNL DCSP fd.write(data) DCNL DCSP fd.close()\n", "intent": "save a collection item to file system .\n", "question_id": 2169}, {"snippet": "def InstallDriver(kext_path): DCNL  DCSP km = objc.KextManager() DCNL DCSP cf_kext_path = km.PyStringToCFString(kext_path) DCNL DCSP kext_url = km.dll.CFURLCreateWithFileSystemPath(objc.CF_DEFAULT_ALLOCATOR, cf_kext_path, objc.POSIX_PATH_STYLE, True) DCNL DCSP status = km.iokit.KextManagerLoadKextWithURL(kext_url, None) DCNL DCSP km.dll.CFRelease(kext_url) DCNL DCSP km.dll.CFRelease(cf_kext_path) DCNL DCSP if (status is not objc.OS_SUCCESS): DCNL DCSP  DCSP raise OSError('Failed DCSP to DCSP load DCSP kext DCSP at DCSP {0}: DCSP {1}'.format(kext_path, status))\n", "intent": "calls into the iokit to load a kext by file-system path .\n", "question_id": 2170}, {"snippet": "def abort_merge(): DCNL  DCSP title = N_(u'Abort DCSP Merge...') DCNL DCSP txt = N_(u'Aborting DCSP the DCSP current DCSP merge DCSP will DCSP cause DCSP *ALL* DCSP uncommitted DCSP changes DCSP to DCSP be DCSP lost.\\nRecovering DCSP uncommitted DCSP changes DCSP is DCSP not DCSP possible.') DCNL DCSP info_txt = N_(u'Aborting DCSP the DCSP current DCSP merge?') DCNL DCSP ok_txt = N_(u'Abort DCSP Merge') DCNL DCSP if qtutils.confirm(title, txt, info_txt, ok_txt, default=False, icon=icons.undo()): DCNL DCSP  DCSP gitcmds.abort_merge()\n", "intent": "prompts before aborting a merge in progress .\n", "question_id": 2171}, {"snippet": "def add_key_to_url(url, scheme, key): DCNL  DCSP query = request.args.to_dict() DCNL DCSP query['view_only'] = key DCNL DCSP replacements = {'query': urllib.urlencode(query)} DCNL DCSP if scheme: DCNL DCSP  DCSP replacements['scheme'] = scheme DCNL DCSP parsed_url = urlparse.urlparse(url) DCNL DCSP if parsed_url.fragment: DCNL DCSP  DCSP replacements['path'] = '{}%23{}'.format(parsed_url.path, parsed_url.fragment) DCNL DCSP  DCSP replacements['fragment'] = '' DCNL DCSP parsed_redirect_url = parsed_url._replace(**replacements) DCNL DCSP return urlparse.urlunparse(parsed_redirect_url)\n", "intent": "redirects the user to the requests url with the given key appended to the query parameters .\n", "question_id": 2172}, {"snippet": "def expand_default(self, option): DCNL  DCSP if ((self.parser is None) or (not self.default_tag)): DCNL DCSP  DCSP return option.help DCNL DCSP optname = option._long_opts[0][2:] DCNL DCSP try: DCNL DCSP  DCSP provider = self.parser.options_manager._all_options[optname] DCNL DCSP except KeyError: DCNL DCSP  DCSP value = None DCNL DCSP else: DCNL DCSP  DCSP optdict = provider.get_option_def(optname) DCNL DCSP  DCSP optname = provider.option_attrname(optname, optdict) DCNL DCSP  DCSP value = getattr(provider.config, optname, optdict) DCNL DCSP  DCSP value = format_option_value(optdict, value) DCNL DCSP if ((value is optik_ext.NO_DEFAULT) or (not value)): DCNL DCSP  DCSP value = self.NO_DEFAULT_VALUE DCNL DCSP return option.help.replace(self.default_tag, str(value))\n", "intent": "monkey patch optionparser .\n", "question_id": 2173}]